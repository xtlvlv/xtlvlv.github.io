<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git基础</title>
    <url>/git%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ol>
<li>有必要把git整理一下了</li>
</ol>
<h1 id="一、起步"><a href="#一、起步" class="headerlink" title="一、起步"></a>一、起步</h1><a id="more"></a>
<h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h3><ol>
<li><p>用户信息</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;John Doe&quot;</span><br><span class="line">$ git config --global user.email johndoe@example.com </span><br></pre></td></tr></table></figure>
<ul>
<li>远程提交时，commit的用户一定要有远程提交的权限，之前我就是这个问题，一直提交不了</li>
</ul>
</li>
<li><p>文本编辑器</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global core.editor &quot;\&quot;D:\应用程序\Sublime Text3\sublime_text.exe\&quot;&quot;</span><br><span class="line">$ git config --global core.editor emacs&#x2F;vim</span><br></pre></td></tr></table></figure>
<ul>
<li>修改config文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;...略</span><br><span class="line">[core]</span><br><span class="line">    editor &#x3D; \&quot;D:\\应用程序\\Sublime Text3\\sublime_text.exe\&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>检查配置信息</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">user.name&#x3D;John Doe</span><br><span class="line">user.email&#x3D;johndoe@example.com</span><br><span class="line">color.status&#x3D;auto</span><br><span class="line">color.branch&#x3D;auto</span><br><span class="line">color.interactive&#x3D;auto</span><br><span class="line">color.diff&#x3D;auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="2-license"><a href="#2-license" class="headerlink" title="2. license"></a>2. license</h3><!-- ![github证书.png](/github证书.png) -->
<img src="/git%E5%9F%BA%E7%A1%80/github%E8%AF%81%E4%B9%A6.png" class="" title="github证书">

</li>
</ol>
<h1 id="二、git基础"><a href="#二、git基础" class="headerlink" title="二、git基础"></a>二、git基础</h1><h3 id="1-获取-Git-仓库"><a href="#1-获取-Git-仓库" class="headerlink" title="1. 获取 Git 仓库"></a>1. 获取 Git 仓库</h3><ol>
<li>本地初始化 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在项目目录</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;信息&quot;</span><br></pre></td></tr></table></figure></li>
<li>克隆现有的仓库<ul>
<li>当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。</li>
<li>从github上clone项目<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;xtlvlv&#x2F;Algorithm.git newname</span><br><span class="line">&#x2F;&#x2F;newname是自定义本地仓库名，可以省略</span><br></pre></td></tr></table></figure></li>
<li>也可以自己在服务器搭建git，详见第四章。</li>
</ul>
</li>
</ol>
<h3 id="2-记录每次更新到仓库"><a href="#2-记录每次更新到仓库" class="headerlink" title="2. 记录每次更新到仓库"></a>2. 记录每次更新到仓库</h3><ol>
<li>检查当前文件状态 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git status -s   &#x2F;&#x2F;更简洁的查看</span><br></pre></td></tr></table></figure></li>
<li>跟踪新文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add README</span><br></pre></td></tr></table></figure>
<ul>
<li>这个也用于暂存修改</li>
<li>若一个文件git add后，又修改了，commit时提交的是修改前的状态，必须再次git add</li>
</ul>
</li>
<li>忽略文件<ul>
<li>创建一个名为 .gitignore 的文件，列出要忽略的文件模式。例如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.[oa]  &#x2F;&#x2F;忽略所有以.o或.a结尾的文件</span><br><span class="line">*~  &#x2F;&#x2F;忽略所有～结尾的文件</span><br></pre></td></tr></table></figure></li>
<li>文件 .gitignore 的格式规范如下：<ul>
<li>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（/）开头防止递归。</li>
<li>匹配模式可以以（/）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ul>
</li>
</ul>
</li>
<li>查看已暂存和未暂存的修改<ul>
<li>当git add 后又修改了文件，git status就会显示已暂存和未暂存的文件</li>
<li>查看都修改了哪些<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>提交更新 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit  &#x2F;&#x2F;这种方式会启动文本编辑器以便输入本次提交的说明。</span><br><span class="line">git commit -m &quot;说明&quot;    &#x2F;&#x2F;简短说明，快速提交</span><br></pre></td></tr></table></figure></li>
<li>跳过使用暂存区域 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure>
<ul>
<li>这种方式 Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</li>
</ul>
</li>
<li>移除文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm README</span><br></pre></td></tr></table></figure></li>
<li>移动文件<ul>
<li>改名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git mv file_from file_to</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">$ mv README.md README</span><br><span class="line">$ git rm README.md</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="3-查看提交历史-git-log"><a href="#3-查看提交历史-git-log" class="headerlink" title="3. 查看提交历史,git log"></a>3. 查看提交历史,git log</h3><ol>
<li><p>常用</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">git log -g -2</span><br></pre></td></tr></table></figure>
<ul>
<li> -p 用来显示每次提交的内容差异。 加上 -2 仅显示最近两次提交</li>
</ul>
</li>
<li><p>每次提交的简略的统计信息，你可以使用 –stat 选项</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure></li>
<li><p>输出限制</p>
<ul>
<li>用时查文档吧</li>
</ul>
</li>
</ol>
<h3 id="4-撤消操作"><a href="#4-撤消操作" class="headerlink" title="4. 撤消操作"></a>4. 撤消操作</h3><ol>
<li>重新提交 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<ul>
<li>若git commit 后没有做任何修改，执行这条命令没有改变</li>
<li>若git commit 后修改了，执行这条命令改变之前的提交，不是重新提交，也就是只有一条提交记录</li>
</ul>
</li>
<li>取消暂存的文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD README.md</span><br></pre></td></tr></table></figure>
<ul>
<li>把 README.md 从暂存区取消，commit时就不会提交这个文件</li>
</ul>
</li>
<li>撤消对文件的修改 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- README.md</span><br></pre></td></tr></table></figure>
<ul>
<li>可以将 README.md 还原成上次提交时的样子</li>
<li> git checkout – [file] 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。</li>
<li>在 Git 中任何 已提交的 东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 –amend 选项覆盖的提交也可以恢复。 然而，任何你未提交的东西丢失后很可能再也找不到了。</li>
</ul>
</li>
</ol>
<h3 id="5-远程仓库的使用-git-remote"><a href="#5-远程仓库的使用-git-remote" class="headerlink" title="5. 远程仓库的使用,git remote"></a>5. 远程仓库的使用,git remote</h3><ol>
<li>查看远程仓库 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote  &#x2F;&#x2F;如果是clone下来的，至少有个origin</span><br><span class="line">$ git remote -v   &#x2F;&#x2F;显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</span><br><span class="line">bakkdoor  https:&#x2F;&#x2F;github.com&#x2F;bakkdoor&#x2F;grit (fetch)</span><br><span class="line">bakkdoor  https:&#x2F;&#x2F;github.com&#x2F;bakkdoor&#x2F;grit (push)</span><br><span class="line">cho45     https:&#x2F;&#x2F;github.com&#x2F;cho45&#x2F;grit (fetch)</span><br><span class="line">cho45     https:&#x2F;&#x2F;github.com&#x2F;cho45&#x2F;grit (push)</span><br><span class="line">defunkt   https:&#x2F;&#x2F;github.com&#x2F;defunkt&#x2F;grit (fetch)</span><br><span class="line">defunkt   https:&#x2F;&#x2F;github.com&#x2F;defunkt&#x2F;grit (push)</span><br><span class="line">koke      git:&#x2F;&#x2F;github.com&#x2F;koke&#x2F;grit.git (fetch)</span><br><span class="line">koke      git:&#x2F;&#x2F;github.com&#x2F;koke&#x2F;grit.git (push)</span><br><span class="line">origin    git@github.com:mojombo&#x2F;grit.git (fetch)</span><br><span class="line">origin    git@github.com:mojombo&#x2F;grit.git (push)</span><br></pre></td></tr></table></figure></li>
<li>添加远程仓库 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote add pb https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit</span><br><span class="line">$ git remote -v</span><br><span class="line">origin	https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (fetch)</span><br><span class="line">origin	https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (push)</span><br><span class="line">pb	https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit (fetch)</span><br><span class="line">pb	https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit (push)</span><br></pre></td></tr></table></figure>
<ul>
<li>pb 代表URL的简写</li>
</ul>
</li>
<li>从远程仓库中抓取与拉取<ul>
<li>git fetch [remote-name]</li>
<li>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch pb</span><br></pre></td></tr></table></figure></li>
<li>如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。</li>
<li> git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</li>
<li>如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）</li>
</ul>
</li>
<li>推送到远程仓库<ul>
<li>git push [remote-name] [branch-name]<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin master    &#x2F;&#x2F;克隆时通常会自动帮你设置好这两个名字</span><br></pre></td></tr></table></figure></li>
<li>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。</li>
<li>当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。</li>
</ul>
</li>
<li>查看远程仓库<ul>
<li>git remote show [remote-name]<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote show origin</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>远程仓库的移除与重命名<ul>
<li>重命名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure></li>
<li>移除<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="6-打标签-git-tag"><a href="#6-打标签-git-tag" class="headerlink" title="6. 打标签,git tag"></a>6. 打标签,git tag</h3><ol>
<li>列出标签 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></li>
<li>创建标签<ul>
<li>轻量标签（lightweight）<br>  轻量标签本质上是将提交校验和存储到一个文件中，没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag v1.4-lw</span><br><span class="line">$ git tag</span><br><span class="line">v1.4-lw</span><br></pre></td></tr></table></figure></li>
<li>附注标签（annotated）<br>  附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.4 -m &#39;my version 1.4&#39;</span><br><span class="line">$ git tag</span><br><span class="line">v1.4</span><br><span class="line">&#x2F;&#x2F;查看标签信息与对应的提交信息</span><br><span class="line">$ git show v1.4</span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:19:12 2014 -0700</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li>
<li>对过去的提交打标签<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查看历史</span><br><span class="line">$ git log --pretty&#x3D;oneline</span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">&#x2F;&#x2F;加标签</span><br><span class="line">$ git tag -a v1.2 9fceb02</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>共享标签<ul>
<li>默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行 git push origin [tagname]。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin v1.5</span><br><span class="line">$ git push origin --tags    &#x2F;&#x2F;把所有不在远程仓库服务器上的标签全部传送到那里。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>删除标签 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -d v1.4-lw  &#x2F;&#x2F;加上 -d 删除，但不会更新远程仓库的</span><br></pre></td></tr></table></figure>
<ul>
<li>远程仓库移除标签<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;git push &lt;remote&gt; :refs&#x2F;tags&#x2F;&lt;tagname&gt;</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;v1.4-lw</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>检出标签 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout 2.0.0</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="三、git分支"><a href="#三、git分支" class="headerlink" title="三、git分支"></a>三、git分支</h1><h3 id="1-分支简介"><a href="#1-分支简介" class="headerlink" title="1. 分支简介"></a>1. 分支简介</h3><ol>
<li><p>分支创建</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure>
<ul>
<li>Git 又是怎么知道当前在哪一个分支上呢？<br>  它有一个名为 HEAD 的特殊指针。在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。</li>
</ul>
</li>
<li><p>分支切换</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout testing</span><br></pre></td></tr></table></figure>
<ul>
<li>HEAD就会指向testing，此时做的更改是在testing分支上，HEAD一直跟着testing,切换为master的话就会回到之前的分支</li>
</ul>
</li>
<li><p>查看各个分支当前所指的对象</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --oneline --decorate</span><br></pre></td></tr></table></figure>
<h3 id="2-分支的新建与合并-git-checkout"><a href="#2-分支的新建与合并-git-checkout" class="headerlink" title="2. 分支的新建与合并,git checkout"></a>2. 分支的新建与合并,git checkout</h3></li>
<li><p>新建分支</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br><span class="line">&#x2F;&#x2F;并将HEAD指向iss53, 等价于</span><br><span class="line">$ git branch iss53</span><br><span class="line">$ git checkout iss53</span><br></pre></td></tr></table></figure></li>
<li><p>删除分支</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d hotfix</span><br></pre></td></tr></table></figure></li>
<li><p>合并分支</p>
<ul>
<li><p>要先移动到被合并的分支，比如想把hotfix合并到master上，要先移动到master分支上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br></pre></td></tr></table></figure></li>
<li><p>不同的合并情况</p>
<ul>
<li><p>快进合并：master和hotfix在一条线上，只是把master往前移动到hotfix上</p>
</li>
<li><p>分叉合并: master和hotfix不在一条线上，复杂一些</p>
<ul>
<li>解决冲突</li>
</ul>
<ol>
<li>直接在文件中修改冲突的地方</li>
<li>git checkout –theirs 文件名 // 在本例中是使hotfix的文件覆盖master的文件</li>
<li>git checkout –ours 文件名 // 在本例中是使master的文件覆盖hotfix的文件</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>遇到冲突时的分支合并</p>
<ul>
<li>如果在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。</li>
<li>若遇到冲突后，只能把冲突解决才能合并，即把连个分支都修改的某个文件，变为相同的修改</li>
</ul>
</li>
</ol>
<h3 id="3-分支管理-git-branch"><a href="#3-分支管理-git-branch" class="headerlink" title="3. 分支管理,git branch"></a>3. 分支管理,git branch</h3><ol>
<li><p>查看分支</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">iss53</span><br><span class="line">* master    &#x2F;&#x2F;表示当前在这个分支上</span><br><span class="line">testing</span><br></pre></td></tr></table></figure></li>
<li><p>查看每一个分支的最后一次提交</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -v </span><br></pre></td></tr></table></figure></li>
<li><p>要查看哪些分支已经合并到当前分支</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch --merged</span><br><span class="line">iss53   &#x2F;&#x2F;表明iss53已经合并到master,可以删除了</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</li>
</ul>
</li>
<li><p>查看所有包含未合并工作的分支</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch --no-merged</span><br><span class="line">testing</span><br></pre></td></tr></table></figure>
<ul>
<li>删除未合并的分支会失败<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d testing</span><br><span class="line">error: The branch &#39;testing&#39; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#39;git branch -D testing&#39;.</span><br></pre></td></tr></table></figure>
<h3 id="4-远程分支-git-fetch-push-pull"><a href="#4-远程分支-git-fetch-push-pull" class="headerlink" title="4. 远程分支,git fetch push pull"></a>4. 远程分支,git fetch push pull</h3></li>
</ul>
</li>
<li><p>更新远程仓库引用</p>
<ul>
<li>如果git clone之后，自己做了一些修改后commit后，本地就会领先远程分支，这时万一有其他人提交远程分支了，在clone那个节点就出现了分叉</li>
<li>这时可以用git fetch拉去远程更新的分支，变成本地的一个分支，合并后再提交<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>推送</p>
<ul>
<li>推送到有写入权限的远程仓库</li>
<li>git push (remote) (branch)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin serverfix</span><br></pre></td></tr></table></figure></li>
<li>这里有些工作被简化了。 Git 自动将 serverfix 分支名字展开为 refs/heads/serverfix:refs/heads/serverfix，那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” </li>
</ul>
</li>
<li><p>跟踪分支</p>
<ul>
<li>跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</li>
<li>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。</li>
<li>创建跟踪分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b sf origin&#x2F;serverfix</span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#39;sf&#39;</span><br><span class="line">&#x2F;&#x2F;现在，本地分支 sf 会自动从 origin&#x2F;serverfix 拉取。</span><br></pre></td></tr></table></figure></li>
<li>修改正在跟踪的上游分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -u origin&#x2F;serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li><ol start="4">
<li>git pull</li>
</ol>
<ul>
<li>git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令</li>
<li>由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。    </li>
</ul>
</li>
<li><ol start="5">
<li>删除远程分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete serverfix</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit</span><br><span class="line">- [deleted]         serverfix</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</li>
</ul>
</li>
<li><ol start="6">
<li>用本地分支创建远程分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin localBranch:remoteBranch</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="5-变基rebase"><a href="#5-变基rebase" class="headerlink" title="5. 变基rebase"></a>5. 变基rebase</h3><ol>
<li><p>和合并merge功能一样</p>
<ul>
<li>无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</li>
</ul>
</li>
<li><p>合并merge好还是变基rebase好？</p>
<ul>
<li>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作</li>
</ul>
</li>
<li><p>rebase的使用</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout experiment</span><br><span class="line">$ git rebase master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br><span class="line">&#x2F;&#x2F;先rebase,然后再合并，这里的合并只是移动指针，如果不变基就合并的话，要做的工作更多</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge experiment</span><br></pre></td></tr></table></figure></li>
<li><p>这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p>
</li>
</ol>
<h1 id="四、服务器上的git"><a href="#四、服务器上的git" class="headerlink" title="四、服务器上的git"></a>四、服务器上的git</h1><ul>
<li>可以自己建立git服务器，但现在用好github就行了，以后需要的时候再说</li>
</ul>
<h1 id="之后"><a href="#之后" class="headerlink" title="之后"></a>之后</h1><ul>
<li>后面的略览了一下，使用基本的git，以上就够了，后面先不看了，有需要再说吧。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/test/</url>
    <content><![CDATA[<h3 id="第一"><a href="#第一" class="headerlink" title="第一"></a>第一</h3><p>111<br>rf</p>
<a id="more"></a>
<p>earger<br>ergesr<br>egrge<br>reger<br>ergerg<br>rh<br>rtrf<br>earger<br>ergesr<br>egrge<br>reger<br>ergerg<br>rh<br>rt</p>
<h5 id="5"><a href="#5" class="headerlink" title="5"></a>5</h5><p>xx<br>agdg<br>garf<br>earger<br>ergesr<br>egrge<br>reger<br>ergerg<br>rhrf<br>earger<br>ergesr<br>egrge<br>reger<br>ergerg<br>rh<br>rt<br>rt</p>
<h3 id="第二"><a href="#第二" class="headerlink" title="第二"></a>第二</h3><p>rf<br>earger<br>ergesr<br>egrge<br>reger<br>ergerg<br>rh<br>rtrf<br>earger<br>ergesr<br>egrge<br>reger<br>ergerg<br>rh<br>rt</p>
<h6 id="6"><a href="#6" class="headerlink" title="6"></a>6</h6><p>66rf<br>earger<br>ergesr<br>egrge<br>reger<br>ergerg<br>rh<br>rt<br><img src="/images/content/head.jpeg" alt="图片"></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试1</tag>
        <tag>测试2</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04下MySQL安装</title>
    <url>/Ubuntu18-04%E4%B8%8BMySQL%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql-apt-config_0.8.11-1_all.deb</span><br><span class="line">dpkg -i mysql-apt-config_0.8.11-1_all.deb</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure>
<ol>
<li>上面第一条后面的网址是 <a href="https://dev.mysql.com/downloads/file/?id=482263">https://dev.mysql.com/downloads/file/?id=482263</a> 里下方的 “No thanks, just start my download.” 的链接</li>
<li>在某些命令执行过程中会出界面提示，一个是输入root密码，剩下的全按“确定”就行</li>
<li>最后有个选择密码的强度，第一个是高强度密码，自己写着练习的画选第二个吧。</li>
<li>最后就安装好了，可以尝试进入数据库： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
 再输入密码</li>
</ol>
<h3 id="MySQL可视化工具安装"><a href="#MySQL可视化工具安装" class="headerlink" title="MySQL可视化工具安装"></a>MySQL可视化工具安装</h3><ol>
<li>若以上执行正确，此时只要这一句就行了 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-workbench</span><br></pre></td></tr></table></figure></li>
<li>最后就能发现MySQL workbench软件，和在Windows下的一样</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是RAII</title>
    <url>/%E4%BB%80%E4%B9%88%E6%98%AFRAII/</url>
    <content><![CDATA[<h1 id="什么是RAII"><a href="#什么是RAII" class="headerlink" title="什么是RAII"></a>什么是RAII</h1><ul>
<li>其他博客中很多写的是“RAII是Resource Acquisition Is Initialization的简称，是C++语言的一种管理资源、避免泄漏的惯用法。”，如果理解什么是RAII后再看这句话就很容易懂，但如果什么都不懂，直接看这一句应该是看不懂的。</li>
<li>我的直白的理解就是，一种编程规范，或者一种编程技巧，不是具体的语法之类的，就是和设计模式一样，是一种技巧。<a id="more"></a>

</li>
</ul>
<h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><ul>
<li>下面解释定义：一种资源管理、避免泄露的惯用法<ul>
<li>比如使用一个指针后，在不使用的时候要将它释放，但是有时候可能会忘记释放指针，就会造成内存泄露，如下面的例子，如果不调用delete s，就会造成s占用的资源一直不释放，直到程序死亡。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">	Studen* s&#x3D;new Student();</span><br><span class="line">	&#x2F;&#x2F;其他处理代码</span><br><span class="line">	delete s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用RAII机制，就是自定义管理，将要管理的东西疯转成对象，在对象的作用域结束的时候，调用对象的析构函数，自动释放资源，就不用程序员自己释放，简单来说就是这样。</li>
<li>为了方便，就直接使用C++11的share_prt做例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">	shared_ptr&lt;Studen&gt; s &#x3D;make_share&lt;Studen&gt; ();</span><br><span class="line">	&#x2F;&#x2F;其他处理代码</span><br><span class="line">	&#x2F;&#x2F; delete s; 不需要这一句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这只是简单的了解RAII，RAII还有一些坑，这些不想整理了，看看其他的博客吧。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>RAII</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++静态变量</title>
    <url>/C++%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="一、静态变量"><a href="#一、静态变量" class="headerlink" title="一、静态变量"></a>一、静态变量</h3><h4 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1. 作用域"></a>1. 作用域</h4><pre><code>      1. 局部静态变量的作用域在它所在的&#123; &#125;内
      2. 全局静态变量在整个文件</code></pre>
<h4 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h4><pre><code>      不管全局还是局部的静态变量，生命周期都是整个程序运行过程</code></pre>
<h3 id="二、静态函数"><a href="#二、静态函数" class="headerlink" title="二、静态函数"></a>二、静态函数</h3><h4 id="1-C-中类的静态函数"><a href="#1-C-中类的静态函数" class="headerlink" title="1. C++中类的静态函数"></a>1. C++中类的静态函数</h4><pre><code>    1. 必须在类外初始化
    2. 函数内只能使用类的静态成员变量</code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>静态变量</tag>
      </tags>
  </entry>
  <entry>
    <title>右值引用的一些理解</title>
    <url>/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<ol>
<li>右值引用之前看过不少次了,但过一段时间就忘了,,,这里简单整理一下我的理解</li>
<li>右值引用主要用来实现 移动语义 和 完美转发</li>
</ol>
<h4 id="1-移动语义"><a href="#1-移动语义" class="headerlink" title="1. 移动语义"></a>1. 移动语义</h4><ol>
<li>使用上可以用std::move() ,把参数强制转换成右值</li>
<li>我理解就是和浅拷贝很像,不过浅拷贝是多个指针指向堆上的空间,可能会重复释放从而出错,而移动语义是只有一个指针占有堆上的空间,移动后源指针就置空了.如果没有堆上的空间,那移动语义和浅拷贝就没什么区别</li>
</ol>
<h4 id="2-完美转发"><a href="#2-完美转发" class="headerlink" title="2. 完美转发"></a>2. 完美转发</h4><ol>
<li>这个是在模板中,结合折叠原则使用,实现”在函数模板中，完全按照模板参数的类型将参数传递给模板函数中调用的另一个函数，并且不产生额外开销。”</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>unterminated conditional directive错误</title>
    <url>/unterminated-conditional-directive%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef XXX</span><br><span class="line">#define XXX</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<ol>
<li>可能是没写#endif</li>
<li>在有#endif的情况下还报错,是头文件互相包含的问题</li>
</ol>
<h3 id="解决头文件互相包含的需求"><a href="#解决头文件互相包含的需求" class="headerlink" title="解决头文件互相包含的需求"></a>解决头文件互相包含的需求</h3><ol>
<li>比如A要使用B,B又使用了A,可以在A.h中声明B,然后在A.cpp中包含B的头文件B.h,不过要注意代码逻辑不要循环递归调用了……</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>循环引用</tag>
      </tags>
  </entry>
  <entry>
    <title>C中对结构体sizeof</title>
    <url>/C%E4%B8%AD%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93sizeof/</url>
    <content><![CDATA[<h3 id="唉"><a href="#唉" class="headerlink" title="唉"></a>唉</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1 Byte</span><br><span class="line">struct test</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* data *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;8 Byte</span><br><span class="line">struct test2</span><br><span class="line">&#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;8 Byte</span><br><span class="line">struct test3</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;12 Byte</span><br><span class="line">struct test4</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;8 Byte</span><br><span class="line">struct test5</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    char b;</span><br><span class="line">    int a;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;2 Byte</span><br><span class="line">struct test6</span><br><span class="line">&#123;</span><br><span class="line">    char a;</span><br><span class="line">    char b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;16 Byte</span><br><span class="line">struct test7</span><br><span class="line">&#123;</span><br><span class="line">    double a;</span><br><span class="line">    char b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;sizeof(test)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;sizeof(test2)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;sizeof(test3)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;sizeof(test4)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;sizeof(test5)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;sizeof(test6)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;sizeof(test7)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>字节数据是存在内存中的，字节对齐能加快内存的访问速度。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>结构体</tag>
        <tag>sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title>线程函数为类函数时</title>
    <url>/%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E4%B8%BA%E7%B1%BB%E5%87%BD%E6%95%B0%E6%97%B6/</url>
    <content><![CDATA[<h3 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h3><ul>
<li>linux编程，当线程执行的函数是类方法时，如何执行，有如下两种方法。</li>
</ul>
<a id="more"></a>
<h3 id="1-把函数定义为静态"><a href="#1-把函数定义为静态" class="headerlink" title="1. 把函数定义为静态"></a>1. 把函数定义为静态</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread t(bind(&amp;Object::func,a));</span><br></pre></td></tr></table></figure>

<h3 id="2-加this"><a href="#2-加this" class="headerlink" title="2. 加this"></a>2. 加this</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread t(bind(&amp;Object::func,this,a));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>信号执行过程中又收到信号</title>
    <url>/%E4%BF%A1%E5%8F%B7%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%88%E6%94%B6%E5%88%B0%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>若signal安装了信号响应函数后，若连续发两次该信号，即第一个信号的函数还没执行完的时候，又收到了这个信号，会怎么处理？<br>答案：会等第一个函数执行完，再执行第二遍这个函数。</p>
<a id="more"></a>
<p>验证如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">void hander(int sig)&#123;</span><br><span class="line">    printf(&quot;收到了 %d 信号\n&quot;,sig);</span><br><span class="line">    sleep(5);</span><br><span class="line">    printf(&quot;hander继续执行了\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    if(signal(SIGUSR1,hander)&#x3D;&#x3D;SIG_ERR)&#123;</span><br><span class="line">        perror(&quot;error\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int i&#x3D;0;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,i);</span><br><span class="line">        pause();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/%E4%BF%A1%E5%8F%B7%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%88%E6%94%B6%E5%88%B0%E4%BF%A1%E5%8F%B7/%E5%8F%91%E9%80%81%E4%B8%A4%E6%AC%A1%E4%BF%A1%E5%8F%B7%E9%AA%8C%E8%AF%81.jpeg" class="" title="发送两次信号验证">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>信号</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx和uwsgi启停</title>
    <url>/nginx%E5%92%8Cuwsgi%E5%90%AF%E5%81%9C/</url>
    <content><![CDATA[<h3 id="1-Nginx-开启"><a href="#1-Nginx-开启" class="headerlink" title="1. Nginx 开启"></a>1. Nginx 开启</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -c &#x2F;home&#x2F;www&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>-c是指定配置文件,不然用默认的配置,后面的文件路径最好从根目录开始,不然会有一个默认目录,试一下就知道了<h3 id="2-Nginx-关闭"><a href="#2-Nginx-关闭" class="headerlink" title="2. Nginx 关闭:"></a>2. Nginx 关闭:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure>
<h3 id="3-Uwsgi-开启"><a href="#3-Uwsgi-开启" class="headerlink" title="3. Uwsgi 开启"></a>3. Uwsgi 开启</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uwsgi -d --ini uwsgi.ini</span><br></pre></td></tr></table></figure></li>
<li>-d是表示在后台运行<h3 id="4-Uwsig-关闭"><a href="#4-Uwsig-关闭" class="headerlink" title="4. Uwsig 关闭"></a>4. Uwsig 关闭</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uwsgi --stop uwsgi.pid</span><br><span class="line">pkill -f uwsgi -9</span><br></pre></td></tr></table></figure></li>
<li>这个uwsgi.pid是uwsgi.ini中指定的文件,运行后存的是uwsgi进程的pid<h3 id="5-Uwsig-重启"><a href="#5-Uwsig-重启" class="headerlink" title="5. Uwsig 重启"></a>5. Uwsig 重启</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uwsgi --reload uwsgi.pid</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>uwsgi</tag>
      </tags>
  </entry>
  <entry>
    <title>asio几种异步编程模型</title>
    <url>/asio%E5%87%A0%E7%A7%8D%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0. 前置知识"></a>0. 前置知识</h3><ol>
<li>asio中io_server是一个很重要的东西,任何操作都需要它,在异步编程的时候,需要io_server.run()启动, 有点像事件驱动模型中的 event.loop().(原理不一样,只是说编程类似)</li>
</ol>
<a id="more"></a>

<h3 id="1-一个io-server和一个线程"><a href="#1-一个io-server和一个线程" class="headerlink" title="1. 一个io_server和一个线程"></a>1. 一个io_server和一个线程</h3><ol>
<li>就是主线程一个io_server.run(),这样加入这里面有三个回调函数调用,如果第一个响应了,正在处理过程中,第二个回调函数响应,要等第一个执行完才行.</li>
</ol>
<h3 id="2-一个io-server和多个线程"><a href="#2-一个io-server和多个线程" class="headerlink" title="2. 一个io_server和多个线程"></a>2. 一个io_server和多个线程</h3><ol>
<li>启动多个线程,每个线程都调用 io_server.run(), 这里各线程中的io_server是同一个</li>
<li>这样碰到上面那种情况,第二个回调函数就会找一个空闲线程去运行,会提高效率</li>
</ol>
<h3 id="3-多个io-server和多个线程"><a href="#3-多个io-server和多个线程" class="headerlink" title="3. 多个io_server和多个线程"></a>3. 多个io_server和多个线程</h3><ol>
<li>就是每个线程有自己的io_server, 这样和第一种情况有些类似, 不过可以对不同的套接字绑定到不同的线程io_server上, 然后各线程只处理自己关注的套接字</li>
</ol>
<ul>
<li>目前个人感觉还是第二种情况更好用</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>linux</tag>
        <tag>asio</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>boost::system::error_code在异步编程中的使用----使用boost::asio::placeholders::error编译报错问题 </title>
    <url>/boost-system-error-code%E5%9C%A8%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8-%E4%BD%BF%E7%94%A8boost-asio-placeholders-error%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><ol>
<li>使用asio避不开boost::system::error_code的使用,在同步编程中很好使用,我主要记录一下异步编程中的用法<a id="more"></a>

</li>
</ol>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><ul>
<li>看一些教程按如下方法使用  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async_read(socket_,buffer(read_buf,4),</span><br><span class="line">      bind(&amp;ChatSession::read_header_handle,shared_from_this(),boost::asio::placeholders::error)</span><br><span class="line">      );</span><br></pre></td></tr></table></figure></li>
<li>但我用如上方法会编译错误, 去掉boost::asio::placeholders::error就可以编译通过,但又需要使用boost::system::error_code,最后找到如下解决方案(原来只要是占位符就行)  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async_read(socket_,buffer(read_buf,4),</span><br><span class="line">       bind(&amp;ChatSession::read_header_handle,shared_from_this(),std::placeholders::_1)</span><br><span class="line">       );</span><br></pre></td></tr></table></figure></li>
<li>以上解决方案参考<a href="http://www.itkeyword.com/doc/6174144975026339x751/cant-use-asioplaceholderserror-in-non-boost-version-of-asio">www.itkeyword.com</a>, 十分感谢大佬</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title>SIGPIPE信号产生原因</title>
    <url>/SIGPIPE%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<p>如果客户端关闭套接字之后(调用close)<br>服务器调用了一次write,服务器会收到一个RST segment(TCP层)<br>如果服务器再次调用了write,这个时候就会产生SIGPIPE信号.<br>SIGPIPE信号的默认处理方式是终止进程,所以要想忽略这个信号,需要加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signal(SIGPIPE,SIG_IGN);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>信号</tag>
        <tag>linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp C/S模型 3个必要设置:SO_REUSEADDR,SIGPIPE,TCP_NODELAY</title>
    <url>/tcp-C-S%E6%A8%A1%E5%9E%8B-3%E4%B8%AA%E5%BF%85%E8%A6%81%E8%AE%BE%E7%BD%AE-SO-REUSEADDR-SIGPIPE-TCP-NODELAY/</url>
    <content><![CDATA[<h3 id="1-SO-REUSEADDR"><a href="#1-SO-REUSEADDR" class="headerlink" title="1. SO_REUSEADDR"></a>1. SO_REUSEADDR</h3><ul>
<li>设置套接字的SO_REUSEADDR选项</li>
<li>一般来说，客户端调用close()后会进入TIME_WAIT状态, 监听的端口仍被占用着，SO_REUSEADDR是让端口释放后立即就可以被再次使用。</li>
</ul>
<a id="more"></a>

<h3 id="2-SIGPIPE"><a href="#2-SIGPIPE" class="headerlink" title="2. SIGPIPE"></a>2. SIGPIPE</h3><ul>
<li>忽略SIGPIPE信号</li>
<li>连接建立，若某一端关闭连接，而另一端仍然向它写数据，第一次写数据后会收到RST响应，此后再写数据，内核将向进程发出SIGPIPE信号，通知进程此连接已经断开。而SIGPIPE信号的默认处理是终止程序.</li>
<li>如果服务器端没有忽略SIGPIPE信号,那如果有一个客户端断开连接,服务器对其因其产生SIGPIPE信号,那么服务器进程就会终止,影响其他客户端,所以要忽略这个信号.</li>
</ul>
<h3 id="3-TCP-NODELAY"><a href="#3-TCP-NODELAY" class="headerlink" title="3. TCP_NODELAY"></a>3. TCP_NODELAY</h3><ul>
<li><p>设置套接字的TCP_NODELAY选项</p>
</li>
<li><p>主要是忽略Nagle算法, 这个算法大致就是send()后,收到ack确认,才会发下一个包, 完整描述如下    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP_NODELAY选项是用来控制是否开启Nagle算法，该算法是为了提高较慢的广域网传输效率，减小小分组的报文个数，</span><br><span class="line"></span><br><span class="line">该算法要求一个TCP连接上最多只能有一个未被确认的小分组，在该小分组的确认到来之前，不能发送其他小分组。</span><br><span class="line"></span><br><span class="line">这里的小分组指的是报文长度小于MSS(Max Segment Size)长度的分组（MSS是在TCP握手的时候在报文选项里面进行通告的大小，</span><br><span class="line">主要是用来限制另一端发送数据的长度，防止IP数据包被分段，提高效率，</span><br><span class="line">一般是链路层的传输最大传输单元大小减去IP首部与TCP首部大小）。</span><br><span class="line"></span><br><span class="line">如果小分组的确认ACK一直没有回来，那么就可能会触发TCP超时重传的定时器。</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个选项不是必须打开的,根据应用场景选择,但很多时候是打开的</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实时性要求比较高的场景，类似用户鼠标操作，键盘输入，触摸屏事件输入，</span><br><span class="line">状态更新等这种连续的小分组数据，需要在对端立刻呈现，让用户尽可能感受不到延迟。</span><br><span class="line">但是如果网络延迟比较高，采用这种方式，那么会导致网路利用率下降。</span><br><span class="line"></span><br><span class="line">一般类似HTTP协议请求响应的模型的场景不太需要考虑禁用这个算法，</span><br><span class="line">因为在一条TCP连接上发送小报文，不管多小都代表了服务端任务执行的指示，</span><br><span class="line">完成了这个请求之后才能继续执行下一个请求，即使Sender端提前发送过去也没有作用，</span><br><span class="line">所以开启Nagle算法是能够优化网络传输的，并且在Receiver端有捎带延迟确认，省掉单独的ACK确认进一步优化小分组传输。</span><br><span class="line">但有时候也需要,可能需要。即使对于那种只需要使用单个连接下载大量数据的客户端实现，</span><br><span class="line">一些数据包仍然需要反向发回以达到最大的传送速度。没有 TCP_NODELAY（但仍然允许 Nagle 算法），</span><br><span class="line">要发出去的数据包可能会被阻塞一会儿，以达到与后续数据包合并的目的</span><br><span class="line">如果有这样一个数据包，它的目的是告诉对方仍有增加发送窗口的空间，</span><br><span class="line">延迟它的发送几百毫秒（或更多）将会对高速连接产生负面的影响。</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>linux</tag>
        <tag>tcp</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程协议设计与protobuf反射</title>
    <url>/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E4%B8%8Eprotobuf%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><ol>
<li>最近在想tcp连接传输信息中应用层协议如何设计, 普遍的有两种: 加结束符和加头部信息,能不能不加头部信息?…….貌似不行</li>
</ol>
<a id="more"></a>

<h3 id="2-协议头"><a href="#2-协议头" class="headerlink" title="2. 协议头"></a>2. 协议头</h3><ol>
<li>协议头必备的两个元素就是长度len, 类型type, 假设占8字节,在客户端和数据封装到一块,发送到服务端,服务端每次先接受8字节,获得类型和长度后,在读取len字节, 根据类型处理.</li>
</ol>
<h3 id="3-protobuf反射机制"><a href="#3-protobuf反射机制" class="headerlink" title="3. protobuf反射机制"></a>3. protobuf反射机制</h3><ol>
<li>protobuf能方便定义传输数据并序列化反序列化, 但还是需要自己加协议头,偶然看到muduo作者陈硕大佬对pootobuf反射机制的博客,本以为不需要协议头了,看完发现还是需要,博客地址: <a href="https://www.cnblogs.com/Solstice/archive/2011/04/03/2004458.html">protobuf反射机制</a>. 不过也了解了这个反射机制</li>
<li>就是能通过”类名”自动推导出类,比如一个User消息格式,可以通过如下方法获得反序列化User对象 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Message* mess&#x3D;get_by_name(&quot;User&quot;);	&#x2F;&#x2F; 这只是个举例,并不是调用这个函数,具体请看上面陈硕的博客</span><br></pre></td></tr></table></figure></li>
<li>陈硕大佬的处理方案是: 封装协议头,协议头里”类型”元素由”类名”取代, 这样的话解析协议头获得类名,然后根据类名获得对象,再进行处理</li>
<li>我个人认为这个解决了自己定义类型可能会重复的问题,自己定义类型可以用typeid或者string, 但不同人可能定义相同的typeid,用string的话可以避免重名,但每次添加新类型也要更新类型种类表,稍显麻烦,除此之外……这个反射机制好像没什么用……粗鄙之见,有什么更好的用处欢迎指教.</li>
</ol>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf不能单独发送一个0</title>
    <url>/protobuf%E4%B8%8D%E8%83%BD%E5%8D%95%E7%8B%AC%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA0/</url>
    <content><![CDATA[<h3 id="1-protobuf使用过程中遇到一个问题-记录一下"><a href="#1-protobuf使用过程中遇到一个问题-记录一下" class="headerlink" title="1. protobuf使用过程中遇到一个问题,记录一下"></a>1. protobuf使用过程中遇到一个问题,记录一下</h3><ul>
<li>定义消息如下  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message RegisterResponse&#123;</span><br><span class="line">    int32 result&#x3D;1; &#x2F;&#x2F; 1表示成功,&gt;1表示账号重复,注意不能为0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li>在服务端使用asio库如下  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res.set_result(0);	&#x2F;&#x2F; 注意这里把result设置为0</span><br><span class="line">...</span><br><span class="line">string send_str;</span><br><span class="line">   res.SerializeToString(&amp;send_str);</span><br><span class="line">   sock_ptr-&gt;write_some(buffer(send_str));</span><br></pre></td></tr></table></figure></li>
<li>客户端如下:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sock.read_some(buffer(buf));</span><br></pre></td></tr></table></figure></li>
<li>上面的把result变量设置为0是问题所在</li>
<li>问题是上述服务端代码把消息发给client,client应该能接收到,但是client却一直阻塞在read_some上,如果把send_str改为char[1024]数组就没问题,于是抓包分析了一下, 发现如果send是string类型,server–&gt;client的包长度为0, 把result设置为其他值,包长就不为0,能正确发送.</li>
<li>可能是protobuf在序列化成字符串的时候,因为值只有一个0,所以被误认为为null了吧,记录一下,以后尽量不用0作为一个结果</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>《图解HTTP》</title>
    <url>/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第1章：了解Web及网络基础"><a href="#第1章：了解Web及网络基础" class="headerlink" title="第1章：了解Web及网络基础"></a>第1章：了解Web及网络基础</h1><h3 id="1-HTTP"><a href="#1-HTTP" class="headerlink" title="1. HTTP"></a>1. HTTP</h3><ul>
<li>HTTP/0.9: HTTP于1990年问世</li>
<li>HTTP/1.0: 在1996年5月正式作为标准被公布，称为1.0版本,至今仍被广泛使用</li>
<li>HTTP/1.1: 1997年1月公布，之后又有修订</li>
<li>HTTP/2.0: 正在制定完善中</li>
</ul>
<h3 id="2-TCP-IP-DNS"><a href="#2-TCP-IP-DNS" class="headerlink" title="2. TCP/IP/DNS"></a>2. TCP/IP/DNS</h3><a id="more"></a>
<ul>
<li>TCP: 负责可靠传输</li>
<li>IP: 负责传输</li>
<li>DNS: 负责域名解析（应用层）</li>
</ul>
<h3 id="3-URI-URL"><a href="#3-URI-URL" class="headerlink" title="3. URI/URL"></a>3. URI/URL</h3><ul>
<li>URI: 统一资源标识符，标识某一互联网资源</li>
<li>URL: 统一资源定位符，标识资源的地点，URL是URI的子集<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;URI例子</span><br><span class="line">ftp:&#x2F;&#x2F;ftp.is.co.za&#x2F;rfc&#x2F;rfc1808.txt</span><br><span class="line">http:&#x2F;&#x2F;www.ietf.org&#x2F;rfc&#x2F;rfc2396.txt</span><br><span class="line">ldap:&#x2F;&#x2F;[2001:db8::7]&#x2F;c&#x3D;GB?objectClass?one</span><br><span class="line">mailto:John.Doe@example.com</span><br><span class="line">news:comp.infosystems.www.servers.unix</span><br><span class="line">tel:+1-816-555-1212</span><br><span class="line">telnet:&#x2F;&#x2F;192.0.2.16:80&#x2F;</span><br><span class="line">urn:oasis:names:specification:docbook:dtd:xml:4.1.2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-RFC"><a href="#4-RFC" class="headerlink" title="4. RFC"></a>4. RFC</h3><ul>
<li>有一些用来制定 HTTP 协议技术标准的文档,它们被称为RFC(Request for Comments,征求修正意见书)。</li>
<li>通常,应用程序会遵照由 RFC 确定的标准实现。但是也有些不遵守。</li>
</ul>
<h1 id="第2章：简单的HTTP协议"><a href="#第2章：简单的HTTP协议" class="headerlink" title="第2章：简单的HTTP协议"></a>第2章：简单的HTTP协议</h1><h3 id="1-请求头与响应头"><a href="#1-请求头与响应头" class="headerlink" title="1. 请求头与响应头"></a>1. 请求头与响应头</h3><ul>
<li>请求头<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法 URI 协议版本</span><br><span class="line">请求首部字段（可选）</span><br><span class="line">\r\n</span><br><span class="line">内容实体</span><br></pre></td></tr></table></figure></li>
<li>响应头<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">协议版本 状态码 状态码的原因短语</span><br><span class="line">响应首部字段（可选）</span><br><span class="line">\r\n</span><br><span class="line">内容主体</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-HTTP是不保存状态的协议"><a href="#2-HTTP是不保存状态的协议" class="headerlink" title="2. HTTP是不保存状态的协议"></a>2. HTTP是不保存状态的协议</h3><ul>
<li>也就是说，在HTTP这个级别，协议对于发送过的请求和相应都不做持久化处理</li>
<li>但是有些需要保持登录状态的网站，需要保存用户的状态</li>
<li>HTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。Cookie在后面详解</li>
</ul>
<h3 id="3-HTTP方法"><a href="#3-HTTP方法" class="headerlink" title="3. HTTP方法"></a>3. HTTP方法</h3><ul>
<li><p>总览</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>支持的 HTTP 协议版本</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取资源</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>POST</td>
<td>传输实体主体</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>PUT</td>
<td>传输文件</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>HEAD</td>
<td>获得报文首部</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除文件</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>询问支持的方法</td>
<td>1.1</td>
</tr>
<tr>
<td>TRACE</td>
<td>追踪路径</td>
<td>1.1</td>
</tr>
<tr>
<td>CONNECT</td>
<td>要求用隧道协议连接代理</td>
<td>1.1</td>
</tr>
<tr>
<td>LINK</td>
<td>建立和资源之间的联系</td>
<td>1.0</td>
</tr>
<tr>
<td>UNLINE</td>
<td>断开连接关系</td>
<td>1.0</td>
</tr>
</tbody></table>
</li>
<li><p>GET</p>
<ul>
<li>请求<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回 index.html 的页面资源</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>POST</p>
<ul>
<li>请求 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;submit.cgi HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br><span class="line">Content-Length: 1560(1560字节的数据)</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回 submit.cgi 接收数据的处理结果</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>PUT</p>
<ul>
<li>PUT 方法用来传输文件。就像 FTP 协议的文件上传一样,要求在请<br>求报文的主体中包含文件内容,然后保存到请求 URI 指定的位置。但是,鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制,任何人都可以上传文件 , 存在安全性问题,因此一般的 Web 网站不使用该方法。若配合 Web 应用程序的验证机制,或架构设计采用REST(REpresentational State Transfer,表征状态转移)标准的同类Web 网站,就可能会开放使用 PUT 方法。</li>
<li>请求 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;example.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Content-Length: 1560(1560 字节的数据)</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">响应返回状态码 204 No Content(比如 :该 html 已存在于服务器上)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>HEAD</p>
<ul>
<li>HEAD 方法和 GET 方法一样,只是不返回报文主体部分。用于确认URI 的有效性及资源更新的日期时间等。</li>
<li>请求 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEAD &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回index.html有关的响应首部</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>DELETE</p>
<ul>
<li>DELETE 方法用来删除文件,是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。但是,HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制,所以一般的 Web 网站也不使用 DELETE 方法。</li>
<li>请求 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE &#x2F;example.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">响应返回状态码 204 No Content(比如 :该 html 已从该服务器上删除)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>OPTIONS</p>
<ul>
<li>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</li>
<li>请求 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPTIONS * HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Allow: GET, POST, HEAD, OPTIONS(返回服务器支持的方法)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>TRACE</p>
<ul>
<li>TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。</li>
<li>客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为,请求想要连接到源目标服务器可能会通过代理中转,TRACE 方法就是用来确认连接过程中发生的一系列操作。</li>
<li>请求<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRACE &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Max-Forwards: 2</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: message&#x2F;http</span><br></pre></td></tr></table></figure></li>
<li>响应<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Length: 1024</span><br><span class="line">TRACE &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Max-Forwards: 2(返回响应包含请求内容)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>CONNECT</p>
<ul>
<li>CONNECT 方法要求在与代理服务器通信时建立隧道,实现用隧道协议进行 TCP 通信。主要使用 SSL(Secure Sockets Layer,安全套接层)和 TLS(Transport Layer Security,传输层安全)协议把通信内容加密后经网络隧道传输。</li>
<li>请求<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONNECT proxy.hackr.jp:8080 HTTP&#x2F;1.1</span><br><span class="line">Host: proxy.hackr.jp</span><br></pre></td></tr></table></figure></li>
<li>响应<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK(之后进入网络隧道)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="4-持久连接节省通信量"><a href="#4-持久连接节省通信量" class="headerlink" title="4. 持久连接节省通信量"></a>4. 持久连接节省通信量</h3><ul>
<li>问题：<br>   HTTP 协议的初始版本中,每进行一次 HTTP 通信就要断开一次 TCP连接。因此,每次的请求都会造成无谓的 TCP 连接建立和断开,增加通信量的开销。</li>
<li><ol>
<li>持久性连接<br> 为解决上述 TCP 连接的问题,HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接(HTTP Persistent Connections,也称为 HTTP keep-alive 或HTTP connection reuse)的方法。持久连接的特点是,只要任意一端没有明确提出断开连接,则保持 TCP 连接状态。</li>
</ol>
<ul>
<li>减少TCP连接次数，减轻服务器负载</li>
<li>Web页面显示速度加快</li>
</ul>
</li>
<li><ol start="2">
<li>管线化</li>
</ol>
<ul>
<li>简单来说就是不等待响应，直接发送下一个请求</li>
<li>从前发送请求后需等待并收到响应,才能发送下一个请求。管线化技术出现后,不用等待响应亦可直接发送下一个请求。管线化技术则比持久连接还要快。请求数越多,时间差就越明显。</li>
</ul>
</li>
</ul>
<h3 id="5-使用Cookie的状态管理"><a href="#5-使用Cookie的状态管理" class="headerlink" title="5. 使用Cookie的状态管理"></a>5. 使用Cookie的状态管理</h3><ul>
<li><ol>
<li>HTTP是无状态的，即服务器不保存客户端的情况，响应之后就不管它是谁谁了。如果让服务器管理全部客户端状态则会成为负担。但这样就不能处理需要登录的情况，所以引入了Cookie技术</li>
</ol>
</li>
<li><ol start="2">
<li>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</li>
</ol>
</li>
<li><ol start="3">
<li>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息,通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入 Cookie 值后发送出去。</li>
</ol>
</li>
<li><ol start="4">
<li>服务器端发现客户端发送过来的 Cookie 后,会去检查究竟是从哪一个客户端发来的连接请求,然后对比服务器上的记录,最后得到之前的状态信息。</li>
</ol>
</li>
<li><ol start="5">
<li>Cookie交互</li>
</ol>
<ul>
<li><ol>
<li>请求报文(没有 Cookie 信息的状态)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第一次连接</span><br><span class="line">GET &#x2F;reader&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">*首部字段内没有Cookie的相关信息</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>响应报文(服务器端生成 Cookie 信息)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">&lt;Set-Cookie: sid&#x3D;1342077140226724; path&#x3D;&#x2F;; expires&#x3D;Wed,10-Oct-12 07:12:20 GMT&gt;</span><br><span class="line">Content-Type: text&#x2F;plain; charset&#x3D;UTF-8</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="3">
<li>请求报文(自动发送保存着的 Cookie 信息)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;image&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Cookie: sid&#x3D;1342077140226724</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="4">
<li>服务器根据再收到的cookie知道是谁连接的</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="第3章：HTTP报文内的HTTP信息"><a href="#第3章：HTTP报文内的HTTP信息" class="headerlink" title="第3章：HTTP报文内的HTTP信息"></a>第3章：HTTP报文内的HTTP信息</h1><h3 id="1-HTTP报文"><a href="#1-HTTP报文" class="headerlink" title="1. HTTP报文"></a>1. HTTP报文</h3><ul>
<li>请求报文<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">报文首部</span><br><span class="line">    - 请求行（包含用于请求的方法,请求 URI 和 HTTP 版本。）</span><br><span class="line">    - 请求首部字段</span><br><span class="line">    - 通用首部字段</span><br><span class="line">    - 实体首部字段</span><br><span class="line">    - 其他（如Cookie等RFC未规定的内容）</span><br><span class="line">空行（CR+LF）</span><br><span class="line">报文主体</span><br></pre></td></tr></table></figure></li>
<li>响应报文<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">报文首部</span><br><span class="line">    - 状态行（包含表明响应结果的状态码,原因短语和 HTTP 版本。）</span><br><span class="line">    - 响应首部字段</span><br><span class="line">    - 通用首部字段</span><br><span class="line">    - 实体首部字段</span><br><span class="line">    - 其他（如Cookie等RFC未定义的内容）</span><br><span class="line">空行（CR+LF）</span><br><span class="line">报文主体</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-编码提高传输效率"><a href="#2-编码提高传输效率" class="headerlink" title="2. 编码提高传输效率"></a>2. 编码提高传输效率</h3><ul>
<li><ol>
<li>报文主体和实体主体的区别</li>
</ol>
<ul>
<li>通常,报文主体等于实体主体。</li>
<li>只有当传输中进行编码操作时,实体主体的内容发生变化,才导致它和报文主体产生差异。</li>
</ul>
</li>
<li><ol start="2">
<li>压缩传输的内容编码</li>
</ol>
<ul>
<li>内容编码指明应用在实体内容上的编码格式,并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。（类似于压缩文件）</li>
<li>常用的内容编码<ul>
<li>gzip(GNU zip)</li>
<li>compress(UNIX 系统的标准压缩)</li>
<li>deflate(zlib)</li>
<li>identity(不进行编码)</li>
</ul>
</li>
</ul>
</li>
<li><ol start="3">
<li>分割发送的分块传输编码</li>
</ol>
<ul>
<li>在 HTTP 通信过程中,请求的编码实体资源尚未全部传输完成之前,浏览器无法显示请求页面。在传输大容量数据时,通过把数据分割成多块,能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码(Chunked TransferCoding)</li>
</ul>
</li>
</ul>
<h3 id="3-发送多种数据的多部分对象集合"><a href="#3-发送多种数据的多部分对象集合" class="headerlink" title="3. 发送多种数据的多部分对象集合"></a>3. 发送多种数据的多部分对象集合</h3><ul>
<li>发送邮件时,我们可以在邮件里写入文字并添加多份附件。这是因为采用了 MIME(Multipurpose Internet Mail Extensions,多用途因特网邮件扩展)机制,它允许邮件处理文本、图片、视频等多个不同类型的数据。</li>
<li>相应地,HTTP 协议中也采纳了多部分对象集合,发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。<ul>
<li>multipart/form-data<br>在 Web 表单文件上传时使用。</li>
<li>multipart/byteranges<br>状态码 206(Partial Content,部分内容)响应报文包含了多</li>
<li>在 HTTP 报文中使用多部分对象集合时,需要在首部字段里加上Content-type。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Type: multipart&#x2F;form-data;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="4-获取部分内容的范围请求"><a href="#4-获取部分内容的范围请求" class="headerlink" title="4. 获取部分内容的范围请求"></a>4. 获取部分内容的范围请求</h3><ul>
<li>以前,用户不能使用现在这种高速的带宽访问互联网,当时,下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况,那就必须重头开始。为了解决上述问题,需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。</li>
<li>对一份 10 000 字节大小的资源,如果使用范围请求,可以只请求5001~10 000 字节内的资源。</li>
<li>例子<ul>
<li>5001~10 000 字节<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Range: bytes&#x3D;5001-10000</span><br></pre></td></tr></table></figure></li>
<li>从 5001 字节之后全部的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Range: bytes&#x3D;5001-</span><br></pre></td></tr></table></figure></li>
<li>从一开始到 3000 字节和 5000~7000 字节的多重范围<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Range: bytes&#x3D;-3000, 5000-7000</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>针对范围请求,响应会返回状态码为 206 Partial Content 的响应报文。另外,对于多重范围的范围请求,响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。</li>
<li>如果服务器端无法响应范围请求,则会返回状态码 200 OK 和完整的实体内容。</li>
</ul>
<h3 id="5-内容协商返回最合适的内容"><a href="#5-内容协商返回最合适的内容" class="headerlink" title="5. 内容协商返回最合适的内容"></a>5. 内容协商返回最合适的内容</h3><ul>
<li>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉,然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</li>
<li>包含在请求报文中的某些首部字段(如下)就是判断的基准。<ul>
<li>Accept</li>
<li>Accept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language</li>
</ul>
</li>
<li>内容协商技术有以下 3 种类型。<ul>
<li>服务器驱动协商(Server-driven Negotiation)<br>由服务器端进行内容协商。以请求的首部字段为参考,在服务器端自动处理。但对用户来说,以浏览器发送的信息作为判定的依据,并不一定能筛选出最优内容。</li>
<li>客户端驱动协商(Agent-driven Negotiation)<br>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型,自行切换成 PC 版页面或手机版页面。</li>
<li>透明协商(Transparent Negotiation)<br>是服务器驱动和客户端驱动的结合体,是由服务器端和客户端各自进行内容协商的一种方法。</li>
</ul>
</li>
</ul>
<h1 id="第4章：返回结果的HTTP状态码"><a href="#第4章：返回结果的HTTP状态码" class="headerlink" title="第4章：返回结果的HTTP状态码"></a>第4章：返回结果的HTTP状态码</h1><h3 id="1-状态码类别"><a href="#1-状态码类别" class="headerlink" title="1. 状态码类别"></a>1. 状态码类别</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational(信息性状态码)</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error(客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error(服务器错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<p>以下为常用的14中状态码</p>
<h3 id="2-2XX成功"><a href="#2-2XX成功" class="headerlink" title="2. 2XX成功"></a>2. 2XX成功</h3><h4 id="2-1-200-OK"><a href="#2-1-200-OK" class="headerlink" title="2.1 200 OK"></a>2.1 200 OK</h4><ul>
<li>正常处理</li>
</ul>
<h4 id="2-2-204-No-Content"><a href="#2-2-204-No-Content" class="headerlink" title="2.2 204 No Content"></a>2.2 204 No Content</h4><ul>
<li>该状态码代表服务器接收的请求已成功处理,但在返回的响应报文中不含实体的主体部分。另外,也不允许返回任何实体的主体。比如,当从浏览器发出请求处理后,返回 204 响应,那么浏览器显示的页面不发生更新。</li>
<li>一般在只需要从客户端往服务器发送信息,而对客户端不需要发送新信息内容的情况下使用</li>
</ul>
<h4 id="2-3-206-Partial-Content"><a href="#2-3-206-Partial-Content" class="headerlink" title="2.3 206 Partial Content"></a>2.3 206 Partial Content</h4><ul>
<li>该状态码表示客户端进行了范围请求,而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<h3 id="3-3XX-重定向"><a href="#3-3XX-重定向" class="headerlink" title="3. 3XX 重定向"></a>3. 3XX 重定向</h3><h4 id="3-1-301-Moved-Permanently"><a href="#3-1-301-Moved-Permanently" class="headerlink" title="3.1 301 Moved Permanently"></a>3.1 301 Moved Permanently</h4><ul>
<li>永久性重定向。该状态码表示请求的资源已被分配了新的 URI,以后应使用资源现在所指的 URI。也就是说,如果已经把资源对应的 URI保存为书签了,这时应该按 Location 首部字段提示的 URI 重新保存。</li>
<li>像下方给出的请求 URI,当指定资源路径的最后忘记添加斜杠“/”,就会产生 301 状态码。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;example.com&#x2F;sample</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-2-302-Found"><a href="#3-2-302-Found" class="headerlink" title="3.2 302 Found"></a>3.2 302 Found</h4><ul>
<li>临时性重定向。该状态码表示请求的资源已被分配了新的 URI,希望用户(本次)能使用新的 URI 访问。</li>
<li>和 301 Moved Permanently 状态码相似,但 302 状态码代表的资源不是被永久移动,只是临时性质的。换句话说,已移动的资源对应的URI 将来还有可能发生改变。比如,用户把 URI 保存成书签,但不会像 301 状态码出现时那样去更新书签,而是仍旧保留返回 302 状态码的页面对应的 URI。</li>
</ul>
<h4 id="3-3-303-See-Other"><a href="#3-3-303-See-Other" class="headerlink" title="3.3 303 See Other"></a>3.3 303 See Other</h4><ul>
<li>该状态码表示由于请求对应的资源存在着另一个 URI,应使用 GET方法定向获取请求的资源。</li>
<li>303 状态码和 302 Found 状态码有着相同的功能,但 303 状态码明确表示客户端应当采用 GET 方法获取资源,这点与 302 状态码有区别。</li>
<li>比如,当使用 POST 方法访问 CGI 程序,其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时,返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能,但这里使用 303状态码是最理想的。</li>
</ul>
<h4 id="3-4-304-Not-Modified"><a href="#3-4-304-Not-Modified" class="headerlink" title="3.4 304 Not Modified"></a>3.4 304 Not Modified</h4><ul>
<li>该状态码表示客户端发送附带条件的请求 2 时,服务器端允许请求访问资源,但未满足条件的情况。304 状态码返回时,不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中,但是和重定向没有关系。</li>
<li>附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match,If-Modified-Since,If-None-Match,If-Range，If-Unmodified-Since 中任一首部。</li>
<li>服务器说：资源已经找到，但是不符合条件请求</li>
</ul>
<h4 id="3-5-307-Temporary-Redirect"><a href="#3-5-307-Temporary-Redirect" class="headerlink" title="3.5 307 Temporary Redirect"></a>3.5 307 Temporary Redirect</h4><ul>
<li>临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET,但实际使用时大家并不遵守。</li>
<li>307 会遵照浏览器标准,不会从 POST 变成 GET。但是,对于处理响应时的行为,每种浏览器有可能出现不同的情况。</li>
</ul>
<h3 id="4-4XX-客户端错误"><a href="#4-4XX-客户端错误" class="headerlink" title="4. 4XX 客户端错误"></a>4. 4XX 客户端错误</h3><h4 id="4-1-400-Bad-Request"><a href="#4-1-400-Bad-Request" class="headerlink" title="4.1 400 Bad Request"></a>4.1 400 Bad Request</h4><ul>
<li>该状态码表示请求报文中存在语法错误。当错误发生时,需修改请求的内容后再次发送请求。另外,浏览器会像 200 OK 一样对待该状态码。</li>
<li>服务器无法理解请求</li>
</ul>
<h4 id="4-2-401-Unauthorized"><a href="#4-2-401-Unauthorized" class="headerlink" title="4.2 401 Unauthorized"></a>4.2 401 Unauthorized</h4><ul>
<li>该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、 DIGEST 认证)的认证信息。另外若之前已进行过 1 次请求,则表示用户认证失败。</li>
<li>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应,会弹出认证用的对话窗口。</li>
</ul>
<h4 id="4-3-403-Forbidden"><a href="#4-3-403-Forbidden" class="headerlink" title="4.3 403 Forbidden"></a>4.3 403 Forbidden</h4><ul>
<li>该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由,但如果想作说明的话,可以在实体的主体部分对原因进行描述,这样就能让用户看到了。</li>
<li>未获得文件系统的访问授权,访问权限出现某些问题(从未授权的发送源 IP 地址试图访问)等列举的情况都可能是发生 403 的原因。</li>
<li>即服务器不允许访问那个资源</li>
</ul>
<h4 id="4-4-404-Not-Found"><a href="#4-4-404-Not-Found" class="headerlink" title="4.4 404 Not Found"></a>4.4 404 Not Found</h4><ul>
<li>该状态码表明服务器上无法找到请求的资源。除此之外,也可以在服务器端拒绝请求且不想说明理由时使用。</li>
</ul>
<h3 id="5-5XX-服务器错误"><a href="#5-5XX-服务器错误" class="headerlink" title="5. 5XX 服务器错误"></a>5. 5XX 服务器错误</h3><h4 id="5-1-500-Internal-Server-Error"><a href="#5-1-500-Internal-Server-Error" class="headerlink" title="5.1 500 Internal Server Error"></a>5.1 500 Internal Server Error</h4><ul>
<li>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。</li>
<li>服务器内部资源出故障</li>
</ul>
<h4 id="5-2-503-Service-Unavailable"><a href="#5-2-503-Service-Unavailable" class="headerlink" title="5.2 503 Service Unavailable"></a>5.2 503 Service Unavailable</h4><ul>
<li>服务器正忙</li>
<li>该状态码表明服务器暂时处于超负载或正在进行停机维护,现在无法处理请求。如果事先得知解除以上状况需要的时间,最好写入RetryAfter 首部字段再返回给客户端。</li>
</ul>
<h3 id="6-状态码和状况的不一致"><a href="#6-状态码和状况的不一致" class="headerlink" title="6. 状态码和状况的不一致"></a>6. 状态码和状况的不一致</h3><ul>
<li>不少返回的状态码响应都是错误的,但是用户可能察觉不到这点。</li>
<li>比如 Web 应用程序内部发生错误,状态码依然返回 200 OK,这种情况也经常遇到。</li>
</ul>
<h1 id="第5章：与-HTTP-协作的-Web-服务器"><a href="#第5章：与-HTTP-协作的-Web-服务器" class="headerlink" title="第5章：与 HTTP 协作的 Web 服务器"></a>第5章：与 HTTP 协作的 Web 服务器</h1><h3 id="1-用单台虚拟主机实现多个域名"><a href="#1-用单台虚拟主机实现多个域名" class="headerlink" title="1. 用单台虚拟主机实现多个域名"></a>1. 用单台虚拟主机实现多个域名</h3><ul>
<li>HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。比如,提供 Web 托管服务(Web Hosting Service)的供应商,可以用一台服务器为多位客户服务,也可以以每位客户持有的域名运行各自不同的网站。这是因为利用了虚拟主机(Virtual Host,又称虚拟服务器)的功能。</li>
<li>若一台服务器上有多个域名，这些域名解析后的IP地址会相同</li>
<li>在相同的 IP 地址下,由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站,因此在发送 HTTP 请求时,必须在 Host 首部内完整指定主机名或域名的 URI。</li>
</ul>
<h3 id="2-通信数据转发程序-代理、网关、隧道"><a href="#2-通信数据转发程序-代理、网关、隧道" class="headerlink" title="2. 通信数据转发程序 :代理、网关、隧道"></a>2. 通信数据转发程序 :代理、网关、隧道</h3><ul>
<li><ol>
<li>代理</li>
</ol>
<ul>
<li>代理是一种有转发功能的应用程序,它扮演了位于服务器和客户端“中间人”的角色,接收由客户端发送的请求并转发给服务器,同时也接收服务器返回的响应并转发给客户端。</li>
<li>使用代理服务器的理由有:<ul>
<li>利用缓存技术(稍后讲解)减少网络带宽的流量</li>
<li>组织内部针对特定网站的访问控制</li>
<li>以获取访问日志为主要目的,等等。</li>
</ul>
</li>
<li>代理有多种使用方法,按两种基准分类。一种是是否使用缓存,另一种是是否会修改报文。<ul>
<li>缓存代理<br>代理转发响应时,缓存代理(Caching Proxy)会预先将资源的副本(缓存)保存在代理服务器上。当代理再次接收到对相同资源的请求时,就可以不从源服务器那里获取资源,而是将之前缓存的资源作为响应返回。</li>
<li>透明代理<br>转发请求或响应时,不对报文做任何加工的代理类型被称为透明代理(Transparent Proxy)。反之,对报文内容进行加工的代理被称为非透明代理。</li>
</ul>
</li>
</ul>
</li>
<li><ol start="2">
<li>网关</li>
</ol>
<ul>
<li>网关是转发其他服务器通信数据的服务器,接收从客户端发送来的请求时,它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉,自己的通信目标是一个网关。</li>
<li>利用网关可以由 HTTP 请求转化为其他协议通信  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端&lt;---------------&gt;网关&lt;---------&gt;非HTTP服务器</span><br><span class="line">    Http请求和响应        其他协议</span><br></pre></td></tr></table></figure></li>
<li>利用网关能提高通信的安全性,因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如,网关可以连接数据库,使用SQL 语句查询数据。另外,在 Web 购物网站上进行信用卡结算时,网关可以和信用卡结算系统联动。</li>
</ul>
</li>
<li><ol start="3">
<li>隧道</li>
</ol>
<ul>
<li>隧道是在相隔甚远的客户端和服务器两者之间进行中转,并保持双方通信连接的应用程序。</li>
<li>隧道可按要求建立起一条与其他服务器的通信线路,届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</li>
<li>隧道本身是透明的,客户端不用在意隧道的存在</li>
</ul>
</li>
</ul>
<h3 id="3-保存资源的缓存"><a href="#3-保存资源的缓存" class="headerlink" title="3. 保存资源的缓存"></a>3. 保存资源的缓存</h3><ul>
<li>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问,因此也就节省了通信流量和通信时间。</li>
<li>缓存有有效期限</li>
<li>客户端(浏览器)也可以缓存，也有有效期限</li>
</ul>
<h1 id="第6章：HTTP首部"><a href="#第6章：HTTP首部" class="headerlink" title="第6章：HTTP首部"></a>第6章：HTTP首部</h1><h3 id="1-HTTP-首部字段一览"><a href="#1-HTTP-首部字段一览" class="headerlink" title="1. HTTP 首部字段一览"></a>1. HTTP 首部字段一览</h3><ul>
<li>通用首部字段</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、连接的管理</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody></table>
<ul>
<li>请求首部字段</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言(自然语言)</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记(ETag)</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记(与 If-Match 相反)</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间(与If-Modified-Since相反)</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP 客户端程序的信息</td>
</tr>
</tbody></table>
<ul>
<li>响应首部字段</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody></table>
<ul>
<li>实体首部字段</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>资源可支持的HTTP方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小(单位:字节)</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody></table>
<h3 id="2-非-HTTP-1-1-首部字段"><a href="#2-非-HTTP-1-1-首部字段" class="headerlink" title="2. 非 HTTP/1.1 首部字段"></a>2. 非 HTTP/1.1 首部字段</h3><ul>
<li>在 HTTP 协议通信交互中使用到的首部字段,不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、Set-Cookie 和Content-Disposition 等在其他 RFC 中定义的首部字段,它们的使用频率也很高。</li>
<li>这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。</li>
</ul>
<h3 id="3-通用首部字段"><a href="#3-通用首部字段" class="headerlink" title="3. 通用首部字段"></a>3. 通用首部字段</h3><h3 id="4-请求首部字段"><a href="#4-请求首部字段" class="headerlink" title="4. 请求首部字段"></a>4. 请求首部字段</h3><h3 id="5-响应首部字段"><a href="#5-响应首部字段" class="headerlink" title="5. 响应首部字段"></a>5. 响应首部字段</h3><h3 id="6-实体首部字段"><a href="#6-实体首部字段" class="headerlink" title="6. 实体首部字段"></a>6. 实体首部字段</h3><ul>
<li>这四个都是讲字段的具体内容，先不做笔记了，有点多和麻烦，需要的时候再搜吧。</li>
</ul>
<h3 id="7-为Cookie服务的首部字段"><a href="#7-为Cookie服务的首部字段" class="headerlink" title="7. 为Cookie服务的首部字段"></a>7. 为Cookie服务的首部字段</h3><ul>
<li>总览</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>首部类型</th>
</tr>
</thead>
<tbody><tr>
<td>Set-Cookie</td>
<td>开始状态管理所使用的Cookie信息</td>
<td>响应首部字段</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器接收到的Cookie信息</td>
<td>请求首部字段</td>
</tr>
</tbody></table>
<ul>
<li><p>set-cookie</p>
<ul>
<li>当服务器准备开始管理客户端的状态时,会事先告知各种信息。下面的表格列举了 Set-Cookie 的字段值。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: status&#x3D;enable; expires&#x3D;Tue, 05 Jul 2011 07:26:31 GMT; path</span><br></pre></td></tr></table></figure>
属性 |说明</li>
</ul>
</li>
<li><p>-|–<br>NAME=VALUE |赋予 Cookie 的名称和其值(必需项)<br>expires=DATE |Cookie 的有效期(若不明确指定则默认为浏览器关闭前为止)<br>path=PATH |将服务器上的文件目录作为Cookie的适用对象(若不指定则默认为文档所在的文件目录)<br>domain=域名 |作为 Cookie 适用对象的域名 (若不指定则默认为创建 Cookie的服务器的域名)<br>Secure |仅在 HTTPS 安全通信时才会发送 Cookie<br>HttpOnly |加以限制,使 Cookie 不能被 JavaScript 脚本访问</p>
</li>
<li><p>cookie</p>
<ul>
<li>首部字段 Cookie 会告知服务器,当客户端想获得 HTTP 状态管理支持时,就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时,同样可以以多个 Cookie 形式发送。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cookie: status&#x3D;enable</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="8-其他首部字段"><a href="#8-其他首部字段" class="headerlink" title="8. 其他首部字段"></a>8. 其他首部字段</h3><ul>
<li>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上,会出现各种非标准的首部字段。</li>
<li>X-Frame-Options<ul>
<li>首部字段 X-Frame-Options 属于 HTTP 响应首部,用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持(clickjacking)攻击。</li>
<li>首部字段 X-Frame-Options 有以下两个可指定的字段值。<ul>
<li>DENY :拒绝</li>
<li>SAMEORIGIN :仅同源域名下的页面(Top-level-browsing-context)匹配时许可。(比如,当指定 <a href="http://hackr.jp/sample.html%E9%A1%B5%E9%9D%A2%E4%B8%BA">http://hackr.jp/sample.html页面为</a> SAMEORIGIN 时,那么 hackr.jp 上所有页面的 frame 都被允许可加载该页面,而 example.com 等其他域名的页面就不行了)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X-Frame-Options: DENY</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>X-XSS-Protection<ul>
<li>首部字段 X-XSS-Protection 属于 HTTP 响应首部,它是针对跨站脚本攻击(XSS)的一种对策,用于控制浏览器 XSS 防护机制的开关。</li>
<li>首部字段 X-XSS-Protection 可指定的字段值如下。<ul>
<li>0 :将 XSS 过滤设置成无效状态</li>
<li>1 :将 XSS 过滤设置成有效状态<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X-XSS-Protection: 1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>DNT<ul>
<li>首部字段 DNT 属于 HTTP 请求首部,其中 DNT 是 Do Not Track 的简称,意为拒绝个人信息被收集,是表示拒绝被精准广告追踪的一种方法。</li>
<li>首部字段 DNT 可指定的字段值如下。<ul>
<li>0 :同意被追踪</li>
<li>1 :拒绝被追踪</li>
</ul>
</li>
<li>由于首部字段 DNT 的功能具备有效性,所以 Web 服务器需要对 DNT做对应的支持。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DNT: 1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>P3P<ul>
<li>首部字段 P3P 属于 HTTP 相应首部,通过利用 P3P(The Platform for Privacy Preferences,在线隐私偏好平台)技术,可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式,以达到保护用户隐私的目的。</li>
<li>要进行 P3P 的设定,需按以下操作步骤进行。<ul>
<li>步骤 1:创建 P3P 隐私</li>
<li>步骤 2:创建 P3P 隐私对照文件后,保存命名在 /w3c/p3p.xml</li>
<li>步骤 3:从 P3P 隐私中新建 Compact policies 后,输出到 HTTP 响应中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第7章-确保-Web-安全的-HTTPS"><a href="#第7章-确保-Web-安全的-HTTPS" class="headerlink" title="第7章 确保 Web 安全的 HTTPS"></a>第7章 确保 Web 安全的 HTTPS</h1><h3 id="1-HTTP-主要有这些不足-例举如下。"><a href="#1-HTTP-主要有这些不足-例举如下。" class="headerlink" title="1. HTTP 主要有这些不足,例举如下。"></a>1. HTTP 主要有这些不足,例举如下。</h3><h5 id="1-通信使用明文-不加密-内容可能会被窃听"><a href="#1-通信使用明文-不加密-内容可能会被窃听" class="headerlink" title="1. 通信使用明文(不加密),内容可能会被窃听"></a>1. 通信使用明文(不加密),内容可能会被窃听</h5><ul>
<li>TCP/IP是可能被窃听的网络<ul>
<li>即使已经过加密处理的通信,也会被窥视到通信内容,这点和未加密的通信是相同的。只是说如果通信经过加密,就有可能让人无法破解报文信息的含义,但加密处理后的报文信息本身还是会被看到的。</li>
</ul>
</li>
<li>加密处理防止被窃听<ul>
<li>通信的加密<ul>
<li>HTTP 协议中没有加密机制,但可以通过和 SSL(Secure Socket Layer,安全套接层)或TLS(Transport Layer Security,安全层传输协议)的组合使用,加密 HTTP 的通信内容。</li>
<li>用 SSL 建立安全通信线路之后,就可以在这条线路上进行 HTTP通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS(HTTP Secure,超文本传输安全协议)或 HTTP over SSL。</li>
</ul>
</li>
<li>内容的加密<ul>
<li>即对报文首部不加密，对报文主体加密</li>
<li>为了做到有效的内容加密,前提是要求客户端和服务器同时具备加密和解密机制。</li>
<li>由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理,所以内容仍有被篡改的风险。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-不验证通信方的身份-因此有可能遭遇伪装"><a href="#2-不验证通信方的身份-因此有可能遭遇伪装" class="headerlink" title="2. 不验证通信方的身份,因此有可能遭遇伪装"></a>2. 不验证通信方的身份,因此有可能遭遇伪装</h5><ul>
<li>任何人都可发起请求<ul>
<li>由于不存在确认通信方的处理步骤,任何人都可以发起请求。另外,服务器只要接收到请求,不管对方是谁都会返回一个响应</li>
<li>仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下</li>
<li>存在的各种隐患<ul>
<li>无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。</li>
<li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。</li>
<li>无法确定正在通信的对方是否具备访问权限。因为某些Web 服务器上保存着重要的信息,只想发给特定用户通信的权限。</li>
<li>无法判定请求是来自何方、出自谁手。</li>
<li>即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击(Denial of Service,拒绝服务攻击)</li>
</ul>
</li>
</ul>
</li>
<li>查明对手的证书<ul>
<li>虽然使用 HTTP 协议无法确定通信方,但如果使用 SSL 则可以。SSL 不仅提供加密处理,而且还使用了一种被称为证书的手段,可用于确定方。</li>
<li>证书由值得信任的第三方机构颁发,用以证明服务器和客户端是实际存在的。另外,伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方(服务器或客户端)持有的证书,即可判断通信方的真实意图。</li>
<li>通过使用证书,以证明通信方就是意料中的服务器。这对使用者个人来讲,也减少了个人信息泄露的危险性。</li>
<li>另外,客户端持有证书即可完成个人身份的确认,也可用于对 Web 网站的认证环节。</li>
</ul>
</li>
</ul>
<h5 id="3-无法证明报文的完整性-所以有可能已遭篡改"><a href="#3-无法证明报文的完整性-所以有可能已遭篡改" class="headerlink" title="3. 无法证明报文的完整性,所以有可能已遭篡改"></a>3. 无法证明报文的完整性,所以有可能已遭篡改</h5><ul>
<li>接收到的内容可能有误<ul>
<li>请求或响应在传输途中,遭攻击者拦截并篡改内容的攻击称为中间人攻击(Man-in-the-Middle attack,MITM)。</li>
</ul>
</li>
<li>如何防止篡改<ul>
<li>虽然有使用 HTTP 协议确定报文完整性的方法,但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法,以及用来确认文件的数字签名方法。这些问题不仅在 HTTP 上出现,其他未加密的协议中也会存在这类问题。</li>
<li>提供文件下载服务的 Web 网站也会提供相应的以 PGP(PrettyGood Privacy,完美隐私)创建的数字签名及 MD5 算法生成的散列值。PGP 是用来证明创建文件的数字签名,MD5 是由单向函数生成的散列值。不论使用哪一种方法,都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件。浏览器无法自动帮用户检查。</li>
<li>可惜的是,用这些方法也依然无法百分百保证确认结果正确。因为 PGP 和 MD5 本身被改写的话,用户是没有办法意识到的。</li>
<li>为了有效防止这些弊端,有必要使用 HTTPS。SSL 提供认证和加密处理及摘要功能。仅靠 HTTP 确保完整性是非常困难的,因此通过和其他协议组合使用来实现这个目标。</li>
</ul>
</li>
</ul>
<h3 id="2-7-2-HTTP-加密-认证-完整性保护-HTTPS"><a href="#2-7-2-HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="2. 7.2 HTTP+ 加密 + 认证 + 完整性保护=HTTPS"></a>2. 7.2 HTTP+ 加密 + 认证 + 完整性保护=HTTPS</h3><h5 id="1-HTTP-加上加密处理和认证以及完整性保护后即是-HTTPS"><a href="#1-HTTP-加上加密处理和认证以及完整性保护后即是-HTTPS" class="headerlink" title="1. HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS"></a>1. HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS</h5><ul>
<li>我们把添加了加密及认证机制的 HTTP 称为 HTTPS(HTTP Secure)。</li>
</ul>
<h5 id="2-HTTPS-是身披-SSL-外壳的-HTTP"><a href="#2-HTTPS-是身披-SSL-外壳的-HTTP" class="headerlink" title="2. HTTPS 是身披 SSL 外壳的 HTTP"></a>2. HTTPS 是身披 SSL 外壳的 HTTP</h5><ul>
<li>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL(Secure Socket Layer)和 TLS(Transport Layer Security)协议代替而已。</li>
<li>通常,HTTP 直接和 TCP 通信。当使用 SSL 时,则演变成先和 SSL 通信,再由 SSL 和 TCP 通信了。简言之,所谓 HTTPS,其实就是身披SSL 协议这层外壳的 HTTP。</li>
<li>SSL 是独立于 HTTP 的协议,所以不光是 HTTP 协议,其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</li>
</ul>
<h5 id="3-相互交换密钥的公开密钥加密技术"><a href="#3-相互交换密钥的公开密钥加密技术" class="headerlink" title="3. 相互交换密钥的公开密钥加密技术"></a>3. 相互交换密钥的公开密钥加密技术</h5><ul>
<li>SSL 采用一种叫做公开密钥加密(Public-key cryptography)的加密处理方式。近代的加密方法中加密算法是公开的,而密钥却是保密的。通过这种方式得以保持加密方法的安全性。加密和解密都会用到密钥。没有密钥就无法对密码解密,反过来说,任何人只要持有密钥就能解密了。如果密钥被攻击者获得,那加密也就失去了意义。</li>
<li>共享密钥加密的困境（对称加密）<ul>
<li>加密和解密同用一个密钥的方式称为共享密钥加密(Common key crypto system),也被叫做对称密钥加密。</li>
<li>密钥发送问题，怎么保证秘钥不会被劫持监听</li>
</ul>
</li>
<li>使用两把密钥的公开密钥加密（非对称加密）<ul>
<li>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥(private key),另一把叫做公开密钥(public key)。顾名思义,私有密钥不能让其他任何人知道,而公开密钥则可以随意发布,任何人都可以获得。</li>
<li>使用公开密钥加密方式,发送密文的一方使用对方的公开密钥进行加密处理,对方收到被加密的信息后,再使用自己的私有密钥进行解密。利用这种方式,不需要发送用来解密的私有密钥,也不必担心密钥被攻击者窃听而盗走。</li>
</ul>
</li>
<li>HTTPS 采用混合加密机制<ul>
<li>若密钥能够实现安全交换,那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比,其处理速度要慢。</li>
<li>充分利用两者各自的优势,将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式,之后的建立通信交换报文阶段则使用共享密钥加密方式。</li>
</ul>
</li>
</ul>
<h5 id="4-证明公开密钥正确性的证书"><a href="#4-证明公开密钥正确性的证书" class="headerlink" title="4. 证明公开密钥正确性的证书"></a>4. 证明公开密钥正确性的证书</h5><ul>
<li>公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。</li>
<li>为了解决上述问题,可以使用由数字证书认证机构(CA,Certificate Authority)和其相关机关颁发的公开密钥证书。</li>
<li>可证明组织真实性的 EV SSL 证书<ul>
<li>证书的一个作用是用来证明作为通信一方的服务器是否规范,另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是 EV SSL 证书(Extended Validation SSL Certificate)。</li>
<li>持有 EV SSL 证书的 Web 网站的浏览器地址栏处的背景色是绿色的,从视觉上就能一眼辨别出。而且在地址栏的左侧显示了 SSL证书中记录的组织名称以及颁发证书的认证机构的名称。</li>
<li>上述机制的原意图是为了防止用户被钓鱼攻击(Phishing),但就效果上来讲,还得打一个问号。很多用户可能不了解 EV SSL证书相关的知识,因此也不太会留意它。</li>
</ul>
</li>
<li>用以确认客户端的客户端证书<ul>
<li>HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认证,证明服务器正在通信的对方始终是预料之内的客户端,其作用跟服务器证书如出一辙。</li>
<li>现状是,安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务。比如那些可支撑客户端证书支出费用的业务。例如,银行的网上银行就采用了客户端证书。在登录网银时不仅要求用户确认输入 ID 和密码,还会要求用户的客户端证书,以确认用户是否从特定的终端访问网银。</li>
</ul>
</li>
<li>认证机构信誉第一</li>
<li>由自认证机构颁发的证书称为自签名证书<ul>
<li>如果使用 OpenSSL 这套开源程序,每个人都可以构建一套属于自己的认证机构,从而自己给自己颁发服务器证书。但该服务器证书在互联网上不可作为证书使用,似乎没什么帮助。</li>
<li>浏览器访问该服务器时,会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。</li>
<li>多数浏览器内预先已植入备受信赖的认证机构的证书,但也有一小部分浏览器会植入中级认证机构的证书。对于中级认证机构颁发的服务器证书,某些浏览器会以正规的证书来对待,可有的浏览器会当作自签名证书。</li>
</ul>
</li>
</ul>
<h5 id="5-HTTPS-通信过程"><a href="#5-HTTPS-通信过程" class="headerlink" title="5. HTTPS 通信过程"></a>5. HTTPS 通信过程</h5><ul>
<li><ol>
<li>Client—&gt;Server Handshake:ClientHello<br> 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件(Cipher Suite)列表(所使用的加密算法及密钥长度等)。</li>
</ol>
</li>
<li><ol start="2">
<li>Server—&gt;Client Handshake:ServerHello<br> 服务器可进行 SSL 通信时,会以 Server Hello 报文作为应答。和客户端一样,在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li>
</ol>
</li>
<li><ol start="3">
<li>Server—&gt;Client Handshake:Certificate<br> 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</li>
</ol>
</li>
<li><ol start="4">
<li>Server—&gt;Client Handshake:ServerHelloDone<br> 最后服务器发送 Server Hello Done 报文通知客户端,最初阶段的 SSL 握手协商部分结束。</li>
</ol>
</li>
<li><ol start="5">
<li>Client—&gt;Server Handshake:ClientKeyExchange<br> SSL 第一次握手结束之后,客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</li>
</ol>
</li>
<li><ol start="6">
<li>Client—&gt;Server ChangeCipherSpec<br> 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器,在此报文之后的通信会采用 Pre-master secret 密钥加密。</li>
</ol>
</li>
<li><ol start="7">
<li>Client—&gt;Server Handshake:Finished<br> 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功,要以服务器是否能够正确解密该报文作为判定标准。</li>
</ol>
</li>
<li><ol start="8">
<li>Server—&gt;Client ChangeCipherSpec<br> 服务器同样发送 Change Cipher Spec 报文。</li>
</ol>
</li>
<li><ol start="9">
<li>Server—&gt;Client Handshake:Finished<br> 服务器同样发送 Finished 报文。</li>
</ol>
</li>
<li><ol start="10">
<li>Client—&gt;Server Application Data(HTTP)<br>服务器和客户端的 Finished 报文交换完毕之后,SSL 连接就算建立完成。当然,通信会受到 SSL 的保护。从此处开始进行应用层协议的通信,即发送 HTTP 请求。</li>
</ol>
</li>
<li><ol start="11">
<li>Server—&gt;Client Application Data(HTTP)<br>应用层协议通信,即发送 HTTP 响应。</li>
</ol>
</li>
<li><ol start="12">
<li>Client—&gt;Server Alert:warning,close_notify<br>最后由客户端断开连接。断开连接时,发送 close_notify 报文。上图做了一些省略,这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。</li>
</ol>
</li>
</ul>
<h5 id="6-HTTPS-的安全通信机制"><a href="#6-HTTPS-的安全通信机制" class="headerlink" title="6. HTTPS 的安全通信机制"></a>6. HTTPS 的安全通信机制</h5><ul>
<li>SSL 和 TLS<ul>
<li>SSL 技术最初是由浏览器开发商网景通信公司率先倡导的,开发过 SSL3.0 之前的版本。目前主导权已转移到 IETF(InternetEngineering Task Force,Internet 工程任务组)的手中。</li>
<li>IETF 以 SSL3.0 为基准,后又制定了 TLS1.0、TLS1.1 和TLS1.2。TSL 是以 SSL 为原型开发的协议,有时会统一称该协议为 SSL。当前主流的版本是 SSL3.0 和 TLS1.0。</li>
<li>由于 SSL1.0 协议在设计之初被发现出了问题,就没有实际投入使用。SSL2.0 也被发现存在问题,所以很多浏览器直接废除了该协议版本。</li>
</ul>
</li>
<li>SSL 速度慢吗<ul>
<li>HTTPS 也存在一些问题,那就是当使用 SSL 时,它的处理速度会变慢。</li>
<li>HTTPS 比 HTTP 要慢 2 到 100 倍</li>
<li>SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源,导致处理速度变慢。<ul>
<li>通信慢：除去和TCP 连接、发送 HTTP 请求 • 响应以外,还必须进行 SSL 通信,因此整体上处理通信量不可避免会增加。</li>
<li>消耗大：SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲,比起 HTTP 会更多地消耗服务器和客户端的硬件资源,导致负载增强。</li>
</ul>
</li>
</ul>
</li>
<li>为什么不全使用HTTPS<ul>
<li><ol>
<li>比HTTP慢，消耗资源多</li>
</ol>
</li>
<li><ol start="2">
<li>证书要钱，减少开销</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="第8章-确认访问用户身份的认证"><a href="#第8章-确认访问用户身份的认证" class="headerlink" title="第8章 确认访问用户身份的认证"></a>第8章 确认访问用户身份的认证</h1><h3 id="1-何为认证"><a href="#1-何为认证" class="headerlink" title="1. 何为认证"></a>1. 何为认证</h3><ul>
<li>计算机本身无法判断坐在显示器前的使用者的身份。进一步说,也无法确认网络的那头究竟有谁。可见,为了弄清究竟是谁在访问服务器,就得让对方的客户端自报家门。</li>
<li>核对的信息有如下几个<ul>
<li>密码:只有本人才会知道的字符串信息。</li>
<li>动态令牌:仅限本人持有的设备内显示的一次性密码。</li>
<li>数字证书:仅限本人(终端)持有的信息。</li>
<li>生物认证:指纹和虹膜等本人的生理信息。</li>
<li>IC 卡等:仅限本人持有的信息。</li>
</ul>
</li>
<li>HTTP/1.1 使用的认证方式<ul>
<li>BASIC 认证(基本认证)</li>
<li>DIGEST 认证(摘要认证)</li>
<li>SSL 客户端认证</li>
<li>FormBase 认证(基于表单认证)</li>
</ul>
</li>
</ul>
<h3 id="2-BASIC-认证"><a href="#2-BASIC-认证" class="headerlink" title="2. BASIC 认证"></a>2. BASIC 认证</h3><ul>
<li>BASIC 认证(基本认证)是从 HTTP/1.0 就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是 Web 服务器与通信客户端之间进行的认证方式。</li>
<li>BASIC 认证使用上不够便捷灵活,且达不到多数 Web 网站期望的安全性等级,因此它并不常用</li>
<li>步骤<ul>
<li><ol>
<li>Client—&gt;Server   GET<br> 请求的资源需要 BASIC 认证</li>
</ol>
</li>
<li><ol start="2">
<li>Server—&gt;Client   401<br> 服务器会随状态码 401 Authorization Required,返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式(BASIC) 及 Request-URI 安全域字符串(realm)。</li>
</ol>
</li>
<li><ol start="3">
<li>Client—&gt;Server<br> 接收到状态码 401 的客户端为了通过 BASIC 认证,需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成,两者中间以冒号(:)连接后,再经过 Base64 编码处理。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;例子</span><br><span class="line">&#x2F;&#x2F;假设用户 ID 为 guest,密码是 guest,连接起来就会形成guest:guest 这样的字符串。</span><br><span class="line">&#x2F;&#x2F;然后经过 Base64 编码,最后的结果即是Z3Vlc3Q6Z3Vlc3Q&#x3D;。</span><br><span class="line">&#x2F;&#x2F;把这串字符串写入首部字段 Authorization 后,发送请求。</span><br><span class="line">GET &#x2F;private&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Authorization: Basic Z3Vlc3Q6Z3Vlc3Q&#x3D;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="4">
<li>Server—&gt;Client<br> 服务器认证成功返回200，失败返回401</li>
</ol>
</li>
</ul>
</li>
<li>BASIC 认证虽然采用 Base64 编码方式,但这不是加密处理。不需要任何附加信息即可对其解码。换言之,由于明文解码后就是用户 ID和密码,在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中,如果被人窃听,被盗的可能性极高。</li>
<li>另外,除此之外想再进行一次 BASIC 认证时,一般的浏览器却无法实现认证注销操作,这也是问题之一。</li>
</ul>
<h3 id="3-DIGEST-认证"><a href="#3-DIGEST-认证" class="headerlink" title="3. DIGEST 认证"></a>3. DIGEST 认证</h3><ul>
<li><p>为弥补 BASIC 认证存在的弱点,从 HTTP/1.1 起就有了 DIGEST 认证。 DIGEST 认证同样使用质询 / 响应的方式(challenge/response),但不会像 BASIC 认证那样直接发送明文密码。</p>
</li>
<li><p>质询响应方式<br>  是指,一开始一方会先发送认证要求给另一方,接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。</p>
</li>
<li><p>步骤</p>
<ul>
<li><ol>
<li>Client—&gt;Server   GET<br> 请求的资源需要 BASIC 认证</li>
</ol>
</li>
<li><ol start="2">
<li>Server—&gt;Client   401<br> 服务器会随状态码 401 Authorization Required,返回带 WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码(随机数,nonce)</li>
</ol>
</li>
<li><ol start="3">
<li>Client—&gt;Server<br> 接收到 401 状态码的客户端,返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。</li>
</ol>
</li>
<li><ol start="4">
<li>Server—&gt;Client<br> 接收到包含首部字段 Authorization 请求的服务器,会确认认证信息的正确性。认证通过后则返回包含 Request-URI 资源的响应。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="4-SSL-客户端认证"><a href="#4-SSL-客户端认证" class="headerlink" title="4. SSL　客户端认证"></a>4. SSL　客户端认证</h3><ul>
<li><p>从使用用户 ID 和密码的认证方式方面来讲,只要二者的内容正确,即可认证是本人的行为。但如果用户 ID 和密码被盗,就很有可能被第三者冒充。利用 SSL 客户端认证则可以避免该情况的发生。</p>
</li>
<li><p>SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书(在 HTTPS 一章已讲解)认证,服务器可确认访问是否来自已登录的客户端。</p>
</li>
<li><p>步骤</p>
<ul>
<li>接收到需要认证资源的请求,服务器会发送 Certificate Request 报文,要求客户端提供客户端证书。</li>
<li>用户选择将发送的客户端证书后,客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。</li>
<li>服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥,然后开始 HTTPS 加密通信。</li>
</ul>
</li>
<li><p>SSL 客户端认证必要的费用</p>
<ul>
<li>使用 SSL 客户端认证需要用到客户端证书。而客户端证书需要支付一定费用才能使用。</li>
</ul>
</li>
</ul>
<h3 id="5-基于表单认证"><a href="#5-基于表单认证" class="headerlink" title="5. 基于表单认证"></a>5. 基于表单认证</h3><ul>
<li>基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息(Credential),按登录信息的验证结果认证。</li>
</ul>
<h5 id="1-认证多半为基于表单认证"><a href="#1-认证多半为基于表单认证" class="headerlink" title="1. 认证多半为基于表单认证"></a>1. 认证多半为基于表单认证</h5><ul>
<li>由于使用上的便利性及安全性问题,HTTP 协议标准提供的 BASIC 认证和 DIGEST 认证几乎不怎么使用。另外,SSL 客户端认证虽然具有高度的安全等级,但因为导入及维持费用等问题,还尚未普及。</li>
<li>不具备共同标准规范的表单认证,在每个 Web 网站上都会有各不相同的实现方式。</li>
</ul>
<h5 id="2-Session-管理及-Cookie-应用"><a href="#2-Session-管理及-Cookie-应用" class="headerlink" title="2. Session 管理及 Cookie 应用"></a>2. Session 管理及 Cookie 应用</h5><ul>
<li>基于表单认证本身是通过服务器端的 Web 应用,将客户端发送过来的用户 ID 和密码与之前登录过的信息做匹配来进行认证的。</li>
<li>但鉴于 HTTP 是无状态协议,之前已认证成功的用户状态无法通过协议层面保存下来。即,无法实现状态管理,因此即使当该用户下一次继续访问,也无法区分他与其他的用户。于是我们会使用 Cookie 来管理 Session,以弥补 HTTP 协议中不存在的状态管理功能。</li>
<li>步骤<ul>
<li><ol>
<li>客户端把用户 ID 和密码等登录信息放入报文的实体部分,通常是以 POST 方法把请求发送给服务器。而这时,会使用 HTTPS通信来进行 HTML 表单画面的显示和用户输入数据的发送。</li>
</ol>
</li>
<li><ol start="2">
<li>服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证,然后把用户的认证状态与Session ID 绑定后记录在服务器端。<br>向客户端返回响应时,会在首部字段 Set-Cookie 内写入 SessionID(如 PHPSESSID=028a8c…)。<br>另外,为减轻跨站脚本攻击(XSS)造成的损失,建议事先在 Cookie内加上 httponly 属性。</li>
</ol>
</li>
<li><ol start="3">
<li>客户端接收到从服务器端发来的 Session ID 后,会将其作为Cookie 保存在本地。下次向服务器发送请求时,浏览器会自动发送Cookie,所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。</li>
</ol>
</li>
</ul>
</li>
<li>通常,一种安全的保存方法是,先利用给密码加盐(salt) 1 的方式增加额外信息,再使用散列(hash)函数计算出散列值后保存。但是我们也经常看到直接保存明文密码的做法,而这样的做法具有导致密码泄露的风险。</li>
</ul>
<h1 id="第9章：基于-HTTP-的功能追加协议"><a href="#第9章：基于-HTTP-的功能追加协议" class="headerlink" title="第9章：基于 HTTP 的功能追加协议"></a>第9章：基于 HTTP 的功能追加协议</h1><h3 id="1-消除-HTTP-瓶颈的-SPDY"><a href="#1-消除-HTTP-瓶颈的-SPDY" class="headerlink" title="1. 消除 HTTP 瓶颈的 SPDY"></a>1. 消除 HTTP 瓶颈的 SPDY</h3><ul>
<li><p>互联网工程任务组（IETF）对谷歌提出的SPDY协议进行了标准化，于2015年5推出了类似于SPDY协议的 HTTP 2.0 协议标准（简称HTTP/2）。谷歌因此宣布放弃对SPDY协议的支持，转而支持HTTP/2。谷歌称，计划于 2016 年初在 Chrome 中移除 SPDY，并将为Chrome 40 添加 HTTP/2 协议支持。</p>
</li>
<li><p>总之就是弃用了</p>
</li>
<li><p>HTTP的瓶颈</p>
<ul>
<li>一条连接上只可发送一个请求。</li>
<li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。</li>
<li>请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。发送冗长的首部。每次互相发送相同的首部造成的浪费较多。</li>
<li>可任意选择数据压缩格式。非强制压缩发送。</li>
</ul>
</li>
<li><p>Ajax 的解决方法</p>
<ul>
<li>Ajax(Asynchronous JavaScript and XML, 异 步 JavaScript 与 XML 技术)是一种有效利用 JavaScript 和 DOM(Document Object Model,文档对象模型)的操作,以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比,由于它只更新一部分页面,响应中传输的数据量会因此而减少,这一优点显而易见。</li>
<li>而利用 Ajax 实时地从服务器获取内容,有可能会导致大量请求产生。另外,Ajax 仍未解决 HTTP 协议本身存在的问题。</li>
</ul>
</li>
<li><p>Comet 的解决方法</p>
<ul>
<li>一旦服务器端有内容更新了,Comet 不会让请求等待,而是直接给客户端返回响应。这是一种通过延迟应答,模拟实现服务器端向客户端推送(Server Push)的功能。</li>
<li>通常,服务器端接收到请求,在处理完毕后就会立即返回响应,但为了实现推送功能,Comet 会先将响应置于挂起状态,当服务器端有内容更新时,再返回该响应。因此,服务器端一旦有更新,就可以立即反馈给客户端。</li>
<li>内容上虽然可以做到实时更新,但为了保留响应,一次连接的持续时间也变长了。期间,为了维持连接会消耗更多的资源。另外,Comet也仍未解决 HTTP 协议本身存在的问题。</li>
</ul>
</li>
</ul>
<h3 id="2-使用浏览器进行全双工通信的-WebSocket"><a href="#2-使用浏览器进行全双工通信的-WebSocket" class="headerlink" title="2. 使用浏览器进行全双工通信的 WebSocket"></a>2. 使用浏览器进行全双工通信的 WebSocket</h3><ul>
<li><p>利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题在于通信若使用 HTTP 协议,就无法彻底解决瓶颈问题。WebSocket网络技术正是为解决这些问题而实现的一套新协议及 API。</p>
</li>
<li><p>WebSocket 协议</p>
<ul>
<li>一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接,之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML 或图片等任意格式的数据。</li>
<li>由于是建立在 HTTP 基础上的协议,因此连接的发起方仍是客户端,而一旦确立 WebSocket 通信连接,不论服务器还是客户端,任意一方都可直接向对方发送报文。</li>
</ul>
</li>
<li><p>WebSocket 协议的主要特点。</p>
<ul>
<li>推送功能<br>支持由服务器向客户端推送数据的推送功能。这样,服务器可直接发送数据,而不必等待客户端的请求。</li>
<li>减少通信量<br>只要建立起 WebSocket 连接,就希望一直保持连接状态。和 HTTP 相比,不但每次连接时的总开销减少,而且由于 WebSocket 的首部信息很小,通信量也相应减少了。</li>
<li>握手<br>为了实现 WebSocket 通信,在 HTTP 连接建立之后,需要完成一次“握手”(Handshaking)的步骤。<ul>
<li>握手·请求<br>为了实现 WebSocket 通信,需要用到 HTTP 的 Upgrade 首部字段,告知服务器通信协议发生改变,以达到握手的目的。<br>Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值。<br>Sec-WebSocket-Protocol 字段内记录使用的子协议。子协议按 WebSocket 协议标准在连接分开使用时,定义那些连接的名称。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ&#x3D;&#x3D;</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></li>
<li>握手·响应<br>对于之前的请求,返回状态码 101 Switching Protocols 的响应。<br>Sec-WebSocket-Accept 的字段值是由握手请求中的 Sec-WebSocket-Key 的字段值生成的。<br>成功握手确立 WebSocket 连接之后,通信时不再使用 HTTP 的数据帧,而采用 WebSocket 独立的数据帧。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第10章：构建-Web-内容的技术"><a href="#第10章：构建-Web-内容的技术" class="headerlink" title="第10章：构建 Web 内容的技术"></a>第10章：构建 Web 内容的技术</h1><h3 id="1-HTML-CSS-JS"><a href="#1-HTML-CSS-JS" class="headerlink" title="1. HTML/CSS/JS"></a>1. HTML/CSS/JS</h3><h3 id="2-Web-应用"><a href="#2-Web-应用" class="headerlink" title="2. Web 应用"></a>2. Web 应用</h3><ul>
<li>Web 应用是指通过 Web 功能提供的应用程序。比如购物网站、网上银行、SNS、BBS、搜索引擎和 e-learning 等。互联网(Internet)或企业内网(Intranet)上遍布各式各样的 Web 应用。原本应用 HTTP 协议的 Web 的机制就是对客户端发来的请求,返回事前准备好的内容。可随着 Web 越来越普及,仅靠这样的做法已不足以应对所有的需求,更需要引入由程序创建 HTML 内容的做法。</li>
</ul>
<h5 id="1-与-Web-服务器及程序协作的-CGI"><a href="#1-与-Web-服务器及程序协作的-CGI" class="headerlink" title="1. 与 Web 服务器及程序协作的 CGI"></a>1. 与 Web 服务器及程序协作的 CGI</h5><ul>
<li>CGI(Common Gateway Interface,通用网关接口)是指 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在 CGI 的作用下,程序会对请求内容做出相应的动作,比如创建 HTML 等动态内容。</li>
<li>使用 CGI 的程序叫做 CGI 程序,通常是用 Perl、PHP、Ruby 和 C 等编程语言编写而成。</li>
</ul>
<h5 id="2-因-Java-而普及的-Servlet"><a href="#2-因-Java-而普及的-Servlet" class="headerlink" title="2. 因 Java 而普及的 Servlet"></a>2. 因 Java 而普及的 Servlet</h5><ul>
<li>Servlet 是一种能在服务器上创建动态内容的程序。Servlet 是用 Java语言实现的一个接口,属于面向企业级 Java(JavaEE,Java Enterprise Edition)的一部分</li>
<li>CGI,由于每次接到请求,程序都要跟着启动一次。因此一旦访问量过大,Web 服务器要承担相当大的负载。而 Servlet 运行在与 Web 服务器相同的进程中,因此受到的负载较小。Servlet 的运行环境叫做 Web 容器或 Servlet 容器。</li>
<li>随着 CGI 的普及,每次请求都要启动新 CGI 程序的 CGI 运行机制逐渐变成了性能瓶颈,所以之后 Servlet 和 mod_perl 等可直接在 Web 服务器上运行的程序才得以开发、普及。</li>
</ul>
<h3 id="3-数据发布的格式及语言"><a href="#3-数据发布的格式及语言" class="headerlink" title="3. 数据发布的格式及语言"></a>3. 数据发布的格式及语言</h3><h5 id="1-XML"><a href="#1-XML" class="headerlink" title="1. XML"></a>1. XML</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;研讨会 编号&#x3D;&quot;TR001&quot; 主题&#x3D;&quot;Web应用程序脆弱性诊断讲座&quot;&gt;</span><br><span class="line">    &lt;类别&gt;安全&lt;&#x2F;类别&gt;</span><br><span class="line">    &lt;概要&gt;为深入研究Web应用程序脆弱性诊断必要的...&lt;&#x2F;概要&gt;</span><br><span class="line">&lt;&#x2F;研讨会&gt;</span><br><span class="line">&lt;研讨会 编号&#x3D;&quot;TR002&quot; 主题&#x3D;&quot;网络系统脆弱性诊断讲座&quot;&gt;</span><br><span class="line">    &lt;类别&gt;安全&lt;&#x2F;类别&gt;</span><br><span class="line">    &lt;概要&gt;为深入研究网络系统脆弱性诊断必要的...&lt;&#x2F;概要&gt;</span><br><span class="line">&lt;&#x2F;研讨会&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-JSON"><a href="#2-JSON" class="headerlink" title="2. JSON"></a>2. JSON</h5><ul>
<li>JSON(JavaScript Object Notation)是一种以JavaScript(ECMAScript)的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有 false/null/true/ 对象 / 数组 / 数字 / 字符串,这 7 种类型。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Web Application Security&quot;,</span><br><span class="line">    &quot;num&quot;: &quot;TR001&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="3-发布更新信息的-RSS-Atom"><a href="#3-发布更新信息的-RSS-Atom" class="headerlink" title="3. 发布更新信息的 RSS/Atom"></a>3. 发布更新信息的 RSS/Atom</h5><ul>
<li>RSS(简易信息聚合,也叫聚合内容)和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了 XML。</li>
</ul>
<h1 id="第11章：Web-的攻击技术"><a href="#第11章：Web-的攻击技术" class="headerlink" title="第11章：Web 的攻击技术"></a>第11章：Web 的攻击技术</h1><h3 id="0-说明"><a href="#0-说明" class="headerlink" title="0. 说明"></a>0. 说明</h3><ul>
<li>因对安全知识了解不多，本章只是做了个大概的笔记，对很多还不懂。</li>
</ul>
<h3 id="1-针对-Web-应用的攻击模式"><a href="#1-针对-Web-应用的攻击模式" class="headerlink" title="1. 针对 Web 应用的攻击模式"></a>1. 针对 Web 应用的攻击模式</h3><h5 id="以服务器为目标的主动攻击"><a href="#以服务器为目标的主动攻击" class="headerlink" title="以服务器为目标的主动攻击"></a>以服务器为目标的主动攻击</h5><ul>
<li>主动攻击(active attack)是指攻击者通过直接访问 Web 应用,把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击,因此攻击者需要能够访问到那些资源。</li>
<li>主动攻击模式里具有代表性的攻击是 SQL 注入攻击和 OS 命令注入攻击。</li>
</ul>
<h5 id="以服务器为目标的被动攻击"><a href="#以服务器为目标的被动攻击" class="headerlink" title="以服务器为目标的被动攻击"></a>以服务器为目标的被动攻击</h5><ul>
<li>被动攻击(passive attack)是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中,攻击者不直接对目标 Web 应用访问发起攻击。</li>
<li>攻击模式<ul>
<li>步骤 1: 攻击者诱使用户触发已设置好的陷阱,而陷阱会启动发送已嵌入攻击代码的 HTTP 请求。</li>
<li>步骤 2: 当用户不知不觉中招之后,用户的浏览器或邮件客户端就会触发这个陷阱。</li>
<li>步骤 3: 中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用,运行攻击代码。</li>
<li>步骤 4: 执行完攻击代码,存在安全漏洞的 Web 应用会成为攻击者的跳板,可能导致用户所持的 Cookie 等个人信息被窃取,登录状态中的用户权限遭恶意滥用等后果。</li>
<li>被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。</li>
</ul>
</li>
<li>利用用户的身份攻击企业内部网络<ul>
<li>利用被动攻击,可发起对原本从互联网上无法直接访问的企业内网等网络的攻击。只要用户踏入攻击者预先设好的陷阱,在用户能够访问到的网络范围内,即使是企业内网也同样会受到攻击。</li>
<li>很多企业内网依然可以连接到互联网上,访问 Web 网站,或接收互联网发来的邮件。这样就可能给攻击者以可乘之机,诱导用户触发陷阱后对企业内网发动攻击。</li>
</ul>
</li>
</ul>
<h3 id="2-因输出值转义不完全引发的安全漏洞"><a href="#2-因输出值转义不完全引发的安全漏洞" class="headerlink" title="2. 因输出值转义不完全引发的安全漏洞"></a>2. 因输出值转义不完全引发的安全漏洞</h3><ul>
<li>实施 Web 应用的安全对策可大致分为以下两部分。<ul>
<li>客户端的验证</li>
<li>Web 应用端(服务器端)的验证<ul>
<li>输入值验证</li>
<li>输出值转义</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h5><ul>
<li>跨站脚本攻击(Cross-Site Scripting,XSS)是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。</li>
<li>跨站脚本攻击有可能造成以下影响<ul>
<li>利用虚假输入表单骗取用户个人信息。</li>
<li>利用脚本窃取用户的 Cookie 值,被害者在不知情的情况下,帮助攻击者发送恶意请求。</li>
<li>显示伪造的文章或图片。</li>
<li>对用户 Cookie 的窃取攻击</li>
</ul>
</li>
</ul>
<h5 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h5><ul>
<li>会执行非法 SQL 的 SQL 注入攻击<br>  例如查询到用户密码</li>
</ul>
<h5 id="OS-命令注入攻击"><a href="#OS-命令注入攻击" class="headerlink" title="OS 命令注入攻击"></a>OS 命令注入攻击</h5><ul>
<li>OS 命令注入攻击(OS Command Injection)是指通过 Web 应用,执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。</li>
</ul>
<h5 id="HTTP-首部注入攻击"><a href="#HTTP-首部注入攻击" class="headerlink" title="HTTP 首部注入攻击"></a>HTTP 首部注入攻击</h5><ul>
<li>HTTP 首部注入攻击(HTTP Header Injection)是指攻击者通过在响应首部字段内插入换行,添加任意响应首部或主体的一种攻击。属于被动攻击模式</li>
<li>HTTP 首部注入攻击有可能会造成以下一些影响<ul>
<li>设置任何 Cookie 信息</li>
<li>重定向至任意 URL</li>
<li>显示任意的主体(HTTP 响应截断攻击)</li>
<li>HTTP 响应截断攻击</li>
</ul>
</li>
</ul>
<h5 id="邮件首部注入攻击"><a href="#邮件首部注入攻击" class="headerlink" title="邮件首部注入攻击"></a>邮件首部注入攻击</h5><ul>
<li>邮件首部注入(Mail Header Injection)是指 Web 应用中的邮件发送功能,攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。利用存在安全漏洞的 Web 网站,可对任意邮件地址发送广告邮件或病毒邮件。</li>
</ul>
<h5 id="目录遍历攻击"><a href="#目录遍历攻击" class="headerlink" title="目录遍历攻击"></a>目录遍历攻击</h5><ul>
<li>目录遍历(Directory Traversal)攻击是指对本无意公开的文件目录,通过非法截断其目录路径后,达成访问目的的一种攻击。这种攻击有时也称为路径遍历(Path Traversal)攻击。</li>
</ul>
<h5 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h5><ul>
<li>远程文件包含漏洞(Remote File Inclusion)是指当部分脚本内容需要从其他文件读入时,攻击者利用指定外部服务器的 URL 充当依赖文件,让脚本读取之后,就可运行任意脚本的一种攻击。</li>
</ul>
<h3 id="3-因设置或设计上的缺陷引发的安全漏洞"><a href="#3-因设置或设计上的缺陷引发的安全漏洞" class="headerlink" title="3. 因设置或设计上的缺陷引发的安全漏洞"></a>3. 因设置或设计上的缺陷引发的安全漏洞</h3><h5 id="强制浏览"><a href="#强制浏览" class="headerlink" title="强制浏览"></a>强制浏览</h5><ul>
<li>强制浏览有可能会造成以下一些影响。<ul>
<li>泄露顾客的个人信息等重要情报</li>
<li>泄露原本需要具有访问权限的用户才可查阅的信息内容</li>
<li>泄露未外连到外界的文件</li>
</ul>
</li>
<li>对那些原本不愿公开的文件,为了保证安全会隐蔽其 URL。可一旦知道了那些 URL,也就意味着可浏览 URL 对应的文件。直接显示容易推测的文件名或文件目录索引时,通过某些方法可能会使 URL 产生泄露。</li>
<li>例子<br>  如加锁日记不想让别人看，但是别人知道日记中的某个图片的存放地址，就能直接通过URL访问这个图片</li>
</ul>
<h5 id="不正确的错误消息处理"><a href="#不正确的错误消息处理" class="headerlink" title="不正确的错误消息处理"></a>不正确的错误消息处理</h5><ul>
<li>不正确的错误消息处理(Error Handling Vulnerability)的安全漏洞是指,Web 应用的错误信息内包含对攻击者有用的信息。</li>
<li>Web 应用不必在用户的浏览画面上展现详细的错误消息。对攻击者来说,详细的错误消息有可能给他们下一次攻击以提示。</li>
<li>与 Web 应用有关的主要错误信息如下所示。<ul>
<li>Web 应用抛出的错误消息</li>
<li>数据库等系统抛出的错误消息</li>
</ul>
</li>
</ul>
<h5 id="开放重定向"><a href="#开放重定向" class="headerlink" title="开放重定向"></a>开放重定向</h5><ul>
<li>开放重定向(Open Redirect)是一种对指定的任意 URL 作重定向跳转的功能。而于此功能相关联的安全漏洞是指,假如指定的重定向 URL到某个具有恶意的 Web 网站,那么用户就会被诱导至那个 Web 网站。</li>
</ul>
<h3 id="4-因会话管理疏忽引发的安全漏洞"><a href="#4-因会话管理疏忽引发的安全漏洞" class="headerlink" title="4. 因会话管理疏忽引发的安全漏洞"></a>4. 因会话管理疏忽引发的安全漏洞</h3><h5 id="会话劫持"><a href="#会话劫持" class="headerlink" title="会话劫持"></a>会话劫持</h5><ul>
<li>会话劫持(Session Hijack)是指攻击者通过某种手段拿到了用户的会话 ID,并非法使用此会话 ID 伪装成用户,达到攻击的目的。</li>
<li>几种攻击者可获得会话 ID 的途径。<ul>
<li>通过非正规的生成方法推测会话 ID</li>
<li>通过窃听或 XSS 攻击盗取会话 ID</li>
<li>通过会话固定攻击(Session Fixation)强行获取会话 ID</li>
</ul>
</li>
</ul>
<h5 id="会话固定攻击"><a href="#会话固定攻击" class="headerlink" title="会话固定攻击"></a>会话固定攻击</h5><ul>
<li>对以窃取目标会话 ID 为主动攻击手段的会话劫持而言,会话固定攻击(Session Fixation)攻击会强制用户使用攻击者指定的会话 ID,属于被动攻击。</li>
</ul>
<h5 id="跨站点请求伪造"><a href="#跨站点请求伪造" class="headerlink" title="跨站点请求伪造"></a>跨站点请求伪造</h5><ul>
<li>跨站点请求伪造(Cross-Site Request Forgeries,CSRF)攻击是指攻击者通过设置好的陷阱,强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新,属于被动攻击。</li>
<li>跨站点请求伪造有可能会造成以下等影响。<ul>
<li>利用已通过认证的用户权限更新设定信息等</li>
<li>利用已通过认证的用户权限购买商品</li>
<li>利用已通过认证的用户权限在留言板上发表言论</li>
</ul>
</li>
</ul>
<h3 id="5-其他安全漏洞"><a href="#5-其他安全漏洞" class="headerlink" title="5. 其他安全漏洞"></a>5. 其他安全漏洞</h3><h5 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h5><ul>
<li>通过网络的密码试错<ul>
<li>穷举法,全试一遍</li>
<li>字典攻击，构造好密码字典，一一尝试</li>
</ul>
</li>
<li>对已加密密码的破解(指攻击者入侵系统,已获得加密或散列处理的密码数据的情况)</li>
</ul>
<h5 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h5><ul>
<li>点击劫持(Clickjacking)是指利用透明的按钮或链接做成陷阱,覆盖在 Web 页面之上。然后诱使用户在不知情的情况下,点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing)。</li>
</ul>
<h5 id="DoS-攻击"><a href="#DoS-攻击" class="headerlink" title="DoS 攻击"></a>DoS 攻击</h5><ul>
<li>DoS 攻击(Denial of Service attack)是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站,还包括网络设备及服务器等。</li>
<li>主要有以下两种 DoS 攻击方式。<ul>
<li>集中利用访问请求造成资源过载,资源用尽的同时,实际上服务也就呈停止状态。</li>
<li>通过攻击安全漏洞使服务停止。</li>
</ul>
</li>
</ul>
<h5 id="后门程序"><a href="#后门程序" class="headerlink" title="后门程序"></a>后门程序</h5><ul>
<li>后门程序(Backdoor)是指开发设置的隐藏入口,可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。</li>
<li>通常的后门程序分为以下 3 种类型。<ul>
<li>开发阶段作为 Debug 调用的后门程序</li>
<li>开发者为了自身利益植入的后门程序</li>
<li>攻击者通过某种方法设置的后门程序</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>《TCPIP详解》</title>
    <url>/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ol>
<li>这本书略看了一下，学习的时候主要学的《计算机网络(谢希仁)》，这个笔记是根据“即时通讯网”上的资料整理的。获益良多。</li>
<li>关于TCP,嗯还有很多要学的。<a id="more"></a>

</li>
</ol>
<h1 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h1><h3 id="网络常识"><a href="#网络常识" class="headerlink" title="网络常识"></a>网络常识</h3><ul>
<li><ol>
<li>互联网地址(ip地址)</li>
</ol>
<ul>
<li>网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。现在，通常使用的IP地址是一个32bit的数字，也就是我们常说的IPv4 标准，这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址。具体的 分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合</li>
</ul>
</li>
<li><ol start="2">
<li>域名系统</li>
</ol>
<ul>
<li>域名系统是一个分布的数据库，它提供将主机名（就是网址）转换成IP地址的服务。</li>
</ul>
</li>
<li><ol start="3">
<li>RFC</li>
</ol>
<ul>
<li>RFC是什么？RFC就是tcp/ip协议的标准文档，在这里我们可以看到RFC那长长的定义列表，现在它一共有4000多个协议的定义，当然，我们所要学习的，也就是那么十几个协议而已。</li>
</ul>
</li>
<li><ol start="4">
<li>端口号(port)</li>
</ol>
<ul>
<li>注意，这个号码是用在TCP，UDP上的一个逻辑号码，并不是一个硬件端口，我们平时说把某某端口封掉了，也只是在IP层次把带有这个号码的IP包给过滤掉了而已。</li>
</ul>
</li>
<li><ol start="5">
<li>应用编程接口</li>
</ol>
<ul>
<li>现在常用的编程接口有socket和TLI。而前面的有时候也叫做“Berkeley socket”，可见Berkeley对于网络的发展有多大的贡献。</li>
</ul>
</li>
</ul>
<h1 id="二：链路层"><a href="#二：链路层" class="headerlink" title="二：链路层"></a>二：链路层</h1><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li><p>链路层主要有三个目的</p>
<ol>
<li>为IP模块发送和接收IP数据报；</li>
<li>为ARP模块发送ARP请求和接收ARP应答；</li>
<li>为RARP发送RARP请求和接收RARP应答。</li>
</ol>
</li>
<li><p>TCP/IP支持多种不同的链路层协议，这取决于网络所使用的硬件，如以太网、令牌环网、FDDI（光纤分布式数据接口）及RS-232串行线路等。</p>
</li>
<li><p>本章讨论内容</p>
<ol>
<li>详细讨论以太网链路层协议</li>
<li>两个串行接口链路层协议（SLIP和PPP），以及大多数实现都包含的环回（loopback）驱动程序。</li>
<li>以太网和SLIP是本书中大多数例子使用的链路层。</li>
<li>对MTU（最大传输单元）进行了介绍</li>
<li>如何为串行线路选择MTU。</li>
</ol>
</li>
</ul>
<h3 id="2-以太网和IEEE-802封装"><a href="#2-以太网和IEEE-802封装" class="headerlink" title="2. 以太网和IEEE 802封装"></a>2. 以太网和IEEE 802封装</h3><ul>
<li>以太网是当今TCP/IP采用的主要的局域网技术。它采用一种称作CSMA/CD的媒体接入方法，其意思是带冲突检测的载波侦听多路接入（Carrier Sense, Multiple Access with Collision Detection）。它的速率为10 Mb/s，地址为48 bit。</li>
<li>几年后，IEEE（电子电气工程师协会）802委员会公布了一个稍有不同的标准集，其中802.3针对整个CSMA/CD网络，802.4针对令牌总线网络，802.5针对令牌环网络。这三者的共同特性由802.2标准来定义，那就是802网络共有的逻辑链路控制（LLC）。不幸的是，802.2和802.3定义了一个与以太网不同的帧格式。</li>
</ul>
<h3 id="3-SLIP：串行线路IP"><a href="#3-SLIP：串行线路IP" class="headerlink" title="3. SLIP：串行线路IP"></a>3. SLIP：串行线路IP</h3><ul>
<li>SLIP的全称是Serial Line IP。它是一种在串行线路上对IP数据报进行封装的简单形式</li>
<li>压缩的SLIP，CSLIP</li>
<li>常用于低速的串行链路</li>
</ul>
<h3 id="4-PPP：点对点协议"><a href="#4-PPP：点对点协议" class="headerlink" title="4. PPP：点对点协议"></a>4. PPP：点对点协议</h3><ul>
<li>点对点协议修改了SLIP协议中的所有缺陷</li>
<li>PPP数据帧的格式。  <!-- ![1.ppp.png](./img/1.ppp.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/1.ppp.png" class="" title="1.ppp.png">
<ul>
<li>每一帧都以标志字符0x7e开始和结束。</li>
<li>紧接着是一个地址字节，值始终是0xff</li>
<li>然后是一个值为0x03的控制字节。</li>
<li>接下来是协议字段，类似于以太网中类型字段的功能。当它的值为0x0021时，表示信息字段是一个IP数据报；值为0xc021时，表示信息字段是链路控制数据；值为0x8021时，表示信息字段是网络控制数据。</li>
<li>CRC字段（或FCS，帧检验序列）是一个循环冗余检验码，以检测数据帧中的错误。</li>
<li>0x7e结束</li>
</ul>
</li>
<li>由于标志字符的值是0x7e，因此当该字符出现在信息字段中时，PPP需要对它进行转义。</li>
<li>与SLIP类似，由于PPP经常用于低速的串行链路</li>
<li>PPP比SLIP具有下面这些优点：<br>  (1)PPP支持在单根串行线路上运行多种协议，不只是IP协议；<br>  (2)每一帧都有循环冗余检验；<br>  (3)通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；<br>  (4)与CSLIP类似，对TCP和IP报文首部进行压缩；<br>  (5)链路控制协议可以对多个数据链路选项进行设置。为这些优点付出的代价是在每一帧的首部增加3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</li>
</ul>
<h3 id="5-环回接口"><a href="#5-环回接口" class="headerlink" title="5. 环回接口"></a>5. 环回接口</h3><ul>
<li>作用：允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信。</li>
<li>A类网络号127就是为环回接口预留的。根据惯例，大多数系统把IP地址127.0.0.1分配给这个接口，并命名为localhost。一个传给环回接口的IP数据报不能在任何网络上出现。</li>
<li>用ifconfig显示的lo就是loopback接口</li>
</ul>
<h3 id="6-最大传输单元MTU"><a href="#6-最大传输单元MTU" class="headerlink" title="6. 最大传输单元MTU"></a>6. 最大传输单元MTU</h3><ul>
<li>以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。链路层的这个特性称作MTU ,最大传输单元。</li>
<li>如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大,那么IP层就需要进行分片（fragmentation），把数据报分成若干片，这样每一片都小于MTU。</li>
<li>netstat -in看MTU值</li>
</ul>
<h3 id="7-路径MTU"><a href="#7-路径MTU" class="headerlink" title="7. 路径MTU"></a>7. 路径MTU</h3><ul>
<li>当在同一个网络上的两台主机互相进行通信时，该网络的MTU是非常重要的。但是如果两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的MTU。重要的不是两台主机所在网络的MTU的值，重要的是两台通信主机路径中的最小MTU。它被称作路径MTU。</li>
<li>两台主机之间的路径MTU不一定是个常数。它取决于当时所选择的路由。而选路不一定是对称的（从A到B的路由可能与从B到A的路由不同），因此路径MTU在两个方向上不一定是一致的。</li>
</ul>
<h3 id="8-串行线路吞吐量计算-如何为串行线路选择MTU"><a href="#8-串行线路吞吐量计算-如何为串行线路选择MTU" class="headerlink" title="8. 串行线路吞吐量计算(如何为串行线路选择MTU)"></a>8. 串行线路吞吐量计算(如何为串行线路选择MTU)</h3><ul>
<li>如果线路速率是9600 b/s，而一个字节有8bit，加上一个起始比特和一个停止比特，那么线路的速率就是960 B/s（字节/秒）。以这个速率传输一个1024字节的分组需要1066 ms。如果用SLIP链接运行一个交互式应用程序，同时还运行另一个应用程序如FTP发送或接收1024字节的数据，那么一般来说就必须等待一半的时间（533 ms）才能把交互式应用程序的分组数据发送出去。</li>
<li>对于交互应用来说，等待533 ms是不能接受的。关于人的有关研究表明，交互响应时间超过100～200 ms就被认为是不好的</li>
<li>把SLIP的MTU缩短到256就意味着链路传输一帧最长需要266 ms，它的一半是133 ms（这是一般需要等待的时间）。这样情况会好一些，但仍然不完美。我们选择它的原因（与64或128相比）是因为大块数据提供良好的线路利用率（如大文件传输）。</li>
<li>假设CSLIP的报文首部是5个字节，数据帧总长为261个字节，256个字节的数据使线路的利用率为98.1%，帧头占了1.9%，这样的利用率是很不错的。如果把MTU降到256以下，那么将降低传输大块数据的最大吞吐量。</li>
</ul>
<h1 id="三：IP-网际协议"><a href="#三：IP-网际协议" class="headerlink" title="三：IP:网际协议"></a>三：IP:网际协议</h1><h3 id="1-引言-1"><a href="#1-引言-1" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输</li>
<li>不可靠unreliable<ul>
<li>意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）。</li>
</ul>
</li>
<li>无连接connectionless<ul>
<li>意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明，IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达。</li>
</ul>
</li>
<li>本章讨论的内容<ul>
<li><ol>
<li>IP首部中的各个字段</li>
</ol>
</li>
<li><ol start="2">
<li>讨论IP路由选择和子网的有关内容</li>
</ol>
</li>
<li><ol start="3">
<li>介绍两个有用的命令：ifconfig和netstat。</li>
</ol>
</li>
<li><ol start="4">
<li>关于IP首部中一些字段的细节，将留在以后使用这些字段的时候再进行讨论。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="2-IP首部"><a href="#2-IP首部" class="headerlink" title="2. IP首部"></a>2. IP首部</h3><!-- ![2.IP首部.png](./img/2.IP首部.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/2.IP%E9%A6%96%E9%83%A8.png" class="" title="2.IP首部.png">
<ul>
<li>首部长度<ul>
<li>首部长度指的是首部占32 bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部最长为60个字节。在第8章中，我们将看到这种限制使某些选项如路由记录选项在当今已没有什么用处。普通IP数据报（没有任何选择项）字段的值是5。</li>
</ul>
</li>
<li>服务类型<ul>
<li>服务类型（TOS）字段包括一个3bit的优先权子字段（现在已被忽略），4bit的TOS子字段和1bit未用位但必须置0。4bit的TO S分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。4bit中只能置其中1bit。如果所有4bit均为0，那么就意味着是一般服务。</li>
</ul>
</li>
<li>总长度字段<ul>
<li>是指整个IP数据报的长度，以字节为单位。利用首部长度字段和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16比特，所以IP数据报最长可达65535字节（超级通道的MTU为65535。它的意思其实不是一个真正的MTU—它使用了最长的IP数据报）。当数据报被分片时，该字段的值也随着变化。</li>
<li>尽管可以传送一个长达65535字节的IP数据报，但是大多数的链路层都会对它进行分片。而且，主机也要求不能接收超过576字节的数据报。</li>
<li>由于TCP把用户数据分成若干片，因此一般来说这个限制不会影响TCP。</li>
<li>大量使用UDP的应用（RIP，TFTP，BOOTP，DNS，以及SNMP），它们都限制用户数据报长度为512字节，小于576字节。但是，事实上现在大多数的实现（特别是那些支持网络文件系统NFS的实现）允许超过8192字节的IP数据报。</li>
</ul>
</li>
<li>标识字段<ul>
<li>唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。</li>
<li>在讨论分片时再来分析标志字段和片偏移字段。</li>
</ul>
</li>
<li>TTL<ul>
<li>生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。</li>
</ul>
</li>
<li>协议字段<ul>
<li>根据它可以识别是哪个协议向IP传送数据。(TCP or UDP?)</li>
</ul>
</li>
<li>首部检验和字段<ul>
<li>是根据IP首部计算的检验和码。它不对首部后面的数据进行计算。ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。</li>
</ul>
</li>
<li>源IP地址和目的IP地址<ul>
<li>它们都是32 bit的值。</li>
</ul>
</li>
<li>任选项<ul>
<li>这些选项很少被使用，并非所有的主机和路由器都支持这些选项。</li>
</ul>
</li>
</ul>
<h3 id="3-IP路由选择"><a href="#3-IP路由选择" class="headerlink" title="3. IP路由选择"></a>3. IP路由选择</h3><ul>
<li>当今的大多数多用户系统，包括几乎所有的Unix系统，都可以配置成一个路由器。我们可以为它指定主机和路由器都可以使用的简单路由算法。本质上的区别在于主机从不把数据报从一个接口转发到另一个接口，而路由器则要转发数据报。内含路由器功能的主机应该从不转发数据报，除非它被设置成那样。</li>
<li>在一般的体制中，IP可以从TCP、UDP、ICMP和IGMP接收数据报（即在本地生成的数据报）并进行发送，或者从一个网络接口接收数据报（待转发的数据报）并进行发送。</li>
<li>IP层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次。<ul>
<li>当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样，数据报就被送到由IP首部协议字段所指定的协议模块进行处理。</li>
<li>如果数据报的目的不是这些地址，那么（1）如果IP层被设置为路由器的功能，那么就对数据报进行转发（也就是说，像下面对待发出的数据报一样处理）；否则（2）数据报被丢弃。</li>
</ul>
</li>
<li>路由表中的每一项都包含下面这些信息：<ul>
<li>目的IP地址</li>
<li>下一跳路由器IP地址</li>
<li>标志</li>
<li>为数据报的传输指定一个网络接口</li>
</ul>
</li>
<li>IP路由选择</li>
<li>为一个网络指定一个路由器，而不必为每个主机指定一个路由器，这是IP路由选择机制的另一个基本特性。这样做可以极大地缩小路由表的规模</li>
</ul>
<h3 id="4-子网寻址和子网掩码"><a href="#4-子网寻址和子网掩码" class="headerlink" title="4. 子网寻址和子网掩码"></a>4. 子网寻址和子网掩码</h3><ul>
<li>先比较是否是同类地址(A?B?C?),然后用子网掩码看是否在同一个子网，然后再看主机号</li>
<li>主机号全1表示是该子网的广播地址</li>
<li>255.255.255.255是受限的广播(永远不被转发)</li>
</ul>
<h3 id="5-ifconfig和netstat"><a href="#5-ifconfig和netstat" class="headerlink" title="5. ifconfig和netstat"></a>5. ifconfig和netstat</h3><ul>
<li>查看/设置网卡信息</li>
<li>查看TCP等连接情况，接口信息等</li>
</ul>
<h1 id="四：ARP-地址解析协议"><a href="#四：ARP-地址解析协议" class="headerlink" title="四：ARP:地址解析协议"></a>四：ARP:地址解析协议</h1><h3 id="1-引言-2"><a href="#1-引言-2" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>数据链路如以太网或令牌环网都有自己的寻址机制（常常为48 bit地址），这是使用数据链路的任何网络层都必须遵从的。</li>
<li>一个网络如以太网可以同时被不同的网络层使用。例如，一组使用TCP/IP协议的主机和另一组使用某种PC网络软件的主机可以共享相同的电缆。</li>
<li>ARP<ul>
<li>为IP地址到对应的硬件地址之间提供动态映射。我们之所以用动态这个词是因为这个过程是自动完成的，一般应用程序用户或系统管理员不必关心。</li>
</ul>
</li>
<li>RARP<ul>
<li>是被那些没有磁盘驱动器的系统使用（一般是无盘工作站或X终端），它需要系统管理员进行手工设置。</li>
</ul>
</li>
</ul>
<h3 id="2-一个例子"><a href="#2-一个例子" class="headerlink" title="2. 一个例子"></a>2. 一个例子</h3><ul>
<li>使用 ftp <a href="http://www.xxx.com/">www.xxx.com</a> 过程<ul>
<li><ol>
<li>应用程序FTP客户端调用函数gethostbyname(3)把主机名（bsdi）转换成32 bit的IP地址。这个函数在DNS（域名系统）中称作解析器，我们将在第14章对它进行介绍。这个转换过程或者使用DNS，或者在较小网络中使用一个静态的主机文件（/etc/hosts）。</li>
</ol>
</li>
<li><ol start="2">
<li>FTP客户端请求TCP用得到的IP地址建立连接。</li>
</ol>
</li>
<li><ol start="3">
<li>TCP发送一个连接请求分段到远端的主机，即用上述IP地址发送一份IP数据报（在第18章我们将讨论完成这个过程的细节）。</li>
</ol>
</li>
<li><ol start="4">
<li>如果目的主机在本地网络上（如以太网、令牌环网或点对点链接的另一端），那么IP数据报可以直接送到目的主机上。如果目的主机在一个远程网络上，那么就通过IP选路函数来确定位于本地网络上的下一站路由器地址，并让它转发IP数据报。在这两种情况下，IP数据报都是被送到位于本地网络上的一台主机或路由器。</li>
</ol>
</li>
<li><ol start="5">
<li>假定是一个以太网，那么发送端主机必须把32 bit的IP地址变换成48 bit的以太网地址。从逻辑Internet地址到对应的物理硬件地址需要进行翻译。这就是ARP的功能。ARP本来是用于广播网络的，有许多主机或路由器连在同一个网络上。</li>
</ol>
</li>
<li><ol start="6">
<li>ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机。这个过程称作广播，如图4-2中的虚线所示。ARP请求数据帧中包含目的主机的IP地址（主机名为bsdi），其意思是“如果你是这个IP地址的拥有者，请回答你的硬件地址。”</li>
</ol>
</li>
<li><ol start="7">
<li>目的主机的ARP层收到这份广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址。</li>
</ol>
</li>
<li><ol start="8">
<li>收到ARP应答后，使ARP进行请求—应答交换的IP数据报现在就可以传送了。</li>
</ol>
</li>
<li><ol start="9">
<li>发送IP数据报到目的主机。<!-- ![3.ftpARP.png](./img/3.ftpARP.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/3.ftpARP.png" class="" title="3.ftpARP.png"></li>
</ol>
</li>
</ul>
</li>
<li>在ARP背后有一个基本概念，那就是网络接口有一个硬件地址（一个48 bit的值，标识不同的以太网或令牌环网络接口）。</li>
<li>点对点链路不使用ARP。当设置这些链路时（一般在引导过程进行），必须告知内核链路每一端的IP地址。像以太网地址这样的硬件地址并不涉及。</li>
</ul>
<h3 id="3-ARP高速缓存"><a href="#3-ARP高速缓存" class="headerlink" title="3. ARP高速缓存"></a>3. ARP高速缓存</h3><ul>
<li>ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了最近Internet地址到硬件地址之间的映射记录。</li>
<li>高速缓存中每一项的生存时间一般为20分钟，起始时间从被创建时开始算起。</li>
<li>arp -a 查看缓存表</li>
</ul>
<h3 id="4-ARP的分组格式"><a href="#4-ARP的分组格式" class="headerlink" title="4. ARP的分组格式"></a>4. ARP的分组格式</h3><!-- ![4.ARP.png](./img/4.ARP.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/4.ARP.png" class="" title="4.ARP.png">
<ul>
<li>以太网首部14字节</li>
<li>ARP请求/应答28字节</li>
</ul>
<h3 id="5-ARP代理"><a href="#5-ARP代理" class="headerlink" title="5. ARP代理"></a>5. ARP代理</h3><ul>
<li>如果ARP请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作委托ARP或ARP代理(Proxy ARP)。</li>
</ul>
<h3 id="6-免费ARP"><a href="#6-免费ARP" class="headerlink" title="6. 免费ARP"></a>6. 免费ARP</h3><ul>
<li>免费ARP(gratuitous ARP)。它是指主机发送ARP查找自己的IP地址。通常，它发生在系统引导期间进行接口配置的时候。</li>
<li>免费ARP可以有两个方面的作用：<ul>
<li><ol>
<li>一个主机可以通过它来确定另一个主机是否设置了相同的IP地址。主机bsdi并不希望对此请求有一个回答。但是，如果收到一个回答，那么就会在终端日志上产生一个错误消息“以太网地址：a:b:c:d:e:f发送来重复的IP地址”。这样就可以警告系统管理员，某个系统有不正确的设置。</li>
</ol>
</li>
<li><ol start="2">
<li>如果发送免费ARP的主机正好改变了硬件地址（很可能是主机关机了，并换了一块接口卡，然后重新启动），那么这个分组就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。</li>
</ol>
</li>
<li>一个比较著名的ARP协议事实[Plummer 1982]是，如果主机收到某个IP地址的ARP请求，而且它已经在接收者的高速缓存中，那么就要用ARP请求中的发送端硬件地址（如以太网地址）对高速缓存中相应的内容进行更新。主机接收到任何ARP请求都要完成这个操作（ARP请求是在网上广播的，因此每次发送ARP请求时网络上的所有主机都要这样做）。</li>
</ul>
</li>
</ul>
<h1 id="五-RARP-逆地址解析协议"><a href="#五-RARP-逆地址解析协议" class="headerlink" title="五 RARP:逆地址解析协议"></a>五 RARP:逆地址解析协议</h1><h3 id="1-引言-3"><a href="#1-引言-3" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li><p>具有本地磁盘的系统引导时，一般是从磁盘上的配置文件中读取IP地址。但是无盘机，如X终端或无盘工作站，则需要采用其他方法来获得IP地址。</p>
</li>
<li><p>网络上的每个系统都具有唯一的硬件地址，它是由网络接口生产厂家配置的。无盘系统的RARP实现过程是从接口卡上读取唯一的硬件地址，然后发送一份RARP请求（一帧在网络上广播的数据），请求某个主机响应该无盘系统的IP地址（在RARP应答中）。</p>
</li>
<li><p>RARP分组的格式与ARP分组基本一致</p>
</li>
<li><p>ARP服务器很简单，通常是TCP/IP在内核中实现的一部分。由于内核知道IP地址和硬件地址，因此当它收到一个询问IP地址的ARP请求时，只需用相应的硬件地址来提供应答就可以了。</p>
</li>
<li><p>但是一个RARP服务器的设计与系统相关而且比较复杂。</p>
</li>
<li><p>虽然RARP在概念上很简单，但是RARP服务器的实现却与系统相关。因此，并不是所有的TCP/IP实现都提供RARP服务器。</p>
</li>
</ul>
<h1 id="六-ICMP-Internet控制报文协议"><a href="#六-ICMP-Internet控制报文协议" class="headerlink" title="六 ICMP:Internet控制报文协议"></a>六 ICMP:Internet控制报文协议</h1><h3 id="1-引言-4"><a href="#1-引言-4" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li><p>IP数据包</p>
<table>
<thead>
<tr>
<th>IP首部</th>
<th>ICMP报文</th>
</tr>
</thead>
<tbody><tr>
<td>20字节</td>
<td>不确定字节</td>
</tr>
<tr>
<td><!-- ![5.ICMP-IP.png](./img/5.ICMP-IP.png) --></td>
<td></td>
</tr>
<tr>
<td><img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/5.ICMP-IP.png" class="" title="5.ICMP-IP.png"></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>ICMP</p>
<table>
<thead>
<tr>
<th>8位类型</th>
<th>8位代码</th>
<th>16位校验和</th>
</tr>
</thead>
<tbody><tr>
<td>其他内容</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><!-- ![6.ICMP.png](./img/6.ICMP.png) --></td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/6.ICMP.png" class="" title="6.ICMP.png"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>本章内容</p>
<ul>
<li><ol>
<li>讨论ICMP报文</li>
</ol>
</li>
<li><ol start="2">
<li>详解地址掩码请求和应答、时间戳请求和应答以及不可达端口。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="2-ICMP报文类型"><a href="#2-ICMP报文类型" class="headerlink" title="2. ICMP报文类型"></a>2. ICMP报文类型</h3><!-- ![7.ICMP报文类型.png](./img/7.ICMP报文类型.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/7.ICMP%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B.png" class="" title="7.ICMP报文类型.png">
<ul>
<li><p>图中的最后两列表明ICMP报文是一份查询报文还是一份差错报文。因为对ICMP差错报文有时需要作特殊处理，因此我们需要对它们进行区分。</p>
<ul>
<li>例如，在对ICMP差错报文进行响应时，永远不会生成另一份ICMP差错报文（如果没有这个限制规则，可能会遇到一个差错产生另一个差错的情况，而差错再产生差错，这样会无休止地循环下去）。</li>
</ul>
</li>
<li><p>当发送一份ICMP差错报文时，报文始终包含IP的首部和产生ICMP差错报文的IP数据报的前8个字节。这样，接收ICMP差错报文的模块就会把它与某个特定的协议（根据IP数据报首部中的协议字段来判断）和用户进程（根据包含在IP数据报前8个字节中的TCP或UDP报文首部中的TCP或UDP端口号来判断）联系起来。</p>
</li>
<li><p>下面各种情况都不会导致产生ICMP差错报文：</p>
<ol>
<li>ICMP差错报文（但是，ICMP查询报文可能会产生ICMP差错报文）。</li>
<li>目的地址是广播地址或多播地址的IP数据报。</li>
<li>作为链路层广播的数据报。</li>
<li>不是IP分片的第一片（将在11.5节介绍分片）。</li>
<li>源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地址或多播地址。</li>
</ol>
<ul>
<li>这些规则是为了防止过去允许ICMP差错报文对广播分组响应所带来的广播风暴。</li>
</ul>
</li>
</ul>
<h3 id="3-ICMP地址掩码请求与应答"><a href="#3-ICMP地址掩码请求与应答" class="headerlink" title="3. ICMP地址掩码请求与应答"></a>3. ICMP地址掩码请求与应答</h3><ul>
<li>ICMP地址掩码请求用于无盘系统在引导过程中获取自己的子网掩码</li>
<li>ICMP地址掩码请求和应答报文共12字节<!-- ![8.ICMP请求掩码.png](./img/8.ICMP请求掩码.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/8.ICMP%E8%AF%B7%E6%B1%82%E6%8E%A9%E7%A0%81.png" class="" title="8.ICMP请求掩码.png">

</li>
</ul>
<h3 id="4-ICMP时间戳请求与应答"><a href="#4-ICMP时间戳请求与应答" class="headerlink" title="4. ICMP时间戳请求与应答"></a>4. ICMP时间戳请求与应答</h3><ul>
<li>ICMP时间戳请求允许系统向另一个系统查询当前的时间。</li>
<li>报文有20字节<!-- ![9.ICMP时间戳.png](./img/9.ICMP时间戳.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/9.ICMP%E6%97%B6%E9%97%B4%E6%88%B3.png" class="" title="9.ICMP时间戳.png">

</li>
</ul>
<h3 id="5-ICMP端口不可达差错"><a href="#5-ICMP端口不可达差错" class="headerlink" title="5. ICMP端口不可达差错"></a>5. ICMP端口不可达差错</h3><ul>
<li><p>端口不可达报文，它是ICMP目的不可到达报文中的一种，以此来看一看ICMP差错报文中所附加的信息。使用UDP（见第11章）来查看它。</p>
</li>
<li><p>UDP的规则之一是，如果收到一份UDP数据报而目的端口与某个正在使用的进程不相符，那么UDP返回一个ICMP不可达报文。可以用TFTP来强制生成一个端口不可达报文（TFTP将在第15章描述）。</p>
</li>
<li><p>有16种不同类型的ICMP不可达报文，代码分别从0到15。</p>
</li>
<li><p>netstat -s 查看每个协议统计数据</p>
</li>
<li><p>ICMP不可达报文</p>
  <!-- ![10.ICMP不可达报文.png](./img/10.ICMP不可达报文.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/10.ICMP%E4%B8%8D%E5%8F%AF%E8%BE%BE%E6%8A%A5%E6%96%87.png" class="" title="10.ICMP不可达报文.png">

</li>
</ul>
<h1 id="七-Ping程序"><a href="#七-Ping程序" class="headerlink" title="七 Ping程序"></a>七 Ping程序</h1><h3 id="1-引言-5"><a href="#1-引言-5" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>一般来说，如果不能Ping到某台主机，那么就不能Telnet或者FTP到那台主机。反过来，如果不能Telnet到某台主机，那么通常可以用Ping程序来确定问题出在哪里。</li>
<li>Ping程序还能测出到这台主机的往返时间，以表明该主机离我们有“多远”。</li>
</ul>
<h3 id="2-Ping程序"><a href="#2-Ping程序" class="headerlink" title="2. Ping程序"></a>2. Ping程序</h3><ul>
<li><p>大多数的TCP/IP实现都在内核中直接支持Ping服务器—这种服务器不是一个用户进程</p>
  <!-- ![11.ICMP回显.png](./img/11.ICMP回显.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/11.ICMP%E5%9B%9E%E6%98%BE.png" class="" title="11.ICMP回显.png"></li>
<li><p>Unix系统在实现ping程序时是把ICMP报文中的标识符字段置成发送进程的ID号。这样即使在同一台主机上同时运行了多个ping程序实例，ping程序也可以识别出返回的信息。</p>
</li>
<li><p>运行在不同的环境下结果不一样</p>
<ul>
<li>LAN</li>
<li>WAN</li>
<li>线路SLIP链接</li>
<li>拨号SLIP链路</li>
</ul>
</li>
</ul>
<h3 id="3-IP记录路由选项"><a href="#3-IP记录路由选项" class="headerlink" title="3. IP记录路由选项"></a>3. IP记录路由选项</h3><ul>
<li>ping程序为我们提供了查看IP记录路由（RR）选项的机会。</li>
<li>发送出去的IP数据报中设置IPRR选项（该IP数据报包含ICMP回显请求报文）。这样，每个处理该数据报的路由器都把它的IP地址放入选项字段中。</li>
<li>只能存放9个IP地址。</li>
</ul>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul>
<li>Ping服务器一般在内核中实现ICMP的功能。</li>
<li>只利用ICMP回显请求(类型8)和回显应答报文(类型0)，而不用经过传输层（TCP/UDP）。</li>
</ul>
<h1 id="八-Traceroute程序"><a href="#八-Traceroute程序" class="headerlink" title="八 Traceroute程序"></a>八 Traceroute程序</h1><h3 id="1-引言-6"><a href="#1-引言-6" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>Traceroute程序可以让我们看到IP数据报从一台主机传到另一台主机所经过的路由。</li>
<li>IP记录路由选项（RR）。为什么不使用这个选项而另外开发一个新的应用程序？有三个方面的原因。<ul>
<li>首先，原先并不是所有的路由器都支持记录路由选项，因此该选项在某些路径上不能使用（Traceroute程序不需要中间路由器具备任何特殊的或可选的功能）。</li>
<li>其次，记录路由一般是单向的选项。发送端设置了该选项，那么接收端不得不从收到的IP首部中提取出所有的信息，然后全部返回给发送端。</li>
<li>最后一个原因也是最主要的原因是，IP首部中留给选项的空间有限，不能存放当前大多数的路径。在IP首部选项字段中最多只能存放9个IP地址。在原先的ARPANET中这是足够的，但是对现在来说是远远不够的。</li>
</ul>
</li>
</ul>
<h3 id="2-Traceroute程序的操作"><a href="#2-Traceroute程序的操作" class="headerlink" title="2. Traceroute程序的操作"></a>2. Traceroute程序的操作</h3><ul>
<li>Traceroute程序使用ICMP报文和IP首部中的TTL字段（生存周期）。</li>
<li>TTL字段的目的是防止数据报在选路时无休止地在网络中流动。</li>
<li>Traceroute程序的操作过程。<ul>
<li>它发送一份TTL字段为1的IP数据报给目的主机。处理这份数据报的第一个路由器将TTL值减1，丢弃该数据报，并发回一份超时ICMP报文。这样就得到了该路径中的第一个路由器的地址。然后Traceroute程序发送一份TTL值为2的数据报，这样我们就可以得到第二个路由器的地址。继续这个过程直至该数据报到达目的主机。但是目的主机哪怕接收到TTL值为1的IP数据报，也不会丢弃该数据报并产生一份超时ICMP报文，这是因为数据报已经到达其最终目的地。那么我们该如何判断是否已经到达目的主机了呢？</li>
<li>Traceroute程序发送一份UDP数据报给目的主机，但它选择一个不可能的值作为UDP端口号（大于30 000），使目的主机的任何一个应用程序都不可能使用该端口。因为，当该数据报到达时，将使目的主机的UDP模块产生一份“端口不可达”错误（见6.5节）的ICMP报文。这样，Traceroute程序所要做的就是区分接收到的ICMP报文是超时还是端口不可达，以判断什么时候结束。</li>
</ul>
</li>
<li>UDP or ICMP<ul>
<li>windows使用的是ICMP，最终使用ICMP seq识别</li>
<li>UNIX使用的UDP+ICMP,最终用一个大于30000的端口号来返回ICMP端口不可达</li>
</ul>
</li>
</ul>
<h1 id="九-IP选路"><a href="#九-IP选路" class="headerlink" title="九 IP选路"></a>九 IP选路</h1><h3 id="1-引言-7"><a href="#1-引言-7" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>需要进行选路的数据报可以由本地主机产生，也可以由其他主机产生。在后一种情况下，主机必须配置成一个路由器，否则通过网络接口接收到的数据报，如果目的地址不是本机就要被丢弃</li>
<li>netstat -r 查看路由表 -n 以数字格式打印出IP地址</li>
<li>IP层工作流程  <!-- ![12.IP层工作流程.png](./img/12.IP层工作流程.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/12.IP%E5%B1%82%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="" title="12.IP层工作流程.png">

</li>
</ul>
<h3 id="2-选路的原理"><a href="#2-选路的原理" class="headerlink" title="2. 选路的原理"></a>2. 选路的原理</h3><ul>
<li><p>首先要理解内核是如何维护路由表的。路由表中包含的信息决定了IP层所做的所有决策。IP搜索路由表的几个步骤：</p>
<ul>
<li>搜索匹配的主机地址；</li>
<li>搜索匹配的网络地址；</li>
<li>搜索默认表项（默认表项一般在路由表中被指定为一个网络表项，其网络号为0）。</li>
</ul>
</li>
<li><p>IP层进行的选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。</p>
</li>
<li><p>路由表的五种标志</p>
<ul>
<li>U 该路由可以使用。</li>
<li>G 该路由是到一个网关（路由器）。如果没有设置该标志，说明目的地是直接相连的。</li>
<li>H 该路由是到一个主机，也就是说，目的地址是一个完整的主机地址。如果没有设置该标志，说明该路由是到一个网络，而目的地址是一个网络地址：一个网络号，或者网络号与子网号的组合。</li>
<li>D 该路由是由重定向报文创建的（9.5节）。</li>
<li>M 该路由已被重定向报文修改（9.5节）。</li>
</ul>
</li>
<li><p>初始化路由表</p>
<ul>
<li>每当初始化一个接口时（通常是用ifconfig命令设置接口地址），就为接口自动创建一个直接路由。</li>
<li>初始化路由表的其他方法是运行路由守护程序（第10章）或者用较新的路由器发现协议（9.6节）。</li>
</ul>
</li>
<li><p>没有到达目的地的路由</p>
<ul>
<li>如果路由表中没有默认项，而又没有找到匹配项，结果取决于该IP数据报是由主机产生的还是被转发的（例如，我们就充当一个路由器）。如果数据报是由本地主机产生的，那么就给发送该数据报的应用程序返回一个差错，或者是“主机不可达差错”或者是“网络不可达差错”。如果是被转发的数据报，那么就给原始发送端发送一份ICMP主机不可达的差错报文。</li>
</ul>
</li>
</ul>
<h3 id="3-ICMP主机与网络不可达差错"><a href="#3-ICMP主机与网络不可达差错" class="headerlink" title="3. ICMP主机与网络不可达差错"></a>3. ICMP主机与网络不可达差错</h3><ul>
<li>当路由器收到一份IP数据报但又不能转发时，就要发送一份ICMP“主机不可达”差错报文</li>
</ul>
<h3 id="4-转发或不转发"><a href="#4-转发或不转发" class="headerlink" title="4. 转发或不转发"></a>4. 转发或不转发</h3><ul>
<li>一般都假定主机不转发IP数据报，除非对它们进行特殊配置而作为路由器使用。</li>
</ul>
<h3 id="5-ICMP重定向差错"><a href="#5-ICMP重定向差错" class="headerlink" title="5. ICMP重定向差错"></a>5. ICMP重定向差错</h3><ul>
<li>当IP数据报应该被发送到另一个路由器时，收到数据报的路由器就要发送ICMP重定向差错报文给IP数据报的发送端。</li>
<li>步骤<ol>
<li>我们假定主机发送一份IP数据报给R1。这种选路决策经常发生，因为R1是该主机的默认路由。</li>
<li>R1收到数据报并且检查它的路由表，发现R2是发送该数据报的下一站。当它把数据报发送给R2时，R1检测到它正在发送的接口与数据报到达接口是相同的（即主机和两个路由器所在的LAN）。这样就给路由器发送重定向报文给原始发送端提供了线索。</li>
<li>R1发送一份ICMP重定向报文给主机，告诉它以后把数据报发送给R2而不是R1。    </li>
</ol>
</li>
<li>ICMP重定向例子  <!-- ![13.ICMP重定向.png](./img/13.ICMP重定向.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/13.ICMP%E9%87%8D%E5%AE%9A%E5%90%91.png" class="" title="13.ICMP重定向.png"></li>
<li>重定向一般用来让具有很少选路信息的主机逐渐建立更完善的路由表。</li>
</ul>
<h3 id="6-ICMP路由器发现报文"><a href="#6-ICMP路由器发现报文" class="headerlink" title="6. ICMP路由器发现报文"></a>6. ICMP路由器发现报文</h3><ul>
<li><p>前面已提到过一种初始化路由表的方法，即在配置文件中指定静态路由。这种方法经常用来设置默认路由。另一种新的方法是利用ICMP路由器通告和请求报文。</p>
</li>
<li><p>一般认为，主机在引导以后要广播或多播传送一份路由器请求报文。一台或更多台路由器响应一份路由器通告报文。另外，路由器定期地广播或多播传送它们的路由器通告报文，允许每个正在监听的主机相应地更新它们的路由表。</p>
</li>
<li><p>路由器操作</p>
<ul>
<li>当路由器启动时，它定期在所有广播或多播传送接口上发送通告报文。准确地说，这些通告报文不是定期发送的，而是随机传送的，以减小与子网上其他路由器发生冲突的概率。一般每两次通告间隔450秒和600秒。一份给定的通告报文默认生命周期是30分钟。</li>
<li>除了定期发送主动提供的通告报文以外，路由器还要监听来自主机的请求报文，并发送路由器通告报文以响应这些请求报文。</li>
</ul>
</li>
<li><p>主机操作</p>
<ul>
<li>主机在引导期间一般发送三份路由器请求报文，每三秒钟发送一次。一旦接收到一个有效的通告报文，就停止发送请求报文。</li>
<li>主机也监听来自相邻路由器的请求报文。这些通告报文可以改变主机的默认路由器。另外，如果没有接收到来自当前默认路由器的通告报文，那么默认路由器会超时。</li>
</ul>
</li>
<li><p>实现</p>
<ul>
<li>路由器发现报文一般由用户进程（守护程序）创建和处理。</li>
</ul>
</li>
</ul>
<h1 id="十-动态选路协议"><a href="#十-动态选路协议" class="headerlink" title="十 动态选路协议"></a>十 动态选路协议</h1><h3 id="1-引言-8"><a href="#1-引言-8" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>动态选路协议，它用于路由器间的通信。</li>
<li>本章内容<ul>
<li>主要讨论RIP，即选路信息协议(Routing Infromation Protocol)，大多数TCP/IP实现都提供这个应用广泛的协议。</li>
<li>然后讨论两种新的选路协议，OSPF和BGP。</li>
<li>最后研究一种名叫无分类域间选路的新的选路技术，现在Internet上正在开始采用该协议以保持B类网络的数量。</li>
</ul>
</li>
</ul>
<h3 id="2-动态选路"><a href="#2-动态选路" class="headerlink" title="2. 动态选路"></a>2. 动态选路</h3><ul>
<li><p>当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时就出现了动态选路。</p>
</li>
<li><p>路由器上有一个进程称为路由守护程序（routing daemon），它运行选路协议，并与其相邻的一些路由器进行通信。</p>
</li>
<li><p>在像Internet这样的系统中，目前采用了许多不同的选路协议。Internet是以一组自治系统(AS，Autonomous System)的方式组织的，每个自治系统通常由单个实体管理。常常将一个公司或大学校园定义为一个自治系统。NSFNET的Internet骨干网形成一个自治系统，这是因为骨干网中的所有路由器都在单个的管理控制之下。</p>
</li>
<li><p>每个自治系统可以选择该自治系统中各个路由器之间的选路协议。这种协议我们称之为内部网关协议IGP（Interior Gateway Protocol）或域内选路协议（intradomain routing protocol）。最常用的IGP是选路信息协议RIP。一种新的IGP是开放最短路径优先OSPF（Open Shortest Path First）协议。它意在取代RIP。另一种1986年在原来NSFNET骨干网上使用的较早的IGP协议——HELLO，现在已经不用了。</p>
</li>
<li><p>外部网关协议EGP（Exterier Gateway Protocol）或域内选路协议的分隔选路协议用于不同自治系统之间的路由器。在历史上，（令人容易混淆）改进的EGP有着一个与它名称相同的协议：EGP。新EGP是当前在NSFNET骨干网和一些连接到骨干网的区域性网络上使用的是边界网关协议BGP（Border Gateway Protocol）。BGP意在取代EGP。</p>
</li>
</ul>
<h3 id="3-Unix选路守护进程"><a href="#3-Unix选路守护进程" class="headerlink" title="3. Unix选路守护进程"></a>3. Unix选路守护进程</h3><ul>
<li>Unix系统上常常运行名为routed路由守护程序。几乎在所有的TCP/IP实现中都提供该程序。该程序只使用RIP进行通信</li>
<li>另一个程序是gated。IGP和EGP都支持它。[Fedor 1998]描述了早期开发的gated。</li>
</ul>
<h3 id="4-RIP：选路信息协议"><a href="#4-RIP：选路信息协议" class="headerlink" title="4. RIP：选路信息协议"></a>4. RIP：选路信息协议</h3><h5 id="1-报文格式"><a href="#1-报文格式" class="headerlink" title="1. 报文格式"></a>1. 报文格式</h5><ul>
<li>RIP报文包含中在UDP数据报中</li>
</ul>
<table>
<thead>
<tr>
<th>IP首部</th>
<th>UDP首部</th>
<th>RIP报文</th>
</tr>
</thead>
</table>
<ul>
<li>RIP报文格式  <!-- ![14.RIP.png](./img/14.RIP.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/14.RIP.png" class="" title="14.RIP.png">

</li>
</ul>
<h5 id="2-正常运行"><a href="#2-正常运行" class="headerlink" title="2. 正常运行"></a>2. 正常运行</h5><ul>
<li>让我们来看一下采用RIP协议的routed程序正常运行的结果。RIP常用的UDP端口号是520。</li>
</ul>
<ol>
<li>初始化：在启动一个路由守护程序时，它先判断启动了哪些接口，并在每个接口上发送一个请求报文，要求其他路由器发送完整路由表。在点对点链路中，该请求是发送给其他终点的。如果网络支持广播的话，这种请求是以广播形式发送的。目的UDP端口号是520（这是其他路由器的路由守护程序端口号）。 这种请求报文的命令字段为1，但地址系列字段设置为0，而度量字段设置为16。这是一种要求另一端完整路由表的特殊请求报文。</li>
<li>接收到请求。如果这个请求是刚才提到的特殊请求，那么路由器就将完整的路由表发送给请求者。否则，就处理请求中的每一个表项：如果有连接到指明地址的路由，则将度量设置成我们的值，否则将度量置为16（度量为16是一种称为“无穷大”的特殊值，它意味着没有到达目的的路由）。然后发回响应。</li>
<li>接收到响应。使响应生效，可能会更新路由表。可能会增加新表项，对已有的表项进行修改，或是将已有表项删除。</li>
<li>定期选路更新。每过30秒，所有或部分路由器会将其完整路由表发送给相邻路由器。发送路由表可以是广播形式的（如在以太网上），或是发送给点对点链路的其他终点的。</li>
<li>触发更新。每当一条路由的度量发生变化时，就对它进行更新。不需要发送完整路由表，而只需要发送那些发生变化的表项。</li>
</ol>
<ul>
<li>每条路由都有与之相关的定时器。如果运行RIP的系统发现一条路由在3分钟内未更新，就将该路由的度量设置成无穷大（16），并标注为删除。这意味着已经在6个30秒更新时间里没收到通告该路由的路由器的更新了。再过60秒，将从本地路由表中删除该路由，以保证该路由的失效已被传播开。</li>
</ul>
<h5 id="3-RIP版本2"><a href="#3-RIP版本2" class="headerlink" title="3. RIP版本2"></a>3. RIP版本2</h5><ul>
<li>RFC 1388 [Malkin 1993a]中对RIP定义进行了扩充，通常称其结果为RIP-2。</li>
<li>RIP2报文格式  <!-- ![15.RIP2.png](./img/15.RIP2.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/15.RIP2.png" class="" title="15.RIP2.png">

</li>
</ul>
<h3 id="5-OSPF：开放最短路径优先"><a href="#5-OSPF：开放最短路径优先" class="headerlink" title="5. OSPF：开放最短路径优先"></a>5. OSPF：开放最短路径优先</h3><ul>
<li>OSPF是除RIP外的另一个内部网关协议。它克服了RIP的所有限制。RFC 1247[Moy 1991]中对第2版OSPF进行了描述。</li>
<li>与采用距离向量的RIP协议不同的是，OSPF是一个链路状态协议。距离向量的意思是，RIP发送的报文包含一个距离向量（跳数）。每个路由器都根据它所接收到邻站的这些距离向量来更新自己的路由表。</li>
<li>二者的不同点是链路状态协议总是比距离向量协议收敛更快。收敛的意思是在路由发生变化后，例如在路由器关闭或链路出故障后，可以稳定下来。</li>
<li>OSPF与RIP（以及其他选路协议）的不同点在于，OSPF直接使用IP。也就是说，它并不使用UDP或TCP。对于IP首部的protocol字段，OSPF有其自己的值</li>
</ul>
<h3 id="6-BGP：边界网关协议"><a href="#6-BGP：边界网关协议" class="headerlink" title="6. BGP：边界网关协议"></a>6. BGP：边界网关协议</h3><ul>
<li>BGP是一种不同自治系统的路由器之间进行通信的外部网关协议。</li>
<li>BGP与RIP和OSPF的不同之处在于BGP使用TCP作为其传输层协议。两个运行BGP的系统之间建立一条TCP连接，然后交换整个BGP路由表。从这个时候开始，在路由表发生变化时，再发送更新信号。</li>
<li>BGP是一个距离向量协议，但是与（通告到目的地址跳数的）RIP不同的是，BGP列举了到每个目的地址的路由（自治系统到达目的地址的序列号）。这样就排除了一些距离向量协议的问题。采用16 bit数字表示自治系统标识。</li>
</ul>
<h3 id="7-CIDR：无类型域间选路"><a href="#7-CIDR：无类型域间选路" class="headerlink" title="7. CIDR：无类型域间选路"></a>7. CIDR：无类型域间选路</h3><ul>
<li>无类型域间选路（CIDR）是一个防止Internet路由表膨胀的方法，它也称为超网（supernetting）。</li>
<li>CIDR同时还使用一种技术，使最佳匹配总是最长的匹配：即在32 bit掩码中，它具有最大值。</li>
<li>“无类型”的意思是现在的选路决策是基于整个32 bit IP地址的掩码操作，而不管其IP地址是A类、B类或是C类，都没有什么区别。</li>
</ul>
<h1 id="十一-UDP-用户数据报协议"><a href="#十一-UDP-用户数据报协议" class="headerlink" title="十一 UDP:用户数据报协议"></a>十一 UDP:用户数据报协议</h1><h3 id="1-引言-9"><a href="#1-引言-9" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>UDP是一个简单的面向数据报的运输层协议<ul>
<li>进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。这与面向流字符的协议不同，如TCP，应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系。</li>
</ul>
</li>
<li>UDP不提供可靠性<ul>
<li>它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的地。由于缺乏可靠性，我们似乎觉得要避免使用UDP而使用一种可靠协议如TCP。我们在第17章讨论完TCP后将再回到这个话题，看看什么样的应用程序可以使用UDP。</li>
</ul>
</li>
<li>应用程序必须关心IP数据报的长度。<ul>
<li>如果它超过网络的MTU（2.8节），那么就要对IP数据报进行分片。如果需要，源端到目的端之间的每个网络都要进行分片，并不只是发送端主机连接第一个网络才这样做（我们在2.9节中已定义了路径MTU的概念）。在11.5节中，我们将讨论IP分片机制。</li>
</ul>
</li>
</ul>
<h3 id="2-UDP首部"><a href="#2-UDP首部" class="headerlink" title="2. UDP首部"></a>2. UDP首部</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|   16位源端口  |   16位目的端口    |</span><br><span class="line">|   16位UDP长度 |   16位UDP校验和  |</span><br><span class="line">|           数据（如果有）         |</span><br></pre></td></tr></table></figure>
<!-- ![16.UDP数据报.png](./img/16.UDP数据报.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/16.UDP%E6%95%B0%E6%8D%AE%E6%8A%A5.png" class="" title="16.UDP数据报.png">
<ul>
<li><p>端口号表示发送进程和接收进程。TCP端口号由TCP来查看，而UDP端口号由UDP来查看。TCP端口号与UDP端口号是相互独立的。</p>
</li>
<li><p>UDP长度字段指的是UDP首部和UDP数据的字节长度。16位，最小值为8字节，也就是没有数据。</p>
</li>
</ul>
<h3 id="3-UDP检验和"><a href="#3-UDP检验和" class="headerlink" title="3. UDP检验和"></a>3. UDP检验和</h3><!-- ![17.UDP校验和.png](./img/17.UDP校验和.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/17.UDP%E6%A0%A1%E9%AA%8C%E5%92%8C.png" class="" title="17.UDP校验和.png">
<ul>
<li>UDP检验和覆盖UDP首部和UDP数据。回想IP首部的检验和，它只覆盖IP的首部—并不覆盖IP数据报中的任何数据。</li>
<li>UDP和TCP在首部中都有覆盖它们首部和数据的检验和。UDP的检验和是可选的，而TCP的检验和是必需的。</li>
<li>UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。伪首部包含IP首部一些字段(源IP/目的IP地址)。其目的是让UDP两次检查数据是否已经正确到达目的地。</li>
<li>UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动。</li>
</ul>
<h3 id="4-IP分片"><a href="#4-IP分片" class="headerlink" title="4. IP分片"></a>4. IP分片</h3><ul>
<li>物理网络层一般要限制每次发送数据帧的最大长度。任何时候IP层接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据（选路），并查询该接口获得其MTU。IP把MTU与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。</li>
<li>把一份IP数据报分片以后，只有到达目的地才进行重新组装（这里的重新组装与其他网络协议不同，它们要求在下一站就进行进行重新组装，而不是在最终的目的地）。重新组装由目的端的IP层来完成，其目的是使分片和重新组装过程对运输层（TCP和UDP）是透明的</li>
<li>回忆IP首部，下面这些字段用于分片过程。对于发送端发送的每份IP数据报来说，其标识字段都包含一个唯一值。该值在数据报分片时被复制到每个片中（我们现在已经看到这个字段的用途）。标志字段用其中一个比特来表示“更多的片”。除了最后一片外，其他每个组成数据报的片都要把该比特置1。片偏移字段指的是该片偏移原始数据报开始处的位置。另外，当数据报被分片后，每个片的总长度值要改为该片的长度值。</li>
<li>IP标志字段中有一个比特称作“不分片”位。如果将这一比特置1，IP将不对数据报进行分片。相反把数据报丢弃并发送一个ICMP差错报文（“需要进行分片但设置了不分片比特”，见图6-3）给起始端。</li>
<li>尽管IP分片过程看起来是透明的，但有一点让人不想使用它：即使只丢失一片数据也要重传整个数据报。为什么会发生这种情况呢？因为IP层本身没有超时重传的机制——由更高层来负责超时和重传（TCP有超时和重传机制，但UDP没有。一些UDP应用程序本身也执行超时和重传）。</li>
<li>解释几个术语：<ul>
<li>IP数据报是指IP层端到端的传输单元（在分片之前和重新组装之后）</li>
<li>分组是指在IP层和链路层之间传送的数据单元。一个分组可以是一个完整的IP数据报，也可以是IP数据报的一个分片。</li>
</ul>
</li>
</ul>
<h3 id="5-ICMP不可达差错（需要分片）"><a href="#5-ICMP不可达差错（需要分片）" class="headerlink" title="5. ICMP不可达差错（需要分片）"></a>5. ICMP不可达差错（需要分片）</h3><ul>
<li>发生ICMP不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在IP首部又设置了不分片（DF）的标志比特。如果某个程序需要判断到达目的端的路途中最小MTU是多少—称作路径MTU发现机制（2.9节），那么这个差错就可以被该程序使用。<!-- ![18.ICMP不可达差错.png](./img/18.ICMP不可达差错.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/18.ICMP%E4%B8%8D%E5%8F%AF%E8%BE%BE%E5%B7%AE%E9%94%99.png" class="" title="18.ICMP不可达差错.png">

</li>
</ul>
<h3 id="6-用Traceroute确定路径MTU"><a href="#6-用Traceroute确定路径MTU" class="headerlink" title="6. 用Traceroute确定路径MTU"></a>6. 用Traceroute确定路径MTU</h3><ul>
<li>尽管大多数的系统不支持路径MTU发现功能，但可以很容易地修改traceroute程序，用它来确定路径MTU。</li>
<li>要做的是发送分组，并设置“不分片”标志比特。发送的第一个分组的长度正好与出口MTU相等，每次收到ICMP“不能分片”差错时（在上一节讨论的）就减小分组的长度。如果路由器发送的ICMP差错报文是新格式，包含出口的MTU，那么就用该MTU值来发送，否则就用下一个最小的MTU值来发送。正如RFC 1191[Mogul and Deering 1990]声明的那样，MTU值的个数是有限的，因此在我们的程序中有一些由近似值构成的表，取下一个最小MTU值来发送。</li>
</ul>
<h3 id="7-采用UDP的路径MTU发现"><a href="#7-采用UDP的路径MTU发现" class="headerlink" title="7. 采用UDP的路径MTU发现"></a>7. 采用UDP的路径MTU发现</h3><p>看书</p>
<h3 id="8-UDP和ARP之间的交互作用"><a href="#8-UDP和ARP之间的交互作用" class="headerlink" title="8. UDP和ARP之间的交互作用"></a>8. UDP和ARP之间的交互作用</h3><p>看书</p>
<h3 id="9-最大UDP数据报长度"><a href="#9-最大UDP数据报长度" class="headerlink" title="9. 最大UDP数据报长度"></a>9. 最大UDP数据报长度</h3><ul>
<li>理论上，IP数据报的最大长度是65535字节，这是由IP首部16比特总长度字段所限制的。去除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最长长度为65507字节。但是，大多数实现所提供的长度比这个最大值小。</li>
<li>两个限制因素。<ul>
<li>第一，应用程序可能会受到其程序接口的限制。socket API提供了一个可供应用程序调用的函数，以设置接收和发送缓存的长度。对于UDP socket，这个长度与应用程序可以读写的最大UDP数据报的长度直接相关。现在的大部分系统都默认提供了可读写大于8192字节的UDP数据报（使用这个默认值是因为8192是NFS读写用户数据数的默认值）。</li>
<li>第二个限制来自于TCP/IP的内核实现。可能存在一些实现特性（或差错），使IP数据报长度小于65535字节。</li>
</ul>
</li>
</ul>
<h3 id="10-UDP服务器的设计"><a href="#10-UDP服务器的设计" class="headerlink" title="10. UDP服务器的设计"></a>10. UDP服务器的设计</h3><ol>
<li>客户IP地址及端口号<ul>
<li>当一个应用程序接收到UDP数据报时，操作系统必须告诉它是谁发送了这份消息，即源IP地址和端口号。</li>
<li>这个特性允许一个交互UDP服务器对多个客户进行处理。给每个发送请求的客户发回应答。</li>
</ul>
</li>
<li>目的IP地址<ul>
<li>一些应用程序需要知道数据报是发送给谁的，即目的IP地址。</li>
</ul>
</li>
<li>UDP输入队列<ul>
<li>大多数UDP服务器是交互服务器。这意味着，单个服务器进程对单个UDP端口上（服务器上的名知端口）的所有客户请求进行处理。</li>
</ul>
</li>
<li>限制本地IP地址</li>
<li>限制远端IP地址</li>
<li>每个端口有多个接收者</li>
</ol>
<h1 id="十二-广播和多播"><a href="#十二-广播和多播" class="headerlink" title="十二 广播和多播"></a>十二 广播和多播</h1><h3 id="1-引言-10"><a href="#1-引言-10" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>有三种IP地址：单播地址、广播地址和多播地址。</li>
<li>广播和多播仅应用于UDP，它们对需将报文同时传往多个接收者的应用来说十分重要。TCP是一个面向连接的协议，它意味着分别运行于两主机（由IP地址确定）内的两进程（由端口号确定）间存在一条连接。</li>
<li>单播<ul>
<li>通常每个以太网帧仅发往单个目的主机，目的地址指明单个接收接口，因而称为单播(unicast)。在这种方式下，任意两个主机的通信不会干扰网内其他主机（可能引起争夺共享信道的情况除外）。</li>
</ul>
</li>
<li>广播<ul>
<li>有时一个主机要向网上的所有其他主机发送帧，这就是广播。</li>
</ul>
</li>
<li>多播(multicast)<ul>
<li>处于单播和广播之间：帧仅传送给属于多播组的多个主机。</li>
</ul>
</li>
</ul>
<h3 id="2-广播"><a href="#2-广播" class="headerlink" title="2. 广播"></a>2. 广播</h3><ol>
<li>受限的广播<ul>
<li>受限的广播地址是255.255.255.255。</li>
<li>在任何情况下，路由器都不转发目的地址为受限的广播地址的数据报，这样的数据报仅出现在本地网络中。</li>
</ul>
</li>
<li>指向网络的广播<ul>
<li>指向网络的广播地址是主机号为全1的地址。</li>
<li>A类网络广播地址为netid.255.255.255，其中netid为A类网络的网络号。</li>
</ul>
</li>
<li>指向子网的广播<ul>
<li>指向子网的广播地址为主机号为全1且有特定子网号的地址。</li>
<li>例如，如果路由器收到发往128.1.2.255的数据报，当B类网络128.1的子网掩码为255.255.255.0时，该地址就是指向子网的广播地址；但如果该子网的掩码为255.255.254.0，该地址就不是指向子网的广播地址。</li>
</ul>
</li>
<li>指向所有子网的广播<ul>
<li>指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开。</li>
<li>指向所有子网的广播地址的子网号及主机号为全1。</li>
<li>例如，如果目的子网掩码为255.255.255.0，那么IP地址128.1.255.255是一个指向所有子网的广播地址。然而，如果网络没有划分子网，这就是一个指向网络的广播。</li>
<li>当前的看法[Almquist 1993]是这种广播是陈旧过时的，更好的方式是使用多播而不是对所有子网的广播。</li>
</ul>
</li>
</ol>
<h3 id="3-ping-255-255-255-255"><a href="#3-ping-255-255-255-255" class="headerlink" title="3. ping 255.255.255.255"></a>3. ping 255.255.255.255</h3><ul>
<li>ping 把点分十进制IP转换成二进制的函数是 inet_addr(),这个函数对255.255.255.255返回-1，即出错</li>
</ul>
<p>###　4. 多播</p>
<ol>
<li>IP多播提供两类服务：<ul>
<li>向多个目的地址传送数据。有许多向多个接收者传送信息的应用：例如交互式会议系统和向多个接收者分发邮件或新闻。如果不采用多播，目前这些应用大多采用TCP来完成（向每个目的地址传送一个单独的数据复制）。然而，即使使用多播，某些应用可能继续采用TCP来保证它的可靠性。</li>
<li>客户对服务器的请求。例如，无盘工作站需要确定启动引导服务器。目前，这项服务是通过广播来提供的（正如第16章的BOOTP），但是使用多播可降低不提供这项服务主机的负担。</li>
</ul>
</li>
<li>多播组地址<ul>
<li>一些多播组地址被IANA确定为知名地址。它们也被当作永久主机组，这和TCP及UDP中的熟知端口相似。</li>
<li>例如，224.0.0.1代表“该子网内的所有系统组”，224.0.0.2代表“该子网内的所有路由器组”。多播地址224.0.1.1用作网络时间协议NTP，224.0.0.9用作RIP-2(见10.5节)，224.0.1.2用作SGI公司的dogfight应用。</li>
<li>D类IP地址被称为多播组地址。通过将其低位23 bit映射到相应以太网地址中便可实现多播组地址到以太网地址的转换。由于地址映射是不唯一的，因此需要其他的协议实现额外的数据报过滤。</li>
</ul>
</li>
</ol>
<h1 id="十三-IGMP-Internet组管理协议"><a href="#十三-IGMP-Internet组管理协议" class="headerlink" title="十三 IGMP:Internet组管理协议"></a>十三 IGMP:Internet组管理协议</h1><h3 id="1-引言-11"><a href="#1-引言-11" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>Internet组管理协议（IGMP）。它让一个物理网络上的所有系统知道主机当前所在的多播组。多播路由器需要这些信息以便知道多播数据报应该向哪些接口转发。</li>
<li>正如ICMP一样，IGMP也被当作IP层的一部分。IGMP报文通过IP数据报进行传输。不像我们已经见到的其他协议，IGMP有固定的报文长度，没有可选数据。</li>
<li>多播是一种将报文发往多个接收者的通信方式。在许多应用中，它比广播更好，因为多播降低了不参与通信的主机的负担。简单的主机成员报告协议(IGMP)是多播的基本模块。</li>
<li>多播还未解决的一个问题是在广域网内的多播。</li>
</ul>
<h3 id="2-IGMP报文"><a href="#2-IGMP报文" class="headerlink" title="2. IGMP报文"></a>2. IGMP报文</h3><ul>
<li><p>格式</p>
  <!-- ![19.IGMP报文.png](./img/19.IGMP报文.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/19.IGMP%E6%8A%A5%E6%96%87.png" class="" title="19.IGMP报文.png"></li>
<li><p>IGMP类型为1说明是由多播路由器发出的查询报文，为2说明是主机发出的报告报文。检验和的计算和ICMP协议相同。</p>
</li>
<li><p>组地址为D类IP地址。</p>
</li>
<li><p>这个需要的时候再看书吧，很多概念有点抽象</p>
</li>
</ul>
<h1 id="十四-DNS-域名系统"><a href="#十四-DNS-域名系统" class="headerlink" title="十四 DNS:域名系统"></a>十四 DNS:域名系统</h1><h3 id="1-引言-12"><a href="#1-引言-12" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>域名系统（DNS）是一种用于TCP/IP应用程序的分布式数据库，它提供主机名字和IP地址之间的转换及有关电子邮件的选路信息。</li>
<li>这里提到的分布式是指在Internet上的单个站点不能拥有所有的信息。每个站点（如大学中的系、校园、公司或公司中的部门）保留它自己的信息数据库，并运行一个服务器程序供Internet上的其他系统（客户程序）查询。</li>
<li>DNS提供了允许服务器和客户程序相互通信的协议。</li>
<li>从应用的角度上看，对DNS的访问是通过一个地址解析器（resolver）来完成的。在Unix主机中，该解析器主要是通过两个库函数gethostbyname(3)和gethostbyaddr(3)来访问的，它们在编译应用程序时与应用程序连接在一起。</li>
</ul>
<h3 id="2-DNS基础"><a href="#2-DNS基础" class="headerlink" title="2. DNS基础"></a>2. DNS基础</h3><ul>
<li>DNS的名字空间和Unix的文件系统相似，也具有树型层次结构。  <!-- ![20.DNS层次结构.png](./img/20.DNS层次结构.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/20.DNS%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" class="" title="20.DNS层次结构.png"></li>
<li>DNS的一个基本特性是使用超高速缓存。即当一个名字服务器收到有关映射的信息（主机名字到IP地址）时，它会将该信息存放在高速缓存中。这样若以后遇到相同的映射请求，就能直接使用缓存中的结果而无需通过其他服务器查询。</li>
<li>7个普通域  <!-- ![21.普通域.png](./img/21.普通域.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/21.%E6%99%AE%E9%80%9A%E5%9F%9F.png" class="" title="21.普通域.png">

</li>
</ul>
<h3 id="3-DNS的报文格式"><a href="#3-DNS的报文格式" class="headerlink" title="3. DNS的报文格式"></a>3. DNS的报文格式</h3><ul>
<li>这个报文由12字节长的首部和4个长度可变的字段组成。  <!-- ![22.DNS报文.png](./img/22.DNS报文.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/22.DNS%E6%8A%A5%E6%96%87.png" class="" title="22.DNS报文.png"></li>
<li>DNS查询报文问题部分  <!-- ![23.DNS问题.png](./img/23.DNS问题.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/23.DNS%E9%97%AE%E9%A2%98.png" class="" title="23.DNS问题.png">
<ol>
<li>如何存储查询名 <!-- ![24.域名.png](./img/24.域名.png) -->
 <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/24.%E5%9F%9F%E5%90%8D.png" class="" title="24.域名.png"></li>
<li>查询类型 <!-- ![25.查询类型.png](./img/25.查询类型.png) -->
 <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/25.%E6%9F%A5%E8%AF%A2%E7%B1%BB%E5%9E%8B.png" class="" title="25.查询类型.png"></li>
<li>查询类通常是1，指互联网地址（某些站点也支持其他非IP地址）。</li>
</ol>
</li>
<li>所有的DNS查询和响应都有相同的报文格式。这个报文格式中包含查询请求和可能的回答资源记录、授权资源记录和附加资源记录。</li>
</ul>
<h3 id="4-名字解析器的配置文件-etc-resolv-conf"><a href="#4-名字解析器的配置文件-etc-resolv-conf" class="headerlink" title="4. 名字解析器的配置文件/etc/resolv.conf"></a>4. 名字解析器的配置文件/etc/resolv.conf</h3><h3 id="5-DNS的优化措施"><a href="#5-DNS的优化措施" class="headerlink" title="5. DNS的优化措施"></a>5. DNS的优化措施</h3><ul>
<li>指向域名的指针（减少报文的长度）、查询结果的高速缓存、in-addr.arpa域（查找IP地址对应的域名）以及返回的附加资源记录（避免主机重发同一查询请求）。</li>
</ul>
<h3 id="6-用-UDP-还是-TCP"><a href="#6-用-UDP-还是-TCP" class="headerlink" title="6. 用 UDP 还是 TCP"></a>6. 用 UDP 还是 TCP</h3><ul>
<li>DNS 服务器支持 TCP 和 UDP 两种协议的查询方式,而且端口都是53。而大多数的查询都是 UDP 查询的</li>
<li>一般需要 TCP 查询的 有两种情况:<ol>
<li>当查询数据多大以至于产生了数据截断(TC标志为1),这时,需要利用TCP的分片能力来进行数据传输(看TCP的相关章节)。</li>
<li>当主(master)服务器和辅(slave)服务器之间通信,辅服务器要拿到主服务器的 zone 信息的时候。</li>
</ol>
</li>
</ul>
<h1 id="十五-TFTP-简单文件传送协议"><a href="#十五-TFTP-简单文件传送协议" class="headerlink" title="十五 TFTP:简单文件传送协议"></a>十五 TFTP:简单文件传送协议</h1><h3 id="1-引言-13"><a href="#1-引言-13" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>TFTP(Trivial File Transfer Protocol)即简单文件传送协议，最初打算用于引导无盘系统（通常是工作站或X终端）。</li>
<li>和将在第27章介绍的使用TCP的文件传送协议（FTP）不同，为了保持简单和短小，TFTP将使用UDP。</li>
<li>TFTP的代码（和它所需要的UDP、IP和设备驱动程序）都能适合只读存储器。</li>
</ul>
<h3 id="2-协议"><a href="#2-协议" class="headerlink" title="2. 协议"></a>2. 协议</h3><ul>
<li>操作码|文件名|0|模式|0</li>
<li>TFTP报文的头两个字节表示操作码。对于读请求和写请求（WRQ）</li>
<li>文件名字段说明客户要读或写的位于服务器上的文件。这个文件字段以0字节作为结束</li>
<li>模式字段是一个ASCII码串netascii或octet（可大小写任意组合），同样以0字节结束。</li>
<li>停止等待协议<ul>
<li>以读一个文件作为例子，TFTP客户需要发送一个读请求说明要读的文件名和文件模式(mode)。如果这个文件能被这个客户读取，TFTP服务器就返回一个块编号为1的数据分组。TFTP客户又发送一个块编号为1的ACK。TFTP服务器随后发送块编号为2的数据。TFTP客户发回块编号为2的ACK。重复这个过程直到这个文件传送完。除了最后一个数据分组可含有不足512字节的数据，其他每个数据分组均含有512字节的数据。当TFTP客户收到一个不足512字节的数据分组，就知道它收到最后一个数据分组。</li>
<li>在写请求的情况下，TFTP客户发送WRQ指明文件名和模式。如果该文件能被该客户写，TFTP服务器就返回块编号为0的ACK包。该客户就将文件的头512字节以块编号为1发出。服务器则返回块编号为1的ACK。</li>
<li>这种类型的数据传输称为停止等待协议。它只用在一些简单的协议如TFTP中。</li>
</ul>
</li>
</ul>
<h3 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3. 安全性"></a>3. 安全性</h3><ul>
<li>在TFTP分组中并不提供用户名和口令。这是TFTP的一个特征（即“安全漏洞”）。</li>
<li>由于TFTP是设计用于系统引导进程，它不可能提供用户名和口令。</li>
<li>TFTP的这一特性被许多解密高手用于获取Unix口令文件的复制，然后来猜测用户口令。为防止这种类型的访问，目前大多数TFTP服务器提供了一个选项来限制只能访问特定目录下的文件（Unix系统中通常是/tftpboot）。这个目录中只包含无盘系统进行系统引导时所需的文件。</li>
</ul>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li>TFTP是一个简单的协议，适合于只读存储器，仅用于无盘系统进行系统引导。</li>
<li>它只使用几种报文格式，是一种停止等待协议。</li>
<li>TFTP服务器通过为每个客户提供一个新的UDP端口来提供并发。这允许不同的客户输入数据报，然后由服务器中的UDP模块根据目的端口号进行区分，而不是由服务器本身来进行区分。</li>
<li>TFTP协议没有提供安全特性。大多数执行指望TFTP服务器的系统管理员来限制客户的访问，只允许它们访问引导所必须的文件。</li>
<li>文件传输协议（FTP）是设计用于一般目的的、高吞吐量的文件传输。</li>
</ul>
<h1 id="十六-BOOTP-引导程序协议"><a href="#十六-BOOTP-引导程序协议" class="headerlink" title="十六 BOOTP:引导程序协议"></a>十六 BOOTP:引导程序协议</h1><h3 id="1-引言-14"><a href="#1-引言-14" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li><p>无盘系统，它在不知道自身IP地址的情况下，在进行系统引导时能够通过RARP来获取它的IP地址。</p>
</li>
<li><p>然而使用RARP有两个问题：</p>
<ul>
<li>（1）IP地址是返回的唯一结果；</li>
<li>（2）既然RARP使用链路层广播，RARP请求就不会被路由器转发（迫使每个实际网络设置一个RARP服务器）。</li>
</ul>
</li>
<li><p>本章将介绍一种用于无盘系统进行系统引导的替代方法，又称为引导程序协议，或BOOTP。</p>
</li>
<li><p>BOOTP使用UDP，且通常需与TFTP（参见第15章）协同工作。</p>
</li>
</ul>
<h3 id="2-BOOTP的分组格式"><a href="#2-BOOTP的分组格式" class="headerlink" title="2. BOOTP的分组格式"></a>2. BOOTP的分组格式</h3><ul>
<li>BOOTP 请求和应答均被封装在UDP数据报中，共300字节  <!-- ![26.BOOTP报文.png](./img/26.BOOTP报文.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/26.BOOTP%E6%8A%A5%E6%96%87.png" class="" title="26.BOOTP报文.png">

</li>
</ul>
<h3 id="3-BOOTP服务器的设计"><a href="#3-BOOTP服务器的设计" class="headerlink" title="3. BOOTP服务器的设计"></a>3. BOOTP服务器的设计</h3><ul>
<li>BOOTP客户通常固化在无盘系统只读存储器中</li>
<li>首先，BOOTP服务器将从它的熟知端口（67）读取UDP数据报。</li>
<li>它不同于RARP服务器，它必须读取类型字段为“RARP请求”的以太网帧。</li>
<li>BOOTP协议通过将客户的硬件地址放入BOOTP分组中，使得服务器很容易获取客户的硬件地址</li>
<li>具体再看书吧</li>
</ul>
<h3 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li>BOOTP使用UDP，它为引导无盘系统获得它的IP地址提供了除RARP外的另外一种选择。</li>
<li>BOOTP还能返回其他的信息，如路由器的IP地址、客户的子网掩码和名字服务器的IP地址。</li>
<li>既然BOOTP用于系统引导过程，一个无盘系统需要下列协议才能在只读存储器中完成：BOOTP、TFTP、UDP、IP和一个局域网的驱动程序。</li>
<li>BOOTP服务器比RARP服务器更易于实现，因为BOOTP请求和应答是在UDP数据报中，而不是特殊的数据链路层帧。一个路由器还能作为真正BOOTP服务器的代理，向位于不同网络的真正BOOTP服务器转发客户的BOOTP请求。</li>
</ul>
<h1 id="十七-TCP：传输控制协议"><a href="#十七-TCP：传输控制协议" class="headerlink" title="十七 TCP：传输控制协议"></a>十七 TCP：传输控制协议</h1><h3 id="1-引言-15"><a href="#1-引言-15" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>本章将介绍<ul>
<li>TCP为应用层提供的服务</li>
<li>TCP首部中的各个字段。</li>
</ul>
</li>
</ul>
<h3 id="2-TCP的服务"><a href="#2-TCP的服务" class="headerlink" title="2. TCP的服务"></a>2. TCP的服务</h3><ul>
<li>TCP提供一种面向连接的、可靠的字节流服务。</li>
<li>面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。</li>
<li>TCP对字节流的内容不作任何解释。TCP不知道传输的数据字节流是二进制数据，还是ASCII字符、EBCDIC字符或者其他类型数据。对字节流的解释由TCP连接双方的应用层解释。</li>
</ul>
<h3 id="3-TCP的首部"><a href="#3-TCP的首部" class="headerlink" title="3. TCP的首部"></a>3. TCP的首部</h3><!-- ![27.TCP.png](./img/27.TCP.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/27.TCP.png" class="" title="27.TCP.png">
<!-- ![28.TCP首部.png](./img/28.TCP首部.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/28.TCP%E9%A6%96%E9%83%A8.png" class="" title="28.TCP首部.png">
<ul>
<li>20字节固定加变长选项</li>
<li>16位源端口/目的端口：每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端应用进程。</li>
<li>序号：序号用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。</li>
<li>确认序号：包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加1。只有ACK标志（下面介绍）为1时确认序号字段才有效。</li>
<li>首部长度给出首部中32 bit字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占4bit，因此TCP最多有60字节的首部。</li>
<li>6位标志位  <!-- ![29.标志位.png](./img/29.标志位.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/29.%E6%A0%87%E5%BF%97%E4%BD%8D.png" class="" title="29.标志位.png"></li>
<li>TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16 bit字段，因而窗口大小最大为65535字节。</li>
<li>检验和覆盖了整个的TCP报文段：TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。TCP检验和的计算和UDP检验和的计算相似，使用如11章所述的一个伪首部。</li>
<li>只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。</li>
<li>最常见的可选字段是最长报文大小，又称为MSS(Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。</li>
<li>TCP报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有TCP首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</li>
</ul>
<h3 id="4-TCP-保证可靠性的简单工作原理"><a href="#4-TCP-保证可靠性的简单工作原理" class="headerlink" title="4. TCP 保证可靠性的简单工作原理"></a>4. TCP 保证可靠性的简单工作原理</h3><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。这和 UDP 完全不同,应用程序产生的 数据报长度将保持不变。由TCP 传递给 IP 的信息单位称为报文段或段( segment)</li>
<li>当 TCP 发出一个段后,它启动一个定时器,等待目的端确认收到这个报文段。如果不能 及时收到一个确认,将重发这个报文段。</li>
<li>当 TCP 收到发自 TCP 连接另一端的数据,它将发送一个确认。这个确认不是立即发送,通常将推迟几分之一秒,</li>
<li>TCP 将保持它首部和数据的检验和。这是一个端到端的检验和,目的是检测数据在传输 过程中的任何变化。如果收到段的检验和有差错, TCP 将丢弃这个报文段和不确认收到此报文段(希望发端超时并重发)。</li>
<li>既然 TCP 报文段作为 IP 数据报来传输,而 IP 数据报的到达可能会失序,因此 TCP 报文段 的到达也可能会失序。如果必要, TCP 将对收到的数据进行重新排序,将收到的数据以正确的顺序交给应用层。</li>
<li>TCP 还能提供流量控制。TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</li>
<li>,TCP 中保持可靠性的方式就是超时重发,这是有道理的,虽然 TCP 也可以用各种各样的 ICMP 报文来处理这些,但是这也不是可靠的,最可靠的方式就是只要不得到确认,就重新发送数据报,直到得到对方的确认为止。</li>
</ol>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul>
<li>TCP将用户数据打包构成报文段；它发送数据后启动一个定时器；另一端对收到的数据进行确认，对失序的数据重新排序，丢弃重复数据；TCP提供端到端的流量控制，并计算和验证一个强制性的端到端检验和。</li>
<li>许多流行的应用程序如Telnet、Rlogin、FTP和SMTP都使用TCP。</li>
</ul>
<h1 id="十八-TCP连接的建立与终止"><a href="#十八-TCP连接的建立与终止" class="headerlink" title="十八 TCP连接的建立与终止"></a>十八 TCP连接的建立与终止</h1><h3 id="1-连接的建立与终止"><a href="#1-连接的建立与终止" class="headerlink" title="1. 连接的建立与终止"></a>1. 连接的建立与终止</h3><ul>
<li><p>三次握手建立连接</p>
<ul>
<li>C–&gt;S:SYN</li>
<li>S–&gt;C:SYN,ACK（ACK是回应上一个SYN）</li>
<li>C–&gt;S:ACK</li>
</ul>
</li>
<li><p>四次握手终止连接</p>
<ul>
<li>C–&gt;S:FIN</li>
<li>S–&gt;C:ACK（对FIN的）</li>
<li>S–&gt;C:FIN（处理未处理完的数据后）</li>
<li>C–&gt;:ACK(对FIN)<!-- ![30.连接建立与断开例子.png](./img/30.连接建立与断开例子.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/30.%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80%E4%BE%8B%E5%AD%90.png" class="" title="30.连接建立与断开例子.png">

</li>
</ul>
</li>
</ul>
<h3 id="2-连接建立的超时"><a href="#2-连接建立的超时" class="headerlink" title="2. 连接建立的超时"></a>2. 连接建立的超时</h3><ul>
<li>在SYN无相应时，客户间隔多长时间再发送一个SYN，试图建立连接。tcpdump实验输出第2个SYN与第1个的间隔是5.8秒，而第3个与第2个的间隔是24秒。</li>
<li>大多数伯克利系统将建立一个新连接的最长时间限制为75秒。超时后就放弃连接</li>
</ul>
<h3 id="3-最大报文段长度"><a href="#3-最大报文段长度" class="headerlink" title="3. 最大报文段长度"></a>3. 最大报文段长度</h3><ul>
<li>最大报文段长度（MSS）表示TCP传往另一端的最大块数据的长度。</li>
<li>当一个连接建立时，连接的双方都要通告各自的MSS。我们已经见过MSS都是1024。这导致IP数据报通常是40字节长：20字节的TCP首部和20字节的IP首部。</li>
</ul>
<h3 id="4-TCP的半关闭"><a href="#4-TCP的半关闭" class="headerlink" title="4. TCP的半关闭"></a>4. TCP的半关闭</h3><ul>
<li>就是四次握手关闭时，服务端对FIN相应ACK后，继续把剩余的数据发送，这时服务端处于close_wait状态，客户端处于半关闭状态</li>
<li>看范例，我对半关闭的理解是：告诉服务器自己的数据传完了，服务器单向传递数据</li>
</ul>
<h3 id="5-TCP的状态变迁图"><a href="#5-TCP的状态变迁图" class="headerlink" title="5. TCP的状态变迁图"></a>5. TCP的状态变迁图</h3><!-- ![TCP状态变迁图](./img/TCP状态变迁图.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/TCP%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81%E5%9B%BE.png" class="" title="TCP状态变迁图.png">
<ul>
<li><p>初看很乱，三次握手四次握手懂了后就能看明白了</p>
</li>
<li><p>2MSL等待状态</p>
<ul>
<li>TIME_WAIT状态也称为2MSL等待状态。</li>
<li>每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime）。它是任何报文段被丢弃前在网络内的最长时间。规定为2分钟，通常为30秒</li>
<li>这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</li>
<li>只有当另一端的进程完成这个关闭，我们这端才会从FIN_WAIT_2状态进入TIME_WAIT状态。</li>
</ul>
</li>
</ul>
<h3 id="6-复位报文段"><a href="#6-复位报文段" class="headerlink" title="6. 复位报文段"></a>6. 复位报文段</h3><ul>
<li>TCP首部中的RST比特是用于“复位”的。一般说来，无论何时一个报文段发往基准的连接（referenced connection）出现错误，TCP都会发出一个复位报文段（这里提到的“基准的连接”是指由目的IP地址和目的端口号以及源IP地址和源端口号指明的连接。这就是为什么RFC 793称之为插口）。</li>
<li>到不存在的端口的连接请求<ul>
<li>产生复位的一种常见情况是当连接请求到达时，目的端口没有进程正在听。</li>
<li>对于UDP，当一个数据报到达目的端口时，该端口没在使用，它将产生一个ICMP端口不可达的信息。而TCP则使用复位。</li>
</ul>
</li>
<li>异常终止一个连接<ul>
<li>终止一个连接的正常方式是一方发送FIN。有时这也称为有序释放（orderly release），因为在所有排队数据都已发送之后才发送FIN，正常情况下没有任何数据丢失。</li>
<li>但也有可能发送一个复位报文段而不是FIN来中途释放一个连接。有时称这为异常释放（abortive release）。</li>
</ul>
</li>
<li>检测半打开连接<ul>
<li>如果一方已经关闭或异常终止连接而另一方却还不知道，我们将这样的TCP连接称为半打开（Half-Open）的。任何一端的主机异常都可能导致发生这种情况。只要不打算在半打开连接上传输数据，仍处于连接状态的一方就不会检测另一方已经出现异常。</li>
<li>半打开连接的另一个常见原因是当客户主机突然掉电而不是正常的结束客户应用程序后再关机。</li>
<li>服务器主机重启后，我们重新接上电缆，并从客户向服务器发送另一行字符。由于服务器的TCP已经重新启动，它将丢失复位前连接的所有信息，因此它不知道数据报文段中提到的连接。TCP的处理原则是接收方以复位作为应答。</li>
</ul>
</li>
</ul>
<h3 id="7-同时打开、同时关闭"><a href="#7-同时打开、同时关闭" class="headerlink" title="7. 同时打开、同时关闭"></a>7. 同时打开、同时关闭</h3><ul>
<li>两个应用程序同时彼此执行主动打开的情况是可能的，尽管发生的可能性极小。</li>
<li>TCP是特意设计为了可以处理同时打开，对于同时打开它仅建立一条连接而不是两条连接（其他的协议族，最突出的是OSI运输层，在这种情况下将建立两条连接而不是一条连接）。</li>
<li>一个同时打开的连接需要交换4个报文段，比正常的三次握手多一个。（去掉最后的ACK再乘2）</li>
<li>双方都执行主动关闭也是可能的，TCP协议也允许这样的同时关闭（simultaneous close）。</li>
</ul>
<h1 id="十九-TCP的交互数据流"><a href="#十九-TCP的交互数据流" class="headerlink" title="十九 TCP的交互数据流"></a>十九 TCP的交互数据流</h1><h3 id="1-引言-16"><a href="#1-引言-16" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>一些有关TCP通信量的研究如[Caceres et al. 1991]发现<ul>
<li>如果按照分组数量计算，约有一半的TCP报文段包含成块数据（如FTP、电子邮件和Usenet新闻），另一半则包含交互数据（如Telnet和Rlogin）。</li>
<li>如果按字节计算，则成块数据与交互数据的比例约为90%和10%。这是因为成块数据的报文段基本上都是满长度（full-sized）的（通常为512字节的用户数据），而交互数据则小得多（上述研究表明Telnet和Rlogin分组中通常约90%左右的用户数据小于10个字节）。</li>
</ul>
</li>
<li>TCP需要同时处理这两类数据，但使用的处理算法则有所不同。</li>
</ul>
<h3 id="2-交互式输入"><a href="#2-交互式输入" class="headerlink" title="2. 交互式输入"></a>2. 交互式输入</h3><!-- ![按键回显服务器](./img/按键回显服务器.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/%E6%8C%89%E9%94%AE%E5%9B%9E%E6%98%BE%E6%9C%8D%E5%8A%A1%E5%99%A8.png" class="" title="按键回显服务器.png">
<ul>
<li>这样就会产生4个报文段：<br>  （1）来自客户的交互按键；<br>  （2）来自服务器的按键确认；<br>  （3）来自服务器的按键回显；<br>  （4）来自客户的按键回显确认。</li>
<li>我们一般可以将报文段2和3进行合并—按键确认与按键回显一起发送。(经受时延的确认,捎带)</li>
<li>对于交互性要求比较高的应用,TCP 给出两个策略来提高发送效率和减低网络负担:<ol>
<li>捎带 ACK。</li>
<li>Nagle 算法(一次尽量多 的发数据)。</li>
</ol>
</li>
</ul>
<h3 id="3-经受时延的确认"><a href="#3-经受时延的确认" class="headerlink" title="3. 经受时延的确认"></a>3. 经受时延的确认</h3><ul>
<li>通常TCP在接收到数据时并不立即发送ACK；相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送（有时称这种现象为数据捎带ACK）。绝大多数实现采用的时延为200 ms，也就是说，TCP将以最大200 ms的时延等待是否有数据一起发送。</li>
<li>Host Requirements RFC声明TCP需要实现一个经受时延的ACK，但时延必须小于500 ms。</li>
</ul>
<h3 id="4-Nagle算法-一次尽量多的发数据"><a href="#4-Nagle算法-一次尽量多的发数据" class="headerlink" title="4. Nagle算法(一次尽量多的发数据)"></a>4. Nagle算法(一次尽量多的发数据)</h3><ul>
<li><p>在前一节我们看到,在一个Rlogin连接上客户一般每次发送一个字节到服务器，这就产生了一些41字节长的分组：20字节的IP首部、20字节的TCP首部和1个字节的数据。在局域网上，这些小分组（被称为微小分组（tinygram））通常不会引起麻烦，因为局域网一般不会出现拥塞。但在广域网上，这些小分组则会增加拥塞出现的可能。一种简单和好的方法就是采用RFC 896 [Nagle 1984]中所建议的Nagle算法。</p>
</li>
<li><p>形象的来说：Nagle 算法是说,当主机 A 给主机 B 发送了一个 TCP 数据报并进入等待主机 B 的 ACK 数据报的状态时,TCP 的输出缓冲区里面 只能有一个 TCP 数 据报,并且,这个数据报不断地收集后来的数据,整合成一个大的数据报,等到 B 主机的 ACK 包一到,就把这些 数据“一股脑”的发送出去。虽然这样的描述有些 不准确,但还算形象和易于理解,我们同样可以体会到这个策略对于低减网络负担的 好处。</p>
</li>
<li><p>该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。</p>
</li>
<li><p>该算法的优越之处在于它是自适应的：确认到达得越快，数据也就发送得越快。</p>
</li>
<li><p>在以太网上一个字节被发送、确认和回显的平均往返时间约为16ms。为了产生比这个速度更快的数据，我们每秒键入的字符必须多于60个。这表明在局域网环境下两个主机之间发送数据时很少使用这个算法。</p>
</li>
<li><p>在编写插口程序的时候,可以通过 TCP_NODELAY 来关闭这个算法。并且,使用这个算法看情况的,比如基于 TCP 的 X 窗口协议,如果处理鼠标事件时还是用这个算法,那么“延迟”可就非常大了。</p>
</li>
</ul>
<h3 id="5-小结-1"><a href="#5-小结-1" class="headerlink" title="5. 小结"></a>5. 小结</h3><ol>
<li>交互数据总是以小于最大报文段长度的分组发送。在Rlogin中通常只有一个字节从客户发送到服务器。Telnet允许一次发送一行输入数据，但是目前大多数实现仍然发送一个字节。</li>
<li>对于这些小的报文段，接收方使用经受时延的确认方法来判断确认是否可被推迟发送，以便与回送数据一起发送。这样通常会减少报文段的数目，尤其是对于需要回显用户输入字符的Rlogin会话。</li>
<li>在较慢的广域网环境中，通常使用Nagle算法来减少这些小报文段的数目。这个算法限制发送者任何时候只能有一个发送的小报文段未被确认。</li>
</ol>
<h1 id="二十-TCP的成块数据流"><a href="#二十-TCP的成块数据流" class="headerlink" title="二十 TCP的成块数据流"></a>二十 TCP的成块数据流</h1><h3 id="1-引言-17"><a href="#1-引言-17" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>TFTP使用了停止等待协议。数据发送方在发送下一个数据块之前需要等待接收对已发送数据的确认。</li>
<li>本章我们将介绍TCP所使用的被称为滑动窗口协议的另一种形式的流量控制方法。该协议允许发送方在停止并等待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。</li>
<li>我们还将介绍TCP的PUSH标志，该标志在前面的许多例子中都出现过。</li>
<li>此外，我们还要介绍慢启动，TCP使用该技术在一个连接上建立数据流</li>
<li>最后介绍成块数据流的吞吐量。</li>
</ul>
<h3 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2. 滑动窗口"></a>2. 滑动窗口</h3><ul>
<li>滑动窗口可视化表达  <!-- ![TCP滑动窗口](./img/TCP滑动窗口.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" class="" title="TCP滑动窗口.png">
<ul>
<li>在这个图中，我们将字节从1至11进行标号。接收方通告的窗口称为提出的窗口（offered window），它覆盖了从第4字节到第9字节的区域，表明接收方已经确认了包括第3字节在内的数据，且通告窗口大小为6。</li>
<li>窗口大小是与确认序号相对应的。发送方计算它的可用窗口，该窗口表明多少数据可以立即被发送。</li>
</ul>
</li>
<li>当接收方确认数据后，这个滑动窗口不时地向右移动。窗口两个边沿的相对运动增加或减少了窗口的大小。我们使用三个术语来描述窗口左右边沿的运动：<ul>
<li>称窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时。</li>
<li>当窗口右边沿向右移动时将允许发送更多的数据，我们称之为窗口张开。这种现象发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时。</li>
<li>当右边沿向左移动时，我们称之为窗口收缩。Host Requirements RFC强烈建议不要使用这种方式。但TCP必须能够在某一端产生这种情况时进行处理。第22.3节给出了这样的一个例子，一端希望向左移动右边沿来收缩窗口，但没能够这样做。<!-- ![窗口移动](./img/窗口移动.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/%E7%AA%97%E5%8F%A3%E7%A7%BB%E5%8A%A8.png" class="" title="窗口移动.png"></li>
<li>因为窗口的左边沿受另一端发送的确认序号的控制，因此不可能向左边移动。如果接收到一个指示窗口左边沿向左移动的ACK，则它被认为是一个重复ACK</li>
<li>如果左边沿到达右边沿，则称其为一个零窗口，此时发送方不能够发送任何数据。</li>
</ul>
</li>
<li>一个例子  <!-- ![滑动窗口例子](./img/滑动窗口例子.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%BE%8B%E5%AD%90.png" class="" title="滑动窗口例子.png">
<ol>
<li>发送方不必发送一个全窗口大小的数据。</li>
<li>来自接收方的一个报文段确认数据并把窗口向右边滑动。这是因为窗口的大小是相对于确认序号的。</li>
<li>正如从报文段7到报文段8中变化的那样，窗口的大小可以减小，但是窗口的右边沿却不能够向左移动。</li>
<li>接收方在发送一个ACK前不必等待窗口被填满。在前面我们看到许多实现每收到两个报文段就会发送一个ACK。</li>
</ol>
</li>
</ul>
<h3 id="3-窗口大小"><a href="#3-窗口大小" class="headerlink" title="3. 窗口大小"></a>3. 窗口大小</h3><ul>
<li>由接收方提供的窗口的大小通常可以由接收进程控制，这将影响TCP的性能。</li>
<li>4.2BSD默认设置发送和接受缓冲区的大小为2048个字节。在4.3BSD中双方被增加为4096个字节。SunOS 4.1.3、BSD/386和SVR4仍然使用4096字节的默认大小。其他的系统，如Solaris 2.2、4.4BSD和AIX3.2则使用更大的默认缓存大小，如8192或16384等。</li>
<li>插口API允许进程设置发送和接收缓存的大小。接收缓存的大小是该连接上所能够通告的最大窗口大小。有一些应用程序通过修改插口缓存大小来增加性能。</li>
</ul>
<h3 id="4-PUSH标志"><a href="#4-PUSH标志" class="headerlink" title="4. PUSH标志"></a>4. PUSH标志</h3><ul>
<li>发送方使用该标志通知接收方将所收到的数据全部提交给接收进程。这里的数据包括与PUSH一起传送的数据以及接收方TCP已经为接收进程收到的其他数据。</li>
<li>通过允许客户应用程序通知其TCP设置PUSH标志，客户进程通知TCP在向服务器发送一个报文段时不要因等待额外数据而使已提交数据在缓存中滞留。</li>
<li>类似地，当服务器的TCP接收到一个设置了PUSH标志的报文段时，它需要立即将这些数据递交给服务器进程而不能等待判断是否还会有额外的数据到达。</li>
<li>然而，目前大多数的API没有向应用程序提供通知其TCP设置PUSH标志的方法。的确，许多实现程序认为PUSH标志已经过时，一个好的TCP实现能够自行决定何时设置这个标志。</li>
<li>如果待发送数据将清空发送缓存，则大多数的源于伯克利的实现能够自动设置PUSH标志。这意味着我们能够观察到每个应用程序写的数据均被设置了PUSH标志，因为数据在写的时候就立即被发送。</li>
<li>由于源于伯克利的实现一般从不将接收到的数据推迟交付给应用程序，因此它们忽略所接收的PUSH标志。</li>
</ul>
<h3 id="5-慢启动"><a href="#5-慢启动" class="headerlink" title="5. 慢启动"></a>5. 慢启动</h3><ul>
<li>迄今为止，在所有的例子中，发送方一开始便向网络发送多个报文段，直至达到接收方通告的窗口大小为止。当发送方和接收方处于同一个局域网时，这种方式是可以的。但是如果在发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题。一些中间路由器必须缓存分组，并有可能耗尽存储器的空间。这种连接方式是如何严重降低了TCP连接的吞吐量的。</li>
<li>现在，TCP需要支持一种被称为“慢启动(slow start)”的算法。该算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。</li>
<li>慢启动为发送方的TCP增加了另一个窗口：拥塞窗口(congestion window)，记为cwnd。当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小）。每收到一个ACK，拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加）。发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。</li>
<li>发送方开始时发送一个报文段，然后等待ACK。当收到该ACK时，拥塞窗口从1增加为2，即可以发送两个报文段。当收到这两个报文段的ACK时，拥塞窗口就增加为4。这是一种指数增加的关系。</li>
<li>在某些点上可能达到了互联网的容量，于是中间路由器开始丢弃分组。这就通知发送方它的拥塞窗口开得过大。当我们在下一章讨论TCP的超时和重传机制时，将会看到它们是怎样对拥塞窗口起作用的。现在，我们来观察一个实际中的慢启动。  <!-- ![慢启动例子](./img/慢启动例子.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/%E6%85%A2%E5%90%AF%E5%8A%A8%E4%BE%8B%E5%AD%90.png" class="" title="慢启动例子.png">
<ul>
<li>我们观察到发送方发送一个长度为512字节的报文段，然后等待ACK。该ACK在716 ms后收到。这个时间是一个往返时间的指示。于是拥塞窗口增加了2个报文段，且又发送了两个报文段。当收到报文段5的ACK后，拥塞窗口增加为3。此时尽管可发送多达3个报文段，可是在下一个ACK收到之前，只发送了2个报文段。</li>
</ul>
</li>
</ul>
<h3 id="6-成块数据的吞吐量"><a href="#6-成块数据的吞吐量" class="headerlink" title="6. 成块数据的吞吐量"></a>6. 成块数据的吞吐量</h3><h5 id="带宽时延乘积"><a href="#带宽时延乘积" class="headerlink" title="带宽时延乘积"></a>带宽时延乘积</h5><ul>
<li>可以计算通道的容量为：<br>  capacity (bit) = bandwidth (b/s) × round-trip time (s)<ul>
<li>一般称之为带宽时延乘积。这个值依赖于网络速度和两端的RT T，可以有很大的变动。</li>
</ul>
</li>
</ul>
<h5 id="拥塞"><a href="#拥塞" class="headerlink" title="拥塞"></a>拥塞</h5><ul>
<li>当数据到达一个大的管道（如一个快速局域网）并向一个较小的管道（如一个较慢的广域网）发送时便会发生拥塞。当多个输入流到达一个路由器，而路由器的输出流小于这些输入流的总和时也会发生拥塞。</li>
</ul>
<h3 id="7-紧急方式"><a href="#7-紧急方式" class="headerlink" title="7. 紧急方式"></a>7. 紧急方式</h3><ul>
<li><p>TCP提供了“紧急方式(urgent mode)”，它使一端可以告诉另一端有些具有某种方式的“紧急数据”已经放置在普通的数据流中。另一端被通知这个紧急数据已被放置在普通数据流中，由接收方决定如何处理。</p>
</li>
<li><p>不幸的是，许多实现不正确地称TCP的紧急方式为带外数据(out-of-band data)。如果一个应用程序确实需要一个独立的带外信道，第二个TCP连接是达到这个目的的最简单的方法（许多运输层确实提供许多人认为的那种真正的带外数据：使用同一个连接的独立的逻辑数据通道作为正常的数据通道。这是TCP所没有提供的）。</p>
</li>
<li><p>TCP的紧急方式与带外数据之间的混淆，也是因为主要的编程接口（插口API）将TCP的紧急方式映射为称为带外数据的插口。</p>
</li>
<li><p>紧急方式有什么作用呢？</p>
<ul>
<li>两个最常见的例子是Telnet和Rlogin。当交互用户键入中断键时，使用紧急方式来完成这个功能。</li>
<li>另一个例子是FTP，当交互用户放弃一个文件的传输时.</li>
</ul>
</li>
<li><p>Telnet和Rlogin从服务器到客户使用紧急方式是因为在这个方向上的数据流很可能要被客户的TCP停止（也即，它通告了一个大小为0的窗口）。但是如果服务器进程进入了紧急方式，尽管它不能够发送任何数据，服务器TCP也会立即发送紧急指针和URG标志。当客户TCP接收到这个通知时就会通知客户进程，于是客户可以从服务器读取其输入、打开窗口并使数据流动。</p>
</li>
</ul>
<h1 id="二十一-TCP的超时与重传"><a href="#二十一-TCP的超时与重传" class="headerlink" title="二十一 TCP的超时与重传"></a>二十一 TCP的超时与重传</h1><h3 id="1-引言-18"><a href="#1-引言-18" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>TCP提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。<ul>
<li>但数据和确认都有可能会丢失。TCP通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据。</li>
<li>对任何实现而言，关键之处就在于超时和重传的策略，即怎样决定超时间隔和如何确定重传的频率。</li>
</ul>
</li>
<li>我们已经看到过两个超时和重传的例子：<ol>
<li>在6.5节的ICMP端口不能到达的例子中，看到TFTP客户使用UDP实现了一个简单的超时和重传机制：假定5秒是一个适当的时间间隔，并每隔5秒进行重传；</li>
<li>在向一个不存在的主机发送ARP的例子中（第4.5节），我们看到当TCP试图建立连接的时候，在每个重传之间使用一个较长的时延来重传SYN。</li>
</ol>
</li>
<li>对每个连接，TCP管理4个不同的定时器。<ol>
<li>重传定时器使用于当希望收到另一端的确认。在本章我们将详细讨论这个定时器以及一些相关的问题，如拥塞避免。</li>
<li>坚持(persist)定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。第22章将讨论这个问题。</li>
<li>保活(keepalive)定时器可检测到一个空闲连接的另一端何时崩溃或重启。第23章将描述这个定时器。</li>
<li>2MSL定时器测量一个连接处于TIME_WA IT状态的时间。我们在18.6节对该状态进行了介绍。</li>
</ol>
</li>
</ul>
<h3 id="2-超时与重传的简单例子"><a href="#2-超时与重传的简单例子" class="headerlink" title="2. 超时与重传的简单例子"></a>2. 超时与重传的简单例子</h3><!-- ![超时与重传例子](./img/超时与重传例子.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0%E4%BE%8B%E5%AD%90.png" class="" title="超时与重传例子.png">
<ul>
<li>第1、2和3行表示正常的TCP连接建立的过程，第4行是“hello,world”（12个字符加上回车和换行）的传输过程，第5行是其确认。接着我们从svr4拔掉了以太网电缆，第6行表示“and hi”将被发送。第7~18行是这个报文段的12次重传过程，而第19行则是发送方的TCP最终放弃并发送一个复位信号的过程。</li>
<li>现在检查连续重传之间不同的时间差，它们取整后分别为1、3、6、12、24、48和多个64秒。</li>
<li>这个倍乘关系被称为“指数退避(exponential backoff)”。</li>
</ul>
<h3 id="3-往返时间测量"><a href="#3-往返时间测量" class="headerlink" title="3. 往返时间测量"></a>3. 往返时间测量</h3><ul>
<li>TCP超时与重传中最重要的部分就是对一个给定连接的往返时间（RTT）的测量。由于路由器和网络流量均会变化，因此我们认为这个时间可能经常会发生变化，TCP应该跟踪这些变化并相应地改变其超时时间。</li>
<li>首先TCP必须测量在发送一个带有特别序号的字节和接收到包含该字节的确认之间的RTT。数据报文段和ACK之间通常并没有一一对应的关系。在上章的例子中，这意味着发送方可以测量到的一个RTT，是在发送报文段4（第1<del>1024字节）和接收报文段7（对1</del>1024字节的ACK）之间的时间，用M表示所测量到的RTT。</li>
</ul>
<h3 id="4-拥塞避免算法"><a href="#4-拥塞避免算法" class="headerlink" title="4. 拥塞避免算法"></a>4. 拥塞避免算法</h3><ul>
<li>在第20章介绍的慢启动算法是在一个连接上发起数据流的方法，但有时我们会达到中间路由器的极限，此时分组将被丢弃。拥塞避免算法是一种处理丢失分组的方法。</li>
<li>该算法假定由于分组受到损坏引起的丢失是非常少的（远小于1%），因此分组丢失就意味着在源主机和目的主机之间的某处网络上发生了拥塞。</li>
<li>有两种分组丢失的指示：<ul>
<li>发生超时，如果使用超时作为拥塞指示，则需要使用一个好的RTT算法，</li>
<li>接收到重复的确认</li>
</ul>
</li>
<li>拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来作到这一点。在实际中这两个算法通常在一起实现。</li>
<li>拥塞避免算法和慢启动算法需要对每个连接维持两个变量：一个拥塞窗口cwnd和一个慢启动门限ssthresh。这样得到的算法的工作过程如下：<ol>
<li>对一个给定的连接，初始化cwnd为1个报文段，ssthresh为65535个字节。</li>
<li>TCP输出例程的输出不能超过cwnd和接收方通告窗口的大小。拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估计，而后者则与接收方在该连接上的可用缓存大小有关。</li>
<li>当拥塞发生时（超时或收到重复确认），ssthresh被设置为当前窗口大小的一半（cwnd和接收方通告窗口大小的最小值，但最少为2个报文段）。此外，如果是超时引起了拥塞，则cwnd被设置为1个报文段（这就是慢启动）。</li>
<li>当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于我们是否正在进行慢启动或拥塞避免。如果cwnd小于或等于ssthresh，则正在进行慢启动，否则正在进行拥塞避免。慢启动一直持续到我们回到当拥塞发生时所处位置的半时候才停止（因为我们记录了在步骤2中给我们制造麻烦的窗口大小的一半），然后转为执行拥塞避免。</li>
</ol>
</li>
<li>慢启动算法初始设置cwnd为1个报文段，此后每收到一个确认就加1。这会使窗口按指数方式增长：发送1个报文段，然后是2个，接着是4个……。</li>
<li>拥塞避免算法要求每次收到一个确认时将cwnd增加1/cwnd。与慢启动的指数增加比起来，这是一种加性增长(additive increase)。我们希望在一个往返时间内最多为cwnd增加1个报文段（不管在这个RTT中收到了多少个ACK），然而慢启动将根据这个往返时间中所收到的确认的个数增加cwnd。</li>
<li>慢启动和拥塞避免的可视化描述  <!-- ![慢启动和拥塞避免的可视化描述](./img/慢启动和拥塞避免的可视化描述.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/%E6%85%A2%E5%90%AF%E5%8A%A8%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8F%8F%E8%BF%B0.png" class="" title="慢启动和拥塞避免的可视化描述.png">
<ul>
<li>在该图中，假定当cwnd为32个报文段时就会发生拥塞。于是设置ssthresh为16个报文段，而cwnd为1个报文段。在时刻0发送了一个报文段，并假定在时刻1接收到它的ACK，此时cwnd增加为2。接着发送了2个报文段，并假定在时刻2接收到它们的ACK，于是cwnd增加为4（对每个ACK增加1次）。这种指数增加算法一直进行到在时刻3和4之间收到8个ACK后cwnd等于ssthresh时才停止，从该时刻起，cwnd以线性方式增加，在每个往返时间内最多增加1个报文段。</li>
</ul>
</li>
</ul>
<h3 id="5-快速重传与快速恢复算法"><a href="#5-快速重传与快速恢复算法" class="headerlink" title="5. 快速重传与快速恢复算法"></a>5. 快速重传与快速恢复算法</h3><ul>
<li>在收到一个失序的报文段时，TCP立即需要产生一个ACK（一个重复的ACK）。这个重复的ACK不应该被迟延。该重复的ACK的在于让对方知道收到一个失序的报文段，并告诉对方自己希望收到的序号。</li>
<li>由于我们不知道一个重复的ACK是由一个丢失的报文段引起的，还是由于仅仅出现了几个报文段的重新排序，因此我们等待少量重复的ACK到来。假如这只是一些报文段的重新排序，则在重新排序的报文段被处理并产生一个新的ACK之前，只可能产生1~2个重复的ACK。如果一连串收到3个或3个以上的重复ACK，就非常可能是一个报文段丢失了</li>
<li>于是我们就重传丢失的数据报文段，而无需等待超时定时器溢出。这就是快速重传算法。接下来执行的不是慢启动算法而是拥塞避免算法。这就是快速恢复算法。</li>
<li>没有执行慢启动的原因是由于收到重复的ACK不仅仅告诉我们一个分组丢失了。由于接收方只有在收到另一个报文段时才会产生重复的ACK，而该报文段已经离开了网络并进入了接收方的缓存。也就是说，在收发两端之间仍然有流动的数据，而我们不想执行慢启动来突然减少数据流。</li>
<li>这个算法通常按如下过程进行实现：<ul>
<li>当收到第3个重复的ACK时，将ssthresh设置为当前拥塞窗口cwnd的一半。重传丢失的报文段。设置cwnd为ssthresh加上3倍的报文段大小。</li>
<li>每次收到另一个重复的ACK时，cwnd增加1个报文段大小并发送1个分组（如果新的cwnd允许发送）。</li>
<li>当下一个确认新数据的ACK到达时，设置cwnd为ssthresh（在第1步中设置的值）。这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认。另外，这个ACK也应该是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半。</li>
</ul>
</li>
</ul>
<h3 id="6-重新分组"><a href="#6-重新分组" class="headerlink" title="6. 重新分组"></a>6. 重新分组</h3><ul>
<li>当TCP超时并重传时，它不一定要重传同样的报文段。相反，TCP允许进行重新分组而发送一个较大的报文段，这将有助于提高性能（当然，这个较大的报文段不能够超过接收方声明的MSS）。在协议中这是允许的，因为TCP是使用字节序号而不是报文段序号来进行识别它所要发送的数据和进行确认。</li>
</ul>
<h1 id="二十二-TCP的坚持定时器"><a href="#二十二-TCP的坚持定时器" class="headerlink" title="二十二 TCP的坚持定时器"></a>二十二 TCP的坚持定时器</h1><h3 id="1-引言-19"><a href="#1-引言-19" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>我们已经看到TCP通过让接收方指明希望从发送方接收的数据字节数（即窗口大小）来进行流量控制。如果窗口大小为0会发生什么情况呢？这将有效地阻止发送方传送数据，直到窗口变为非0为止。</li>
<li>TCP不对ACK报文段进行确认，TCP只确认那些包含有数据的ACK报文段。<ul>
<li>如果一个确认丢失了，则双方就有可能因为等待对方而使连接终止：接收方等待接收数据（因为它已经向发送方通告了一个非0的窗口），而发送方在等待允许它继续发送数据的窗口更新。</li>
</ul>
</li>
<li>为防止这种死锁情况的发生，发送方使用一个坚持定时器(persist timer)来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为窗口探查(window probe)。</li>
<li>本章<ul>
<li>我们将讨论窗口探查和坚持定时器</li>
<li>还将讨论与坚持定时器有关的糊涂窗口综合症。</li>
</ul>
</li>
</ul>
<h3 id="2-窗口探查"><a href="#2-窗口探查" class="headerlink" title="2. 窗口探查"></a>2. 窗口探查</h3><ul>
<li>窗口为0，从而使客户停止发送任何其他的数据。这就引起客户设置其坚持定时器。如果在该定时器时间到时客户还没有接收到一个窗口更新，它就探查这个空的窗口以决定窗口更新是否丢失。</li>
<li>请注意客户发出的窗口探查之间的时间间隔。在收到一个大小为0的窗口通告后的第1个间隔为4.949秒，下一个间隔是4.996秒，随后的间隔分别约为6,12,24,48和60秒。</li>
<li>坚持状态与第21章中介绍的重传超时之间一个不同的特点就是TCP从不放弃发送窗口探查。这些探查每隔60秒发送一次，这个过程将持续到或者窗口被打开，或者应用进程使用的连接被终止。</li>
</ul>
<h3 id="3-糊涂窗口综合症"><a href="#3-糊涂窗口综合症" class="headerlink" title="3. 糊涂窗口综合症"></a>3. 糊涂窗口综合症</h3><ul>
<li>如果发生这种情况，则少量的数据将通过连接进行交换，而不是满长度的报文段</li>
<li>这个问题可以归结为小包的问题，就是由于发送端和接收端上的处理不一致，导致网络上产生很多的小包，之前也介绍过避免网络上产生过多小包的措施，比如Nagle算法。在滑动窗口机制下，如果发送端和接收端速率很不一致，也会产生这种比较犯傻的状态：发送方发送的数据，只要一个大大的头部，携带数据很少。</li>
<li>对于接收端来讲，如果接收很慢，一次接收1个字节或者几个字节，这个时候接收端 缓冲区很快就会被填满，然后窗口通告为0字节，这个时候发送端停止发送，应用程序收上去1个字节后，发出窗口通告为1字节，发送方收到通告之后，发出1个字节的数据，这样周而复始，传输效率会非常低。</li>
<li>该现象可发生在两端中的任何一端：接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通告），而发送方也可以发送少量的数据（而不是等待其他的数据以便发送一个大的报文段）。可以在任何一端采取措施避免出现糊涂窗口综合症的现象。<ol>
<li>接收方不通告小窗口。通常的算法是接收方不通告一个比当前窗口大的窗口（可以为0），除非窗口可以增加一个报文段大小（也就是将要接收的MSS）或者可以增加接收方缓存空间的一半，不论实际有多少。</li>
<li>发送方避免出现糊涂窗口综合症的措施是只有以下条件之一满足时才发送数据:<br> (a)可以发送一个满长度的报文段；<br> (b)可以发送至少是接收方通告窗口大小一半的报文段；<br> (c)可以发送任何数据并且不希望接收ACK（也就是说，我们没有还未被确认的数据）或者该连接上不能使用Nagle算法。</li>
</ol>
</li>
</ul>
<h1 id="二十三-TCP的保活定时器"><a href="#二十三-TCP的保活定时器" class="headerlink" title="二十三 TCP的保活定时器"></a>二十三 TCP的保活定时器</h1><h3 id="1-引言-20"><a href="#1-引言-20" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>如果TCP连接的双方都没有向对方发送数据，则在两个TCP模块之间不交换任何信息。</li>
<li>我们可以启动一个客户与服务器建立一个连接，然后离去数小时、数天、数个星期或者数月，而连接依然保持。中间路由器可以崩溃和重启，电话线可以被挂断再连通，但是只要两端的主机没有被重启，则连接依然保持建立。<ul>
<li>这意味着两个应用进程—客户进程或服务器进程—都没有使用应用级的定时器来检测非活动状态，而这种非活动状态可以导致应用进程中的任何一个终止其活动。</li>
<li>然而，许多时候一个服务器希望知道客户主机是否崩溃并关机或者崩溃又重新启动。许多实现提供的保活定时器可以提供这种能力。</li>
</ul>
</li>
<li>保活并不是TCP规范中的一部分。Host Requirements RFC提供了3个不使用保活定时器的理由：<br>  (1)在出现短暂差错的情况下，这可能会使一个非常好的连接释放掉；<br>  (2)它们耗费不必要的带宽；<br>  (3)在按分组计费的情况下会在互联网上花掉更多的钱。<ul>
<li>然而，许多实现提供了保活定时器。</li>
</ul>
</li>
<li>保活定时器是一个有争论的功能。许多人认为如果需要，这个功能不应该在TCP中提供，而应该由应用程序来完成。</li>
<li>保活功能主要是为服务器应用程序提供的。服务器应用程序希望知道客户主机是否崩溃，从而可以代表客户使用资源。许多版本的Rlogin和Telnet服务器默认使用这个选项。</li>
<li>一个说明现在需要使用保活功能的常见例子是当个人计算机用户使用TCP/IP向一个使用Telnet的主机注册时。如果在一天结束时，他们仅仅关闭了电源而没有注销，那么便会留下一个半开放的连接。一个半开放连接发送数据会导致返回一个复位，但那是在来自正在发送数据的客户端。如果客户已经消失了，使得在服务器上留下一个半开放连接，而服务器又在等待来自客户的数据，则服务器将永远等待下去。保活功能就是试图在服务器端检测到这种半开放的连接。</li>
</ul>
<h3 id="2-描述"><a href="#2-描述" class="headerlink" title="2. 描述"></a>2. 描述</h3><ul>
<li><p>通常都是服务器设置这个功能。如果双方都特别需要了解对方是否已经消失，则双方都可以使用这个选项,Telnet和Rlogin中，只有服务器设置了这个选项，而客户则没有</p>
</li>
<li><p>如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段（我们将在随后的例子中看到这个探查报文段看起来像什么）。客户主机必须处于以下4个状态之一。</p>
<ol>
<li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常工作的。服务器在两小时以后将保活定时器复位。如果在两个小时定时器到时间之前有应用程序的通信量通过此连接，则定时器在交换数据后的未来2小时再复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务器将不能够收到对探查的响应，并在75秒后超时。服务器总共发送10个这样的探查，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。</li>
<li>客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与状态2之间的区别，它所能发现的就是没有收到探查的响应。</li>
</ol>
</li>
<li><p>一个被人们不断讨论的关于保活选项的问题就是两个小时的空闲时间是否可以改变。通常他们希望该数值可以小得多，处在分钟的数量级。正如我们在附录E看到的，这个值通常可以改变，但是在该附录所描述的所有系统中，保活间隔时间是系统级的变量，因此改变它会影响到所有使用该功能的用户。</p>
</li>
</ul>
<h1 id="二十四-TCP的未来和性能"><a href="#二十四-TCP的未来和性能" class="headerlink" title="二十四 TCP的未来和性能"></a>二十四 TCP的未来和性能</h1><h3 id="1-引言-21"><a href="#1-引言-21" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>本章讨论TCP的一些修改建议，这些建议可以使TCP在高速率环境中获得最大的吞吐量。</li>
<li>首先要讨论前面已经碰到过的路径MTU发现机制，本章主要关注它如何与TCP协同工作。这个机制通常可以使TCP为非本地的连接使用大于536字节的MTU，从而增加吞吐量。</li>
<li>接着介绍长肥管道(long fat pipe)，也就是那些具有很大的带宽时延乘积的网络，以及TCP在这些网络上所具有的局限性。<ul>
<li>为处理长肥管道，我们描述两个新的TCP选项：窗口扩大选项（用来增加TCP的最大窗口，使之超过65535字节）和时间戳选项。</li>
<li>后面这个选项可以使TCP对报文段进行更加精确的RTT测量，还可以在高速率下对可能发生的序号回绕提供保护。</li>
</ul>
</li>
<li>我们还将介绍建议的T/TCP，这是为增加事务功能而对TCP进行的修改。通信的事务模式以客户的请求将被服务器应答的响应为主要特征。这是客户服务器计算的常见模型。T/TCP的目的就是减少两端交换的报文段数量，避免三次握手和使用4个报文段进行连接的关闭，从而使客户可以在一个RTT和处理请求所必需的时间内收到服务器的应答。</li>
<li>这些新选项（路径MTU发现、窗口扩大选项、时间戳选项和T/TCP）中令人印象最深刻的就是它们与现有的TCP实现能够向后兼容，即包括这些新选项的系统仍然可以与原有的旧系统进行交互。除了在一个ICMP报文中为路径MTU发现增加了一个额外字段之外，这些新的选项只需要在那些需要使用它们的端系统中进行实现。</li>
</ul>
<h3 id="2-路径MTU发现"><a href="#2-路径MTU发现" class="headerlink" title="2. 路径MTU发现"></a>2. 路径MTU发现</h3><ul>
<li><p>TCP的路径MTU发现按如下方式进行：在连接建立时，TCP使用输出接口或对端声明的MSS中的最小MTU作为起始的报文段大小。路径MTU发现不允许TCP超过对端声明的MSS。如果对端没有指定一个MSS，则默认为536。</p>
</li>
<li><p>一旦选定了起始的报文段大小，在该连接上的所有被TCP发送的IP数据报都将被设置DF比特。如果某个中间路由器需要对一个设置了DF标志的数据报进行分片，它就丢弃这个数据报</p>
<h3 id="3-长肥管道"><a href="#3-长肥管道" class="headerlink" title="3. 长肥管道"></a>3. 长肥管道</h3></li>
<li><p>在20章中，我们把一个连接的容量表示为如下，并称之为带宽时延乘积。也可称它为两端的管道大小。<br>  capacity(b) = bandwidth(b/s) × round - triptime(s)</p>
</li>
<li><p>具有大的带宽时延乘积的网络被称为长肥网络（Long Fat Network，即LFN，发音为“elefan(t)s”），而一个运行在LFN上的TCP连接被称为长肥管道。</p>
</li>
<li><p>管道可以被水平拉长（一个长的RT T），或被垂直拉高（较高的带宽），或向两个方向拉伸。使用长肥管道会遇到多种问题。</p>
</li>
<li><p>千兆比网络</p>
<ul>
<li>在千兆比速率下，时延限制占据了主要地位，而带宽不再成为限制。</li>
<li>时延主要是由光速引起的，而且不能够被减小（除非爱因斯坦是错误的）。当我们考虑到分组需要建立和终止一个连接时，这个固定时延起的作用就更糟糕了。千兆比网络会引起一些需要不同看待的连网观点。</li>
</ul>
</li>
</ul>
<h3 id="4-窗口扩大选项"><a href="#4-窗口扩大选项" class="headerlink" title="4. 窗口扩大选项"></a>4. 窗口扩大选项</h3><ul>
<li>窗口扩大选项使TCP的窗口定义从16 bit增加为32 bit。这并不是通过修改TCP首部来实现的，TCP首部仍然使用16 bit，而是通过定义一个选项实现对16 bit的扩大操作(scaling operation)来完成的。于是TCP在内部将实际的窗口大小维持为32 bit的值。</li>
</ul>
<h3 id="5-时间戳选项"><a href="#5-时间戳选项" class="headerlink" title="5. 时间戳选项"></a>5. 时间戳选项</h3><ul>
<li>时间戳选项使发送方在每个报文段中放置一个时间戳值。接收方在确认中返回这个数值，从而允许发送方为每一个收到的ACK计算RTT（我们必须说“每一个收到的ACK”而不是“每一个报文段”，是因为TCP通常用一个ACK来确认多个报文段）。我们提到过目前许多实现为每一个窗口只计算一个RTT，对于包含8个报文段的窗口而言这是正确的。然而，较大的窗口大小则需要进行更好的RTT计算。</li>
</ul>
<h3 id="6-T-TCP：为事务用的TCP扩展"><a href="#6-T-TCP：为事务用的TCP扩展" class="headerlink" title="6. T/TCP：为事务用的TCP扩展"></a>6. T/TCP：为事务用的TCP扩展</h3><ul>
<li>TCP提供的是一种虚电路方式的运输服务。一个连接的生存时间包括三个不同的阶段：建立、数据传输和终止。这种虚电路服务非常适合诸如远程注册和文件传输之类的应用。</li>
<li>但是，还有出现其他的应用进程被设计成使用事务服务。一个事务(transaction)就是符合下面这些特征的一个客户请求及其随后的服务器响应。<ol>
<li>应该避免连接建立和连接终止的开销，在可能的时候，发送一个请求分组并接收一个应答分组。</li>
<li>等待时间应当减少到等于RTT与SPT之和。其中RTT(Round-Trip Time)为往返时间，而SPT(Server Processing Time)则是服务器处理请求的时间。</li>
<li>服务器应当能够检测出重复的请求，并且当收到一个重复的请求时不重新处理事务（避免重新处理意味着服务器不必再次处理请求，而是返回保存的、与该请求对应的应答）。</li>
</ol>
</li>
<li>如今一个应用程序设计人员面对的一种选择是使用TCP还是UDP。TCP提供了过多的事务特征，而UDP提供的则不够。通常应用程序使用UDP来构造（避免TCP连接的开销），而许多需要的特征（如动态超时和重传、拥塞避免等）被放置在应用层，一遍又一遍的重新设计和实现。</li>
<li>一个较好的解决方法是提供一个能够提供足够多的事务处理功能的运输层。我们在本节所介绍的事务协议被称为T/TCP。</li>
<li>TCP为处理事务而需要进行的两个改动是避免三次握手和缩短WAIT_TIME状态。T/TCP通过使用加速打开来避免三次握手</li>
</ul>
<h1 id="二十五-SNMP-简单网络管理协议"><a href="#二十五-SNMP-简单网络管理协议" class="headerlink" title="二十五 SNMP:简单网络管理协议"></a>二十五 SNMP:简单网络管理协议</h1><h3 id="1-引言-22"><a href="#1-引言-22" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li><p>随着网络技术的飞速发展，网络的数量也越来越多。而网络中的设备来自各个不同的厂家，如何管理这些设备就变得十分重要。本章的内容就是介绍管理这些设备的标准。</p>
</li>
<li><p>基于TCP/IP的网络管理包含两个部分：</p>
<ol>
<li>网络管理站（也叫管理进程，manager）<ul>
<li><ul>
<li>管理站一般都是带有彩色监视器的工作站，可以显示所有被管设备的状态(例如连接是否掉线、各种连接上的流量状况等)。</li>
</ul>
</li>
</ul>
</li>
<li>被管的网络单元（也叫被管设备）<ul>
<li>被管设备种类繁多，例如：路由器、X终端、终端服务器和打印机等。</li>
<li>这些被管设备的共同点就是都运行TCP/IP协议。</li>
<li>被管设备端和管理相关的软件叫做代理程序(agent)或代理进程。</li>
</ul>
</li>
</ol>
</li>
<li><p>管理进程和代理进程之间的通信可以有两种方式。</p>
<ol>
<li>一种是管理进程向代理进程发出请求，询问一个具体的参数值（例如：你产生了多少个不可达的ICMP端口？）。它还可以按要求改变代理进程的参数值（例如：把默认的IP TTL值改为64）。</li>
<li>另外一种方式是代理进程主动向管理进程报告有某些重要的事件发生（例如：一个连接口掉线了）。</li>
</ol>
</li>
<li><p>基于TCP/IP的网络管理包含3个组成部分：</p>
<ol>
<li>一个管理信息库MIB（Management Information Base）。<ul>
<li>管理信息库包含所有代理进程的所有可被查询和修改的参数。</li>
</ul>
</li>
<li>关于MIB的一套公用的结构和表示符号。叫做管理信息结构SMI（Structure of Management Information）。<ul>
<li>SMI定义计数器是一个非负整数，它的计数范围是0~4294 967 295，当达到最大值时，又从0开始计数。</li>
</ul>
</li>
<li>管理进程和代理进程之间的通信协议，叫做简单网络管理协议SNMP（Simple Network Management Protocol）。<ul>
<li>尽管可以在运输层采用各种各样的协议，但是在SNMP中，用得最多的协议还是UDP。</li>
</ul>
</li>
</ol>
</li>
<li><p>本章</p>
<ul>
<li>首先介绍管理进程和代理进程之间的协议</li>
<li>然后讨论参数的数据类型。</li>
</ul>
</li>
</ul>
<h3 id="2-协议-1"><a href="#2-协议-1" class="headerlink" title="2. 协议"></a>2. 协议</h3><ul>
<li>关于管理进程和代理进程之间的交互信息，SNMP定义了5种报文：<ol>
<li>get-request操作：从代理进程处提取一个或多个参数值。</li>
<li>get-next-request操作：从代理进程处提取一个或多个参数的下一个参数值（关于“下一个（next）”的含义将在后面的章节中介绍）。</li>
<li>set-request操作：设置代理进程的一个或多个参数值。</li>
<li>get-response操作：返回的一个或多个参数值。这个操作是由代理进程发出的。它是前面3中操作的响应操作。</li>
<li>trap操作：代理进程主动发出的报文，通知管理进程有某些事情发生。</li>
</ol>
<ul>
<li>前面的3个操作是由管理进程向代理进程发出的。后面两个是代理进程发给管理进程的<!-- ![SNMP5种操作](./img/SNMP5种操作.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/SNMP5%E7%A7%8D%E6%93%8D%E4%BD%9C.png" class="" title="SNMP5种操作.png"></li>
</ul>
</li>
<li>前4种操作是简单的请求-应答方式（也就是管理进程发出请求，代理进程应答响应），而且在SNMP中往往使用UDP协议，可能发生管理进程和代理进程之间数据报丢失的情况。因此一定要有超时和重传机制。</li>
<li>管理进程发出的前面3种操作采用UDP的161端口。代理进程发出的Tr ap操作采用UDP的162端口。由于收发采用了不同的端口号，所以一个系统可以同时为管理进程和代理进程</li>
<li>封装成UDP数据报的5种操作的SNMP报文格式。  <!-- ![SNMP报文](./img/SNMP报文.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/SNMP%E6%8A%A5%E6%96%87.png" class="" title="SNMP报文.png">

</li>
</ul>
<h3 id="3-管理信息结构"><a href="#3-管理信息结构" class="headerlink" title="3. 管理信息结构"></a>3. 管理信息结构</h3><ul>
<li>SNMP中有一些自己的数据类型。有点多，有需要再看书吧。</li>
</ul>
<h3 id="4-对象标识符"><a href="#4-对象标识符" class="headerlink" title="4. 对象标识符"></a>4. 对象标识符</h3><ul>
<li>对象标识是一种数据类型，它指明一种“授权”命名的对象。“授权”的意思就是这些标识不是随便分配的，它是由一些权威机构进行管理和分配的。</li>
<li>对象标识是一个整数序列，以点（“.”）分隔。这些整数构成一个树型结构，类似于DNS或Unix的文件系统。对象标识从树的顶部开始，顶部没有标识，以root表示（这和Unix中文件系统的树遍历方向非常类似）。</li>
<li>下图显示了在SNMP中用到的这种树型结构。所有的MIB变量都从1.3.6.1.2.1这个标识开始。  <!-- ![SNMP对象标识](./img/SNMP对象标识.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/SNMP%E5%AF%B9%E8%B1%A1%E6%A0%87%E8%AF%86.png" class="" title="SNMP对象标识.png">

</li>
</ul>
<h3 id="5-管理信息库介绍"><a href="#5-管理信息库介绍" class="headerlink" title="5. 管理信息库介绍"></a>5. 管理信息库介绍</h3><ul>
<li>所谓管理信息库，或者MIB，就是所有代理进程包含的、并且能够被管理进程进行查询和设置的信息的集合。</li>
<li>如上图所示，MIB被划分为若干个组，如system、interfaces、at（地址转换）和ip组等。</li>
<li>在本节，我们仅仅讨论UDP组中的变量。这个组比较简单，它包含几个变量和一个表格。  <!-- ![SNMP之UDP组结构](./img/SNMP之UDP组结构.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/SNMP%E4%B9%8BUDP%E7%BB%84%E7%BB%93%E6%9E%84.png" class="" title="SNMP之UDP组结构.png"></li>
<li>在该组中，包含4个简单变量和1个由两个简单变量组成的表格。  <!-- ![UDP组下简单变量](./img/UDP组下简单变量.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/UDP%E7%BB%84%E4%B8%8B%E7%AE%80%E5%8D%95%E5%8F%98%E9%87%8F.png" class="" title="UDP组下简单变量.png">
  <!-- ![UDPtable中的变量](./img/UDPtable中的变量.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/UDPtable%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F.png" class="" title="UDPtable中的变量.png">

</li>
</ul>
<h3 id="6-实例标识"><a href="#6-实例标识" class="headerlink" title="6. 实例标识"></a>6. 实例标识</h3><ul>
<li>当对MIB变量进行操作，如查询和设置变量的值时，必须对MIB的每个变量进行标识。首先，只有叶子结点是可操作的。SNMP没法处理表格的一整行或一整列。mib、udp、udpTable和udpEntry就不是叶子结点。udpTable里面的数据是叶子节点。</li>
</ul>
<h1 id="二十六-Telnet和Rlogin-远程登录"><a href="#二十六-Telnet和Rlogin-远程登录" class="headerlink" title="二十六 Telnet和Rlogin:远程登录"></a>二十六 Telnet和Rlogin:远程登录</h1><h3 id="1-引言-23"><a href="#1-引言-23" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>远程登录（Remote Login）是Internet上最广泛的应用之一。我们可以先登录（即注册）到一台主机然后再通过网络远程登录到任何其他一台网络主机上去，而不需要为每一台主机连接一个硬件终端（当然必须有登录帐号）。</li>
<li>在TCP/IP网络上，有两种应用提供远程登录功能。<ol>
<li>Telnet是标准的提供远程登录功能的应用，几乎每个TCP/IP的实现都提供这个功能。它能够运行在不同操作系统的主机之间。Telnet通过客户进程和服务器进程之间的选项协商机制，从而确定通信双方可以提供的功能特性。</li>
<li>Rlogin起源于伯克利Unix，开始它只能工作在Unix系统之间，现在已经可以在其他操作系统上运行。</li>
</ol>
</li>
<li>远程登录采用客户-服务器模式。下图显示的是一个Telnet客户和服务器的典型连接图（对于Rlogin的客户和服务器连接图，我们可以画得更加简单）。  <!-- ![Telnet登录](./img/Telnet登录.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/Telnet%E7%99%BB%E5%BD%95.png" class="" title="Telnet登录.png">
<ol>
<li>Telnet客户进程同时和终端用户和TCP/IP协议模块进行交互。通常我们所键入的任何信息的传输是通过TCP连接，连接的任何返回信息都输出到终端上。</li>
<li>Telnet服务器进程经常要和一种叫做“伪终端设备”（pseudo-terminal device）打交道，至少在Unix系统下是这样的。<ul>
<li>这就使得对于登录外壳(shell)进程来讲，它是被Telnet服务器进程直接调用的，而且任何运行在登录外壳进程处的程序都感觉是直接和一个终端进行交互。</li>
<li>对于像满屏编辑器这样的应用来讲，就像直接在和终端打交道一样。</li>
<li>实际上，如何对服务器进程的登录外壳进程进行处理，使得它好像在直接和终端交互，往往是编写远程登录服务器进程程序中最困难的方面之一。</li>
</ul>
</li>
<li>仅仅使用了一条TCP连接。由于客户进程必须多次和服务器进程进行通信（反之亦然），这就必然需要某些方法，来描绘在连接上传输的命令和用户数据。我们在后面的内容中会介绍Telnet和Rlogin是如何处理这个问题的。</li>
<li>注意在上图中，我们用虚线框把终端驱动进程和伪终端驱动进程框了起来。在TCP/IP实现中，虚线框的内容一般是操作系统内核的一部分。Telnet客户进程和服务器进程一般只是属于用户应用程序。</li>
<li>把服务器进程的登录外壳进程画出来的目的是为了说明：当我们想登录到系统的时候，必须要有一个帐号，Telnet和Rlogin都是如此。</li>
</ol>
</li>
<li>现在，不断有新的Telnet选项被添加到Telnet中去，这就使得Telnet实现的源代码数量大大增加，而Rlogin依然变化不大，还是比较简单。</li>
<li>远程登录不是那种有大量数据报传输的应用。正如我们前面讲到的一样，客户进程和服务器进程交互的分组大多比较小。[Paxson 1993]发现客户进程发出的字节数（用户在终端上键入的信息）和服务器进程端发出的字节数的数量之比是 1:20。这是因为我们在终端上键入的一条短命令往往令服务器进程端产生很多输出。</li>
</ul>
<h3 id="2-Rlogin协议"><a href="#2-Rlogin协议" class="headerlink" title="2. Rlogin协议"></a>2. Rlogin协议</h3><h5 id="1-应用进程的启动"><a href="#1-应用进程的启动" class="headerlink" title="1. 应用进程的启动"></a>1. 应用进程的启动</h5><ul>
<li>Rlogin的客户进程和服务器进程使用一个TCP连接。当普通的TCP连接建立完毕之后，客户进程和服务器进程之间将发生下面所述的动作。<ul>
<li>客户进程给服务器进程发送4个字符串：<br>  （a）一个字节的0；<br>  （b）用户登录进客户进程主机的登录名，以一个字节的0结束；<br>  （c）登录服务器进程端主机的登录名，以一个字节的0结束；<br>  （d）用户终端类型名，紧跟一个正斜杠“/”，然后是终端速率，以一个字节的0结束。<ul>
<li>在这里需要两个登录名字，这是因为用户登录客户和服务器的名称有可能不一样。由于大多满屏应用程序需要知道终端类型，所以终端类型也必须发送到服务器进程。发送终端速率的原因是因为有些应用随着速率的改变，它的操作也有所变化。例如vi编辑器，当速率比较小的时候，它的工作窗口也变小。所以它不能永远保持同样大小的窗口。</li>
</ul>
</li>
<li>服务器进程返回一个字节的0。</li>
<li>服务器进程可以选择是否要求用户输入口令。这个步骤的数据交互没有什么特别的协议，而被当作是普通的数据进行传输。服务器进程给客户进程发送一个字符串（显示在客户进程的屏幕上），通常是password:。如果在一定的限定时间内（通常是60秒）客户进程没有输入口令，服务器进程将关闭该连接。</li>
<li>通常可以在服务器进程的主目录(home directory)下生成一个文件（通常叫 .rhosts），该文件的某些行记录了一个主机名和用户名。如果从该文件中已经记录的主机上用已经记录的用户名进行登录，服务器进程将不提示我们输入口令。但是很多关于安全性的文献，如[Curry 1992]，强烈建议不要采用这种方法，因为这存在安全漏洞。</li>
<li>如果提示输入口令，那么我们输入的口令将以明文的形式发送到服务器进程。我们所键入的每个字符都是以明文的格式传输的。所以某人只要能够截取网络上的原始传输的分组，他就可以截获用户口令。针对这个问题，新版本的Rlogin客户程序，例如4.4BSD版本的客户程序，第一次采用了Kerberos安全模型。Kerberos安全模型可以避免用户口令以明文的形式在网络上传输。当然，这要求服务器进程也支持Kerberos（[Curry 1992]详细描述了Kerberos安全模型）。</li>
<li>服务器进程通常要给客户进程发送请求，询问终端的窗口大小（将在后面解释）。</li>
</ul>
</li>
<li>客户进程每次给服务器进程发送一个字节的内容，并且接收服务器进程的所有返回信息。同样我们也采用了Nagle算法，该算法可以保证在速率较低的网络上，若干输入字节以单个TCP报文段传输。操作其实很简单：用户键入的所有东西被发送到服务器，服务器发送给客户的任何信息返回到用户的屏幕上。</li>
</ul>
<h5 id="2-流量控制"><a href="#2-流量控制" class="headerlink" title="2. 流量控制"></a>2. 流量控制</h5><ul>
<li>默认情况下，流量控制是由Rlogin的客户进程完成的。客户进程能够识别用户键入的STO P和STA RT的ASCII字符（Control_S和Control_Q），并且终止或启动终端的输出。</li>
<li>如果不是这样，每次我们为终止终端输出而键入的Control_S字符将沿网络传输到服务器进程，这时服务器进程将停止往网络上写数据。但是在写操作终止之前，服务器进程可能已经往网络上写了一窗口的输出数据。也就是说，在输出停止之前，成千上万的数据字节还将在屏幕上显示。  <!-- ![Rlogin流量控制](./img/Rlogin流量控制.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/Rlogin%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png" class="" title="Rlogin流量控制.png"></li>
<li>对于一个交互式用户来讲，Control_S字符的响应延时是较大的。</li>
</ul>
<h3 id="3-Telnet协议"><a href="#3-Telnet协议" class="headerlink" title="3. Telnet协议"></a>3. Telnet协议</h3><ul>
<li>Telnet协议可以工作在任何主机（例如，任何操作系统）或任何终端之间。</li>
<li>定义了一种通用字符终端叫做网络虚拟终端NVT（Network Virtual Terminal）。NVT是虚拟设备，连接的双方，即客户机和服务器，都必须把它们的物理终端和NVT进行相互转换。也就是说，不管客户进程终端是什么类型，操作系统必须把它转换为NVT格式。同时，不管服务器进程的终端是什么类型，操作系统必须能够把NVT格式转换为终端所能够支持的格式。</li>
</ul>
<!-- ![rlogin和telnet的不同特性](./img/rlogin和telnet的不同特性.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/rlogin%E5%92%8Ctelnet%E7%9A%84%E4%B8%8D%E5%90%8C%E7%89%B9%E6%80%A7.png" class="" title="rlogin和telnet的不同特性.png">

<h1 id="二十七-FTP-文件传送协议"><a href="#二十七-FTP-文件传送协议" class="headerlink" title="二十七 FTP:文件传送协议"></a>二十七 FTP:文件传送协议</h1><h3 id="1-引言-24"><a href="#1-引言-24" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>FTP是另一个常见的应用程序。它是用于文件传输的Internet标准。</li>
<li>我们必须分清文件传送（file transfer）和文件存取(file access)之间的区别，前者是FTP提供的，后者是如NFS（Sun的网络文件系统）等应用系统提供的。</li>
<li>由FTP提供的文件传送是将一个完整的文件从一个系统复制到另一个系统中。要使用FTP，就需要有登录服务器的注册帐号，或者通过允许匿名FTP的服务器来使用</li>
<li>与Telnet类似，FTP最早的设计是用于两台不同的主机，这两个主机可能运行在不同的操作系统下、使用不同的文件结构、并可能使用不同字符集。但不同的是，Telnet获得异构性是强制两端都采用同一个标准：使用7比特ASCII码的NVT。而FTP是采用另一种方法来处理不同系统间的差异。FTP支持有限数量的文件类型（ASCII，二进制，等等）和文件结构（面向字节流或记录）。</li>
</ul>
<h3 id="2-FTP协议"><a href="#2-FTP协议" class="headerlink" title="2. FTP协议"></a>2. FTP协议</h3><ul>
<li>FTP与我们已描述的另一种应用不同，它采用两个TCP连接来传输一个文件。<ul>
<li>控制连接以通常的客户服务器方式建立。服务器以被动方式打开众所周知的用于FTP的端口（21），等待客户的连接。客户则以主动方式打开TCP端口21，来建立连接。控制连接始终等待客户与服务器之间的通信。该连接将命令从客户传给服务器，并传回服务器的应答。</li>
<li>由于命令通常是由用户键入的，所以IP对控制连接的服务类型就是“最大限度地减小迟延”。</li>
<li>每当一个文件在客户与服务器之间传输时，就创建一个数据连接。（其他时间也可以创建，后面我们将说到）。</li>
<li>由于该连接用于传输目的，所以IP对数据连接的服务特点就是“最大限度提高吞吐量”。</li>
</ul>
</li>
</ul>
<h5 id="客户与服务器以及它们之间的连接情况。"><a href="#客户与服务器以及它们之间的连接情况。" class="headerlink" title="客户与服务器以及它们之间的连接情况。"></a>客户与服务器以及它们之间的连接情况。</h5><!-- ![FTP文件传输](./img/FTP文件传输.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/FTP%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" class="" title="FTP文件传输.png">
<ul>
<li>从图中可以看出，交互式用户通常不处理在控制连接中转换的命令和应答。这些细节均由两个协议解释器来完成。</li>
<li>标有“用户接口”的方框功能是按用户所需提供各种交互界面（全屏幕菜单选择，逐行输入命令，等等），并把它们转换成在控制连接上发送的FTP命令。</li>
</ul>
<h5 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h5><ul>
<li>FTP协议规范提供了控制文件传送与存储的多种选择。在以下四个方面中每一个方面都必须作出一个选择。</li>
</ul>
<ol>
<li><p>文件类型</p>
<ul>
<li>ASCII码文件类型（默认选择）文本文件以NVT ASCII码形式在数据连接中传输。这要求发方将本地文本文件转换成NVT ASCII码形式，而收方则将NVT ASCII码再还原成本地文本文件。其中，用NVT ASCII码传输的每行都带有一个回车，而后是一个换行。这意味着收方必须扫描每个字节，查找CR、LF对（我们在第15.2节见过的关于TFIP的ASCII码文件传输情况与此相同）。</li>
<li>EBCDIC文件类型该文本文件传输方式要求两端都是EBCDIC系统。</li>
<li>图像文件类型（也称为二进制文件类型）数据发送呈现为一个连续的比特流。通常用于传输二进制文件。</li>
<li>本地文件类型该方式在具有不同字节大小的主机间传输二进制文件。每一字节的比特数由发方规定。对使用8bit字节的系统来说，本地文件以8bit字节传输就等同于图像文件传输。</li>
</ul>
</li>
<li><p>格式控制，该选项只对ASCII和EBCDIC文件类型有效。</p>
<ul>
<li>非打印（默认选择）文件中不含有垂直格式信息。</li>
<li>远程登录格式控制文件含有向打印机解释的远程登录垂直格式控制。</li>
<li>Fortran回车控制每行首字符是Fortran格式控制符。</li>
</ul>
</li>
<li><p>结构</p>
<ul>
<li>文件结构（默认选择）文件被认为是一个连续的字节流。不存在内部的文件结构。</li>
<li>记录结构该结构只用于文本文件（ASCII或EBCDIC）。</li>
<li>页结构每页都带有页号发送，以便收方能随机地存储各页。该结构由TO PS-20操作系统提供（主机需求RFC不提倡采用该结构）。</li>
</ul>
</li>
<li><p>传输方式，它规定文件在数据连接中如何传输。</p>
<ul>
<li>流方式（默认选择）文件以字节流的形式传输。对于文件结构，发方在文件尾提示关闭数据连接。对于记录结构，有专用的两字节序列码标志记录结束和文件结束。</li>
<li>块方式文件以一系列块来传输，每块前面都带有一个或多个首部字节。</li>
<li>压缩方式一个简单的全长编码压缩方法，压缩连续出现的相同字节。在文本文件中常用来压缩空白串，在二进制文件中常用来压缩0字节（这种方式很少使用，也不受支持。现在有一些更好的文件压缩方法来支持FTP）。</li>
</ul>
</li>
</ol>
<ul>
<li>通常由Unix实现的FTP客户和服务器把我们的选择限制如下：<ul>
<li>类型：ASCII或图像。</li>
<li>格式控制：只允许非打印。</li>
<li>结构：只允许文件结构。</li>
<li>传输方式：只允许流方式。</li>
</ul>
</li>
</ul>
<h5 id="FTP命令"><a href="#FTP命令" class="headerlink" title="FTP命令"></a>FTP命令</h5><ul>
<li>命令和应答在客户和服务器的控制连接上以NVT ASCII码形式传送。这就要求在每行结尾都要返回CR、LF对（也就是每个命令或每个应答）。</li>
<li>常见的FTP命令  <!-- ![常见的FTP命令](./img/常见的FTP命令.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/%E5%B8%B8%E8%A7%81%E7%9A%84FTP%E5%91%BD%E4%BB%A4.png" class="" title="常见的FTP命令.png">

</li>
</ul>
<h5 id="FTP应答"><a href="#FTP应答" class="headerlink" title="FTP应答"></a>FTP应答</h5><ul>
<li>应答都是ASCII码形式的3位数字，并跟有报文选项。类似于HTTP的应答</li>
<li>应答代码第1位和第2位的含义。  <!-- ![FTP应答代码](./img/FTP应答代码.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/FTP%E5%BA%94%E7%AD%94%E4%BB%A3%E7%A0%81.png" class="" title="FTP应答代码.png"></li>
<li>第3位数字给出差错报文的附加含义。例如，这里是一些典型的应答，都带有一个可能的报文串。<ul>
<li>125   数据连接已经打开;传输开始。</li>
<li>200   就绪命令。</li>
<li>214   帮助报文(面向用户)。</li>
<li>331   用户名就绪,要求输入口令。</li>
<li>425   不能打开数据连接。</li>
<li>452   错写文件。</li>
<li>500   语法错误(未认可的命令)。</li>
<li>501   语法错误(无效参数)。</li>
<li>502   未实现的 MODE ( 方式命令 ) 类型。</li>
</ul>
</li>
</ul>
<h5 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h5><ul>
<li>数据连接有以下三大用途：<ol>
<li>从客户向服务器发送一个文件。</li>
<li>从服务器向客户发送一个文件。</li>
<li>从服务器向客户发送文件或目录列表。<!-- ![FTP连接](./img/FTP连接.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/FTP%E8%BF%9E%E6%8E%A5.png" class="" title="FTP连接.png"></li>
</ol>
</li>
<li>服务器总是执行数据连接的主动打开。通常服务器也执行数据连接的主动关闭，除非当客户向服务器发送流形式的文件时，需要客户来关闭连接（它给服务器一个文件结束的通知）。</li>
</ul>
<h1 id="二十八-SMTP-简单邮件传送协议"><a href="#二十八-SMTP-简单邮件传送协议" class="headerlink" title="二十八 SMTP:简单邮件传送协议"></a>二十八 SMTP:简单邮件传送协议</h1><h3 id="1-引言-25"><a href="#1-引言-25" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>一个用TCP/IP交换电子邮件的示意图。  <!-- ![TCPIP交换电子邮件](./img/TCPIP交换电子邮件.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/TCPIP%E4%BA%A4%E6%8D%A2%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6.png" class="" title="TCPIP交换电子邮件.png"></li>
<li>用户与用户代理（user agent）打交道，可能会有多个用户代理可供选择。常用的Unix上的用户代理包括MH，Berkeley Mail,Elm和Mush。</li>
<li>用TCP进行的邮件交换是由报文传送代理MTA（Message Transfer Agent）完成的。最普通的Unix系统中的MTA是Sendmail。用户通常不和MTA打交道，由系统管理员负责设置本地的MTA。通常，用户可以选择它们自己的用户代理。</li>
<li>本章研究在两个MTA之间如何用TCP交换邮件。我们不考虑用户代理的运行或实现。</li>
</ul>
<h3 id="2-SMTP协议"><a href="#2-SMTP协议" class="headerlink" title="2. SMTP协议"></a>2. SMTP协议</h3><ul>
<li>两个MTA之间用NVT ASCII进行通信。客户向服务器发出命令，服务器用数字应答码和可选的人可读字符串进行响应。这与上一章的FTP类似。</li>
<li>客户只能向服务器发送很少的命令：不到12个（相比较而言，FTP超过40个）。</li>
<li>电子邮件包括在两端（发送方和接收方）都有的一个用户代理以及两个或多个报文传送代理。</li>
<li>可以把一个邮件报文分成三个部分：信封、首部和正文。</li>
</ul>
<h1 id="二十九-网络文件系统"><a href="#二十九-网络文件系统" class="headerlink" title="二十九 网络文件系统"></a>二十九 网络文件系统</h1><h3 id="1-引言-26"><a href="#1-引言-26" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>NFS（网络文件系统），它为客户程序提供透明的文件访问。</li>
<li>NFS的基础是Sun RPC：远程过程调用。我们首先必须描述一下RPC。</li>
<li>客户程序使用NFS不需要做什么特别的工作，当NFS内核检测到被访问的文件位于一个NFS服务器时，就会自动产生一个访问该文件的RPC调用。</li>
<li>我们对NFS如何访问文件的细节并不感兴趣，只对它如何使用Internet的协议，尤其是UDP协议，感兴趣。</li>
</ul>
<h3 id="2-Sun远程过程调用"><a href="#2-Sun远程过程调用" class="headerlink" title="2. Sun远程过程调用"></a>2. Sun远程过程调用</h3><ul>
<li>般来说，客户发送命令给服务器，服务器向客户发送应答。目前为止，我们讨论过的所有应用程序—Ping，Traceroute，选路守护程序、以及DNS、TFTP、BOOTP、SNMP、Telnet、FTP和SMTP的客户和服务器—都是采用这种方式实现的。</li>
<li>远程过程调用RPC(Remote Procedure Call)是一种不同的网络程序设计方法。客户程序编写时只是调用了服务器程序提供的函数。这只是程序员所感觉到的，实际上发生了下面一些动作。<ol>
<li>当客户程序调用远程的过程时，它实际上只是调用了一个位于本机上的、由RPC程序包生成的函数。这个函数被称为客户残桩（stub）。客户残桩将过程的参数封装成一个网络报文，并且将这个报文发送给服务器程序。</li>
<li>服务器主机上的一个服务器残桩负责接收这个网络报文。它从网络报文中提取参数，然后调用应用程序员编写的服务器过程。</li>
<li>当服务器函数返回时，它返回到服务器残桩。服务器残桩提取返回值，把返回值封装成一个网络报文，然后将报文发送给客户残桩。</li>
<li>客户残桩从接收到的网络报文中取出返回值，将其返回给客户程序。</li>
</ol>
</li>
<li>网络程序设计是通过残桩和使用诸如插口或TLI的某个API的RPC库例程来实现的，但是用户程序—客户程序和被客户程序调用的服务器过程—不会和这个API打交道。客户应用程序只是调用服务器的过程，所有网络程序设计的细节都被RPC程序包、客户残桩和服务器残桩所隐藏。</li>
<li>一个RPC程序包提供了很多好处。<ol>
<li>程序设计更加容易，因为很少或几乎没有涉及网络编程。应用程序设计员只需要编写一个客户程序和客户程序调用的服务器过程。</li>
<li>如果使用了一个不可靠的协议，如UDP，像超时和重传等细节就由RPC程序包来处理。这就简化了用户应用程序。</li>
<li>RPC库为参数和返回值的传输提供任何需要的数据转换。例如，如果参数是由整数和浮点数组成的，RPC程序包处理整数和浮点数在客户机和服务器主机上存储的不同形式。这个功能简化了在异构环境中的客户和服务器的编码问题。</li>
</ol>
</li>
<li>下图显示的是使用UDP时，一个RPC过程调用报文的格式。  <!-- ![RPC过程调用报文](./img/RPC过程调用报文.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/RPC%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E6%8A%A5%E6%96%87.png" class="" title="RPC过程调用报文.png"></li>
<li>RPC应答报文的格式。当远程过程返回时，服务器残桩将这个报文发送给客户残桩。  <!-- ![RPC应答报文](./img/RPC应答报文.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/RPC%E5%BA%94%E7%AD%94%E6%8A%A5%E6%96%87.png" class="" title="RPC应答报文.png">

</li>
</ul>
<h3 id="3-XDR-外部数据表示"><a href="#3-XDR-外部数据表示" class="headerlink" title="3. XDR:外部数据表示"></a>3. XDR:外部数据表示</h3><ul>
<li>外部数据表示XDR(eXternal Data Representation)是一个标准，用来对RPC调用报文和应答报文中的值进行编码。这些值包括RPC首部字段（XID、程序号、接受状态等）、过程参数和过程结果。采用标准化的方法对这些值进行编码使得一个系统中的客户可以调用另一个不同架构的系统中的一个过程。</li>
<li>XDR定义了很多数据类型以及它们如何在一个RPC报文中传输的具体形式（如比特顺序，字节顺序等）。发送者必须采用XDR格式构造一个RPC报文，然后接收者将XDR格式的报文转换为本机的表示形式。</li>
</ul>
<h3 id="4-端口映射器"><a href="#4-端口映射器" class="headerlink" title="4. 端口映射器"></a>4. 端口映射器</h3><ul>
<li>包含远程过程的RPC服务器程序使用的是临时端口，而不是知名端口。这就需要某种形式的“注册”程序来跟踪哪一个RPC程序使用了哪一个临时端口。在Sun RPC中，这个注册程序被称为端口映射器(port mapper)。</li>
<li>很自然地，端口映射器本身必须有一个知名端口：UDP端口111和TCP端口111。端口映射器也就是一个RPC服务器程序。它有一个程序号（100000）、一个版本号（2）、一个TCP端口111和一个UDP端口111。服务器程序使用RPC调用向端口映射器注册自身，客户程序使用RPC调用向端口映射器查询。</li>
<li>端口映射器提供四个服务过程：<ol>
<li>PMAPPROC_SET。一个RPC服务器启动时调用这个过程，注册一个程序号、版本号和带有一个端口号的协议。</li>
<li>PMAPPROC_UNSET。RPC服务器调用此过程来删除一个已经注册的映射。</li>
<li>PMAPPROC_GETPORT。一个RPC客户启动时调用此过程。根据一个给定的程序号、版本号和协议来获得注册的端口号。</li>
<li>PMAPPROC_DUMP。返回端口映射器数据库中所有的记录（每个记录包括程序号、版本号、协议和端口号）。</li>
</ol>
</li>
</ul>
<h3 id="5-NFS协议"><a href="#5-NFS协议" class="headerlink" title="5. NFS协议"></a>5. NFS协议</h3><ul>
<li>使用NFS，客户可以透明地访问服务器上的文件和文件系统。这不同于提供文件传输的FTP</li>
<li>FTP会产生文件一个完整的副本。NFS只访问一个进程引用文件的那一部分，并且NFS的一个目的就是使得这种访问透明。这就意味着任何能够访问一个本地文件的客户程序不需要做任何修改，就应该能够访问一个NFS文件。</li>
<li>NFS是一个使用Sun RPC构造的客户服务器应用程序。NFS客户通过向一个NFS服务器发送RPC请求来访问其上的文件。</li>
<li>一个NFS客户和一个NFS服务器的典型配置  <!-- ![NFS客户服务器](./img/NFS客户服务器.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/NFS%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8.png" class="" title="NFS客户服务器.png"></li>
<li>大多数的Unix主机可以作为一个NFS客户，一个NFS服务器，或者两者都是。大多数PC机的实现（MS-DOS）只提供了NFS客户实现。大多数的IBM大型机只提供了NFS服务器功能。</li>
</ul>
<h5 id="文件句柄"><a href="#文件句柄" class="headerlink" title="文件句柄"></a>文件句柄</h5><ul>
<li>NFS中一个基本概念是文件句柄(file handle)。它是一个不透明(opaque)的对象，用来引用服务器上的一个文件或目录。</li>
<li>不透明指的是服务器创建文件句柄，把它传递给客户，然后客户访问文件时，使用对应的文件句柄。客户不会查看文件句柄的内容—它的内容只对服务器有意义。</li>
<li>每次一个客户进程打开一个实际上位于一个NFS服务器上的文件时，NFS客户就会从NFS服务器那里获得该文件的一个文件句柄。每次NFS客户为用户进程读或写文件时，文件句柄就会传给服务器以指定被访问的文件。</li>
<li>一般情况下，用户进程不会和文件句柄打交道—只有NFS客户和NFS服务器将文件句柄传来传去。</li>
</ul>
<h5 id="安装协议"><a href="#安装协议" class="headerlink" title="安装协议"></a>安装协议</h5><ul>
<li>一个NFS的安装过程。  <!-- ![NFS安装](./img/NFS安装.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/NFS%E5%AE%89%E8%A3%85.png" class="" title="NFS安装.png">

</li>
</ul>
<h5 id="UDP还是TCP"><a href="#UDP还是TCP" class="headerlink" title="UDP还是TCP"></a>UDP还是TCP</h5><ul>
<li>NFS最初是用UDP写的，所有的厂商都提供了这种实现。最新的一些实现也支持TCP。TCP支持主要用于广域网，它可以使文件操作更快。NFS已经不再局限于局域网的使用。</li>
<li>当从LAN转换到WAN时，网络的动态特征变化得非常大。往返时间（round-trip time）变动范围大，拥塞经常发生。WAN的这些特征使得我们考虑使用具有TCP属性的算法——慢启动，但是可以避免拥塞。既然UDP没有提供任何类似的东西，那么在NFS客户和服务器上加进同样的算法或者使用TCP。</li>
</ul>
<h1 id="三十-其他的TCP-IP应用程序"><a href="#三十-其他的TCP-IP应用程序" class="headerlink" title="三十 其他的TCP/IP应用程序"></a>三十 其他的TCP/IP应用程序</h1><h3 id="1-引言-27"><a href="#1-引言-27" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>本章中我们描述了另外一些很多实现都支持的TCP/IP应用程序。</li>
<li>简单的：Finger，Whois</li>
<li>复杂的：X窗口系统</li>
</ul>
<h3 id="2-Finger协议"><a href="#2-Finger协议" class="headerlink" title="2. Finger协议"></a>2. Finger协议</h3><ul>
<li>Finger协议返回一个指定主机上一个或多个用户的信息。它常被用来检查某个人是否登录了，或者搞清一个人的登录名以便给他发送邮件。</li>
<li>很多站点不支持一个Finger服务器。</li>
<li>从一个协议的角度来看，Finger服务器有一个知名的端口79。客户对这个端口做一个主动打开，然后发送一个在线的请求。服务器处理这个请求，把输出发送回去，然后关闭连接。查询和响应都是采用NVT ASCII，类似于我们在FTP和SMTP协议中所看到的。</li>
</ul>
<h3 id="3-Whois协议"><a href="#3-Whois协议" class="headerlink" title="3. Whois协议"></a>3. Whois协议</h3><ul>
<li>从协议的角度来看，Whois服务器有一个知名的TCP端口43。它接受客户的连接请求，客户向服务器发送一个在线的查询。服务器响应以任何可用的信息，然后关闭连接。请求和应答都以NVT ASCII来传输。除了请求和应答所包含的信息不一样，Whois服务器和Finger服务器几乎是一样的。</li>
<li>讲真的，本地的whois程序知道一些，不太明白这个协议是干嘛的</li>
</ul>
<h3 id="4-Archie、WAIS、Gopher、Veronica和WWW"><a href="#4-Archie、WAIS、Gopher、Veronica和WWW" class="headerlink" title="4. Archie、WAIS、Gopher、Veronica和WWW"></a>4. Archie、WAIS、Gopher、Veronica和WWW</h3><ul>
<li><p>前两节我们讨论的工具—Finger、Whois和一个白页服务—是用来查找人的信息的。还有一些工具是用来定位文件和文档的，本节中对这些工具给出了一个概述。</p>
</li>
<li><p>Archie提供了Internet上几千个FTP服务器的目录。我们可以通过登录进一个Archie服务器，搜索那些名字中包含了一个指定的常规表达式的文件。</p>
</li>
<li><p>其他。。。略，也不懂是干嘛的</p>
</li>
</ul>
<h3 id="5-X窗口系统"><a href="#5-X窗口系统" class="headerlink" title="5. X窗口系统"></a>5. X窗口系统</h3><ul>
<li><p>X窗口系统(XWindow System)，或简称为X，是一种客户-服务器应用程序。它可以使得多个客户（应用）使用由一个服务器管理的位映射显示器。</p>
</li>
<li><p>服务器是一个软件，用来管理显示器、键盘和鼠标。</p>
</li>
<li><p>客户是一个应用程序，它与服务器在同一台主机上或者在不同的主机上。在后一种情况下，客户与服务器之间通信的通用形式是TCP，尽管也可以使用诸如DECNET的其他协议。</p>
<ul>
<li>在有些场合，服务器是与其他主机上客户通信的一个专门的硬件（一个X终端）。</li>
<li>在另一种场合，一个独立的工作站，客户与服务器位于同一台主机，使用那台主机上的进程间通信机制进行通信，而根本不涉及任何网络操作。在这两种极端情况之间，是一台既支持同一台主机上的客户又支持不同主机上的客户的工作站。</li>
</ul>
</li>
<li><p>在一个Unix系统中，当X客户和X服务器在同一台主机上时，一般使用Unix系统的本地协议，而不使用TCP协议，因为这样比使用TCP的情况减少了协议处理时间。Unix系统的本地协议是同一台主机上的客户和服务器之间可以使用的一种进程间通信的形式。</p>
</li>
<li><p>下图显示了三个客户使用一个显示器的可能的脚本。一个客户与服务器在同一台主机上，使用Unix系统的本地协议。另外两个位于不同的主机上，使用TCP。</p>
</li>
<li><p>一般来说，其中一个客户是一个窗口管理程序(window manager)，它有权限管理显示器上窗口的布局。例如，窗口管理程序允许我们在屏幕上移动窗口，或者改变窗口的大小。</p>
  <!-- ![xwindow](./img/xwindow.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/xwindow.png" class="" title="xwindow.png">
</li>
<li><p>在这里客户和服务器这两个词猛一看含义相反了。对于Telnet和FTP的应用，我们把客户看作是在键盘和显示器上的交互式用户。但是对于X，键盘和显示器是属于服务器的。服务器被认为是提供服务的一方。X提供的服务是对窗口、键盘和鼠标的访问。对于Telnet，服务是登录远程的主机。对于FTP，服务是服务器上的文件系统。</p>
</li>
<li><p>当一个客户在另一台主机上启动时，它创建一个TCP端点，对服务器上的端口6000+n做一个主动打开。每个客户都得到了一个自己与服务器的连接。服务器负责对所有的客户请求进行复用。从这点开始，客户通过TCP连接向服务器发送请求（例如，创建一个窗口），服务器返回应答，服务器也发送事件给客户（鼠标按钮按下，键盘键按下，窗口暴露，窗口大小改变，等等）。</p>
  <!-- ![x服务器进程](./img/x服务器进程.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/x%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E7%A8%8B.png" class="" title="x服务器进程.png">
</li>
<li><p>Xscope程序</p>
<ul>
<li>Xscope是检查X客户与它的服务器之间交换的信息的一个方便的程序。</li>
<li>它处在客户与服务器之间，双向传输所有的数据，同时解析所有的客户请求和服务器应答。<!-- ![xscope](./img/xscope.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/xscope.png" class="" title="xscope.png"></li>
<li>首先，我们在服务器所在的主机上启动xscope进程，但是xscope不是在端口6000而是在端口6001上监听TCP的连接请求。然后我们在另一台主机上启动一个客户，指明显示器号为1，而不是0，使得客户与xscope相连，而不直接与服务器相连。当客户的连接请求到达时，xscope创建与端口6000上的真正的服务器的一个TCP连接，在客户与服务器之间复制所有的数据，同时生成请求与应答的一个可读的描述。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title>《操作系统精髓与设计原理》</title>
    <url>/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E3%80%8B/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ol>
<li>知识过于繁杂，挑重点简要记录</li>
<li>主要针对Linux操作系统，Windows和Android需要的时候再学</li>
<li>虽然书过了一遍，但深深的知道自己还有很多不动的地方，特别是多处理器那里，想起来刚学操作系统的时候，也是觉得没什么用，不知道在学什么，后来了解到Linux编程，再看操作系统真的有不少感悟，现在看多处理器那部分就是处于不知道干什么的状态，还是没有实践啊</li>
<li>看完后觉得我们大二的时候上操作系统课，为什么不用这本书，觉得这里面的课后习题什么的都挺好的，附录也很好，特别是OS/161，我之前为了做大作业也尝试看过《一个64为操作系统的实现》《30天自制一个操作系统》这种书，没想到这就有一个现成的，难受。<a id="more"></a>
<h1 id="第一章：计算机系统概述"><a href="#第一章：计算机系统概述" class="headerlink" title="第一章：计算机系统概述"></a>第一章：计算机系统概述</h1></li>
</ol>
<h3 id="1-基本构成"><a href="#1-基本构成" class="headerlink" title="1. 基本构成"></a>1. 基本构成</h3><ol>
<li>处理器</li>
<li>内存</li>
<li>IO模块</li>
<li>系统总线</li>
</ol>
<h3 id="2-指令分类"><a href="#2-指令分类" class="headerlink" title="2. 指令分类"></a>2. 指令分类</h3><ol>
<li>处理器&lt;–&gt;存储器</li>
<li>处理器&lt;–&gt;IO</li>
<li>数据处理</li>
<li>控制</li>
</ol>
<h3 id="3-中断"><a href="#3-中断" class="headerlink" title="3. 中断"></a>3. 中断</h3><h5 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h5><table>
<thead>
<tr>
<th>分类</th>
<th>表现</th>
</tr>
</thead>
<tbody><tr>
<td>程序中断</td>
<td>在某些条件下由指令的执行结果产生，如算术溢出，除数为0，试图执行一条非法机器指令，访问用户不允许的位置</td>
</tr>
<tr>
<td>时钟中断</td>
<td>处理器内部的计时器产生，允许操作系统周期性的执行函数</td>
</tr>
<tr>
<td>I/O中断</td>
<td>由IO控制器产生，用于发信号通知一个操作完成或各种错误条件</td>
</tr>
<tr>
<td>硬件失效中断</td>
<td>有掉电，奇偶校验错之类的故障产生</td>
</tr>
</tbody></table>
<h5 id="多个中断"><a href="#多个中断" class="headerlink" title="多个中断"></a>多个中断</h5><ul>
<li>禁止再中断</li>
<li>优先级</li>
</ul>
<h3 id="4-内存层次"><a href="#4-内存层次" class="headerlink" title="4. 内存层次"></a>4. 内存层次</h3><h5 id="板上存储器"><a href="#板上存储器" class="headerlink" title="板上存储器"></a>板上存储器</h5><ol>
<li>寄存器</li>
<li>高速缓存</li>
<li>内存</li>
</ol>
<h5 id="板外存储器"><a href="#板外存储器" class="headerlink" title="板外存储器"></a>板外存储器</h5><ol start="4">
<li>磁盘，CD</li>
</ol>
<h5 id="离线存储器"><a href="#离线存储器" class="headerlink" title="离线存储器"></a>离线存储器</h5><ol start="5">
<li>磁带</li>
</ol>
<h3 id="5-高速缓存"><a href="#5-高速缓存" class="headerlink" title="5. 高速缓存"></a>5. 高速缓存</h3><ol>
<li>CPU&lt;—-字传送(快)—&gt;高速缓存(L1,L2,L3)&lt;—块传送(慢)—-内存</li>
</ol>
<h3 id="6-多处理器和多核"><a href="#6-多处理器和多核" class="headerlink" title="6. 多处理器和多核"></a>6. 多处理器和多核</h3><h5 id="多处理器"><a href="#多处理器" class="headerlink" title="多处理器"></a>多处理器</h5><ul>
<li>是有多个独立的CPU,每个CPU能执行相同的功能，也叫对称处理器</li>
</ul>
<h5 id="多核"><a href="#多核" class="headerlink" title="多核"></a>多核</h5><ul>
<li>是多个处理器组装在同一个硅片上，又名芯片多处理器</li>
</ul>
<h5 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h5><ul>
<li>对于多个处理器而言，它们在执行命令的时候多个处理器之间的通信手段是电脑主板上的总线；而对于多核处理器而言，多个核心处理器之间通信时通过CPU内部总线进行信息的交互的。对于执行效率而言，多核处理器要优于多个处理器</li>
<li>若跑小程序，选多核<br>  对于多处理器：如果跑一个多线程的程序（常见典型情况），不考虑超线程，那么每一个线程就要跑在一个独立的CPU上，线程间的所有协作都要走总线，而共享的数据更是有可能要在好几个Cache里同时存在。这样的话，总线开销相比较而言是很大的，怎么办？那么多Cache，即使我们不心疼存储能力的浪费，一致性怎么保证？如果真正做出来，还要在主板上占多块地盘，给布局布线带来更大的挑战？所以对于个人计算机来说，都采用单处理器多核。只需要一套芯片组，一套存储，多核之间通过芯片内部总线进行通信，共享使用内存。在这样的架构上，如果我们跑一个多线程的程序，那么线程间通信将比上一种情形更快。如果最终实现出来，对板上空间的占用较小，布局布线的压力也较小。</li>
<li>若跑大程序，选多CPU多核<br>  假设俩大程序，每一个程序都好多线程还几乎用满cache，它们分时使用CPU，那在程序间切换的时候，光指令和数据的替换就很费事。所以，需要更强的多任务并发能力，就用多颗多核CPU的机子。</li>
</ul>
<h1 id="第二章：操作系统概述"><a href="#第二章：操作系统概述" class="headerlink" title="第二章：操作系统概述"></a>第二章：操作系统概述</h1><h3 id="1-Linux主要内核组件"><a href="#1-Linux主要内核组件" class="headerlink" title="1. Linux主要内核组件"></a>1. Linux主要内核组件</h3><ol>
<li>信号(Signals)<ul>
<li>内核使用信号向进程提供信息</li>
</ul>
</li>
<li>系统调用(System calls)<ul>
<li>为进程提供系统服务，大致分为6类：文件系统，进程，调度，进程间通信，套接字，其他</li>
</ul>
</li>
<li>进程和调度器(Processes and Scheduler)<ul>
<li>创建，管理，调度进程</li>
</ul>
</li>
<li>虚存(Virtual memory)<ul>
<li>为进程分配和管理虚存</li>
</ul>
</li>
<li>文件系统(File System)<ul>
<li>为文件，目录和其他文件对象提供一个全局的分层命名空间，并提供文件系统函数</li>
</ul>
</li>
<li>网络协议(Network protocols)<ul>
<li>  为用户的TCP/IP协议套件提供套接字接口</li>
</ul>
</li>
<li>字符设备驱动(Character device drivers)<ul>
<li>如打印机，调制解调器，终端</li>
</ul>
</li>
<li>块设备驱动(Block device drivers)<ul>
<li>如各种外存</li>
</ul>
</li>
<li>网络设备驱动(Network device drivers)<ul>
<li>管理网卡和通信端口，即管理连接到网桥或路由的网络设备</li>
</ul>
</li>
<li>陷阱与错误(Traps and faults)<ul>
<li>处理CPU产生的陷阱和错误，如内存错误</li>
</ul>
</li>
<li>物理内存(Physical memory)<ul>
<li>管理实际内存中的内存页池，并为虚存分配内存页</li>
</ul>
</li>
<li>中断(Interrupts)<ul>
<li>处理来自外设的中断</li>
</ul>
</li>
</ol>
<h3 id="2-Windows和Android先不整理，以后需要再学"><a href="#2-Windows和Android先不整理，以后需要再学" class="headerlink" title="2. Windows和Android先不整理，以后需要再学"></a>2. Windows和Android先不整理，以后需要再学</h3><h1 id="第三章：进程"><a href="#第三章：进程" class="headerlink" title="第三章：进程"></a>第三章：进程</h1><h3 id="1-进程介绍"><a href="#1-进程介绍" class="headerlink" title="1. 进程介绍"></a>1. 进程介绍</h3><h5 id="进程的两个基本元素"><a href="#进程的两个基本元素" class="headerlink" title="进程的两个基本元素"></a>进程的两个基本元素</h5><ul>
<li>程序代码</li>
<li>数据集</li>
</ul>
<h5 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块(PCB)"></a>进程控制块(PCB)</h5><ul>
<li>标识符</li>
<li>状态</li>
<li>优先级</li>
<li>程序计数器</li>
<li>内存指针</li>
<li>上下文数据</li>
<li>I/O 状态信息</li>
<li>记账信息</li>
</ul>
<h3 id="2-进程状态"><a href="#2-进程状态" class="headerlink" title="2. 进程状态"></a>2. 进程状态</h3><h5 id="经典5状态"><a href="#经典5状态" class="headerlink" title="经典5状态"></a>经典5状态</h5><ul>
<li>新建态<ul>
<li>空–&gt;新建</li>
</ul>
</li>
<li>就绪<ul>
<li>新建–&gt;就绪</li>
<li>运行–&gt;就绪</li>
<li>阻塞–&gt;就绪</li>
</ul>
</li>
<li>运行<ul>
<li>就绪–&gt;运行</li>
</ul>
</li>
<li>阻塞<ul>
<li>运行–&gt;阻塞</li>
</ul>
</li>
<li>退出态<ul>
<li>运行–&gt;退出</li>
<li>阻塞–&gt;退出</li>
<li>就绪–&gt;退出</li>
</ul>
</li>
</ul>
<h5 id="挂起态"><a href="#挂起态" class="headerlink" title="挂起态"></a>挂起态</h5><ul>
<li>这个主要是内存不足，就把进程先换到外存</li>
</ul>
<h3 id="3-操作系统的控制结构"><a href="#3-操作系统的控制结构" class="headerlink" title="3. 操作系统的控制结构"></a>3. 操作系统的控制结构</h3><ul>
<li>内存–&gt;内存表</li>
<li>设备–&gt;设备表</li>
<li>文件–&gt;文件表</li>
<li>进程–&gt;主进程表–&gt;进程映像</li>
</ul>
<h3 id="4-进程映像"><a href="#4-进程映像" class="headerlink" title="4. 进程映像"></a>4. 进程映像</h3><ul>
<li>进程控制块<ul>
<li>进程id</li>
<li>处理器状态信息</li>
<li>进程控制信息</li>
</ul>
</li>
<li>用户栈</li>
<li>私有用户地址空间(程序，数据)<ul>
<li>堆</li>
<li>静态数据区</li>
<li>代码段</li>
</ul>
</li>
<li>共享地址空间</li>
</ul>
<h1 id="第四章：线程"><a href="#第四章：线程" class="headerlink" title="第四章：线程"></a>第四章：线程</h1><h3 id="1-线程介绍"><a href="#1-线程介绍" class="headerlink" title="1. 线程介绍"></a>1. 线程介绍</h3><ul>
<li>一个进程可以有多个线程</li>
<li>每个线程有自己的线程控制块，用户栈，内核栈</li>
<li>所有线程共享用户地址空间</li>
</ul>
<h3 id="2-线程状态"><a href="#2-线程状态" class="headerlink" title="2. 线程状态"></a>2. 线程状态</h3><ul>
<li>就绪，运行，阻塞</li>
<li>没有挂起</li>
</ul>
<h3 id="3-Linux中的线程"><a href="#3-Linux中的线程" class="headerlink" title="3. Linux中的线程"></a>3. Linux中的线程</h3><ul>
<li>Linux中没有给线程单独定义数据结构，所以Linux中的线程和进程没有区别</li>
<li>Linux提供一种不区分进程和线程的解决方案<ul>
<li>将用户级线程映射到内核级进程上。</li>
<li>组成一个用户级进程的多个用户级线程则映射到共享同一个组ID的多个Linux内核级进程上。</li>
<li>因此，这些进程可以共享文件和内存等资源，使得同一个组中的进程调度切换时不需要切换上下文</li>
</ul>
</li>
<li>当Linux内核执行从一个进程到另一个进程的切换时，会检查当前进程的页目录地址是否与将被调度的进程的相同。<ul>
<li>若相同，则它们共享同一个地址空间，所以此时的上下午切换仅是从代码的一处跳转到另一处</li>
<li>可以共享同一内存空间，但不能共享同一个用户栈。所以每个线程有自己单独的栈空间</li>
</ul>
</li>
</ul>
<h3 id="4-Linux的命名空间"><a href="#4-Linux的命名空间" class="headerlink" title="4. Linux的命名空间"></a>4. Linux的命名空间</h3><ul>
<li>命名空间可以使一个进程(或共享同一命名空间下的多个进程)拥有与其他相关命名空间下的其他进程不同的系统视图。</li>
<li>当前Linux有6种命名空间：mnt,pid,net,ipc,uts,user<ul>
<li>Mount命名空间<br>  为进程提供文件系统层级结构的特定视图，因次两个不同mount命名空间的进程会看到不同的文件系统层次结构</li>
<li>UTS命名空间<br>  UNIX timesharing UNIX 分时，通过UTS命名空间，初始化和配置参数能够根据同一系统上的不同进程而变化</li>
<li>IPC命名空间<br>  隔离某些进程间通信资源，如信号量</li>
<li>PID命名空间<br>  隔离进程ID空间</li>
<li>网络命名空间<br>  隔离与网络相关的系统资源</li>
<li>用户命名空间<br>  为自身的UID集建立一个容器</li>
</ul>
</li>
</ul>
<h1 id="第五章：并发性：互斥和同步"><a href="#第五章：并发性：互斥和同步" class="headerlink" title="第五章：并发性：互斥和同步"></a>第五章：并发性：互斥和同步</h1><h3 id="1-常用的并发机制"><a href="#1-常用的并发机制" class="headerlink" title="-1. 常用的并发机制"></a>-1. 常用的并发机制</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>信号量</td>
<td>用于进程间传递信号的整数值，只有三个原子操作：初始化，递增，递减</td>
</tr>
<tr>
<td>二元信号量</td>
<td>只有0和1的信号量</td>
</tr>
<tr>
<td>互斥量/互斥锁</td>
<td>类似于二元信号量，关键区别在于为其加锁(设定值为0)的进程和解锁(设定值为0)的进程必须为同一个进程</td>
</tr>
<tr>
<td>条件变量</td>
<td>一种数据类型，用于阻塞进程或线程，直到特定的条件为真</td>
</tr>
<tr>
<td>管程</td>
<td>一种编程语言结构</td>
</tr>
<tr>
<td>自旋锁</td>
<td>一种互斥机制，进程在一个无条件循环中执行，等待锁变量的值可用</td>
</tr>
</tbody></table>
<h3 id="0-进程和线程的管理"><a href="#0-进程和线程的管理" class="headerlink" title="0. 进程和线程的管理"></a>0. 进程和线程的管理</h3><ul>
<li>多道程序设计技术<br>  管理单处理器的多个进程</li>
<li>多处理器技术<br>  管理多处理器的多个进程</li>
<li>分布式处理器技术<br>  管理多态分布式计算机系统中多个进程的执行。集群就是这个的典型例子</li>
</ul>
<h5 id="互斥的要求"><a href="#互斥的要求" class="headerlink" title="互斥的要求"></a>互斥的要求</h5><ol>
<li>一次只允许一个进程进入临界区</li>
<li>一个在非临界区停止的进程不能干涉其他进程</li>
<li>不允许出现需要访问临界区的进程被无限延迟的情况，即不会死锁和饥饿</li>
<li>没有进程在临界区时，需要进入的进程要能立刻进入</li>
<li>对相关进程的执行速度和处理器的数量没有任何要求</li>
<li>一个进程驻留在临界区的时间必须是有限的</li>
</ol>
<h3 id="1-互斥：硬件的支持"><a href="#1-互斥：硬件的支持" class="headerlink" title="1. 互斥：硬件的支持"></a>1. 互斥：硬件的支持</h3><h5 id="1-中断禁用"><a href="#1-中断禁用" class="headerlink" title="1. 中断禁用"></a>1. 中断禁用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    &#x2F;&#x2F;禁用中断</span><br><span class="line">    &#x2F;&#x2F;临界区</span><br><span class="line">    &#x2F;&#x2F;启用中断</span><br><span class="line">    &#x2F;&#x2F;其余非临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这种办法执行效率低</li>
<li>不能用于多处理器体系结构中，当有多个处理器，就可能有多个进程同时执行，在这种情况下，禁用中断并不能保证互斥</li>
</ul>
<h5 id="2-专用机器指令"><a href="#2-专用机器指令" class="headerlink" title="2. 专用机器指令"></a>2. 专用机器指令</h5><ul>
<li>保证某些机器指令的原子性</li>
</ul>
<h3 id="2-信号量"><a href="#2-信号量" class="headerlink" title="2. 信号量"></a>2. 信号量</h3><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者/消费者问题"></a>生产者/消费者问题</h5><ul>
<li>有一个缓冲区，生产者往里面放东西(字节或记录)，消费者取东西，一次只能有一个进行操作</li>
</ul>
<h3 id="3-管程"><a href="#3-管程" class="headerlink" title="3. 管程"></a>3. 管程</h3><ul>
<li>为什么感觉第一次听这个概念。。。先跳过</li>
</ul>
<h3 id="4-消息传递"><a href="#4-消息传递" class="headerlink" title="4. 消息传递"></a>4. 消息传递</h3><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><ul>
<li>发送者和接收者都可阻塞或不阻塞。通常有三种组合，但任一特定操作系统通常只实现一种或两种<ul>
<li>阻塞send，阻塞receive<br>  发送者和接收者都阻塞，直到完成消息传递。进程间紧密同步</li>
<li>无阻塞send,阻塞receive<br>  发送者可以继续执行，接收阻塞，这可能是最有用的一种组合</li>
<li>无阻塞send,无阻塞receive<br>  双方都不等待</li>
</ul>
</li>
</ul>
<h5 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h5><ul>
<li>直接寻址<ul>
<li>进程对进程直接发送消息</li>
</ul>
</li>
<li>间接寻址<ul>
<li>消息发送到一个共享的数据结构，如管道</li>
</ul>
</li>
</ul>
<h5 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h5><ul>
<li>直白的说就是：具体情况具体分析</li>
</ul>
<h3 id="5-读者-写者问题"><a href="#5-读者-写者问题" class="headerlink" title="5. 读者/写者问题"></a>5. 读者/写者问题</h3><h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><ol>
<li>任意数量的读进程可以读这个文件</li>
<li>一次只有一个写进程能写这个文件</li>
<li>若一个写进程正在写文件，则禁止任何读进程读文件</li>
</ol>
<h5 id="读者优先"><a href="#读者优先" class="headerlink" title="读者优先"></a>读者优先</h5><h5 id="写者优先"><a href="#写者优先" class="headerlink" title="写者优先"></a>写者优先</h5><h1 id="第六章：并发：死锁和饥饿"><a href="#第六章：并发：死锁和饥饿" class="headerlink" title="第六章：并发：死锁和饥饿"></a>第六章：并发：死锁和饥饿</h1><h3 id="6-1-死锁原理"><a href="#6-1-死锁原理" class="headerlink" title="6.1 死锁原理"></a>6.1 死锁原理</h3><h5 id="6-1-1-可重用资源死锁"><a href="#6-1-1-可重用资源死锁" class="headerlink" title="6.1.1 可重用资源死锁"></a>6.1.1 可重用资源死锁</h5><ul>
<li>资源可重用，如设备</li>
<li>两个进程各自占用一个设备，都需要另一个设备时死锁</li>
</ul>
<h5 id="6-1-2-可消耗资源死锁"><a href="#6-1-2-可消耗资源死锁" class="headerlink" title="6.1.2 可消耗资源死锁"></a>6.1.2 可消耗资源死锁</h5><ul>
<li>资源只能使用一次，消耗性的，如缓冲区中的数据</li>
<li>两个进程都想从缓冲区读数据，没进程写，都处于阻塞等待状态，死锁</li>
</ul>
<h5 id="6-1-3-资源分配图"><a href="#6-1-3-资源分配图" class="headerlink" title="6.1.3 资源分配图"></a>6.1.3 资源分配图</h5><ul>
<li>系统资源和进程的有向状态图</li>
</ul>
<h5 id="6-1-4-死锁条件"><a href="#6-1-4-死锁条件" class="headerlink" title="6.1.4 死锁条件"></a>6.1.4 死锁条件</h5><ul>
<li>互斥<ul>
<li>一次只有一个进程可以使用某个资源</li>
</ul>
</li>
<li>占有且等待<ul>
<li>当一个进程等待其他进程时，继续占有已经占有的资源</li>
<li>解决办法：一次性占有所有资源</li>
</ul>
</li>
<li>不可抢占<ul>
<li>不能强行抢占其他进程已经占有的资源</li>
<li>解决办法：若申请其他资源不成功，则释放已占有的资源</li>
</ul>
</li>
<li>循环等待<ul>
<li>存在一个闭合的进程链，每个进程至少占有此链下一个进程所需的一个资源</li>
<li>这一条实际上是前三条的潜在结果</li>
<li>解决办法：定义资源的线性顺序，若一个进程已经占用了R资源，接下来只能占有R之后的资源</li>
</ul>
</li>
</ul>
<h5 id="6-1-5-处理死锁的办法"><a href="#6-1-5-处理死锁的办法" class="headerlink" title="6.1.5 处理死锁的办法"></a>6.1.5 处理死锁的办法</h5><ul>
<li>预防<ul>
<li>消除某一个死锁条件</li>
</ul>
</li>
<li>避免<ul>
<li>基于资源分配的当前状态做动态选择</li>
</ul>
</li>
<li>检测<ul>
<li>检测死锁的存在并从死锁中恢复</li>
</ul>
</li>
</ul>
<h3 id="6-2-小结"><a href="#6-2-小结" class="headerlink" title="6.2 小结"></a>6.2 小结</h3><table>
<thead>
<tr>
<th>原则</th>
<th>资源分配策略</th>
<th>不同的方案</th>
</tr>
</thead>
<tbody><tr>
<td>预防</td>
<td>保守:预提交资源</td>
<td>一次性请求所有方案</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
<td>抢占</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
<td>资源排序</td>
</tr>
<tr>
<td>避免</td>
<td>介于检测和预防之间</td>
<td>操作以便发现至少一条安全路径</td>
</tr>
<tr>
<td>检测</td>
<td>非常自由：只要有可能，请求的资源都被允许</td>
<td>周期性的调用以便检测死锁</td>
</tr>
</tbody></table>
<h3 id="6-3-哲学家就餐问题"><a href="#6-3-哲学家就餐问题" class="headerlink" title="6.3 哲学家就餐问题"></a>6.3 哲学家就餐问题</h3><p>假设有5跟筷子，5个座位</p>
<h5 id="6-3-1-基于信号量的解决方案"><a href="#6-3-1-基于信号量的解决方案" class="headerlink" title="6.3.1 基于信号量的解决方案"></a>6.3.1 基于信号量的解决方案</h5><ul>
<li>只能允许4个人同时吃</li>
</ul>
<h5 id="6-3-2-基于管程的解决方案"><a href="#6-3-2-基于管程的解决方案" class="headerlink" title="6.3.2 基于管程的解决方案"></a>6.3.2 基于管程的解决方案</h5><ul>
<li>实际上就是左右同时拿，只有左右同时可用才拿，只要有一个不可用，就都不拿</li>
</ul>
<h3 id="6-4-UNIX并发机制"><a href="#6-4-UNIX并发机制" class="headerlink" title="6.4 UNIX并发机制"></a>6.4 UNIX并发机制</h3><ul>
<li>管道<ul>
<li>pipe</li>
<li>mkfifo</li>
</ul>
</li>
<li>消息<ul>
<li>有msgsnd和msgrcv系统调用</li>
</ul>
</li>
<li>共享内存</li>
<li>信号量<ul>
<li>semctl</li>
<li>sem_op</li>
</ul>
</li>
<li>信号</li>
</ul>
<h3 id="6-5-Linux内核并发机制"><a href="#6-5-Linux内核并发机制" class="headerlink" title="6.5 Linux内核并发机制"></a>6.5 Linux内核并发机制</h3><ul>
<li>包含UNIX的所有</li>
<li>原子操作<ul>
<li>atomic_xxx()</li>
</ul>
</li>
<li>自旋锁<ul>
<li>一次只有一个进程能进入临界区</li>
<li>其它试图获得自旋锁的进程将一直进行尝试（即自旋），直到获得该锁</li>
<li>spin_lock系列调用</li>
</ul>
</li>
</ul>
<h1 id="第七章：内存管理"><a href="#第七章：内存管理" class="headerlink" title="第七章：内存管理"></a>第七章：内存管理</h1><h3 id="0-内存管理术语"><a href="#0-内存管理术语" class="headerlink" title="0. 内存管理术语"></a>0. 内存管理术语</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>页框</td>
<td>内存中固定长度的块</td>
</tr>
<tr>
<td>页</td>
<td>固定长度的数据块，存储在二级存储器中(如磁盘)。数据页可以临时复制到内存的页框中</td>
</tr>
<tr>
<td>段</td>
<td>变长数据块，存储在二级存储器中。整个段可以临时复制到内存中的一个可用区域(分段)，或可以将一个段分为许多页，然后将每页单独复制到内存中(分段和分页相结合)</td>
</tr>
</tbody></table>
<h3 id="1-内存管理的需求"><a href="#1-内存管理的需求" class="headerlink" title="1. 内存管理的需求"></a>1. 内存管理的需求</h3><ul>
<li>重定位</li>
<li>保护</li>
<li>共享</li>
<li>逻辑组织</li>
<li>物理组织</li>
</ul>
<h3 id="2-分页和分段"><a href="#2-分页和分段" class="headerlink" title="2. 分页和分段"></a>2. 分页和分段</h3><ul>
<li>分页是对分区的改进，减少了内存碎片</li>
<li>每个进程维护一个页表</li>
<li>使用分段技术，可以把程序和与其相关的数据划分到几个段中</li>
<li>分页对程序员透明，分段通常是可见的</li>
</ul>
<h1 id="第八章：虚拟内存"><a href="#第八章：虚拟内存" class="headerlink" title="第八章：虚拟内存"></a>第八章：虚拟内存</h1><h3 id="0-虚拟内存术语"><a href="#0-虚拟内存术语" class="headerlink" title="0. 虚拟内存术语"></a>0. 虚拟内存术语</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>虚拟内存</td>
<td>程序引用内存使用的地址与内存系统用于识别物理存储站点的地址是不同的，程序生成的地址会自动转换为机器地址。虚拟存储的大小受系统寻址机制和可用的备用内存量的限制，而不受主存储位置实际数量的限制</td>
</tr>
<tr>
<td>虚拟地址</td>
<td>在虚拟内存中分配给某一位置的地址，它使得该位置可被访问，就好像是主存内的一部分那样</td>
</tr>
<tr>
<td>虚拟地址空间</td>
<td>分配给进程的虚拟存储</td>
</tr>
<tr>
<td>地址空间</td>
<td>用于某进程的内存地址范围</td>
</tr>
<tr>
<td>实地址</td>
<td>内存中存储位置的地址</td>
</tr>
</tbody></table>
<h3 id="1-关键概念"><a href="#1-关键概念" class="headerlink" title="1. 关键概念"></a>1. 关键概念</h3><ul>
<li>内存碎片<ul>
<li>内部碎片<br>  已经使用的内存，不能用到的地方</li>
<li>外部碎片<br>  没有使用的内存，但是太小了不能再用的内存</li>
</ul>
</li>
<li>抖动<ul>
<li>频繁中断进行内存页的换进换出，常见于先进先出算法</li>
</ul>
</li>
<li>置换页的基本算法<ul>
<li>最佳<ul>
<li>置换下次访问距当前时间最长的页，需要预测</li>
<li>不可能实现，仅作为衡量其他算法性能的一种标准</li>
</ul>
</li>
<li>最近最少使用<ul>
<li>时钟策略的变体</li>
</ul>
</li>
<li>先进先出<ul>
<li>实现简单，性能较差</li>
</ul>
</li>
<li>时钟<ul>
<li>有一个只能为1或0的使用位，初始为1，若要置换，找下一个，下一个若为0，就换出，若为1就变为0，继续找下一个，就是多给了一次机会，所有的页组成一个环</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第九章：单处理器调度"><a href="#第九章：单处理器调度" class="headerlink" title="第九章：单处理器调度"></a>第九章：单处理器调度</h1><h3 id="1-处理器调度的类型"><a href="#1-处理器调度的类型" class="headerlink" title="1. 处理器调度的类型"></a>1. 处理器调度的类型</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>长程调度</td>
<td>决定加入待执行进程池</td>
</tr>
<tr>
<td>中程调度</td>
<td>决定加入部分或全部位于内存中的进程集合</td>
</tr>
<tr>
<td>短程调度</td>
<td>决定处理器执行哪个可运行进程</td>
</tr>
<tr>
<td>I/O调度</td>
<td>决定可用IO设备处理哪个进程挂起的IO请求</td>
</tr>
</tbody></table>
<ul>
<li><p>长程调度和中程调度主要由与系统并发度相关的性能驱动，如第7,8章的页面置换等。本章主要讲短程调度。</p>
</li>
<li><p>导致当前进程阻塞或抢占当前运行进程的事件发生时，调用短程调度程序。这类事件包括：</p>
<ul>
<li>时钟中断</li>
<li>IO中断</li>
<li>操作系统调用</li>
<li>信号（如信号量）</li>
</ul>
</li>
</ul>
<h3 id="2-调度算法"><a href="#2-调度算法" class="headerlink" title="2. 调度算法"></a>2. 调度算法</h3><h5 id="调度规则"><a href="#调度规则" class="headerlink" title="调度规则"></a>调度规则</h5><h5 id="优先级的使用"><a href="#优先级的使用" class="headerlink" title="优先级的使用"></a>优先级的使用</h5><h5 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h5><ul>
<li>先来先服务</li>
<li>时间片轮转</li>
<li>最短进程优先</li>
<li>最短剩余时间</li>
<li>最短相应比优先</li>
<li>反馈<br>  建立一组调度队列，基于每个进程的执行历史和其他一些规则，把它们分配到各个队列中</li>
<li>调度算法的选择取决于预期的性能和实现的复杂度</li>
</ul>
<h1 id="第十章：多处理器和实时调度"><a href="#第十章：多处理器和实时调度" class="headerlink" title="第十章：多处理器和实时调度"></a>第十章：多处理器和实时调度</h1><h3 id="1-多处理器调度"><a href="#1-多处理器调度" class="headerlink" title="1. 多处理器调度"></a>1. 多处理器调度</h3><h5 id="多处理器系统分类"><a href="#多处理器系统分类" class="headerlink" title="多处理器系统分类"></a>多处理器系统分类</h5><ul>
<li>松耦合、分布式多处理器、集群<ul>
<li>由一系列相对自治的系统组成，每个处理器都有自身的内存和IO通道</li>
</ul>
</li>
<li>专用处理器<ul>
<li>IO处理器是一个典型的例子。此时，有一个通用的主处理器，专用处理器由主处理器控制，并为主处理器提供服务。</li>
</ul>
</li>
<li>紧耦合多处理器<ul>
<li>由一系列共享同一内存并受操作系统完全控制的处理器组成</li>
</ul>
</li>
</ul>
<h5 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h5><table>
<thead>
<tr>
<th>粒度大小</th>
<th>说明</th>
<th>同步间隔(指令)</th>
</tr>
</thead>
<tbody><tr>
<td>细</td>
<td>单指令流中固有的并行</td>
<td>&lt;20</td>
</tr>
<tr>
<td>中等</td>
<td>一个单独应用中的并行处理或多任务处理</td>
<td>20~200</td>
</tr>
<tr>
<td>粗</td>
<td>多道程序环境中并发进程的多处理</td>
<td>200~2000</td>
</tr>
<tr>
<td>极粗</td>
<td>在网络节点上进行分布式处理，形成一个计算环境</td>
<td>2000~1M</td>
</tr>
<tr>
<td>无约束</td>
<td>多个无关进程</td>
<td>不适用</td>
</tr>
</tbody></table>
<ul>
<li>无约束并行性<ul>
<li>进程间没有显式的同步，每个进程都代表独立的应用或作业。这类并行性的一个典型应用是分时系统。每个yoghurt执行一个特定的应用，如字处理。</li>
</ul>
</li>
<li>粗粒度和极粗粒度并行性<ul>
<li>进程间存在同步，但这种同步的级别极粗。</li>
</ul>
</li>
</ul>
<h5 id="设计问题"><a href="#设计问题" class="headerlink" title="设计问题"></a>设计问题</h5><p>多处理器中的调度涉及三个相互关联的问题</p>
<ul>
<li>把进程分配到处理器<ul>
<li>分配到那个处理器</li>
</ul>
</li>
<li>在单处理器上使用多道程序设计</li>
<li>一个进程的实际分派<ul>
<li>选择哪个进程运行</li>
</ul>
</li>
</ul>
<h3 id="2-实时调度"><a href="#2-实时调度" class="headerlink" title="2. 实时调度"></a>2. 实时调度</h3><ul>
<li>负责Linux调度的三个类<ul>
<li>SCHED_FIFO:先进先出实时线程</li>
<li>SCHED_RR:轮转实时线程</li>
<li>SCHED_OTHER:其他非实时线程</li>
</ul>
</li>
<li>这个还有好多没记，主要是不理解什么意思，不知道哪些是重点，以后能有实践机会了深入了解了再学。</li>
</ul>
<h1 id="第十一章：IO管理和磁盘调度"><a href="#第十一章：IO管理和磁盘调度" class="headerlink" title="第十一章：IO管理和磁盘调度"></a>第十一章：IO管理和磁盘调度</h1><h3 id="1-IO设备"><a href="#1-IO设备" class="headerlink" title="1. IO设备"></a>1. IO设备</h3><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul>
<li>人可读<ul>
<li>打印机</li>
<li>终端</li>
<li>鼠标等</li>
</ul>
</li>
<li>机器可读<ul>
<li>USB秘钥</li>
<li>传感器等</li>
</ul>
</li>
<li>通信<ul>
<li>调制解调器</li>
</ul>
</li>
</ul>
<h5 id="各设备主要差异"><a href="#各设备主要差异" class="headerlink" title="各设备主要差异"></a>各设备主要差异</h5><ul>
<li>数据传输速率</li>
<li>应用</li>
<li>控制的复杂度</li>
<li>传送单位</li>
<li>数据表示</li>
<li>错误条件</li>
</ul>
<h3 id="2-IO功能的组织"><a href="#2-IO功能的组织" class="headerlink" title="2. IO功能的组织"></a>2. IO功能的组织</h3><h5 id="三种执行IO的技术"><a href="#三种执行IO的技术" class="headerlink" title="三种执行IO的技术"></a>三种执行IO的技术</h5><ul>
<li>程序控制IO</li>
<li>中断驱动IO</li>
<li>直接存储器访问(DMA)</li>
</ul>
<h3 id="3-IO缓冲"><a href="#3-IO缓冲" class="headerlink" title="3. IO缓冲"></a>3. IO缓冲</h3><h5 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h5><ul>
<li>有一个缓冲区</li>
</ul>
<h5 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h5><ul>
<li>两个系统缓冲区，在一个进程向一个缓冲区中传送数据的同时，操作系统正在清空(或填充)另一个缓冲区，这叫双缓冲或缓冲交换</li>
</ul>
<h5 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h5><ul>
<li>多于两个缓冲区</li>
</ul>
<h5 id="缓冲作用"><a href="#缓冲作用" class="headerlink" title="缓冲作用"></a>缓冲作用</h5><ul>
<li>平滑IO需求的峰值</li>
</ul>
<h3 id="4-磁盘调度"><a href="#4-磁盘调度" class="headerlink" title="4. 磁盘调度"></a>4. 磁盘调度</h3><h5 id="磁盘性能参数"><a href="#磁盘性能参数" class="headerlink" title="磁盘性能参数"></a>磁盘性能参数</h5><ul>
<li>寻道时间</li>
<li>旋转延迟</li>
<li>传输时间</li>
<li>时序比较</li>
</ul>
<h5 id="调度策略-1"><a href="#调度策略-1" class="headerlink" title="调度策略"></a>调度策略</h5><ul>
<li>先进先出</li>
<li>优先级</li>
<li>后进先出</li>
<li>最短服务时间优先</li>
<li>SCAN(电梯算法)</li>
<li>C-SCAN，只向一个方向移动</li>
</ul>
<h5 id="RDIA"><a href="#RDIA" class="headerlink" title="RDIA"></a>RDIA</h5><ul>
<li>这个需要的时候再了解吧，有点抽象，不知道是干嘛的</li>
</ul>
<h1 id="第十二章：文件管理"><a href="#第十二章：文件管理" class="headerlink" title="第十二章：文件管理"></a>第十二章：文件管理</h1><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h5 id="文件和文件系统"><a href="#文件和文件系统" class="headerlink" title="文件和文件系统"></a>文件和文件系统</h5><ul>
<li>一些理想的属性<ul>
<li>长期存在</li>
<li>可在进程间共享</li>
<li>结构</li>
</ul>
</li>
<li>典型的操作<ul>
<li>创建</li>
<li>删除</li>
<li>打开</li>
<li>关闭</li>
<li>读</li>
<li>写</li>
</ul>
</li>
<li>文件系统通常为文件维护一组属性，包括所有者、创建时间、最后修改时间和访问权限</li>
</ul>
<h5 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h5><ul>
<li>4个术语<ul>
<li>域 field<br>  基本的数据单元，如人名，出生日期</li>
<li>记录 record<br>  一组相关域的集合，如一个人作为一条记录，有名字，出生日期等域</li>
<li>文件 file<br>  一组相似记录的集合</li>
<li>数据库<br>  一组相关数据的集合</li>
</ul>
</li>
<li>并非所有文件管理系统都会是这种结构，在类UNIX系统上，文件的基本结构是字节流。例如一个C语言程序以文件的形式存储，而没有物理域、记录等</li>
</ul>
<h5 id="文件管理系统"><a href="#文件管理系统" class="headerlink" title="文件管理系统"></a>文件管理系统</h5><ul>
<li>典型情况下，文件管理系统是用户或应用程序访问文件的唯一方式</li>
<li>文件系统架构<ul>
<li>用户程序</li>
<li>堆 顺序 索引顺序 索引 散列</li>
<li>逻辑IO</li>
<li>基本IO管理程序</li>
<li>基本文件系统</li>
<li>磁盘设备驱动 磁带设备驱动等驱动程序</li>
</ul>
</li>
</ul>
<h3 id="2-文件组织和访问"><a href="#2-文件组织和访问" class="headerlink" title="2. 文件组织和访问"></a>2. 文件组织和访问</h3><ul>
<li>选择文件组织的原则<ul>
<li>快速访问</li>
<li>易于修改</li>
<li>节约存储空间</li>
<li>维护简单</li>
<li>可靠性<br>这些原则的优先级取决于使用这些文件的应用程序</li>
</ul>
</li>
<li>5种基本组织<ul>
<li>堆<ul>
<li>不是数据结构中的堆，是最简单的文件组织形式</li>
<li>堆文件没有结构，访问记录只能穷举查找</li>
<li>对大多数应用都不适用，当数据难以组织时，可以用堆文件</li>
</ul>
</li>
<li>顺序文件<ul>
<li>最常用，每条记录有固定的格式</li>
<li>通常应用于批处理应用中</li>
<li>另一种选择是把顺序文件组织成链表的形式。但增加额外的处理和空间开销</li>
</ul>
</li>
<li>索引文件<ul>
<li>只能通过索引访问</li>
</ul>
</li>
<li>索引顺序文件<ul>
<li>克服顺序文件的缺点，增加了用于支持随机访问的文件索引和溢出文件</li>
</ul>
</li>
<li>直接或散列文件<ul>
<li>记录长度固定，快速访问，一次只能访问一条记录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-B树"><a href="#3-B树" class="headerlink" title="3. B树"></a>3. B树</h3><ul>
<li>用于文件系统和数据库</li>
<li>每个节点有多个关键码的树</li>
</ul>
<h3 id="4-Linux文件系统"><a href="#4-Linux文件系统" class="headerlink" title="4. Linux文件系统"></a>4. Linux文件系统</h3><h5 id="VFS虚拟文件系统"><a href="#VFS虚拟文件系统" class="headerlink" title="VFS虚拟文件系统"></a>VFS虚拟文件系统</h5><ul>
<li>VFS的4个主要对象<ul>
<li>超级块对象 superblock<br>  表示一个已挂载的特定文件系统</li>
<li>索引节点对象 inode<br>  表示一个特定的问价</li>
<li>目录项对象 dentry<br>  表示一个特定的目录项</li>
<li>文件对象 file<br>  表示一个与进程相关的已打开文件</li>
</ul>
</li>
</ul>
<h1 id="第十三章：嵌入式操作系统"><a href="#第十三章：嵌入式操作系统" class="headerlink" title="第十三章：嵌入式操作系统"></a>第十三章：嵌入式操作系统</h1><h3 id="1-嵌入式系统"><a href="#1-嵌入式系统" class="headerlink" title="1. 嵌入式系统"></a>1. 嵌入式系统</h3><ul>
<li>为完成某个特定功能而设计的</li>
</ul>
<h3 id="2-嵌入式Linux"><a href="#2-嵌入式Linux" class="headerlink" title="2. 嵌入式Linux"></a>2. 嵌入式Linux</h3><ul>
<li>内核比普通Linux小队多</li>
<li>交叉编译，在一个平台上编译，在另一个平台上运行</li>
<li>文件系统<ul>
<li>通常使用闪存作为持久性存储设备</li>
</ul>
</li>
</ul>
<h1 id="第十四章：虚拟机"><a href="#第十四章：虚拟机" class="headerlink" title="第十四章：虚拟机"></a>第十四章：虚拟机</h1><ul>
<li>这章……讲的……真抽象</li>
<li>虚拟化技术使得单个PC或服务器能够同时运行多个操作系统或一个操作系统的多个会话</li>
</ul>
<h1 id="第十五章：计算机安全技术"><a href="#第十五章：计算机安全技术" class="headerlink" title="第十五章：计算机安全技术"></a>第十五章：计算机安全技术</h1><h3 id="1-入侵者与恶意软件"><a href="#1-入侵者与恶意软件" class="headerlink" title="1. 入侵者与恶意软件"></a>1. 入侵者与恶意软件</h3><h5 id="入侵者"><a href="#入侵者" class="headerlink" title="入侵者"></a>入侵者</h5><ul>
<li>伪装者<ul>
<li>越过系统访问控制并使用了一个合法的用户账号</li>
<li>来自外部</li>
</ul>
</li>
<li>违法者<ul>
<li>合法用户，但访问了为被授权的数据</li>
<li>来自外部</li>
</ul>
</li>
<li>秘密用户<ul>
<li>能控制系统的个体</li>
<li>来自外部或内部</li>
</ul>
</li>
</ul>
<h5 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h5><ul>
<li>寄生型<ul>
<li>需要宿主程序</li>
<li>如病毒，逻辑炸弹和程序后门</li>
</ul>
</li>
<li>独立运行<ul>
<li>可以被操作系统调度和执行的独立程序</li>
<li>如蠕虫和机器人程序</li>
</ul>
</li>
</ul>
<h5 id="应对措施"><a href="#应对措施" class="headerlink" title="应对措施"></a>应对措施</h5><ul>
<li>入侵检测系统(IDS)<ul>
<li>基于宿主的IDS</li>
<li>基于网络的IDS</li>
</ul>
</li>
<li>认证</li>
<li>访问控制</li>
<li>防火墙</li>
</ul>
<h3 id="2-缓冲区溢出"><a href="#2-缓冲区溢出" class="headerlink" title="2. 缓冲区溢出"></a>2. 缓冲区溢出</h3><h5 id="缓冲区溢出例子"><a href="#缓冲区溢出例子" class="headerlink" title="缓冲区溢出例子"></a>缓冲区溢出例子</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int valid &#x3D; FALSE;</span><br><span class="line">    char str1[8];</span><br><span class="line">    char str2[8];</span><br><span class="line"></span><br><span class="line">    next_tag(str1); &#x2F;&#x2F;另str1里面存STATE</span><br><span class="line">    gets(str2);</span><br><span class="line">    if(strncmp(str1,str2,8)&#x3D;&#x3D;0)&#123;</span><br><span class="line">        valid &#x3D; TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;str1:%s,str2:%s,valid:%d\n&quot;,str1,str2,valid);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个就会造成缓冲区溢出</li>
<li>一般情况下，valid,str1,str2在内存中连续存放</li>
<li>调用next_tag后，str1里面存储字符串”STATE”</li>
<li>C语言库函数gets不对复制的数据量做任何检查。它从程序的标准输入读取下一行文本，知道出现\n，将其复制到缓冲区，并用C语言字符串使用的NULL作为结尾。如果读入时的字符超过7个(NULL还得占一个)，照样会读入，覆盖相邻变量的值，在本例中即覆盖str1的值，从而破坏其他变量的值</li>
<li>运行如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;正确运行的例子</span><br><span class="line">$ .&#x2F;a.out</span><br><span class="line">STATE</span><br><span class="line">str1:STATE,str2:STATE,valid:1</span><br><span class="line">&#x2F;&#x2F;溢出例子,可以看出已经改变了str1的值</span><br><span class="line">$ .&#x2F;a.out</span><br><span class="line">123456789abcde</span><br><span class="line">str1:9abcde,str2:123456789abcde,valid:0</span><br><span class="line">&#x2F;&#x2F;溢出例子，不仅改了str1的值，还使valid为TRUE</span><br><span class="line">$ .&#x2F;a.out</span><br><span class="line">badinputbadinput</span><br><span class="line">str1:badinput,str2:badinputbadinput,valid:1</span><br></pre></td></tr></table></figure></li>
<li>如果这里是比较密码，成功就登入，就可以用这种办法，不需要知道密码，直接比较成功，从而登入</li>
</ul>
<h5 id="编译时防御"><a href="#编译时防御" class="headerlink" title="编译时防御"></a>编译时防御</h5><ul>
<li>编程语言的选择</li>
<li>安全编码技术</li>
<li>语言扩展及使用安全库</li>
<li>栈保护机制</li>
</ul>
<h5 id="运行时防御"><a href="#运行时防御" class="headerlink" title="运行时防御"></a>运行时防御</h5><ul>
<li>可执行的地址空间保护</li>
<li>地址空间布局随机化</li>
<li>守卫页</li>
</ul>
<h1 id="第十六章：分布式处理、客户-服务器和集群"><a href="#第十六章：分布式处理、客户-服务器和集群" class="headerlink" title="第十六章：分布式处理、客户-服务器和集群"></a>第十六章：分布式处理、客户-服务器和集群</h1><h3 id="1-客户-服务器计算"><a href="#1-客户-服务器计算" class="headerlink" title="1. 客户-服务器计算"></a>1. 客户-服务器计算</h3><table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>应用程序编程接口(API)</td>
<td>允许客户和服务器之间相互通信的一组函数和可调用程序集</td>
</tr>
<tr>
<td>客户端</td>
<td>网络上的一个信息请求方，通常是一台PC或工作站，能够从服务器处查询数据库和其他信息</td>
</tr>
<tr>
<td>中间件</td>
<td>一组驱动程序、应用程序编程接口或其他软件集，用于改善客户应用程序和服务器之间的连通性</td>
</tr>
<tr>
<td>关系数据库</td>
<td>一种把对信息的访问限制于满足搜索条件的数据行的数据库</td>
</tr>
<tr>
<td>服务器</td>
<td>一台计算机，通常是一台高性能工作站、小型计算机或大型机，存储并提供信息给网络中的众多客户使用</td>
</tr>
<tr>
<td>结构化查询语言(SQL)</td>
<td>由IBM开发并由ANSI标准化的一种语言，用于对关系数据库的寻址，创建，更新和查询</td>
</tr>
</tbody></table>
<ul>
<li>我的理解，实际上就是C/S,B/S架构，中间件是像代理服务器之类的东西</li>
</ul>
<h3 id="2-分布式消息传递"><a href="#2-分布式消息传递" class="headerlink" title="2. 分布式消息传递"></a>2. 分布式消息传递</h3><ul>
<li>就是客户端和服务器不能直接通过信号等传递消息，可以通过报文，用特定的结构传递信息，如HTTP</li>
<li>可靠和不可靠性<ul>
<li>是否保证传递消息的正确性</li>
</ul>
</li>
<li>阻塞与无阻塞<ul>
<li>发送和接受消息是否等待</li>
</ul>
</li>
</ul>
<h3 id="3-远程过程调用-RPC"><a href="#3-远程过程调用-RPC" class="headerlink" title="3. 远程过程调用(RPC)"></a>3. 远程过程调用(RPC)</h3><ul>
<li><p>是基本消息传递的一种变体</p>
</li>
<li><p>举例就是客户端给服务器发送个消息，服务器就本地调用某个程序</p>
</li>
<li><p>同步和异步</p>
<ul>
<li>同步RPC<br>  和子程序调用行为类似，要等待返回结果。</li>
<li>异步RPC<br>  调用者并不等待应答</li>
</ul>
</li>
</ul>
<h3 id="4-集群"><a href="#4-集群" class="headerlink" title="4. 集群"></a>4. 集群</h3><ul>
<li>集群技术可以替代对称多处理技术(SMP)</li>
<li>集群定义为一组互联的完整计算机，这些完整计算机作为一种统一的计算资源协同工作，就像一台计算机那样。</li>
<li>集群的四个优点<ul>
<li>绝对可伸缩性<ul>
<li>一个集群可以有用数十台至数百台机器，每台机器都可以是多处理机</li>
</ul>
</li>
<li>增加可伸缩性<ul>
<li>集群能这样配置：向集群中添加系统时只需少量的额外工作，即用户可以在一个大小适度的系统上开始工作，在需求增加时可以扩展系统，而不用升级主体来用较大的系统代替较小的系统。</li>
</ul>
</li>
<li>高可用性<ul>
<li>因为集群中的每个节点都是一台独立的计算机，因此某个节点故障并不意味着服务失败。在很多产品中，软件能够自动地进行容错处理</li>
</ul>
</li>
<li>高性价比<ul>
<li>使用普通的计算机来构建集群系统，能够以非常低的价格，获得与一台大型计算机相同或更大的计算能力</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="练习项目"><a href="#练习项目" class="headerlink" title="练习项目"></a>练习项目</h1><ul>
<li>后期可以看一下附录的一些问题，比如理发店问题，各个小作业</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL必知必会》</title>
    <url>/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ol>
<li>虽然去年上过数据库的课，但是发现基本只是学了增删该查的语句而已，优化什么的，还有很多要学的。</li>
<li>这本书更教导实践，上课时学的更多的理论</li>
</ol>
<a id="more"></a>
<h1 id="第一章：了解SQL"><a href="#第一章：了解SQL" class="headerlink" title="第一章：了解SQL"></a>第一章：了解SQL</h1><h3 id="1-数据库基础"><a href="#1-数据库基础" class="headerlink" title="1. 数据库基础"></a>1. 数据库基础</h3><ul>
<li>表</li>
<li>模式<ul>
<li>关于数据库和表的布局及特性的信息</li>
</ul>
</li>
<li>列和数据类型</li>
<li>行</li>
<li>主键<ul>
<li>对行来说，唯一不为NULL</li>
<li>每个表都应该定义</li>
<li>对列来说，可以有多个主键，即主键不唯一。</li>
</ul>
</li>
</ul>
<h3 id="2-SQL"><a href="#2-SQL" class="headerlink" title="2. SQL"></a>2. SQL</h3><ul>
<li>结构化查询语言 Structured Query Language</li>
<li>SQL不是某个特定数据库供应商专有的语言，几乎所有重要的DBMS都支持SQL</li>
<li>但各个数据库的SQL并不完全相同，有细微差别</li>
</ul>
<h1 id="第二章：MySQL简介"><a href="#第二章：MySQL简介" class="headerlink" title="第二章：MySQL简介"></a>第二章：MySQL简介</h1><h3 id="1-DBMS分为两类"><a href="#1-DBMS分为两类" class="headerlink" title="1. DBMS分为两类"></a>1. DBMS分为两类</h3><ul>
<li>基于共享文件系统的DBMS<ul>
<li>如Microsoft Access和FileMaker</li>
<li>用于桌面用途，通常不用于高端或更关键的应用</li>
</ul>
</li>
<li>基于客户机-服务器的DBMS<ul>
<li>如MySQL,Oracle等</li>
<li>服务器部分是负责所有数据访问和处理的一个软件，把请求的结果送回客户机软件</li>
<li>客户机可以是MySQL提供的工具，脚本语言，Web应用开发语言，程序设计语言等<h3 id="2-工具"><a href="#2-工具" class="headerlink" title="2. 工具"></a>2. 工具</h3></li>
</ul>
</li>
<li>命令行</li>
<li>图形界面</li>
</ul>
<h1 id="第三章：使用MySQL"><a href="#第三章：使用MySQL" class="headerlink" title="第三章：使用MySQL"></a>第三章：使用MySQL</h1><h3 id="1-连接"><a href="#1-连接" class="headerlink" title="1. 连接"></a>1. 连接</h3><ul>
<li><p>需要的信息</p>
<ul>
<li>主机名，本地localhost</li>
<li>端口，默认3306</li>
<li>用户名</li>
<li>密码<h3 id="2-选择数据库"><a href="#2-选择数据库" class="headerlink" title="2. 选择数据库"></a>2. 选择数据库</h3></li>
</ul>
</li>
<li><p>切换数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输入</span><br><span class="line">use student &#x2F;&#x2F;切换到student数据库</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-了解数据库和表"><a href="#3-了解数据库和表" class="headerlink" title="3. 了解数据库和表"></a>3. 了解数据库和表</h3><ul>
<li><p>显示数据库信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输入</span><br><span class="line">show database;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示表信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输入</span><br><span class="line">show tablename;</span><br></pre></td></tr></table></figure></li>
<li><p>显示列信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show colume from tablename;</span><br></pre></td></tr></table></figure></li>
<li><p>其他show</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status; &#x2F;&#x2F;显示广泛的服务器状态信息</span><br><span class="line">show grants; &#x2F;&#x2F;显示授予用户的安全权限</span><br><span class="line">show errors;</span><br><span class="line">show warnings; &#x2F;&#x2F;显示服务器错误或警告消息</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第四章：检索数据"><a href="#第四章：检索数据" class="headerlink" title="第四章：检索数据"></a>第四章：检索数据</h1><h3 id="1-检索单个列"><a href="#1-检索单个列" class="headerlink" title="1. 检索单个列"></a>1. 检索单个列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student;</span><br></pre></td></tr></table></figure>
<ul>
<li>以分号结束<h3 id="2-检索多个列"><a href="#2-检索多个列" class="headerlink" title="2. 检索多个列"></a>2. 检索多个列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,id,sex</span><br><span class="line">from student;</span><br></pre></td></tr></table></figure>
<h3 id="3-检索所有列"><a href="#3-检索所有列" class="headerlink" title="3. 检索所有列"></a>3. 检索所有列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from student;</span><br></pre></td></tr></table></figure></li>
<li>一般，除非确定要检索每个列，要不然不要使用*通配符，这样会降低检索和应用程序的性能</li>
<li>*的优点是能检索出名字未知的列</li>
</ul>
<h3 id="4-检索不同的行，distinct"><a href="#4-检索不同的行，distinct" class="headerlink" title="4. 检索不同的行，distinct"></a>4. 检索不同的行，distinct</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct name</span><br><span class="line">from student;</span><br></pre></td></tr></table></figure>
<ul>
<li>distinct能去掉重复的行，这样显示出来的就没有重名的了</li>
</ul>
<h3 id="5-限制结果，limit"><a href="#5-限制结果，limit" class="headerlink" title="5. 限制结果，limit"></a>5. 限制结果，limit</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">limit 5;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回不多于5行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">limit 5,5;</span><br></pre></td></tr></table></figure></li>
<li>为得出下一个5行，指明开始行和行数</li>
<li>新语法：limit 4 offset 3<br>  等价于 limit 4,3</li>
</ul>
<h3 id="6-使用完全限定的表名"><a href="#6-使用完全限定的表名" class="headerlink" title="6. 使用完全限定的表名"></a>6. 使用完全限定的表名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select student.name</span><br><span class="line">from student;</span><br></pre></td></tr></table></figure>

<h1 id="第五章：排序检索数据"><a href="#第五章：排序检索数据" class="headerlink" title="第五章：排序检索数据"></a>第五章：排序检索数据</h1><h3 id="1-排序数据，order-by"><a href="#1-排序数据，order-by" class="headerlink" title="1. 排序数据，order by"></a>1. 排序数据，order by</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">order by name;</span><br></pre></td></tr></table></figure>
<ul>
<li>若不排序，数据一般将以它在底层表中出现的顺序显示。若增删后，顺序会发生变化</li>
</ul>
<h3 id="2-按多个列排序"><a href="#2-按多个列排序" class="headerlink" title="2. 按多个列排序"></a>2. 按多个列排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">order by name,id;</span><br></pre></td></tr></table></figure>
<ul>
<li>先按照name，再按照id排序</li>
</ul>
<h3 id="3-指定排序方向-desc-asc"><a href="#3-指定排序方向-desc-asc" class="headerlink" title="3. 指定排序方向,desc/asc"></a>3. 指定排序方向,desc/asc</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">order by name desc,id;</span><br></pre></td></tr></table></figure>
<ul>
<li>desc为降序，默认为asc升序</li>
<li>例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;找出最贵的</span><br><span class="line">select name</span><br><span class="line">from product</span><br><span class="line">order by price desc</span><br><span class="line">limit 1;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第六章：过滤数据"><a href="#第六章：过滤数据" class="headerlink" title="第六章：过滤数据"></a>第六章：过滤数据</h1><h3 id="1-使用where子句"><a href="#1-使用where子句" class="headerlink" title="1. 使用where子句"></a>1. 使用where子句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from product</span><br><span class="line">where price&#x3D;10.0;</span><br></pre></td></tr></table></figure>
<ul>
<li>同时使用where和order by时，where必须在前面</li>
<li>数据也可以在应用层过滤，把所有数据检索到，写代码过滤数据，但是效率低，不推荐</li>
</ul>
<h3 id="2-where子句操作符"><a href="#2-where子句操作符" class="headerlink" title="2. where子句操作符"></a>2. where子句操作符</h3><table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
</tbody></table>
<blockquote>
<p>|大于<br>=|大于等于<br>between|两个指定值之间</p>
</blockquote>
<ul>
<li><p>匹配检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from product</span><br><span class="line">where price&lt;&#x3D;10.0;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不匹配检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查找价格不为10.0的物品名</span><br><span class="line">select name</span><br><span class="line">from product</span><br><span class="line">where price&lt;&gt;10.0;</span><br></pre></td></tr></table></figure></li>
<li><p>范围值检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from product</span><br><span class="line">where price between 5.0 and 10.0;</span><br></pre></td></tr></table></figure></li>
<li><p>空值检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;空值不是price&#x3D;0</span><br><span class="line">select name</span><br><span class="line">from product</span><br><span class="line">where price is null;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第七章-数据过滤-进阶"><a href="#第七章-数据过滤-进阶" class="headerlink" title="第七章:数据过滤(进阶)"></a>第七章:数据过滤(进阶)</h1><h3 id="1-组合where子句，and-or"><a href="#1-组合where子句，and-or" class="headerlink" title="1. 组合where子句，and/or"></a>1. 组合where子句，and/or</h3><ul>
<li><p>and</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where grade&#x3D;100 and sex&#x3D;male;</span><br></pre></td></tr></table></figure>
</li>
<li><p>or</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where grade&#x3D;100 or sex&#x3D;male;</span><br></pre></td></tr></table></figure></li>
<li><p>计算次序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where grade&#x3D;100 or grade&#x3D;99 and sex&#x3D;male;</span><br><span class="line">&#x2F;&#x2F;这样会先计算and，再计算or，想用or应该括起来</span><br><span class="line">where (grade&#x3D;100 or grade&#x3D;99) and sex&#x3D;male;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-in-操作符"><a href="#2-in-操作符" class="headerlink" title="2. in 操作符"></a>2. in 操作符</h3><ul>
<li>in 操作符用来指定条件范<br>围,范围中的每个条件都可以进行匹配。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where grade in (99,100);</span><br></pre></td></tr></table></figure></li>
<li>为什么用in不用or<ul>
<li>在选项较多时,in更清晰明了</li>
<li>in一般比or执行更快</li>
<li>in里面也可以用where</li>
</ul>
</li>
</ul>
<h3 id="3-not-操作符"><a href="#3-not-操作符" class="headerlink" title="3. not 操作符"></a>3. not 操作符</h3><ul>
<li>否定它之后所跟的任何条件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where grade in (99,100);</span><br></pre></td></tr></table></figure></li>
<li>mysql支持not 对in,between,exists取反，这和多数其他的DBMS有区别</li>
</ul>
<h1 id="第八章：用通配符进行过滤"><a href="#第八章：用通配符进行过滤" class="headerlink" title="第八章：用通配符进行过滤"></a>第八章：用通配符进行过滤</h1><h3 id="1-like-操作符"><a href="#1-like-操作符" class="headerlink" title="1. like 操作符"></a>1. like 操作符</h3><h5 id="百分号-通配符"><a href="#百分号-通配符" class="headerlink" title="百分号 % 通配符"></a>百分号 % 通配符</h5><ul>
<li>在搜索串中, % 表示任何字符出现任意次数。例如,为了找出所有高姓的名字,可使用以下 SELECT语句:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where name like &#39;吕%&#39;;</span><br></pre></td></tr></table></figure></li>
<li>名字中带‘钰’的人<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where name like &#39;%潇%&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="下划线-通配符"><a href="#下划线-通配符" class="headerlink" title="下划线 _ 通配符"></a>下划线 _ 通配符</h5><ul>
<li>下划线的用途与 % 一样,但下划线只匹配单个字符而不是多个字符。</li>
<li>匹配 高某，_匹配任意一个字，不能多也不能少，%可以匹配0到多个<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where name like &#39;吕_&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-使用通配符的技巧"><a href="#2-使用通配符的技巧" class="headerlink" title="2. 使用通配符的技巧"></a>2. 使用通配符的技巧</h3><ul>
<li>通配符的处理一般比其他搜索花时间更长</li>
<li>一些技巧<ul>
<li>不要过度使用通配符，如果其他操作符能达到目的，就用其他的。</li>
<li>在确实需要通配符时，除非有必要，否则不要放在搜索模式的开始处。放在开始处搜索起来最慢</li>
</ul>
</li>
</ul>
<h1 id="第九章：用正则表达式进行搜索"><a href="#第九章：用正则表达式进行搜索" class="headerlink" title="第九章：用正则表达式进行搜索"></a>第九章：用正则表达式进行搜索</h1><h3 id="MySQL正则表达式"><a href="#MySQL正则表达式" class="headerlink" title="MySQL正则表达式"></a>MySQL正则表达式</h3><ul>
<li>MySQL正则表达是并不是支持所有的正则语法</li>
</ul>
<h5 id="基本字符匹配"><a href="#基本字符匹配" class="headerlink" title="基本字符匹配"></a>基本字符匹配</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where name regexp &#39;aaa&#39;;</span><br><span class="line">&#x2F;&#x2F;这个并不是只匹配 ‘aaa’,而是匹配所有名字中带aaa的，例如</span><br><span class="line">ccaaaasf</span><br><span class="line">aaasaf</span><br><span class="line">sadaaa</span><br></pre></td></tr></table></figure>
<ul>
<li>默认的regexp不区分大小写，若想区分要加binary<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where name regexp binary &#39;AAA&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="其他的一些正则表达式规则"><a href="#其他的一些正则表达式规则" class="headerlink" title="其他的一些正则表达式规则"></a>其他的一些正则表达式规则</h5><ul>
<li>因为这些规则本人已经掌握的差不多了，所以不再赘述，直接列出来MySQL支持哪些</li>
<li>or匹配<ul>
<li>a|b</li>
</ul>
</li>
<li>匹配几个字符之一<ul>
<li>[abc]</li>
</ul>
</li>
<li>匹配范围<ul>
<li>[a-z]</li>
<li>[0-9]</li>
</ul>
</li>
<li>匹配特殊字符<ul>
<li>要加两个\转义</li>
<li>\. 表示匹配.</li>
</ul>
</li>
<li>匹配字符类</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[:alnum:]</td>
<td>任意字母和数字(同[a-zA-Z0-9])</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>任意字符(同[a-zA-Z])</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空格和制表(同[\t])</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>ASCII控制字符(ASCII 0到31和127)</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>任意数字(同[0-9])</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>与[:print:]相同,但不包括空格</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>任意小写字母(同[a-z])</td>
</tr>
<tr>
<td>[:print:]</td>
<td>任意可打印字符</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>既不在[:alnum:]又不在[:cntrl:]中的任意字符</td>
</tr>
<tr>
<td>[:space:]</td>
<td>包括空格在内的任意空白字符(同[\f\n\r\t\v])</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>任意大写字母(同[A-Z])</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>任意十六进制数字(同[a-fA-F0-9])</td>
</tr>
</tbody></table>
<ul>
<li>匹配多个实例</li>
</ul>
<table>
<thead>
<tr>
<th>元 字 符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>0个或多个匹配</td>
</tr>
<tr>
<td>+</td>
<td>1个或多个匹配(等于{1,})</td>
</tr>
<tr>
<td>?</td>
<td>0个或1个匹配(等于{0,1})</td>
</tr>
<tr>
<td>{n}</td>
<td>指定数目的匹配</td>
</tr>
<tr>
<td>{n,}</td>
<td>不少于指定数目的匹配</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配数目的范围(m不超过255)</td>
</tr>
</tbody></table>
<ul>
<li>定位符</li>
</ul>
<table>
<thead>
<tr>
<th>元 字 符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>文本的开始</td>
</tr>
<tr>
<td>$</td>
<td>文本的结尾</td>
</tr>
<tr>
<td>[[:&lt;:]]</td>
<td>词的开始</td>
</tr>
<tr>
<td>[[:&gt;:]]</td>
<td>词的结尾</td>
</tr>
</tbody></table>
<h1 id="第十章：创建计算字段"><a href="#第十章：创建计算字段" class="headerlink" title="第十章：创建计算字段"></a>第十章：创建计算字段</h1><h3 id="1-拼接字段，Concat"><a href="#1-拼接字段，Concat" class="headerlink" title="1. 拼接字段，Concat()"></a>1. 拼接字段，Concat()</h3><ul>
<li>多数DBMS使用 + 或 || 来实现拼接，MySQL使用Concat()函数来实现<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select Concat(name,&#39;-&#39;,sex)</span><br><span class="line">from student</span><br><span class="line">order by name;</span><br><span class="line">&#x2F;&#x2F;结果为：</span><br><span class="line">aname-male</span><br><span class="line">bname-female</span><br></pre></td></tr></table></figure></li>
<li>Rtrim()函数去掉值右边的所有空格<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select Concat(Rtrim(name),&#39;-&#39;,Rtrim(sex))</span><br><span class="line">from student</span><br><span class="line">order by name;</span><br></pre></td></tr></table></figure>
<h5 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h5></li>
<li>若如上面拼接，只能查看，不能使用，要想使用得用别名</li>
<li>别名是一个值或字段的替换名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select Concat(Rtrim(name),&#39;-&#39;,Rtrim(sex))</span><br><span class="line">as name_sex</span><br><span class="line">from student</span><br><span class="line">order by name;</span><br></pre></td></tr></table></figure></li>
<li>别名也称作导出列</li>
</ul>
<h3 id="2-执行算术计算"><a href="#2-执行算术计算" class="headerlink" title="2. 执行算术计算"></a>2. 执行算术计算</h3><ul>
<li>MySQL支持的基本运算符</li>
</ul>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
</table>
<ul>
<li>|加</li>
</ul>
<ul>
<li>|减</li>
</ul>
<ul>
<li>|乘<br>/ |除</li>
</ul>
<ul>
<li>例如知道单价和数量，求总价格<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select a_price,num,a_price*num</span><br><span class="line">as expanded_price</span><br><span class="line">from product</span><br><span class="line">where id&#x3D;111;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第十一章：使用数据处理函数"><a href="#第十一章：使用数据处理函数" class="headerlink" title="第十一章：使用数据处理函数"></a>第十一章：使用数据处理函数</h1><h3 id="1-SQL函数"><a href="#1-SQL函数" class="headerlink" title="1. SQL函数"></a>1. SQL函数</h3><ul>
<li><p>函数的可移植性差，各个DBMS支持的函数可能不相同</p>
</li>
<li><p>大多数SQL实现支持以下类型的函数</p>
<ul>
<li>用于处理文本串的文本函数</li>
<li>用于在数值数据上进行算术操作的数值函数</li>
<li>用于处理日期和时间值并从这些值中提取特定成分的日期和时间函数</li>
<li>返回DBMS正使用的特殊信息的系统函数，如用户的登录信息，检查版本细节</li>
</ul>
</li>
</ul>
<h3 id="2-文本处理函数"><a href="#2-文本处理函数" class="headerlink" title="2. 文本处理函数"></a>2. 文本处理函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Left()</td>
<td>返回串左边的字符</td>
</tr>
<tr>
<td>Length()</td>
<td>返回串的长度</td>
</tr>
<tr>
<td>Locate()</td>
<td>找出串的一个子串</td>
</tr>
<tr>
<td>Lower()</td>
<td>将串转换为小写</td>
</tr>
<tr>
<td>Upper()</td>
<td>将串转换为大写</td>
</tr>
<tr>
<td>LTrim()</td>
<td>去掉串左边的空格</td>
</tr>
<tr>
<td>RTrim()</td>
<td>去掉串右边的空格</td>
</tr>
<tr>
<td>Right()</td>
<td>返回串右边的字符</td>
</tr>
<tr>
<td>Soundex()</td>
<td>返回串的SOUNDEX值</td>
</tr>
<tr>
<td>SubString()</td>
<td>返回子串的字符</td>
</tr>
</tbody></table>
<ul>
<li>使用方法上面已经演示</li>
<li>SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法<br>SOUNDEX考虑的类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。</li>
<li>SOUNDEX不是SQL概念，但多数DBMS都提供对SOUNDEX的支持</li>
<li>SOUNDEX例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">customers 表中有一个顾客 Coyote Inc. ,其联系名为 Y.Lee 。</span><br><span class="line">但如果这是输入错误,此联系名实际应该是 Y.Lie ,怎么办?</span><br><span class="line">显然,按正确的联系名搜索不会返回数据,如下所示:</span><br><span class="line">    select sex</span><br><span class="line">    from customers</span><br><span class="line">    where name&#x3D;&#39;Y.Lee&#39;;</span><br><span class="line">    &#x2F;&#x2F;输错了，没有Y.Lee,想要搜的是Y.Lie</span><br></pre></td></tr></table></figure></li>
<li>可以用Soundex()函数解决<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sex</span><br><span class="line">from customers</span><br><span class="line">where Soundex(name)&#x3D;Soundex(&#39;Y.Lee&#39;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-时间和日期处理函数"><a href="#3-时间和日期处理函数" class="headerlink" title="3. 时间和日期处理函数"></a>3. 时间和日期处理函数</h3><ul>
<li>日期和时间采用相应的数据类型和特殊的格式存储,以便能快速和有效地排序或过滤,并且节省物理存储空间。</li>
<li>常用日期和时间处理函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AddDate()</td>
<td>增加一个日期(天、周等)</td>
</tr>
<tr>
<td>AddTime()</td>
<td>增加一个时间(时、分等)</td>
</tr>
<tr>
<td>CurDate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CurTime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>Date()</td>
<td>返回日期时间的日期部分</td>
</tr>
<tr>
<td>DateDiff()</td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td>Date_Add()</td>
<td>高度灵活的日期运算函数</td>
</tr>
<tr>
<td>Date_Format()</td>
<td>返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td>Day()</td>
<td>返回一个日期的天数部分</td>
</tr>
<tr>
<td>DayOfWeek()</td>
<td>对于一个日期,返回对应的星期几</td>
</tr>
<tr>
<td>Hour()</td>
<td>返回一个时间的小时部分</td>
</tr>
<tr>
<td>Minute()</td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr>
<td>Month()</td>
<td>返回一个日期的月份部分</td>
</tr>
<tr>
<td>Now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>Second()</td>
<td>返回一个时间的秒部分</td>
</tr>
<tr>
<td>Time()</td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td>Year()</td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody></table>
<ul>
<li><p>不管是插入或更新表值还是用 WHERE 子句进行过滤,日期必须为格式yyyy-mm-dd</p>
</li>
<li><p>例子,为什么不直接用=？因为time中可能有具体的时分秒时间，这样的话和日期比较就永远不会相等，用Date()函数转成日期比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from products</span><br><span class="line">where Date(time) between &#39;2019-01-01&#39; and &#39;2019-01-10&#39;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-数值处理函数"><a href="#4-数值处理函数" class="headerlink" title="4. 数值处理函数"></a>4. 数值处理函数</h3><ul>
<li>在主要DBMS的函数中,数值函数是最一致最统一的函数</li>
<li>常用的数值处理函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Abs()</td>
<td>返回一个数的绝对值</td>
</tr>
<tr>
<td>Cos()</td>
<td>返回一个角度的余弦</td>
</tr>
<tr>
<td>Exp()</td>
<td>返回一个数的指数值</td>
</tr>
<tr>
<td>Mod()</td>
<td>返回除操作的余数</td>
</tr>
<tr>
<td>Pi()</td>
<td>返回圆周率</td>
</tr>
<tr>
<td>Rand()</td>
<td>返回一个随机数</td>
</tr>
<tr>
<td>Sin()</td>
<td>返回一个角度的正弦</td>
</tr>
<tr>
<td>Sqrt()</td>
<td>返回一个数的平方根</td>
</tr>
<tr>
<td>Tan()</td>
<td>返回一个角度的正切</td>
</tr>
</tbody></table>
<h1 id="第十二章：汇总数据"><a href="#第十二章：汇总数据" class="headerlink" title="第十二章：汇总数据"></a>第十二章：汇总数据</h1><h3 id="1-聚集函数"><a href="#1-聚集函数" class="headerlink" title="1. 聚集函数"></a>1. 聚集函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AVG()</td>
<td>返回某列的平均值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>返回某列的行数</td>
</tr>
<tr>
<td>MAX()</td>
<td>返回某列的最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>返回某列的最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>返回某列值之和</td>
</tr>
</tbody></table>
<h5 id="avg-求列平均"><a href="#avg-求列平均" class="headerlink" title="avg()求列平均"></a>avg()求列平均</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select avg(price)</span><br><span class="line">as avg_price</span><br><span class="line">from products;</span><br></pre></td></tr></table></figure>
<ul>
<li>avg忽略值为NULL的行</li>
<li>avg只能求一列，若想求多列，要多个avg</li>
</ul>
<h5 id="count-计行数"><a href="#count-计行数" class="headerlink" title="count()计行数"></a>count()计行数</h5><ul>
<li>count(*)统计行数，NULL也统计<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count(*)</span><br><span class="line">as all_num</span><br><span class="line">from products;</span><br></pre></td></tr></table></figure></li>
<li>count(column)对特定列计数，忽略NULL<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;只对price列不为NULL的计数</span><br><span class="line">select count(price)</span><br><span class="line">as have_price_num</span><br><span class="line">from products;</span><br></pre></td></tr></table></figure>
<h5 id="max-min"><a href="#max-min" class="headerlink" title="max()/min()"></a>max()/min()</h5></li>
<li>一般对值和日期使用，也可以对文本使用</li>
<li>忽略NULL</li>
</ul>
<h5 id="sum-求列值的和，count是统计行数"><a href="#sum-求列值的和，count是统计行数" class="headerlink" title="sum()求列值的和，count是统计行数"></a>sum()求列值的和，count是统计行数</h5><ul>
<li>得出订单的总金额<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sum(price*num)</span><br><span class="line">as all_price</span><br><span class="line">from orderitems</span><br></pre></td></tr></table></figure></li>
<li>忽略NULL</li>
</ul>
<h3 id="2-聚集不同值，distinct"><a href="#2-聚集不同值，distinct" class="headerlink" title="2. 聚集不同值，distinct"></a>2. 聚集不同值，distinct</h3><ul>
<li><p>统计有多少种价格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count(distinct price)</span><br><span class="line">as num_price</span><br><span class="line">from items;</span><br></pre></td></tr></table></figure>
<h3 id="3-组合聚集函数"><a href="#3-组合聚集函数" class="headerlink" title="3. 组合聚集函数"></a>3. 组合聚集函数</h3></li>
<li><p>可以使用多个函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count(distinct price) as num_price，</span><br><span class="line">min(price) as min_price</span><br><span class="line">from items;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在SQL中使用这些函数比在应用中用代码要快得多</p>
</li>
</ul>
<h1 id="第十三章：分组数据"><a href="#第十三章：分组数据" class="headerlink" title="第十三章：分组数据"></a>第十三章：分组数据</h1><h3 id="1-创建分组，group-by"><a href="#1-创建分组，group-by" class="headerlink" title="1. 创建分组，group by"></a>1. 创建分组，group by</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id,count(*) as num</span><br><span class="line">from items</span><br><span class="line">group by id;</span><br><span class="line">&#x2F;&#x2F;同一id为一组，分别统计每组的数量</span><br></pre></td></tr></table></figure>
<ul>
<li>若分组列中有NULL值，NULL单独作为一组，如果有多个NULL,这些NULL一组</li>
<li>group by必须出现在where子句之后，order by子句之前</li>
<li>使用rollup<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用 WITH ROLLUP 关键字,可以得到每个分组以及每个分组汇总级别(针对每个分组)的值,如下所示:</span><br><span class="line">    select id,count(*) as num</span><br><span class="line">    from items</span><br><span class="line">    group by id with rollup;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-过滤分组，having"><a href="#2-过滤分组，having" class="headerlink" title="2. 过滤分组，having"></a>2. 过滤分组，having</h3><ul>
<li>所学过的有关 WHERE 的所有这些技术和选项都适用于HAVING 。它们的句法是相同的,只是关键字有差别。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id,count(*) as num</span><br><span class="line">from items</span><br><span class="line">group by id</span><br><span class="line">having count(*) &gt;&#x3D; 2;</span><br></pre></td></tr></table></figure>

<h3 id="3-select-子句顺序"><a href="#3-select-子句顺序" class="headerlink" title="3. select 子句顺序"></a>3. select 子句顺序</h3><table>
<thead>
<tr>
<th>子句</th>
<th>说明</th>
<th>是否必须使用</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT</td>
<td>要返回的列或表达式</td>
<td>是</td>
</tr>
<tr>
<td>FROM</td>
<td>从中检索数据的表</td>
<td>仅在从表选择数据时使用</td>
</tr>
<tr>
<td>WHERE</td>
<td>行级过滤</td>
<td>否</td>
</tr>
<tr>
<td>GROUP BY</td>
<td>分组说明</td>
<td>仅在按组计算聚集时使用</td>
</tr>
<tr>
<td>HAVING</td>
<td>组级过滤</td>
<td>否</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>输出排序顺序</td>
<td>否</td>
</tr>
<tr>
<td>LIMIT</td>
<td>要检索的行数</td>
<td>否</td>
</tr>
</tbody></table>
<h1 id="第十四章：使用子查询"><a href="#第十四章：使用子查询" class="headerlink" title="第十四章：使用子查询"></a>第十四章：使用子查询</h1><h3 id="1-利用子查询进行过滤"><a href="#1-利用子查询进行过滤" class="headerlink" title="1. 利用子查询进行过滤"></a>1. 利用子查询进行过滤</h3><ul>
<li>找成绩等于100的学生名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where id in (</span><br><span class="line">    select id</span><br><span class="line">    from grade_table</span><br><span class="line">    where grade&#x3D;100</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-作为计算字段使用子查询"><a href="#2-作为计算字段使用子查询" class="headerlink" title="2. 作为计算字段使用子查询"></a>2. 作为计算字段使用子查询</h3><ul>
<li><p>要显示 customers表中每个客户的订单总数。订单与相应的客户ID存储在 orders 表中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select cust_name,cust_state,(select count(*)</span><br><span class="line">                            from orders</span><br><span class="line">                            where orders.cust_id&#x3D;customers.cust_id) as orders</span><br><span class="line">from customers</span><br><span class="line">order by cust_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>相关子查询<br>  设计外部查询的子查询</p>
</li>
</ul>
<h1 id="第十五章：联结表"><a href="#第十五章：联结表" class="headerlink" title="第十五章：联结表"></a>第十五章：联结表</h1><ul>
<li>维护引用完整性<ul>
<li>要理解联结不是物理实体。换句话说,它在实际的数据库表中不存在。</li>
<li>如果在 products 表中插入拥有非法供应商ID(即没有在 vendors 表中出现)的供应商生产的产品,则这些产品是不可访问的,因为它们没有关联到某个供应商。</li>
<li>为防止这种情况发生,可指示MySQL只允许在 products 表的供应商ID列中出现合法值(即出现在 vendors 表中的供应商)。这就是维护引用完整性,它是通过在表的定义中指定主键和外键来实现的。(这将在第21章介绍。)</li>
</ul>
</li>
</ul>
<h3 id="1-创建联结-等值连接"><a href="#1-创建联结-等值连接" class="headerlink" title="1. 创建联结(等值连接)"></a>1. 创建联结(等值连接)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select vend_name,prod_name</span><br><span class="line">from vendors,products</span><br><span class="line">where vendors.vend_id&#x3D;products.vend_id</span><br><span class="line">order by vend_name,prod_name;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在引用的列可能出现二义性时,必须使用完全限定列名(用一个点分隔的表名和列名)。</p>
</li>
<li><p>where 子句很重要,如果没有where,就会变成笛卡尔积，vendors里的每一行和products里的每一行连接</p>
</li>
<li><p>所有用联结的语句都要用where</p>
</li>
</ul>
<h3 id="2-内部联结"><a href="#2-内部联结" class="headerlink" title="2. 内部联结"></a>2. 内部联结</h3><ul>
<li>上述联结为等值联结，也称作内部联结</li>
<li>可以用不同的语法表示内部联结<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select vend_name,prod_name</span><br><span class="line">from vendors</span><br><span class="line">inner join products</span><br><span class="line">on vendors.vend_id&#x3D;products.vend_id</span><br><span class="line">order by vend_name,prod_name;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-联结多个表"><a href="#3-联结多个表" class="headerlink" title="3. 联结多个表"></a>3. 联结多个表</h3><ul>
<li>就是from后面多写几个表，where多几个条件</li>
<li>性能考虑<ul>
<li>MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的,因此应该仔细,不要联结不必要的表。联结的表越多,性能下降越厉害。</li>
</ul>
</li>
<li>联结和嵌套子查询(十四章)没有绝对的性能优劣，受数据量，操作类型，是否有索引等的影响</li>
</ul>
<h1 id="第十六章：创建高级联结"><a href="#第十六章：创建高级联结" class="headerlink" title="第十六章：创建高级联结"></a>第十六章：创建高级联结</h1><h3 id="1-使用表别名"><a href="#1-使用表别名" class="headerlink" title="1. 使用表别名"></a>1. 使用表别名</h3><ul>
<li>优点<ul>
<li>缩短SQL语句</li>
<li>允许在单条select语句中多次使用相同的表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select vend_name,prod_name</span><br><span class="line">from vendors as v,products as p</span><br><span class="line">where v.vend_id&#x3D;p.vend_id</span><br><span class="line">order by vend_name,prod_name;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>应该注意,表别名只在查询执行中使用。与列别名不一样,表别名不返回到客户机。</li>
</ul>
<h3 id="2-使用不同类型的联结"><a href="#2-使用不同类型的联结" class="headerlink" title="2. 使用不同类型的联结"></a>2. 使用不同类型的联结</h3><ul>
<li>之前的是等值联结/内部联结</li>
<li>下面讲自联结，自然联结，外部联结</li>
</ul>
<h5 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h5><ul>
<li>假如你发现某物品(其ID为 DTNTR )存在问题,因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为 111 的物品的供应商,然后找出这个供应商生产的其他物品。</li>
<li>可以用子查询<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select prod_name</span><br><span class="line">from products</span><br><span class="line">where vend_id &#x3D; (</span><br><span class="line">    select vend_id</span><br><span class="line">    from products</span><br><span class="line">    where prod_id&#x3D;&#39;111&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>也可以用自联结<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select prod_name</span><br><span class="line">from products as p1,products as p2</span><br><span class="line">where p1.vend_id&#x3D;p2.vend_id and p2.vend_id&#x3D;&#39;111&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h5><ul>
<li>事实上,迄今为止我们建立的每个内部联结都是自然联结,很可能我们永远都不会用到不是自然联结的内部联结。</li>
<li>标准的联结(前一章中介绍的内部联结)返回所有数据,甚至相同的列多次出现。自然联结排除多次出现,使每个列只返回一次。</li>
<li>就是万一两个表有相同的列，去掉重复的，要自己实现<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select c.*,o.num</span><br><span class="line">from customers as c,orders as 0</span><br><span class="line">where c.id&#x3D;o.id;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h5><ul>
<li>许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。</li>
<li>例如<ul>
<li>对每个客户下了多少订单进行计数,包括那些至今尚未下订单的客户;</li>
</ul>
</li>
<li>如下为内部联结，检索所有客户及其订单:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select customers.id,orders.num</span><br><span class="line">from customers inner join orders</span><br><span class="line">on customers.id&#x3D;orders.id;</span><br></pre></td></tr></table></figure></li>
<li>外部联结语法蕾西，但是检索所有客户,包括那些没有订单的客户,就是左边的表每行都有，若右边表没有与之对应的，就为NULL<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select customers.id,orders.num</span><br><span class="line">from customers left outer join orders</span><br><span class="line">on customers.id&#x3D;orders.id;</span><br><span class="line">&#x2F;&#x2F;left 可以换成right，就变成右边的表每行否有</span><br><span class="line">&#x2F;&#x2F;检索结果</span><br><span class="line">id  num</span><br><span class="line">1   11</span><br><span class="line">2   12</span><br><span class="line">3   NULL</span><br><span class="line">4   10</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-使用带聚集函数的联结"><a href="#3-使用带聚集函数的联结" class="headerlink" title="3. 使用带聚集函数的联结"></a>3. 使用带聚集函数的联结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select customers.id,count(orders.num) as num_ord</span><br><span class="line">from customers left outer join orders</span><br><span class="line">on customers.id&#x3D;orders.id</span><br><span class="line">group by customers.id</span><br></pre></td></tr></table></figure>

<h3 id="4-使用联结和联结条件"><a href="#4-使用联结和联结条件" class="headerlink" title="4. 使用联结和联结条件"></a>4. 使用联结和联结条件</h3><ul>
<li>注意所使用的联结类型。一般我们使用内部联结,但使用外部联<br>结也是有效的。</li>
<li>保证使用正确的联结条件,否则将返回不正确的数据。</li>
<li>应该总是提供联结条件,否则会得出笛卡儿积。</li>
<li>在一个联结中可以包含多个表,甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的,一般也很有用,但应该在一起测试它们前,分别测试每个联结。这将使故障排除更为简单。</li>
</ul>
<h1 id="第十七章：组合查询"><a href="#第十七章：组合查询" class="headerlink" title="第十七章：组合查询"></a>第十七章：组合查询</h1><h3 id="1-有两种基本情况-其中需要使用组合查询"><a href="#1-有两种基本情况-其中需要使用组合查询" class="headerlink" title="1. 有两种基本情况,其中需要使用组合查询:"></a>1. 有两种基本情况,其中需要使用组合查询:</h3><ul>
<li>在单个查询中从不同的表返回类似结构的数据;</li>
<li>对单个表执行多个查询,按单个查询返回数据。</li>
</ul>
<h3 id="2-创建组合查询，union"><a href="#2-创建组合查询，union" class="headerlink" title="2. 创建组合查询，union"></a>2. 创建组合查询，union</h3><ul>
<li>假如需要价格小于等于 5 的所有物品的一个列表,而且还想包括供应商 1001 和 1002 生产的所有物品(不考虑价格)。当然,可以利用 WHERE 子句来完成此工作,不过这次我们将使用 UNION 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select v_id,p_id,p_price</span><br><span class="line">from products</span><br><span class="line">where p_price&lt;&#x3D;5</span><br><span class="line">union</span><br><span class="line">select v_id,p_id,p_price</span><br><span class="line">from products</span><br><span class="line">where v_id in (1001,1002)</span><br></pre></td></tr></table></figure>
<ul>
<li>where 子句格式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select v_id,p_id,p_price</span><br><span class="line">from products</span><br><span class="line">where p_price&lt;&#x3D;5 and v_id in (1001,1002)</span><br></pre></td></tr></table></figure></li>
<li>上面这个例子where比union简单，但有时候用union更简单</li>
</ul>
<h3 id="3-union规则"><a href="#3-union规则" class="headerlink" title="3. union规则"></a>3. union规则</h3><ul>
<li>UNION 必须由两条或两条以上的 SELECT 语句组成,语句之间用关键字 UNION 分隔(因此,如果组合4条 SELECT 语句,将要使用3个UNION 关键字)。</li>
<li>UNION 中的每个查询必须包含相同的列、表达式或聚集函数(不过各个列不需要以相同的次序列出)。</li>
<li>列数据类型必须兼容:类型不必完全相同,但必须是DBMS可以隐含地转换的类型(例如,不同的数值类型或不同的日期类型)。</li>
</ul>
<h3 id="4-包含或取消重复行，union-all"><a href="#4-包含或取消重复行，union-all" class="headerlink" title="4. 包含或取消重复行，union all"></a>4. 包含或取消重复行，union all</h3><ul>
<li>UNION 从查询结果集中自动去除了重复的行(换句话说,它的行为与。因为供应商 1002 生产<br>单条 SELECT 语句中使用多个 WHERE 子句条件一样)的一种物品的价格也低于 5 ,所以两条 SELECT 语句都返回该行。在使用UNION 时,重复的行被自动取消。</li>
<li>这是 UNION 的默认行为,但是如果需要,可以改变它。事实上,如果想返回所有匹配行,可使用 UNION ALL 而不是 UNION 。</li>
<li>如下这样，有重复行就重复显示<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select v_id,p_id,p_price</span><br><span class="line">from products</span><br><span class="line">where p_price&lt;&#x3D;5</span><br><span class="line">union all</span><br><span class="line">select v_id,p_id,p_price</span><br><span class="line">from products</span><br><span class="line">where v_id in (1001,1002)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-对组合查询结果排序-order-by"><a href="#5-对组合查询结果排序-order-by" class="headerlink" title="5. 对组合查询结果排序,order by"></a>5. 对组合查询结果排序,order by</h3><ul>
<li>在用 UNION 组合查询时,只能使用一条 ORDER BY 子句,它必须出现在最后一条 SELECT 语句之后。</li>
</ul>
<h1 id="第十八章：全文本搜索"><a href="#第十八章：全文本搜索" class="headerlink" title="第十八章：全文本搜索"></a>第十八章：全文本搜索</h1><h3 id="1-理解全文本搜索"><a href="#1-理解全文本搜索" class="headerlink" title="1. 理解全文本搜索"></a>1. 理解全文本搜索</h3><ul>
<li>并非所有引擎都支持全文本搜索<ul>
<li>两个最常使用的引擎为MyISAM 和 InnoDB ,前者支持全文本搜索,而后者不支持。</li>
</ul>
</li>
<li>正则表达式匹配的限制<ul>
<li>性能——通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行(而且这些搜索极少使用表索引)。因此,由于被搜索行数不断增加,这些搜索可能非常耗时。</li>
<li>明确控制——使用通配符和正则表达式匹配,很难(而且并不总是能)明确地控制匹配什么和不匹配什么。例如,指定一个词必须匹配,一个词必须不匹配,而一个词仅在第一个词确实匹配的情况下才可以匹配或者才可以不匹配。</li>
<li>智能化的结果——虽然基于通配符和正则表达式的搜索提供了非常灵活的搜索,但它们都不能提供一种智能化的选择结果的方法。例如,一个特殊词的搜索将会返回包含该词的所有行,而不区分包含单个匹配的行和包含多个匹配的行(按照可能是更好的匹配来排列它们)。类似,一个特殊词的搜索将不会找出不包含该词但包含其他相关词的行。</li>
</ul>
</li>
</ul>
<h3 id="2-使用全文本搜索"><a href="#2-使用全文本搜索" class="headerlink" title="2. 使用全文本搜索"></a>2. 使用全文本搜索</h3><ul>
<li>为了进行全文本搜索,必须索引被搜索的列,而且要随着数据的改变不断地重新索引。</li>
<li>一般在创建表时启用全文本搜索。 CREATE TABLE 语句接受 FULLTEXT 子句<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table students(</span><br><span class="line">    id  int not null auto_increment,</span><br><span class="line">    name not null,</span><br><span class="line">    primary key(id),</span><br><span class="line">    fulltext(name)</span><br><span class="line">)enging&#x3D;MyISAM</span><br></pre></td></tr></table></figure></li>
<li>使用Match()和Against()执行全文本搜索，其中Match() 指定被搜索的列,Against() 指定要使用的搜索表达式。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where Match(name) Against(&#39;hello&#39;);</span><br><span class="line">&#x2F;&#x2F;返回包含‘hello’的行</span><br><span class="line">&#x2F;&#x2F;like的方式</span><br><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where name like &#39;%hello%&#39;;</span><br></pre></td></tr></table></figure></li>
<li>上述两条 SELECT 语句都不包含 ORDER BY 子句。后者(使用 LIKE )以不特别有用的顺序返回数据。前者(使用全文本搜索)返回以文本匹配的良好程度排序的数据。两个行都包含词 rabbit ,但包含词 rabbit 作为第3个词的行的等级比作为第20个词的行高。这很重要。全文本搜索的一个重要部分就是对结果排序。具有较高等级的行先返回(因为这些行很可能是你真正想要的行)。</li>
<li>使 用 完 整 的 Match() 说 明 <ul>
<li>传 递 给 Match() 的 值 必 须 与FULLTEXT() 定义中的相同。如果指定多个列,则必须列出它们(而且次序正确)。</li>
</ul>
</li>
<li>搜索不区分大小写 <ul>
<li>除非使用 BINARY 方式(本章中没有介绍),否则全文本搜索不区分大小写。</li>
</ul>
</li>
<li>由于数据是索引的,全文本搜索比like快。</li>
</ul>
<h3 id="3-使用查询扩展"><a href="#3-使用查询扩展" class="headerlink" title="3. 使用查询扩展"></a>3. 使用查询扩展</h3><ul>
<li>什么是查询扩展<ul>
<li>查询扩展用来设法放宽所返回的全文本搜索结果的范围。考虑下面的情况。你想找出所有提到 anvils 的注释。只有一个注释包含词 anvils ,但你还想找出可能与你的搜索有关的所有其他行,即使它们不包含词anvils 。</li>
</ul>
</li>
<li>查询扩展原理<ul>
<li>这也是查询扩展的一项任务。在使用查询扩展时,MySQL对数据和索引进行两遍扫描来完成搜索:</li>
<li>首先,进行一个基本的全文本搜索,找出与搜索条件匹配的所有行;</li>
<li>其次,MySQL检查这些匹配行并选择所有有用的词(我们将会简要地解释MySQL如何断定什么有用,什么无用)。</li>
<li>再其次, MySQL再次进行全文本搜索,这次不仅使用原来的条件,而且还使用所有有用的词。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where Match(name) Against(&#39;hello&#39; with query expansion);</span><br><span class="line">&#x2F;&#x2F;返回不只是包含hello的行，和有hello的行关联较大的行也会返回</span><br></pre></td></tr></table></figure>
<ul>
<li>行越多越好 <ul>
<li>表中的行越多(这些行中的文本就越多),使用查询扩展返回的结果越好。</li>
</ul>
</li>
</ul>
<h3 id="4-布尔文本搜索"><a href="#4-布尔文本搜索" class="headerlink" title="4. 布尔文本搜索"></a>4. 布尔文本搜索</h3><ul>
<li><p>布尔方式,可以提供关于如下内容的细节:</p>
<ul>
<li>要匹配的词;</li>
<li>要排斥的词(如果某行包含这个词,则不返回该行,即使它包含其他指定的词也是如此);</li>
<li>排列提示(指定某些词比其他词更重要,更重要的词等级更高);</li>
<li>表达式分组;</li>
<li>另外一些内容。</li>
</ul>
</li>
<li><p>即使没有 FULLTEXT 索引也可以使用</p>
<ul>
<li>布尔方式不同于迄今为止使用的全文本搜索语法的地方在于,即使没有定义FULLTEXT 索引,也可以使用它。但这是一种非常缓慢的操作(其性能将随着数据量的增加而降低)。</li>
</ul>
</li>
<li><p>IN BOOLEAN MODE</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;匹配包含hello但不包含任意以lv开头的名字</span><br><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where Match(name) Against(&#39;hello -lv*&#39; in boolean mode);</span><br><span class="line">&#x2F;&#x2F;-lv*,排除lv*的词</span><br></pre></td></tr></table></figure>
</li>
<li><p>全文本布尔操作符</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>布尔操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>包含,词必须存在</td>
</tr>
<tr>
<td>-</td>
<td>排除,词必须不出现</td>
</tr>
</tbody></table>
<blockquote>
<p>|包含,而且增加等级值<br>&lt;|包含,且减少等级值<br>()|把词组成子表达式(允许这些子表达式作为一个组被包含、排除、排列等)<br>~|取消一个词的排序值<br>*|词尾的通配符<br>“”|定义一个短语(与单个词的列表不一样,它匹配整个短语以便包含或排除这个短语)</p>
</blockquote>
<ul>
<li><p>几个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;name中必须有gao和ling</span><br><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where Match(name) Against(&#39;+gao +ling&#39; in boolean mode);</span><br><span class="line">&#x2F;&#x2F;name中至少有gao和ling的一个</span><br><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where Match(name) Against(&#39;gao ling&#39; in boolean mode);</span><br><span class="line">&#x2F;&#x2F;name中匹配短语 rabbit bait 而不是匹配两个词 rabbit 和bait 。</span><br><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where Match(name) Against(&#39;&quot;gao ling&quot;&#39; in boolean mode);</span><br><span class="line">&#x2F;&#x2F;增加gao的等级，降低ling的等级</span><br><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where Match(name) Against(&#39;&gt;gao &lt;ling&#39; in boolean mode);</span><br></pre></td></tr></table></figure>
</li>
<li><p>排列而不排序</p>
<ul>
<li>在布尔方式中,不按等级值降序排序返回的行。</li>
</ul>
</li>
</ul>
<h3 id="5-一些说明"><a href="#5-一些说明" class="headerlink" title="5. 一些说明"></a>5. 一些说明</h3><pre><code>- 在索引全文本数据时,短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词(如果需要,这个数目可以更改)。
- MySQL带有一个内建的非用词(stopword)列表,这些词在索引全文本数据时总是被忽略。如果需要,可以覆盖这个列表(请参阅MySQL文档以了解如何完成此工作)。
- 许多词出现的频率很高,搜索它们没有用处(返回太多的结果)。因此,MySQL规定了一条50%规则,如果一个词出现在50%以上的行中,则将它作为一个非用词忽略。 50%规则不用于 IN BOOLEAN MODE 。
- 如果表中的行数少于3行,则全文本搜索不返回结果(因为每个词或者不出现,或者至少出现在50%的行中)。
- 忽略词中的单引号。例如, don&#39;t 索引为 dont 。
- 不具有词分隔符(包括日语和汉语)的语言不能恰当地返回全文本搜索结果。
- 如前所述,仅在 MyISAM 数据库引擎中支持全文本搜索</code></pre>
<h1 id="第十九章：插入数据"><a href="#第十九章：插入数据" class="headerlink" title="第十九章：插入数据"></a>第十九章：插入数据</h1><h3 id="1-数据插入"><a href="#1-数据插入" class="headerlink" title="1. 数据插入"></a>1. 数据插入</h3><ul>
<li>插入完整的行;</li>
<li>插入行的一部分;</li>
<li>插入多行;</li>
<li>插入某些查询的结果。</li>
</ul>
<h3 id="2-插入完整的行"><a href="#2-插入完整的行" class="headerlink" title="2. 插入完整的行"></a>2. 插入完整的行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into student</span><br><span class="line">values(</span><br><span class="line">    &#39;1001&#39;,</span><br><span class="line">    &#39;zhangsan&#39;,</span><br><span class="line">    &#39;male&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然这种语法很简单,但并不安全,应该尽量避免使用。上面的SQL语句高度依赖于表中列的定义次序,并且还依赖于其次序容易获得的信息。即使可得到这种次序信息,也不能保证下一次表结构变动后各个列保持完全相同的次序。因此,编写依赖于特定列次序的SQL语句是很不安全的。如果这样做,有时难免会出问题。</li>
<li>编写 INSERT 语句的更安全(不过更烦琐)的方法如下:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into student(</span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    sex</span><br><span class="line">)</span><br><span class="line">values(</span><br><span class="line">    &#39;1001&#39;,</span><br><span class="line">    &#39;zhangsan&#39;,</span><br><span class="line">    &#39;male&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>降低优先级，low priority<br>如果数据检索是最重要的(通常是这样),则你可以通过在INSERT 和 INTO 之间添加关键字 LOW_PRIORITY ,指示MySQL降低 INSERT 语句的优先级,如下所示:<ul>
<li>insert low priority into student</li>
<li>low priority 也适用于update和delete</li>
</ul>
</li>
</ul>
<h3 id="3-插入多个行"><a href="#3-插入多个行" class="headerlink" title="3. 插入多个行"></a>3. 插入多个行</h3><ul>
<li>可以适用多条insert语句</li>
<li>只要每条 INSERT 语句中的列名(和次序)相同,可以如下组合各语句:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into student(</span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    sex</span><br><span class="line">)</span><br><span class="line">values(</span><br><span class="line">    &#39;1001&#39;,</span><br><span class="line">    &#39;zhangsan&#39;,</span><br><span class="line">    &#39;male&#39;</span><br><span class="line">),(</span><br><span class="line">    &#39;1002&#39;,</span><br><span class="line">    &#39;lisi&#39;,</span><br><span class="line">    &#39;female&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-插入检索出的数据"><a href="#4-插入检索出的数据" class="headerlink" title="4. 插入检索出的数据"></a>4. 插入检索出的数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into student(</span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    sex</span><br><span class="line">)</span><br><span class="line">select id,name,sex</span><br><span class="line">from people;</span><br></pre></td></tr></table></figure>

<h1 id="第二十章：更新和删除数据"><a href="#第二十章：更新和删除数据" class="headerlink" title="第二十章：更新和删除数据"></a>第二十章：更新和删除数据</h1><h3 id="1-更新数据"><a href="#1-更新数据" class="headerlink" title="1. 更新数据"></a>1. 更新数据</h3><ul>
<li>更新表中特定行;</li>
<li>更新表中所有行。</li>
<li>不要省略 WHERE 子句 在使用 UPDATE 时一定要注意细心。因为稍不注意,就会更新表中所有行。</li>
<li>UPDATE 语句由3部分组成<ul>
<li>要更新的表;</li>
<li>列名和它们的新值;</li>
<li>确定要更新行的过滤条件。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update student</span><br><span class="line">set name&#x3D;&#39;hhh&#39;</span><br><span class="line">where id&#x3D;&#39;1001&#39;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>UPDATE 语句中可以使用子查询,使得能用 SELECT 语句检索出的数据更新列数据。</li>
<li>IGNORE 关键字<ul>
<li>如果用 UPDATE 语句更新多行,并且在更新这些行中的一行或多行时出一个现错误,则整个 UPDATE 操作被取消(错误发生前更新的所有行被恢复到它们原来的值)</li>
<li>即使是发生错误,也继续进行更新,可使用 IGNORE 关键字,如下所示:<ul>
<li>update ignore student…</li>
</ul>
</li>
</ul>
</li>
<li>为了删除某个列的值,可设置它为 NULL (假如表定义允许 NULL 值)。</li>
</ul>
<h3 id="2-删除数据"><a href="#2-删除数据" class="headerlink" title="2. 删除数据"></a>2. 删除数据</h3><ul>
<li><p>两种方式使用 DELETE :</p>
<ul>
<li>从表中删除特定的行;</li>
<li>从表中删除所有行。</li>
</ul>
</li>
<li><p>不要省略 WHERE 子句</p>
</li>
<li><p>从 customers 表中删除一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from student</span><br><span class="line">where id&#x3D;1001;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DELETE 不需要列名或通配符。 DELETE 删除整行而不是删除列。为了删除指定的列,请使用 UPDATE 语句。</p>
</li>
<li><p>删除表的内容而不是表</p>
</li>
<li><p>更快的删除</p>
<ul>
<li>如果想从表中删除所有行,不要使用 DELETE 。可使用 TRUNCATE TABLE 语句,它完成相同的工作,但速度更快( TRUNCATE 实际是删除原来的表并重新创建一个表,而不是逐行删除表中的数据)。</li>
</ul>
</li>
</ul>
<h3 id="3-更新和删除的指导原则"><a href="#3-更新和删除的指导原则" class="headerlink" title="3. 更新和删除的指导原则"></a>3. 更新和删除的指导原则</h3><ul>
<li>除非确实打算更新和删除每一行,否则绝对不要使用不带 WHERE子句的 UPDATE 或 DELETE 语句。</li>
<li>保证每个表都有主键(如果忘记这个内容,请参阅第15章),尽可能像 WHERE 子句那样使用它(可以指定各主键、多个值或值的范围)。</li>
<li>在对 UPDATE 或 DELETE 语句使用 WHERE 子句前,应该先用 SELECT 进行测试,保证它过滤的是正确的记录,以防编写的 WHERE 子句不正确。</li>
<li>使用强制实施引用完整性的数据库(关于这个内容,请参阅第15章),这样MySQL将不允许删除具有与其他表相关联的数据的行。</li>
</ul>
<h1 id="第二十一章：创建和操纵表"><a href="#第二十一章：创建和操纵表" class="headerlink" title="第二十一章：创建和操纵表"></a>第二十一章：创建和操纵表</h1><h3 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1. 创建表"></a>1. 创建表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table students(</span><br><span class="line">    id int not null auto_increment,</span><br><span class="line">    name char(20) not null,</span><br><span class="line">    sex char(10) null,</span><br><span class="line">    is_good int null default 1,</span><br><span class="line">    primary key(id)</span><br><span class="line">)enging&#x3D;InnoDB;</span><br></pre></td></tr></table></figure>
<ul>
<li>主键<ul>
<li>主键可以有多个列，但每行必须唯一</li>
<li>primary key(id1，id2)</li>
</ul>
</li>
<li>auto_increment<ul>
<li>每个表只允许一个 AUTO_INCREMENT 列,而且它必须被索引(如,通过使它成为主键)。</li>
<li>AUTO_INCREMENT 告诉MySQL,本列每当增加一行时自动增量。</li>
<li>select last_insert_id()获得最后一个auto_increment值</li>
</ul>
</li>
<li>default设置默认值</li>
</ul>
<h5 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h5><ul>
<li><p>MySQL与其他DBMS不一样,它具有多种引擎。</p>
</li>
<li><p>如果省略 ENGINE= 语句,则,多数SQL语句都会默认使用它。使用默认引擎(很可能是 MyISAM)</p>
</li>
<li><p>几个需要知道的引擎:</p>
<ul>
<li>InnoDB 是一个可靠的事务处理引擎(参见第26章),它不支持全文本搜索;</li>
<li>MEMORY 在功能等同于 MyISAM ,但由于数据存储在内存(不是磁盘)中,速度很快(特别适合于临时表);</li>
<li>MyISAM 是一个性能极高的引擎,它支持全文本搜索(参见第18章),但不支持事务处理。</li>
</ul>
</li>
<li><p>引擎类型可以混用。希望支持事务处理的话使用 InnoDB,需要支持全文本搜索的话使用 MyISAM</p>
</li>
<li><p>外键不能跨引擎混用引擎类型有一个大缺陷。外键(用于强制实施引用完整性,如第1章所述)不能跨引擎,即使用一个引擎的表不能引用具有使用不同引擎的表的外键。</p>
</li>
</ul>
<h3 id="2-更新表，alert-table"><a href="#2-更新表，alert-table" class="headerlink" title="2. 更新表，alert table"></a>2. 更新表，alert table</h3><ul>
<li>理想状态下,当表中存储数据以后,该表就不应该再被更新。</li>
<li>alert更改<ul>
<li>在 ALTER TABLE 之后给出要更改的表名(该表必须存在,否则将出错);</li>
<li>所做更改的列表。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert table students</span><br><span class="line">add phone char(20);</span><br><span class="line"></span><br><span class="line">alert table students</span><br><span class="line">drop column phone;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>ALTER TABLE 的一种常见用途是定义外键。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert table students</span><br><span class="line">add constraint fk_students_class</span><br><span class="line">foreign key(id) references class(stu_id);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-删除表"><a href="#3-删除表" class="headerlink" title="3. 删除表"></a>3. 删除表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop table students;</span><br></pre></td></tr></table></figure>

<h3 id="4-重命名表"><a href="#4-重命名表" class="headerlink" title="4. 重命名表"></a>4. 重命名表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rename table students to students2,</span><br><span class="line">            class to class2;</span><br></pre></td></tr></table></figure>

<h1 id="第二十二章：使用视图"><a href="#第二十二章：使用视图" class="headerlink" title="第二十二章：使用视图"></a>第二十二章：使用视图</h1><h3 id="1-视图"><a href="#1-视图" class="headerlink" title="1. 视图"></a>1. 视图</h3><ul>
<li>视图是虚拟的表。与包含数据的表不一样,视图只包含使用时动态检索数据的查询。</li>
<li>如下例：从两个表中检索数据<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,grade</span><br><span class="line">from students,grades</span><br><span class="line">where students.id&#x3D;grades.id and students.id&#x3D;1111;</span><br></pre></td></tr></table></figure></li>
<li>若是上面这种方式，任何需要这个数据的人都必须理解相关表的结构,并且知道如何创建查询和对表进行联结。为了检索其他产品(或多个产品)的相同数据,必须修改最后的 WHERE 子句。</li>
<li>可以使用试图作为虚拟表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,grade</span><br><span class="line">from students_grades</span><br><span class="line">where id&#x3D;1111;</span><br><span class="line">&#x2F;&#x2F;students_grades是一个试图</span><br></pre></td></tr></table></figure></li>
<li>性能问题<ul>
<li>因为视图不包含数据,所以每次使用视图时,都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图,可能会发现性能下降得很厉害。因此,在部署使用了大量视图的应用前,应该进行测试</li>
</ul>
</li>
</ul>
<h3 id="2-视图的应用"><a href="#2-视图的应用" class="headerlink" title="2. 视图的应用"></a>2. 视图的应用</h3><ul>
<li>重用SQL语句。</li>
<li>简化复杂的SQL操作。在编写查询后,可以方便地重用它而不必知道它的基本查询细节。</li>
<li>使用表的组成部分而不是整个表。</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<h3 id="3-视图的规则和限制"><a href="#3-视图的规则和限制" class="headerlink" title="3. 视图的规则和限制"></a>3. 视图的规则和限制</h3><ul>
<li>与表一样,视图必须唯一命名(不能给视图取与别的视图或表相同的名字)。</li>
<li>对于可以创建的视图数目没有限制。</li>
<li>为了创建视图,必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</li>
<li>视图可以嵌套,即可以利用从其他视图中检索数据的查询来构造一个视图。</li>
<li>ORDER BY 可以用在视图中,但如果从该视图检索数据 SELECT 中也含有 ORDER BY ,那么该视图中的 ORDER BY 将被覆盖。</li>
<li>视图不能索引,也不能有关联的触发器或默认值。</li>
<li>视图可以和表一起使用。例如,编写一条联结表和视图的 SELECT语句。</li>
</ul>
<h3 id="4-使用视图"><a href="#4-使用视图" class="headerlink" title="4. 使用视图"></a>4. 使用视图</h3><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><ul>
<li>视图用 CREATE VIEW 语句来创建。</li>
<li>使用 SHOW CREATE VIEW viewname ;来查看创建视图的语句。</li>
<li>用 DROP 删除视图,其语法为 DROP VIEW viewname;。</li>
<li>更新视图时,可以先用DROP再用CREATE,也可以直接用CREATE ORREPLACE VIEW。如果要更新的视图不存在,则第 2 条更新语句会创建一个视图;如果要更新的视图存在,则第 2 条更新语句会替换原有视图。</li>
</ul>
<h5 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create view student_class as</span><br><span class="line">select student.id,student.name,class.cls_id</span><br><span class="line">from student,class</span><br><span class="line">where student.id&#x3D;class.stu_id</span><br></pre></td></tr></table></figure>

<h5 id="用视图重新格式化检索出的数据"><a href="#用视图重新格式化检索出的数据" class="headerlink" title="用视图重新格式化检索出的数据"></a>用视图重新格式化检索出的数据</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select Concat(RTrim(name),&#39;(&#39;,RTrim(id),&#39;)&#39;) as new_line</span><br><span class="line">from student</span><br><span class="line">order by name;</span><br></pre></td></tr></table></figure>
<ul>
<li>若经常使用上述格式，可以写成视图<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create view student_new as</span><br><span class="line">select Concat(RTrim(name),&#39;(&#39;,RTrim(id),&#39;)&#39;) as new_line</span><br><span class="line">from student</span><br><span class="line">order by name;</span><br><span class="line">&#x2F;&#x2F;查询时</span><br><span class="line">select *</span><br><span class="line">from student_new</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h5><ul>
<li>和上面的格式化类似</li>
</ul>
<h5 id="视图更新"><a href="#视图更新" class="headerlink" title="视图更新"></a>视图更新</h5><ul>
<li>视图是可以更新的，可以使用insert,updata,delete,同时对基表也会更新，但是更新有许多限制</li>
<li>一般,应该将视图用于检索( SELECT 语句)，而不用于更新( INSERT 、 UPDATE 和 DELETE )。</li>
</ul>
<h1 id="第二十三章：使用存储过程"><a href="#第二十三章：使用存储过程" class="headerlink" title="第二十三章：使用存储过程"></a>第二十三章：使用存储过程</h1><h3 id="1-存储过程"><a href="#1-存储过程" class="headerlink" title="1. 存储过程"></a>1. 存储过程</h3><ul>
<li>存储过程简单来说,就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件,虽然它们的作用不仅限于批处理。</li>
<li>就像封装的函数</li>
</ul>
<h3 id="2-为什么使用存储过程"><a href="#2-为什么使用存储过程" class="headerlink" title="2. 为什么使用存储过程"></a>2. 为什么使用存储过程</h3><h5 id="优点：简单、安全、高性能"><a href="#优点：简单、安全、高性能" class="headerlink" title="优点：简单、安全、高性能"></a>优点：简单、安全、高性能</h5><ul>
<li>通过把处理封装在容易使用的单元中,简化复杂的操作(正如前面例子所述)。</li>
<li>由于不要求反复建立一系列处理步骤,这保证了数据的完整性。如果所有开发人员和应用程序都使用同一(试验和测试)存储过<br>程,则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多,出错的可能性就越大。防止错误保证了数据的一致性。</li>
<li>简化对变动的管理。如果表名、列名或业务逻辑(或别的内容)有变化,只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。</li>
<li>提高性能。因为使用存储过程比使用单独的SQL语句要快。</li>
<li>存在一些只能用在单个请求中的MySQL元素和特性,存储过程可以使用它们来编写功能更强更灵活的代码(在下一章的例子中可<br>以看到。</li>
</ul>
<h5 id="缺点：复杂"><a href="#缺点：复杂" class="headerlink" title="缺点：复杂"></a>缺点：复杂</h5><ul>
<li>一般来说,存储过程的编写比基本SQL语句复杂,编写存储过程需要更高的技能,更丰富的经验。</li>
<li>你可能没有创建存储过程的安全访问权限。许多数据库管理员限制存储过程的创建权限,允许用户使用存储过程,但不允许他们创建存储过程。</li>
</ul>
<h3 id="3-执行存储过程，call"><a href="#3-执行存储过程，call" class="headerlink" title="3. 执行存储过程，call"></a>3. 执行存储过程，call</h3><ul>
<li>执行名为 productpricing 的存储过程,它计算并返回产品的最低、最高和平均价格。存储在传进去的参数里<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call productpricing(</span><br><span class="line">    @pricelow,</span><br><span class="line">    @pricehigh,</span><br><span class="line">    @priceaverage</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-创建存储过程"><a href="#4-创建存储过程" class="headerlink" title="4. 创建存储过程"></a>4. 创建存储过程</h3><ul>
<li>返回产品平均价格的存储过程。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure productpricing()</span><br><span class="line">begin</span><br><span class="line">    select avg(prod_price)</span><br><span class="line">    as avg_price</span><br><span class="line">    from product;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure></li>
<li>调用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call productprining();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-删除存储过程"><a href="#5-删除存储过程" class="headerlink" title="5. 删除存储过程"></a>5. 删除存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;删除没有括号()</span><br><span class="line">call procedure productprining;</span><br></pre></td></tr></table></figure>

<h3 id="6-使用参数"><a href="#6-使用参数" class="headerlink" title="6. 使用参数"></a>6. 使用参数</h3><ul>
<li><p>变量(variable)</p>
<ul>
<li>内存中一个特定的位置,用来临时存储数据。</li>
</ul>
</li>
<li><p>变量名 </p>
<ul>
<li>所有MySQL变量都必须以 @ 开始<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure productpricing(</span><br><span class="line">    out pl decimal(8,2),</span><br><span class="line">    out ph decimal(8,2)</span><br><span class="line">)</span><br><span class="line">begin</span><br><span class="line">    select min(prod_price)</span><br><span class="line">    into pl</span><br><span class="line">    from product;</span><br><span class="line">    select max(prod_price)</span><br><span class="line">    into ph</span><br><span class="line">    from product;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>pl，ph为从外面传进的变量(相当于引用参数),decimal指定为十进制类型</p>
</li>
<li><p>out指明为传进，MySQL支持 IN (传递给存储过程)、 OUT (从存储过程传出,如这里所用)和 INOUT (对存储过程传入和传出)类型的参数。</p>
</li>
<li><p>参数的数据类型，见后面附录D</p>
</li>
<li><p>存储过程的参数允许的数据类型与表中使用的数据类型相同。</p>
</li>
<li><p>记录集不是允许的类型,因此,不能通过一个参数返回多个行和列。</p>
</li>
<li><p>变量使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call productpricing(</span><br><span class="line">    @pricelow,</span><br><span class="line">    @pricehigh</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;调用上述call后，如下查看变量内容</span><br><span class="line">select @pricelow;</span><br></pre></td></tr></table></figure></li>
<li><p>使用in传参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure productpricing(</span><br><span class="line">    in num int,</span><br><span class="line">    out total decimal(8,2)</span><br><span class="line">)</span><br><span class="line">begin</span><br><span class="line">    select prod_total</span><br><span class="line">    from product</span><br><span class="line">    where id&#x3D;num</span><br><span class="line">    into pl;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="7-建立智能存储过程"><a href="#7-建立智能存储过程" class="headerlink" title="7. 建立智能存储过程"></a>7. 建立智能存储过程</h3><ul>
<li>就是更复杂的过程</li>
<li>COMMENT 关键字<ul>
<li>在 CREATE PROCEDURE 语句中可以包含了 COMMENT 值。它不是必需的,但如果给出,将在 SHOW PROCEDURE STATUS 的结果中显示。</li>
</ul>
</li>
<li>注释<ul>
<li>两个杠表示注释：–</li>
</ul>
</li>
<li>局部变量<ul>
<li>在begin,end中声明</li>
<li>declare var int default 0;</li>
</ul>
</li>
<li>完整例子：需要获得与以前一样的订单合计,但需要对合计增加营业税,不过只针对某些顾客(或许是你所在州中那些顾客)。那么,需要做下面几件事情:<ul>
<li>获得合计(与以前一样);</li>
<li>把营业税有条件地添加到合计;</li>
<li>返回合计(带或不带税)。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure ordertotal(</span><br><span class="line">    in onum int,</span><br><span class="line">    int taxable boolean,</span><br><span class="line">    out ototal decimal(8,2)</span><br><span class="line">)comment &#39;this is a test&#39;</span><br><span class="line">begin</span><br><span class="line">    declare total decimal(8,2),</span><br><span class="line">    declare taxrate int default 6;</span><br><span class="line">    select sum(item_price*quantity)</span><br><span class="line">    from orderitems</span><br><span class="line">    where order_num&#x3D;onum</span><br><span class="line">    into total;</span><br><span class="line">    if taxable then</span><br><span class="line">        select total+(total&#x2F;100*taxrate)</span><br><span class="line">        into total;</span><br><span class="line">    ebd if;</span><br><span class="line">    select total into ototal;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="8-检查存储过程"><a href="#8-检查存储过程" class="headerlink" title="8. 检查存储过程"></a>8. 检查存储过程</h3><ul>
<li>显示用来创建一个存储过程的 CREATE 语句<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create procedure print;</span><br></pre></td></tr></table></figure></li>
<li>获得包括何时、由谁创建等详细信息的存储过程列表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show procedure status;</span><br></pre></td></tr></table></figure></li>
<li>限制过程状态结果,SHOW PROCEDURE STATUS 列出所有存储过程。为限制其输出,可使用 LIKE 指定一个过滤模式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show procedure status like &#39;lvkou&#39;;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="第二十四章：使用游标"><a href="#第二十四章：使用游标" class="headerlink" title="第二十四章：使用游标"></a>第二十四章：使用游标</h1><h3 id="1-游标"><a href="#1-游标" class="headerlink" title="1. 游标"></a>1. 游标</h3><ul>
<li>游标(cursor)是一个存储在MySQL服务器上的数据库查询,它不是一条 SELECT 语句,而是被该语句检索出来的结果集。在存储了游标之后,应用程序可以根据需要滚动或浏览其中的数据。</li>
<li>只能用于存储过程不像多数DBMS,MySQL游标只能用于存储过程(和函数)。</li>
</ul>
<h3 id="2-游标使用步骤"><a href="#2-游标使用步骤" class="headerlink" title="2. 游标使用步骤"></a>2. 游标使用步骤</h3><ul>
<li>在能够使用游标前,必须声明(定义)它。这个过程实际上没有检索数据,它只是定义要使用的 SELECT 语句。</li>
<li>一旦声明后,必须打开游标以供使用。这个过程用前面定义的SELECT 语句把数据实际检索出来。</li>
<li>对于填有数据的游标,根据需要取出(检索)各行。</li>
<li>在结束游标使用时,必须关闭游标。</li>
</ul>
<h3 id="3-创建游标"><a href="#3-创建游标" class="headerlink" title="3. 创建游标"></a>3. 创建游标</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure func()</span><br><span class="line">begin</span><br><span class="line">    declere ordernumbers cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个存储过程并没有做很多事情,DECLARE 语句用来定义和命名游标,这里为 ordernumbers 。 存储过程处理完成后,游标就消失(因为它局限于存储过程)。</li>
</ul>
<h3 id="4-打开和关闭游标"><a href="#4-打开和关闭游标" class="headerlink" title="4. 打开和关闭游标"></a>4. 打开和关闭游标</h3><ul>
<li>打开<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open oredernumbers;</span><br></pre></td></tr></table></figure></li>
<li>在处理 OPEN 语句时执行查询,存储检索出的数据以供浏览和滚动。游标处理完成后,应当使用如下语句关闭游标:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">close oredernumbers;</span><br></pre></td></tr></table></figure></li>
<li>隐含关闭 <ul>
<li>如果你不明确关闭游标, MySQL将会在到达 END 语句时自动关闭它。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure func()</span><br><span class="line">begin</span><br><span class="line">    declare ordernumbers cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line">    open ordernumbers;</span><br><span class="line">    -- do something;</span><br><span class="line">    close ordernumbers;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h3 id="5-使用游标数据"><a href="#5-使用游标数据" class="headerlink" title="5. 使用游标数据"></a>5. 使用游标数据</h3><h5 id="简单fetch"><a href="#简单fetch" class="headerlink" title="简单fetch"></a>简单fetch</h5><ul>
<li>在一个游标被打开后,可以使用 FETCH 语句分别访问它的每一行。FETCH 指定检索什么数据(所需的列),检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针,使下一条 FETCH 语句检索下一行(不重复读取同一行)。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure func()</span><br><span class="line">begin</span><br><span class="line">    declare temp int;</span><br><span class="line">    declare ordernumbers cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line">    open ordernumbers;</span><br><span class="line">    fetch ordernumbers into temp;</span><br><span class="line">    close ordernumbers;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure></li>
<li>其中 FETCH 用来检索当前行的 order_num 列(将自动从第一行开始)到一个名为 o 的局部声明的变量中。对检索出的数据不做任何处理。</li>
</ul>
<h5 id="循环检索数据"><a href="#循环检索数据" class="headerlink" title="循环检索数据"></a>循环检索数据</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure func()</span><br><span class="line">begin</span><br><span class="line">    declare done boolean default 0;</span><br><span class="line">    declare temp int;</span><br><span class="line">    declare ordernumbers cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line">    declare continue handler for sqlstate &#39;02000&#39; set done&#x3D;1;</span><br><span class="line">    open ordernumbers;</span><br><span class="line">    -- loop through all rows</span><br><span class="line">    repeat</span><br><span class="line">        fetch ordernumbers into temp;</span><br><span class="line">    until done end repeat;</span><br><span class="line">    close ordernumbers;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>定义了一个 CONTINUE HANDLER ,它是在条件出现时被执行的代码。这里,它指出当 SQLSTATE ‘02000’ 出现时, SET done=1。 SQLSTATE’02000’ 是一个未找到条件,当 REPEAT 由于没有更多的行供循环而不能继续时,出现这个条件。</p>
</li>
<li><p>在过程中可以调用过程，可以在循环中进行更复杂的操作，具体情况具体分析。</p>
</li>
</ul>
<h1 id="第二十五章：使用触发器"><a href="#第二十五章：使用触发器" class="headerlink" title="第二十五章：使用触发器"></a>第二十五章：使用触发器</h1><h3 id="1-触发器"><a href="#1-触发器" class="headerlink" title="1. 触发器"></a>1. 触发器</h3><ul>
<li>触发器是MySQL响应以下任意语句而<br>自动执行的一条MySQL语句(或位于BEGIN 和 END 语句之间的一组语句):<ul>
<li>DELETE ;</li>
<li>INSERT ;</li>
<li>UPDATE 。</li>
<li>其他MySQL语句不支持触发器。</li>
</ul>
</li>
</ul>
<h3 id="2-创建触发器，create-trigger"><a href="#2-创建触发器，create-trigger" class="headerlink" title="2. 创建触发器，create trigger"></a>2. 创建触发器，create trigger</h3><ul>
<li>在创建触发器时,需要给出4条信息:</li>
<li>唯一的触发器名;</li>
<li>触发器关联的表;</li>
<li>触发器应该响应的活动( DELETE 、 INSERT 或 UPDATE );</li>
<li>触发器何时执行(处理之前或之后)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger t_name</span><br><span class="line">after insert on products</span><br><span class="line">for each row </span><br><span class="line">select &#39;Product added&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个触发器还指定 FOR EACH ROW ,因此代码对每个插入行执行。在这个例子中,文本 Product added 将对每个插入的行显示一次。</li>
<li>仅支持表<ul>
<li>只有表才支持触发器,视图不支持(临时表也不支持)</li>
<li>每个表最多支持6个触发器</li>
</ul>
</li>
<li>触发器失败 <ul>
<li>如果 BEFORE 触发器失败,则MySQL将不执行请求的操作。此外,如果 BEFORE 触发器或语句本身失败, MySQL将不执行 AFTER 触发器(如果有的话)</li>
</ul>
</li>
</ul>
<h3 id="3-删除触发器"><a href="#3-删除触发器" class="headerlink" title="3. 删除触发器"></a>3. 删除触发器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop trigger t_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>触发器不能更新或覆盖。为了修改一个触发器,必须先删除它,然后再重新创建。</li>
</ul>
<h3 id="4-使用触发器"><a href="#4-使用触发器" class="headerlink" title="4. 使用触发器"></a>4. 使用触发器</h3><h5 id="INSERT-触发器"><a href="#INSERT-触发器" class="headerlink" title="INSERT 触发器"></a>INSERT 触发器</h5><ul>
<li>INSERT 触发器在 INSERT 语句执行之前或之后执行。需要知道以下几点:</li>
<li>在 INSERT 触发器代码内,可引用一个名为 NEW 的虚拟表,访问被插入的行;</li>
<li>在 BEFORE INSERT 触发器中, NEW 中的值也可以被更新(允许更改被插入的值);</li>
<li>对于 AUTO_INCREMENT 列, NEW 在 INSERT 执行之前包含 0 ,在 INSERT执行之后包含新的自动生成值。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger t_name</span><br><span class="line">after insert on products</span><br><span class="line">for each row </span><br><span class="line">select NEW.id;</span><br></pre></td></tr></table></figure></li>
<li>此触发器必须按照 AFTER INSERT 执行,因为在 BEFOREINSERT 语句执行之前,新 id 还没有生成。对于 products 的每次插入使用这个触发器将总是返回新的id号。</li>
</ul>
<h5 id="DELETE-触发器"><a href="#DELETE-触发器" class="headerlink" title="DELETE 触发器"></a>DELETE 触发器</h5><ul>
<li>DELETE 触发器在 DELETE 语句执行之前或之后执行。需要知道以下两点:<ul>
<li>在 DELETE 触发器代码内,你可以引用一个名为 OLD 的虚拟表,访问被删除的行;</li>
<li>OLD 中的值全都是只读的,不能更新。</li>
</ul>
</li>
<li>下面的例子演示使用 OLD 保存将要被删除的行到一个存档表中:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger t_name</span><br><span class="line">after insert on products</span><br><span class="line">for each row </span><br><span class="line">begin</span><br><span class="line">    insert into backup(id,name)</span><br><span class="line">    values(old.id,old.name);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="UPDATE触发器"><a href="#UPDATE触发器" class="headerlink" title="UPDATE触发器"></a>UPDATE触发器</h5><ul>
<li>UPDATE 触发器在 UPDATE 语句执行之前或之后执行。需要知道以下几点:<ul>
<li>在 UPDATE 触发器代码中,你可以引用一个名为 OLD 的虚拟表访问以前( UPDATE 语句前)的值,引用一个名为 NEW 的虚拟表访问新更新的值;</li>
<li>在 BEFORE UPDATE 触发器中, NEW 中的值可能也被更新(允许更改将要用于 UPDATE 语句中的值);</li>
<li>OLD 中的值全都是只读的,不能更新。</li>
</ul>
</li>
</ul>
<h1 id="第二十六章：管理事务处理"><a href="#第二十六章：管理事务处理" class="headerlink" title="第二十六章：管理事务处理"></a>第二十六章：管理事务处理</h1><h3 id="1-事务处理"><a href="#1-事务处理" class="headerlink" title="1. 事务处理"></a>1. 事务处理</h3><ul>
<li><p>并非所有引擎都支持事务处理</p>
<ul>
<li>MyISAM 和 InnoDB 是两种最常使用的引擎。前者不支持明确的事务处理管理,而后者支持。</li>
</ul>
</li>
<li><p>事务处理(transaction processing)可以用来维护数据库的完整性,它保证成批的MySQL操作要么完全执行,要么完全不执行。</p>
</li>
<li><p>几个术语:</p>
<ul>
<li>事务( transaction )指一组SQL语句;</li>
<li>回退( rollback )指撤销指定SQL语句的过程;</li>
<li>提交( commit )指将未存储的SQL语句结果写入数据库表;</li>
<li>保留点( savepoint )指事务处理中设置的临时占位符(place-holder),你可以对它发布回退(与回退整个事务处理不同)。</li>
</ul>
</li>
</ul>
<h3 id="2-控制事务处理"><a href="#2-控制事务处理" class="headerlink" title="2. 控制事务处理"></a>2. 控制事务处理</h3><h5 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start transaction</span><br></pre></td></tr></table></figure>

<h5 id="使用rollback"><a href="#使用rollback" class="headerlink" title="使用rollback"></a>使用rollback</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from ordertotals;</span><br><span class="line">strat transaction;</span><br><span class="line">delete from ordertotals;</span><br><span class="line">select *</span><br><span class="line">from ordertotals;</span><br><span class="line">rollback;</span><br><span class="line">select *</span><br><span class="line">from ordertotals;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述rollback取消了delete操作</li>
<li>ROLLBACK 只能在一个事务处理内使用(在执行一条 STARTTRANSACTION 命令之后)。</li>
<li>哪些语句可以回退?<ul>
<li>insert,update,delete可以回退</li>
<li>create和drop不能回退</li>
</ul>
</li>
</ul>
<h5 id="使用commit"><a href="#使用commit" class="headerlink" title="使用commit"></a>使用commit</h5><ul>
<li>隐含提交<ul>
<li>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交(implicit commit),即提交(写或保存)操作是自动进行的。</li>
</ul>
</li>
<li>在事务处理块中,提交不会隐含地进行。为进行明确的提交,使用 COMMIT 语句,如下所示:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strat transaction;</span><br><span class="line">delete from ordertotals</span><br><span class="line">where id&#x3D;111;</span><br><span class="line">delete from ordertotals</span><br><span class="line">where id&#x3D;222;</span><br><span class="line">commit;&#x2F;&#x2F;显式提交</span><br></pre></td></tr></table></figure></li>
<li>若提交前出错，自动撤销事务中的所有能撤销的操作(create,drop不能撤销)。</li>
<li>隐含事务关闭<ul>
<li>当 COMMIT 或 ROLLBACK 语句执行后,事务会自动关闭(将来的更改会隐含提交)。</li>
</ul>
</li>
</ul>
<h5 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h5><ul>
<li>为了支持回退部分事务处理,必须能在事务处理块中合适的位置放置占位符。这样,如果需要回退,可以回退到某个占位符。</li>
<li>创建占位符<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">savepoint point1;</span><br></pre></td></tr></table></figure></li>
<li>每个保留点都取标识它的唯一名字,以便在回退时,MySQL知道要回退到何处。为了回退到本例给出的保留点,可如下进行:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rollback to point1;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="更改默认的提交行为"><a href="#更改默认的提交行为" class="headerlink" title="更改默认的提交行为"></a>更改默认的提交行为</h5><ul>
<li>默认的MySQL行为是自动提交所有更改。换句话说,任何时候你执行一条MySQL语句,该语句实际上都是针对表执行的,而且所做的更改立即生效。为指示MySQL不自动提交更改,需要使用以下语句:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set autocommit&#x3D;0;</span><br></pre></td></tr></table></figure></li>
<li>autocommit 标志决定是否自动提交更改,不管有没有 COMMIT语句。设置 autocommit 为 0 (假)指示MySQL不自动提交更改(直到 autocommit 被设置为真为止)。</li>
</ul>
<h1 id="第二十七章：全球化和本地化"><a href="#第二十七章：全球化和本地化" class="headerlink" title="第二十七章：全球化和本地化"></a>第二十七章：全球化和本地化</h1><ul>
<li>本章介绍MySQL处理不同字符集和语言的基础知识。</li>
</ul>
<h3 id="1-字符集和校对顺序"><a href="#1-字符集和校对顺序" class="headerlink" title="1. 字符集和校对顺序"></a>1. 字符集和校对顺序</h3><ul>
<li>术语<ul>
<li>字符集为字母和符号的集合;</li>
<li>编码为某个字符集成员的内部表示;</li>
<li>校对为规定字符如何比较的指令。</li>
</ul>
</li>
<li>使用何种字符集和校对的决定在服务器、数据库和表级进行。</li>
<li>查看所支持的字符集完整列表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show character set;</span><br></pre></td></tr></table></figure></li>
<li>查看所支持校对的完整列表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show collation;</span><br></pre></td></tr></table></figure></li>
<li>创建表的时候指定字符集和校对顺序。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table mytable(</span><br><span class="line">    column1 int,</span><br><span class="line">    column2 char(10)</span><br><span class="line">)default character set hebrew</span><br><span class="line">collate hebrew_general_ci;</span><br><span class="line">&#x2F;&#x2F;不指定的话用数据库默认的</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第二十八章：安全管理"><a href="#第二十八章：安全管理" class="headerlink" title="第二十八章：安全管理"></a>第二十八章：安全管理</h1><h3 id="1-访问控制"><a href="#1-访问控制" class="headerlink" title="1. 访问控制"></a>1. 访问控制</h3><ul>
<li>MySQL服务器的安全基础是:用户应该对他们需要的数据具有适当的访问权,既不能多也不能少。</li>
<li>在现实世界的日常工作中,决不能使用 root 。应该创建一系列的账号,有的用于管理,有的供用户使用,有的供开发人员使用,等等。</li>
</ul>
<h3 id="2-管理用户"><a href="#2-管理用户" class="headerlink" title="2. 管理用户"></a>2. 管理用户</h3><ul>
<li>MySQL用户账号和信息存储在名为 mysql 的MySQL数据库中。</li>
</ul>
<h5 id="创建用户账号"><a href="#创建用户账号" class="headerlink" title="创建用户账号"></a>创建用户账号</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user lvkou</span><br><span class="line">identified by &#39;123456&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li>重新命名一个用户账号,使用 RENAME USER 语句<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rename user lvkou to test;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="删除用户账号"><a href="#删除用户账号" class="headerlink" title="删除用户账号"></a>删除用户账号</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop user lvkou;</span><br></pre></td></tr></table></figure>

<h5 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h5><ul>
<li>在创建用户账号后,必须接着分配访问权限。新创建的用户账号没有访问权限。它们能登录MySQL,但不能看到数据,不能执行任何数据库操作。</li>
<li>查看赋予用户账号的权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show grants for lvkou;</span><br></pre></td></tr></table></figure></li>
<li>使用grant语句赋予权限<ul>
<li>要授予的权限;</li>
<li>被授予访问权限的数据库或表;</li>
<li>用户名。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant select on student.* to lvkou;</span><br><span class="line">&#x2F;&#x2F;赋予lvkou用户在student数据库中所有表的查询权限</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>撤销权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">revoke select on student.* from lvkou;</span><br></pre></td></tr></table></figure></li>
<li>GRANT 和 REVOKE 可在几个层次上控制访问权限:<ul>
<li>整个服务器,使用 GRANT ALL 和 REVOKE ALL;</li>
<li>整个数据库,使用 ON database.*;</li>
<li>特定的表,使用 ON database.table;</li>
<li>特定的列;</li>
<li>特定的存储过程。</li>
</ul>
</li>
</ul>
<h5 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h5><table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ALL</td>
<td>除GRANT OPTION外的所有权限</td>
</tr>
<tr>
<td>ALTER</td>
<td>使用ALTER TABLE</td>
</tr>
<tr>
<td>ALTER ROUTINE</td>
<td>使用ALTER PROCEDURE和DROP PROCEDURE</td>
</tr>
<tr>
<td>CREATE</td>
<td>使用CREATE TABLE</td>
</tr>
<tr>
<td>CREATE ROUTINE</td>
<td>使用CREATE PROCEDURE</td>
</tr>
<tr>
<td>CREATE TEMPORARY TABLES</td>
<td>使用CREATE TEMPORARY TABLE</td>
</tr>
<tr>
<td>CREATE USER</td>
<td>使用CREATE USER、 DROP USER、 RENAME USER和REVOKE ALL PRIVILEGES</td>
</tr>
<tr>
<td>CREATE VIEW</td>
<td>使用CREATE VIEW</td>
</tr>
<tr>
<td>DELETE</td>
<td>使用DELETE</td>
</tr>
<tr>
<td>DROP</td>
<td>使用DROP TABLE</td>
</tr>
<tr>
<td>EXECUTE</td>
<td>使用CALL和存储过程</td>
</tr>
<tr>
<td>FILE</td>
<td>使用SELECT INTO OUTFILE和LOAD DATA INFILE</td>
</tr>
<tr>
<td>GRANT OPTION</td>
<td>使用GRANT和REVOKE</td>
</tr>
<tr>
<td>INDEX</td>
<td>使用CREATE INDEX和DROP INDEX</td>
</tr>
<tr>
<td>INSERT</td>
<td>使用INSERT</td>
</tr>
<tr>
<td>LOCK TABLES</td>
<td>使用LOCK TABLES</td>
</tr>
<tr>
<td>PROCESS</td>
<td>使用SHOW FULL PROCESSLIST</td>
</tr>
<tr>
<td>RELOAD</td>
<td>使用FLUSH</td>
</tr>
<tr>
<td>REPLICATION CLIENT</td>
<td>服务器位置的访问</td>
</tr>
<tr>
<td>REPLICATION SLAVE</td>
<td>由复制从属使用</td>
</tr>
<tr>
<td>SELECT</td>
<td>使用SELECT</td>
</tr>
<tr>
<td>SHOW DATABASES</td>
<td>使用SHOW DATABASES</td>
</tr>
<tr>
<td>SHOW VIEW</td>
<td>使用SHOW CREATE VIEW</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>使用mysqladmin shutdown(用来关闭MySQL)</td>
</tr>
<tr>
<td>SUPER</td>
<td>使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER和SET GLOBAL。还允许mysqladmin调试登录</td>
</tr>
<tr>
<td>UPDATE</td>
<td>使用UPDATE</td>
</tr>
<tr>
<td>USAGE</td>
<td>无访问权限</td>
</tr>
</tbody></table>
<h5 id="更改口令，SET-PASSWORD"><a href="#更改口令，SET-PASSWORD" class="headerlink" title="更改口令，SET PASSWORD"></a>更改口令，SET PASSWORD</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set password for lvkou&#x3D;Password(&#39;123456&#39;);</span><br><span class="line">set PASSWORD&#x3D;Password(&#39;123456&#39;);&#x2F;&#x2F;更新当前用户的口令</span><br></pre></td></tr></table></figure>

<h1 id="第二十九章：数据库维护"><a href="#第二十九章：数据库维护" class="headerlink" title="第二十九章：数据库维护"></a>第二十九章：数据库维护</h1><h3 id="1-备份数据"><a href="#1-备份数据" class="headerlink" title="1. 备份数据"></a>1. 备份数据</h3><ul>
<li>由于MySQL数据库是基于磁盘的文件,普通的备份系统和例程就能备份MySQL的数据。但是,由于这些文件总是处于打开和使用状态,普通的文件副本备份不一定总是有效。</li>
<li>下面列出这个问题的可能解决方案。<ul>
<li>使用命令行实用程序 mysqldump 转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行,以便能正确地备份转储文件。</li>
<li>可用命令行实用程序 mysqlhotcopy 从一个数据库复制所有数据(并非所有数据库引擎都支持这个实用程序)。</li>
<li>可以使用MySQL的 BACKUP TABLE 或 SELECT INTO OUTFILE 转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名,此系统文件必须不存在,否则会出错。数据可以用 RESTORETABLE 来复原。</li>
</ul>
</li>
<li>首先刷新未写数据 <ul>
<li>为了保证所有数据被写到磁盘(包括索引数据),可能需要在进行备份前使用 FLUSH TABLES 语句。</li>
</ul>
</li>
</ul>
<h3 id="2-数据维护"><a href="#2-数据维护" class="headerlink" title="2. 数据维护"></a>2. 数据维护</h3><ul>
<li>MySQL提供了一系列的语句,可以(应该)用来保证数据库正确和正常运行。<ul>
<li>ANALYZE TABLE ,用来检查表键是否正确。</li>
<li>CHECK TABLE 用来针对许多问题对表进行检查。在 MyISAM 表上还对索引进行检查<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">analyze table students;</span><br><span class="line">check table students;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="3-查看日志文件"><a href="#3-查看日志文件" class="headerlink" title="3. 查看日志文件"></a>3. 查看日志文件</h3><ul>
<li>错误日志。它包含启动和关闭问题以及任意关键错误的细节。此日志通常名为 hostname.err ,位于 data 目录中。此日志名可用–log-error 命令行选项更改。</li>
<li>查询日志。它记录所有MySQL活动,在诊断问题时非常有用。此日志文件可能会很快地变得非常大,因此不应该长期使用它。此日志通常名为 hostname.log ,位于 data 目录中。此名字可以用–log 命令行选项更改。</li>
<li>二进制日志。它记录更新过数据(或者可能更新过数据)的所有语句。此日志通常名为 hostname-bin ,位于 data 目录内。此名字可以用 –log-bin 命令行选项更改。注意,这个日志文件是MySQL5中添加的,以前的MySQL版本中使用的是更新日志。</li>
<li>缓慢查询日志。顾名思义,此日志记录执行缓慢的任何查询。这个日志在确定数据库何处需要优化很有用。此日志通常名为hostname-slow.log , 位 于 data 目 录 中 。 此 名 字可 以 用–log-slow-queries 命令行选项更改。</li>
<li>在使用日志时,可用 FLUSH LOGS 语句来刷新和重新开始所有日志文件。</li>
</ul>
<h1 id="第三十章：改善性能"><a href="#第三十章：改善性能" class="headerlink" title="第三十章：改善性能"></a>第三十章：改善性能</h1><ul>
<li>首先,MySQL(与所有DBMS一样)具有特定的硬件建议。在学习和研究MySQL时,使用任何旧的计算机作为服务器都可以。但对用于生产的服务器来说,应该坚持遵循这些硬件建议。</li>
<li>一般来说,关键的生产DBMS应该运行在自己的专用服务器上。</li>
<li>MySQL是用一系列的默认设置预先配置的,从这些设置开始通常是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大小 等 。( 为 查 看 当 前 设 置 , 可 使 用 SHOW VARIABLES; 和 SHOWSTATUS; 。)</li>
<li>MySQL一个多用户多线程的DBMS,换言之,它经常同时执行多个任务。如果这些任务中的某一个执行缓慢,则所有请求都会执行缓慢。如果你遇到显著的性能不良,可使用 SHOW PROCESSLIST显示所有活动进程(以及它们的线程ID和执行时间)。你还可以用KILL 命令终结某个特定的进程(使用这个命令需要作为管理员登录)。</li>
<li>总是有不止一种方法编写同一条 SELECT 语句。应该试验联结、并、子查询等,找出最佳的方法。</li>
<li>使用 EXPLAIN 语句让MySQL解释它将如何执行一条 SELECT 语句。一般来说,存储过程执行得比一条一条地执行其中的各条MySQL语句快。</li>
<li>应该总是使用正确的数据类型。</li>
<li>决不要检索比需求还要多的数据。换言之,不要用 SELECT * (除非你真正需要每个列)。</li>
<li>有的操作(包括 INSERT )支持一个可选的 DELAYED 关键字,如果使用它,将把控制立即返回给调用程序,并且一旦有可能就实际执行该操作。</li>
<li>在导入数据时,应该关闭自动提交。你可能还想删除索引(包括FULLTEXT 索引),然后在导入完成后再重建它们。</li>
<li>必须索引数据库表以改善数据检索的性能。确定索引什么不是一件微不足道的任务,需要分析使用的 SELECT 语句以找出重复的WHERE 和 ORDER BY 子句。如果一个简单的 WHERE 子句返回结果所花的时间太长,则可以断定其中使用的列(或几个列)就是需要索引的对象。</li>
<li>你的 SELECT 语句中有一系列复杂的 OR 条件吗?通过使用多条SELECT 语句和连接它们的 UNION 语句,你能看到极大的性能改进。</li>
<li>索引改善数据检索的性能,但损害数据插入、删除和更新的性能。如果你有一些表,它们收集数据且不经常被搜索,则在有必要之前不要索引它们。(索引可根据需要添加和删除。)</li>
<li>LIKE 很慢。一般来说,最好是使用 FULLTEXT 而不是 LIKE 。数据库是不断变化的实体。一组优化良好的表一会儿后可能就面目全非了。由于表的使用和内容的更改,理想的优化和配置也会改变。</li>
<li>最重要的规则就是,每条规则在某些条件下都会被打破。</li>
</ul>
<h1 id="附录B-样例"><a href="#附录B-样例" class="headerlink" title="附录B,样例"></a>附录B,样例</h1><h3 id="1-样例表"><a href="#1-样例表" class="headerlink" title="1. 样例表"></a>1. 样例表</h3><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><pre><code>- 管理供应商;
- 管理产品目录;
- 管理顾客列表;
- 录入顾客订单。</code></pre>
<h5 id="vendors表"><a href="#vendors表" class="headerlink" title="vendors表"></a>vendors表</h5><ul>
<li>vendors 表存储销售产品的供应商。每个供应商在这个表中有一个记录,供应商ID( vend_id )列用来匹配产品和供应商。</li>
</ul>
<table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>vend_id</td>
<td>唯一的供应商ID</td>
</tr>
<tr>
<td>vend_name</td>
<td>供应商名</td>
</tr>
<tr>
<td>vend_address</td>
<td>供应商的地址</td>
</tr>
<tr>
<td>vend_city</td>
<td>供应商的城市</td>
</tr>
<tr>
<td>vend_state</td>
<td>供应商的州</td>
</tr>
<tr>
<td>vend_zip</td>
<td>供应商的邮政编码</td>
</tr>
<tr>
<td>vend_country</td>
<td>供应商的国家</td>
</tr>
</tbody></table>
<ul>
<li>所有表都应该有主键。这个表使用 vend_id 作为主键。 vend_id 为一个自动增量字段。</li>
</ul>
<h5 id="products-表"><a href="#products-表" class="headerlink" title="products 表"></a>products 表</h5><ul>
<li>products 表包含产品目录,每行一个产品。每个产品有唯一的ID( prod_id 列),通过 vend_id (供应商的唯一ID)关联到它的供应商。</li>
</ul>
<table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>prod_id</td>
<td>唯一的产品ID</td>
</tr>
<tr>
<td>vend_id</td>
<td>产品供应商ID(关联到vendors表中的vend_id)</td>
</tr>
<tr>
<td>prod_name</td>
<td>产品名</td>
</tr>
<tr>
<td>prod_price</td>
<td>产品价格</td>
</tr>
<tr>
<td>prod_desc</td>
<td>产品描述</td>
</tr>
</tbody></table>
<ul>
<li>所有表都应该有一个主键,这个表用 prod_id 作为其主键。</li>
<li>为实施引用完整性,应该在 vend_id 上定义一个外键,关联到vendors 的 vend_id 。</li>
</ul>
<h5 id="customers-表"><a href="#customers-表" class="headerlink" title="customers 表"></a>customers 表</h5><ul>
<li>customers 表存储所有顾客的信息。每个顾客有唯一的ID( cust_id列)。</li>
</ul>
<table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>cust_id</td>
<td>唯一的顾客ID</td>
</tr>
<tr>
<td>cust_name</td>
<td>顾客名</td>
</tr>
<tr>
<td>cust_address</td>
<td>顾客的地址</td>
</tr>
<tr>
<td>cust_city</td>
<td>顾客的城市</td>
</tr>
<tr>
<td>cust_state</td>
<td>顾客的州</td>
</tr>
<tr>
<td>cust_zip</td>
<td>顾客的邮政编码</td>
</tr>
<tr>
<td>cust_country</td>
<td>顾客的国家</td>
</tr>
<tr>
<td>cust_contact</td>
<td>顾客的联系名</td>
</tr>
<tr>
<td>cust_email</td>
<td>顾客的联系email地址</td>
</tr>
</tbody></table>
<ul>
<li>所有表都应该定义主键,这个表将使用 cust_id 作为它的主键。cust_id 是一个自动增量字段。</li>
</ul>
<h5 id="orders-表"><a href="#orders-表" class="headerlink" title="orders 表"></a>orders 表</h5><ul>
<li>orders 表存储顾客订单(但不是订单细节)。每个订单唯一地编号( order_num 列)。订单用 cust_id 列(它关联到 customer 表的顾客唯一ID)与相应的顾客关联。</li>
</ul>
<table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>order_num</td>
<td>唯一订单号</td>
</tr>
<tr>
<td>order_date</td>
<td>订单日期</td>
</tr>
<tr>
<td>cust_id</td>
<td>订 单 顾 客 ID ( 关 系 到 customers 表 的cust_id)</td>
</tr>
</tbody></table>
<ul>
<li>所有表都应该定义主键,这个表使用 order_num 作为它的主键。order_num 是一个自动增量字段。</li>
<li>为实施引用完整性,应该在 cust_id 上定义一个外键,关联到customers 的 cust_id 。</li>
</ul>
<h5 id="orderitems-表"><a href="#orderitems-表" class="headerlink" title="orderitems 表"></a>orderitems 表</h5><ul>
<li>orderitems 表存储每个订单中的实际物品,每个订单的每个物品占一行。对 orders 中的每一行, orderitems 中有一行或多行。每个订单物品由订单号加订单物品(第一个物品、第二个物品等)唯一标识。订单物品通过 order_num 列(关联到 orders 中订单的唯一ID)与它们相应的订单相关联。此外,每个订单项包含订单物品的产品ID(它关联物品到products 表)。、</li>
</ul>
<table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>order_num</td>
<td>订单号(关联到orders表的order_num)</td>
</tr>
<tr>
<td>order_item</td>
<td>订单物品号(在某个订单中的顺序)</td>
</tr>
<tr>
<td>prod_id</td>
<td>产品ID(关联到products表的prod_id)</td>
</tr>
<tr>
<td>quantity</td>
<td>物品数量</td>
</tr>
<tr>
<td>item_price</td>
<td>物品价格</td>
</tr>
</tbody></table>
<ul>
<li>所有表都应该有主键,这个表使用 order_num 和 order_item 作为其主键。</li>
<li>为实施引用完整性,应该在 order_num 上定义外键,关联它到orders 的 order_num ,在 prod_id 上定义外键,关联它到 products的 prod_id 。</li>
</ul>
<h5 id="productnotes-表"><a href="#productnotes-表" class="headerlink" title="productnotes 表"></a>productnotes 表</h5><ul>
<li>productnotes 表存储与特定产品有关的注释。并非所有产品都有相关的注释,而有的产品可能有许多相关的注释。</li>
</ul>
<table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>note_id</td>
<td>唯一注释ID</td>
</tr>
<tr>
<td>prod_id</td>
<td>产品ID(对应于products表中的prod_id)</td>
</tr>
<tr>
<td>note_date</td>
<td>增加注释的日期</td>
</tr>
<tr>
<td>note_text</td>
<td>注释文本</td>
</tr>
</tbody></table>
<h3 id="2-脚本"><a href="#2-脚本" class="headerlink" title="2. 脚本"></a>2. 脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">########################################</span><br><span class="line"># MySQL Crash Course</span><br><span class="line"># http:&#x2F;&#x2F;www.forta.com&#x2F;books&#x2F;0672327120&#x2F;</span><br><span class="line"># Example table creation scripts</span><br><span class="line">########################################</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">########################</span><br><span class="line"># Create customers table</span><br><span class="line">########################</span><br><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line">  cust_id      int       NOT NULL AUTO_INCREMENT,</span><br><span class="line">  cust_name    char(50)  NOT NULL ,</span><br><span class="line">  cust_address char(50)  NULL ,</span><br><span class="line">  cust_city    char(50)  NULL ,</span><br><span class="line">  cust_state   char(5)   NULL ,</span><br><span class="line">  cust_zip     char(10)  NULL ,</span><br><span class="line">  cust_country char(50)  NULL ,</span><br><span class="line">  cust_contact char(50)  NULL ,</span><br><span class="line">  cust_email   char(255) NULL ,</span><br><span class="line">  PRIMARY KEY (cust_id)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">#########################</span><br><span class="line"># Create orderitems table</span><br><span class="line">#########################</span><br><span class="line">CREATE TABLE orderitems</span><br><span class="line">(</span><br><span class="line">  order_num  int          NOT NULL ,</span><br><span class="line">  order_item int          NOT NULL ,</span><br><span class="line">  prod_id    char(10)     NOT NULL ,</span><br><span class="line">  quantity   int          NOT NULL ,</span><br><span class="line">  item_price decimal(8,2) NOT NULL ,</span><br><span class="line">  PRIMARY KEY (order_num, order_item)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#####################</span><br><span class="line"># Create orders table</span><br><span class="line">#####################</span><br><span class="line">CREATE TABLE orders</span><br><span class="line">(</span><br><span class="line">  order_num  int      NOT NULL AUTO_INCREMENT,</span><br><span class="line">  order_date datetime NOT NULL ,</span><br><span class="line">  cust_id    int      NOT NULL ,</span><br><span class="line">  PRIMARY KEY (order_num)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">#######################</span><br><span class="line"># Create products table</span><br><span class="line">#######################</span><br><span class="line">CREATE TABLE products</span><br><span class="line">(</span><br><span class="line">  prod_id    char(10)      NOT NULL,</span><br><span class="line">  vend_id    int           NOT NULL ,</span><br><span class="line">  prod_name  char(255)     NOT NULL ,</span><br><span class="line">  prod_price decimal(8,2)  NOT NULL ,</span><br><span class="line">  prod_desc  text          NULL ,</span><br><span class="line">  PRIMARY KEY(prod_id)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">######################</span><br><span class="line"># Create vendors table</span><br><span class="line">######################</span><br><span class="line">CREATE TABLE vendors</span><br><span class="line">(</span><br><span class="line">  vend_id      int      NOT NULL AUTO_INCREMENT,</span><br><span class="line">  vend_name    char(50) NOT NULL ,</span><br><span class="line">  vend_address char(50) NULL ,</span><br><span class="line">  vend_city    char(50) NULL ,</span><br><span class="line">  vend_state   char(5)  NULL ,</span><br><span class="line">  vend_zip     char(10) NULL ,</span><br><span class="line">  vend_country char(50) NULL ,</span><br><span class="line">  PRIMARY KEY (vend_id)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">###########################</span><br><span class="line"># Create productnotes table</span><br><span class="line">###########################</span><br><span class="line">CREATE TABLE productnotes</span><br><span class="line">(</span><br><span class="line">  note_id    int           NOT NULL AUTO_INCREMENT,</span><br><span class="line">  prod_id    char(10)      NOT NULL,</span><br><span class="line">  note_date datetime       NOT NULL,</span><br><span class="line">  note_text  text          NULL ,</span><br><span class="line">  PRIMARY KEY(note_id),</span><br><span class="line">  FULLTEXT(note_text)</span><br><span class="line">) ENGINE&#x3D;MyISAM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#####################</span><br><span class="line"># Define foreign keys</span><br><span class="line">#####################</span><br><span class="line">ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_orders FOREIGN KEY (order_num) REFERENCES orders (order_num);</span><br><span class="line">ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id);</span><br><span class="line">ALTER TABLE orders ADD CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id) REFERENCES customers (cust_id);</span><br><span class="line">ALTER TABLE products ADD CONSTRAINT fk_products_vendors FOREIGN KEY (vend_id) REFERENCES vendors (vend_id);</span><br></pre></td></tr></table></figure>

<h1 id="附录D-数据类型"><a href="#附录D-数据类型" class="headerlink" title="附录D.数据类型"></a>附录D.数据类型</h1><h3 id="1-串数据类型"><a href="#1-串数据类型" class="headerlink" title="1. 串数据类型"></a>1. 串数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td>1~255个字符的定长串。它的长度必须在创建时指定,否则MySQL假定为CHAR(1)</td>
</tr>
<tr>
<td>ENUM</td>
<td>接受最多64 K个串组成的一个预定义集合的某个串</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>与TEXT相同,但最大长度为4 GB</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>与TEXT相同,但最大长度为16 K</td>
</tr>
<tr>
<td>SET</td>
<td>接受最多64个串组成的一个预定义集合的零个或多个串</td>
</tr>
<tr>
<td>TEXT</td>
<td>最大长度为64 K的变长文本</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>与TEXT相同,但最大长度为255字节</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>长度可变,最多不超过255字节。如果在创建时指定为VARCHAR(n),则可存储0到n个字符的变长串(其中n≤255)</td>
</tr>
</tbody></table>
<ul>
<li>使用引号 <ul>
<li>不管使用何种形式的串数据类型,串值都必须括在引号内(通常单引号更好)。</li>
</ul>
</li>
</ul>
<h3 id="2-数值数据类型"><a href="#2-数值数据类型" class="headerlink" title="2. 数值数据类型"></a>2. 数值数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BIT</td>
<td>位字段,1~64位。(在MySQL 5之前,BIT在功能上等价于TINYINT</td>
</tr>
<tr>
<td>BIGINT</td>
<td>整数值,支持-9223372036854775808<del>9223372036854775807(如果是UNSIGNED,为0</del>18446744073709551615)的数</td>
</tr>
<tr>
<td>BOOLEAN(或BOOL)</td>
<td>布尔标志,或者为0或者为1,主要用于开/关(on/off)标志</td>
</tr>
<tr>
<td>DECIMAL(或DEC)</td>
<td>精度可变的浮点值</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>双精度浮点值</td>
</tr>
<tr>
<td>FLOAT</td>
<td>单精度浮点值</td>
</tr>
<tr>
<td>INT(或INTEGER)</td>
<td>整数值,支持2147483648<del>2147483647 (如果是UNSIGNED,为0</del>4294967295)的数</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>整数值,支持-8388608<del>8388607(如果是UNSIGNED,为0</del>16777215)的数</td>
</tr>
<tr>
<td>REAL</td>
<td>4字节的浮点值</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>整数值,支持-32768<del>32767(如果是UNSIGNED,为0</del>65535)的数</td>
</tr>
<tr>
<td>TINYINT</td>
<td>整数值,支持128<del>127(如果为UNSIGNED,为0</del>255)的数</td>
</tr>
</tbody></table>
<ul>
<li>不使用引号 <ul>
<li>与串不一样,数值不应该括在引号内。</li>
</ul>
</li>
<li>存储货币数据类型<ul>
<li>MySQL中没有专门存储货币的数据类型,一般情况下使用 DECIMAL(8, 2)</li>
</ul>
</li>
</ul>
<h3 id="3-日期和时间数据类型"><a href="#3-日期和时间数据类型" class="headerlink" title="3. 日期和时间数据类型"></a>3. 日期和时间数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>表示1000-01-01~9999-12-31的日期,格式为YYYY-MM-DD</td>
</tr>
<tr>
<td>DATETIME</td>
<td>DATE和TIME的组合</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>功能和DATETIME相同(但范围较小)</td>
</tr>
<tr>
<td>TIME</td>
<td>格式为HH:MM:SS</td>
</tr>
<tr>
<td>YEAR</td>
<td>用2位数字表示,范围是70(1970年)<del>69(2069年),用4位数字表示,范围是1901年</del>2155年</td>
</tr>
</tbody></table>
<h3 id="4-二进制数据类型"><a href="#4-二进制数据类型" class="headerlink" title="4. 二进制数据类型"></a>4. 二进制数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BLOB</td>
<td>Blob最大长度为64 KB</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>Blob最大长度为16 MB</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>Blob最大长度为4 GB</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>Blob最大长度为255字节</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First Java》</title>
    <url>/%E3%80%8AHead-First-Java%E3%80%8B/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ol>
<li>在写这个笔记的时候已经有了一定的java基础，所以一些极其基础的东西就没有记录</li>
<li>这本书不推荐入门看，说的花里胡哨的。。。没有按照书目录整理笔记，自己按照知识点整理的。<a id="more"></a>
<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1></li>
</ol>
<h3 id="1-编译运行"><a href="#1-编译运行" class="headerlink" title="1. 编译运行"></a>1. 编译运行</h3><ul>
<li>代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac test.java &#x2F;&#x2F;编译，生成Test.class</span><br><span class="line">java Test   &#x2F;&#x2F;运行，输出hello</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-基本语句"><a href="#2-基本语句" class="headerlink" title="2. 基本语句"></a>2. 基本语句</h3><ul>
<li>顺序选择循环，略</li>
</ul>
<h3 id="3-原始数据类型"><a href="#3-原始数据类型" class="headerlink" title="3. 原始数据类型"></a>3. 原始数据类型</h3><ul>
<li>这些是非引用的<table>
<thead>
<tr>
<th>类型</th>
<th>位数</th>
<th>值域</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>java虚拟机决定</td>
<td>true/false</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>0~65535</td>
</tr>
<tr>
<td>byte</td>
<td>8</td>
<td>-128~127</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>-很大～很大</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>范围规模可变</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>范围规模可变</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="4-引用"><a href="#4-引用" class="headerlink" title="4. 引用"></a>4. 引用</h3><ol>
<li>new的对象都是引用，和C++指针类似</li>
<li>引用占字节大小由java虚拟机决定</li>
<li>把一个对象赋值给另一个同对象变量，增加引用数，不创建新对象</li>
<li>数组也是对象，传数组就是传引用</li>
</ol>
<h3 id="5-静态-static"><a href="#5-静态-static" class="headerlink" title="5. 静态 static"></a>5. 静态 static</h3><ul>
<li>和C++类似</li>
<li>Math类全是静态函数，且它的构造是私有的，不能创建Math实例</li>
<li>静态方法不能调用非静态方法</li>
</ul>
<h3 id="6-常量-final"><a href="#6-常量-final" class="headerlink" title="6. 常量 final"></a>6. 常量 final</h3><ul>
<li>和C++ const类似，必须初始化赋值</li>
<li>final 修饰的方法不能被覆盖，C++的final和这个功能基本一样</li>
<li>final 的类不能被继承</li>
</ul>
<h3 id="7-primitive数据类型的包装"><a href="#7-primitive数据类型的包装" class="headerlink" title="7. primitive数据类型的包装"></a>7. primitive数据类型的包装</h3><ul>
<li>把primitive数据类型当对象来处理<table>
<thead>
<tr>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
</tr>
<tr>
<td>Character</td>
</tr>
<tr>
<td>Byte</td>
</tr>
<tr>
<td>Short</td>
</tr>
<tr>
<td>Integer</td>
</tr>
<tr>
<td>Long</td>
</tr>
<tr>
<td>Float</td>
</tr>
<tr>
<td>Double</td>
</tr>
</tbody></table>
</li>
<li>java5 以后自动装箱</li>
<li>利用上述对象可以实现类型转化  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Double.toString(2.2);</span><br><span class="line">Integer.parseInt(&quot;123&quot;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="8-数字格式化"><a href="#8-数字格式化" class="headerlink" title="8. 数字格式化"></a>8. 数字格式化</h3><ul>
<li>String.format(“asd,%d”,1230);</li>
</ul>
<h1 id="二、类与对象"><a href="#二、类与对象" class="headerlink" title="二、类与对象"></a>二、类与对象</h1><h3 id="1-访问权限"><a href="#1-访问权限" class="headerlink" title="1. 访问权限"></a>1. 访问权限</h3><ul>
<li>java的访问权限有下面四种：<ul>
<li>public–都可访问(公有)</li>
<li>protected–包内和子类可访问（保护）</li>
<li>不写(default)–包内可访问 （默认）</li>
<li>private–类内可访问（私有）</li>
</ul>
</li>
<li>和C++不同，每个变量前都要加private或public声明</li>
</ul>
<h3 id="2-对象方法"><a href="#2-对象方法" class="headerlink" title="2. 对象方法"></a>2. 对象方法</h3><ol>
<li>java方法是通过值传递的，也就是拷贝传递<ul>
<li>对基本类型直接拷贝传递</li>
<li>对引用，传递的是远程控制的拷贝</li>
</ul>
</li>
</ol>
<h3 id="3-实例变量和局部变量"><a href="#3-实例变量和局部变量" class="headerlink" title="3. 实例变量和局部变量"></a>3. 实例变量和局部变量</h3><ul>
<li>实例变量是属于类的，局部变量是方法中的</li>
<li>实例变量有默认值，局部变量没有，必须初始化或赋值</li>
</ul>
<h3 id="3-封装继承多态"><a href="#3-封装继承多态" class="headerlink" title="3. 封装继承多态"></a>3. 封装继承多态</h3><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><ol>
<li>emmm没啥说的，主要是注意访问权限</li>
</ol>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ol>
<li>extends父类</li>
<li>函数重载：参数列表数量和类型不同，权限可以改变，和多态无关</li>
<li>java的继承和C++不一样，不分公有私有保护</li>
</ol>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><ol>
<li>基类对象变量可以被赋值为它的子类</li>
<li>函数覆盖：子类覆盖父类方法，参数列表要相同，返回值类型兼容，函数权限不能改变</li>
</ol>
<h3 id="4-接口和抽象类"><a href="#4-接口和抽象类" class="headerlink" title="4. 接口和抽象类"></a>4. 接口和抽象类</h3><ol>
<li>抽象类<ul>
<li>abstract关键字声明：abstract class student{}</li>
<li>不能初始化，类似于C++的pure virtual</li>
<li>子类可以再被声明为abstract</li>
<li>抽象类的方法无实体</li>
<li>必须实现所有的抽象方法，抽象类也有非抽象方法</li>
</ul>
</li>
<li>具体类<ul>
<li>不是抽象类的就是具体类</li>
<li>调用父类的方法用super.function()</li>
</ul>
</li>
<li>接口<ul>
<li>interface关键字声明接口</li>
<li>implements关键字使用接口</li>
<li>所有接口的方法都是抽象的</li>
<li>接口里方法没有实体，只是定义一种“规则”，使用接口并不是多重继承</li>
<li>不同继承树的类可以使用相同的接口</li>
</ul>
</li>
<li>抽象和接口的主要区别是，子类只能继承一个抽象类，但可以实现很多接口</li>
</ol>
<h3 id="5-构造函数"><a href="#5-构造函数" class="headerlink" title="5. 构造函数"></a>5. 构造函数</h3><ul>
<li>和C++类似</li>
<li>调用父类构造函数:<ul>
<li>super();</li>
</ul>
</li>
<li>java没有析构，把对象置为null，垃圾回收器会自动释放</li>
</ul>
<h1 id="三、Java-API"><a href="#三、Java-API" class="headerlink" title="三、Java API"></a>三、Java API</h1><h3 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1. ArrayList"></a>1. ArrayList</h3><ul>
<li>动态数组</li>
</ul>
<h3 id="2-Calendar"><a href="#2-Calendar" class="headerlink" title="2. Calendar"></a>2. Calendar</h3><ul>
<li>日期类</li>
<li>Date类基本被舍弃不用了</li>
</ul>
<h3 id="3-Math"><a href="#3-Math" class="headerlink" title="3. Math"></a>3. Math</h3><ul>
<li>各种数学函数</li>
<li>构造函数是私有，不能实例化</li>
<li>所有方法都是static</li>
</ul>
<h3 id="4-各种数据结构"><a href="#4-各种数据结构" class="headerlink" title="4. 各种数据结构"></a>4. 各种数据结构</h3><ol>
<li>TreeSet<ul>
<li>有序无重复</li>
</ul>
</li>
<li>HashMap<ul>
<li>键值对</li>
</ul>
</li>
<li>LinkedList<ul>
<li>链表结构</li>
</ul>
</li>
<li>HashSet<ul>
<li>无重复，快速查找</li>
</ul>
</li>
<li>LinkedHashMap<ul>
<li>类似HashMap,但可记住元素的插入顺序</li>
</ul>
</li>
</ol>
<h1 id="四、异常处理"><a href="#四、异常处理" class="headerlink" title="四、异常处理"></a>四、异常处理</h1><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h3><ul>
<li>捕获异常<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    &#x2F;&#x2F;可能产生异常的代码</span><br><span class="line">&#125;catch(异常种类，Exception类对象)&#123;</span><br><span class="line">    &#x2F;&#x2F;处理</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    &#x2F;&#x2F;无论如何都执行</span><br><span class="line">    &#x2F;&#x2F; 有finally的try必须要声明异常，就是在函数名后面加 throws ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>抛出异常<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void test() throws BadException&#123;</span><br><span class="line">    if(aaa)&#123;</span><br><span class="line">        throw new BadException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>由上一级处理异常<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void test() throws BadException&#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="五、图形用户接口"><a href="#五、图形用户接口" class="headerlink" title="五、图形用户接口"></a>五、图形用户接口</h1><h3 id="1-基本框架"><a href="#1-基本框架" class="headerlink" title="1. 基本框架"></a>1. 基本框架</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import javax.swing.*;</span><br><span class="line"></span><br><span class="line">public class helloJFrame&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        JFrame frame&#x3D;new JFrame();</span><br><span class="line">        JButton b1&#x3D;new JButton(&quot;Hello&quot;);</span><br><span class="line">        &#x2F;&#x2F;设置退出窗口时，程序结束</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        frame.getContentPane().add(b1);</span><br><span class="line"></span><br><span class="line">        frame.setSize(300,300);</span><br><span class="line">        frame.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-事件监听"><a href="#2-事件监听" class="headerlink" title="2. 事件监听"></a>2. 事件监听</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.awt.event.*;</span><br><span class="line">import javax.swing.*;</span><br><span class="line"></span><br><span class="line">public class Listen&#123;</span><br><span class="line">    JButton b1;</span><br><span class="line">    &#x2F;&#x2F; JFrame frame;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Listen l&#x3D;new Listen();</span><br><span class="line">        l.init();</span><br><span class="line">    &#125;</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        JFrame frame&#x3D;new JFrame();</span><br><span class="line">        b1&#x3D;new JButton(&quot;Hello&quot;);</span><br><span class="line">        b1.addActionListener(new ActionListener()&#123;</span><br><span class="line">        </span><br><span class="line">            @Override</span><br><span class="line">            public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">                b1.setText(&quot;new&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;设置退出窗口时，程序结束</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        frame.getContentPane().add(b1);</span><br><span class="line"></span><br><span class="line">        frame.setSize(300,300);</span><br><span class="line">        frame.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-swing"><a href="#3-swing" class="headerlink" title="3. swing"></a>3. swing</h1><ul>
<li>布局管理器和各种控件略</li>
</ul>
<h1 id="六、序列化和文件输入输出"><a href="#六、序列化和文件输入输出" class="headerlink" title="六、序列化和文件输入输出"></a>六、序列化和文件输入输出</h1><h3 id="1-让类可序列化"><a href="#1-让类可序列化" class="headerlink" title="1. 让类可序列化"></a>1. 让类可序列化</h3><ul>
<li>实现Serializable接口  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test() implements Serializable&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-把序列化对象写入文件"><a href="#2-把序列化对象写入文件" class="headerlink" title="2. 把序列化对象写入文件"></a>2. 把序列化对象写入文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    FileOutputStream fs&#x3D;new FileOutputStream(&quot;foo.ser&quot;);</span><br><span class="line">    ObjectOutputStream os&#x3D;new ObjectOutputStream(fs);</span><br><span class="line">    os.writeObject(myObj);</span><br><span class="line">    os.close();</span><br><span class="line">&#125;catch(Exception ex)&#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-取消某些变量的序列化"><a href="#3-取消某些变量的序列化" class="headerlink" title="3. 取消某些变量的序列化"></a>3. 取消某些变量的序列化</h3><ul>
<li>使用transient关键字  <!-- ![1.取消序列化.png](./img/1.取消序列化.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/1.%E5%8F%96%E6%B6%88%E5%BA%8F%E5%88%97%E5%8C%96.png" class="" title="1.取消序列化.png"></li>
<li>transient的引用实例会以null返回</li>
</ul>
<h3 id="4-解序列化-Deserializations"><a href="#4-解序列化-Deserializations" class="headerlink" title="4. 解序列化(Deserializations)"></a>4. 解序列化(Deserializations)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    FileInputStream fs&#x3D;new FileInputStream(&quot;foo.ser&quot;);</span><br><span class="line">    ObjectInputStream is&#x3D;new ObjectInputStream(fs);</span><br><span class="line"></span><br><span class="line">    GameCharacter a1&#x3D;(GameCharacter)is.readObject();</span><br><span class="line">    GameCharacter a2&#x3D;(GameCharacter)is.readObject();</span><br><span class="line">    GameCharacter a3&#x3D;(GameCharacter)is.readObject();</span><br><span class="line">    os.close();</span><br><span class="line">&#125;catch(Exception ex)&#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每次调用readObject()会读出一个对象，读出顺序和存入顺序相同，次数超过会报异常</li>
</ul>
<h3 id="5-序列化的识别：Version-ID"><a href="#5-序列化的识别：Version-ID" class="headerlink" title="5. 序列化的识别：Version ID"></a>5. 序列化的识别：Version ID</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final long serialVersionUID&#x3D;546655...651L;</span><br></pre></td></tr></table></figure>
<ul>
<li>略</li>
</ul>
<h3 id="6-文件操作"><a href="#6-文件操作" class="headerlink" title="6. 文件操作"></a>6. 文件操作</h3><ul>
<li>java.io.file</li>
<li>略</li>
</ul>
<h1 id="七、网络与线程"><a href="#七、网络与线程" class="headerlink" title="七、网络与线程"></a>七、网络与线程</h1><h3 id="1-服务器端"><a href="#1-服务器端" class="headerlink" title="1. 服务器端"></a>1. 服务器端</h3><ul>
<li>比Linux原生函数简便很多<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServerSocket server&#x3D;new ServerSocket(12345);</span><br><span class="line">server.accept();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2. 客户端"></a>2. 客户端</h3><ul>
<li>把socket绑定到输入输出流上，更方便的操作  <!-- ![2.Client.png](./img/2.Client.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/2.Client.png" class="" title="2.Client.png">

</li>
</ul>
<h3 id="3-线程"><a href="#3-线程" class="headerlink" title="3. 线程"></a>3. 线程</h3><ul>
<li>启动线程<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Runable threadJob&#x3D;new MyRunable();</span><br><span class="line">Thread myThread&#x3D;new Thread(threadJob);</span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure></li>
<li>MyRunable是自己写的类，实现Runable接口</li>
<li>Runable只有一个run()接口</li>
</ul>
<h3 id="4-同步"><a href="#4-同步" class="headerlink" title="4. 同步"></a>4. 同步</h3><ul>
<li>synchronized</li>
</ul>
<h1 id="八、集合与泛型"><a href="#八、集合与泛型" class="headerlink" title="八、集合与泛型"></a>八、集合与泛型</h1><h3 id="1-集合"><a href="#1-集合" class="headerlink" title="1. 集合"></a>1. 集合</h3><ul>
<li>就是各种数据结构，上面有说</li>
</ul>
<h3 id="2-排序"><a href="#2-排序" class="headerlink" title="2. 排序"></a>2. 排序</h3><ol>
<li>set自动排序</li>
<li>Collections.sort();</li>
<li>Comparator</li>
</ol>
<h3 id="3-泛型"><a href="#3-泛型" class="headerlink" title="3. 泛型"></a>3. 泛型</h3><ul>
<li>和C++的模板差不多吧</li>
</ul>
<h1 id="九、包、jar存档文件和部署"><a href="#九、包、jar存档文件和部署" class="headerlink" title="九、包、jar存档文件和部署"></a>九、包、jar存档文件和部署</h1><h3 id="1-部署的选择"><a href="#1-部署的选择" class="headerlink" title="1. 部署的选择"></a>1. 部署的选择</h3><!-- ![3.部署的选择.png](./img/3.部署的选择.png) -->
<img src="/%E3%80%8AHead-First-Java%E3%80%8B/3.%E9%83%A8%E7%BD%B2%E7%9A%84%E9%80%89%E6%8B%A9.png" class="" title="3.部署的选择.png">

<h3 id="2-本地部署jar"><a href="#2-本地部署jar" class="headerlink" title="2. 本地部署jar"></a>2. 本地部署jar</h3><ol>
<li>javac -d … 可以指定编译生成文件的路径</li>
<li>创建可执行的jar <!-- ![4.可执行jar.png](./img/4.可执行jar.png) -->
 <img src="/%E3%80%8AHead-First-Java%E3%80%8B/4.%E5%8F%AF%E6%89%A7%E8%A1%8Cjar.png" class="" title="4.可执行jar.png">

</li>
</ol>
<h3 id="3-创建与部署Java-Web-Start"><a href="#3-创建与部署Java-Web-Start" class="headerlink" title="3. 创建与部署Java Web Start"></a>3. 创建与部署Java Web Start</h3><p><img src="./img/5.Web%E9%83%A8%E7%BD%B2.png" alt="5.Web部署.png"></p>
<img src="/%E3%80%8AHead-First-Java%E3%80%8B/5.Web%E9%83%A8%E7%BD%B2.png" class="" title="5.Web部署.png">

<h1 id="十、远程部署RMI"><a href="#十、远程部署RMI" class="headerlink" title="十、远程部署RMI"></a>十、远程部署RMI</h1><h3 id="1-RMI"><a href="#1-RMI" class="headerlink" title="1. RMI"></a>1. RMI</h3><ul>
<li>调用远程机器上的方法</li>
<li>创建远程服务步骤  <!-- ![6.创建远程服务.png](./img/6.创建远程服务.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/6.%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1.png" class="" title="6.创建远程服务.png"></li>
<li>创建远程接口  <!-- ![7.创建远程接口.png](./img/7.创建远程接口.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/7.%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3.png" class="" title="7.创建远程接口.png"></li>
<li>实现远程接口  <!-- ![8.实现远程接口.png](./img/8.实现远程接口.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/8.%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3.png" class="" title="8.实现远程接口.png"></li>
<li>产生stub和skeleton,启动服务  <!-- ![9.启动服务.png](./img/9.启动服务.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/9.%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1.png" class="" title="9.启动服务.png"></li>
<li>客户端  <!-- ![10.client.png](./img/10.client.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/10.client.png" class="" title="10.client.png"></li>
<li>常见错误  <!-- ![11.error.png](./img/11.error.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/11.error.png" class="" title="11.error.png">

</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
