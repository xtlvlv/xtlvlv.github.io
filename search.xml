<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1.muduo安装使用与源码阅读说明</title>
    <url>/1-muduo%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="1-源码阅读说明"><a href="#1-源码阅读说明" class="headerlink" title="1.源码阅读说明"></a>1.源码阅读说明</h1><ol>
<li><p>在具有C++基础和Linux系统与网络编程基础的情况下阅读muduo源码,如果对Linux网络编程不熟悉,最好先学习一下Linux网络编程</p>
</li>
<li><p>阅读时可以参考&lt;muduo网络库使用手册&gt;,这个一搜就能搜到,对muduo整体的框架有讲解,能帮助理解Buffer,TcpConnection等类,可以先读读这个再看源码</p>
<a id="more"></a></li>
<li><p>这里写的代码阅读笔记,只是对阅读源码的辅助,对各个类的功能和各函数难理解的地方做一些注释讲解,可以完全按照本人的阅读顺序,从base–&gt;net–&gt;httpserver–&gt;example文件夹顺序阅读,每个文件夹里面的都按照顺序阅读,结合我自身的经验是循序渐进的阅读学习.下面是CSDN博客目录,推荐按如下顺序阅读:</p>
<ul>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99935275">2.muduo学习笔记之base_Timestamp.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99935311">3.muduo学习笔记之base_Atomic.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99935453">4.muduo学习笔记之base_Exception.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99935505">5.muduo学习笔记之base_Mutex.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99935627">6.muduo学习笔记之base_Condition.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99935708">7.muduo学习笔记之base_CountDownLatch.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99935783">8.muduo学习笔记之base_CurrentThread.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99935837">9.muduo学习笔记之base_Thread.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99935905">10.muduo学习笔记之base_BlockingQueue.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99935946">11.muduo学习笔记之base_BoundedBlockingQueue.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99936017">12.muduo学习笔记之base_ThreadPool.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99936083">13.muduo学习笔记之base_Singleton.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99936122">14.muduo学习笔记之base_ThreadLocal.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99936171">15.muduo学习笔记之base_ThreadLocalSingleton.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99936218">16.muduo学习笔记之base_LogStream.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99936271">17.muduo学习笔记之base_Logging.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99936318">18.muduo学习笔记之base_FileUtil.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99936380">19.muduo学习笔记之base_LogFile.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99936425">20.muduo学习笔记之base_其他.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99936940">21.muduo学习笔记之net_Callback.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99936991">22.muduo学习笔记之net_Endian.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99937029">23.muduo学习笔记之net_InetAddress.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99937065">24.muduo学习笔记之net_SocketsOps.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99937165">25.muduo学习笔记之net_Socket.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99937285">26.muduo学习笔记之net_Timer.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99937339">27.muduo学习笔记之net_TimerId.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99937419">28.muduo学习笔记之net_TimerQueue.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99937485">29.muduo学习笔记之net_EventLoop.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99937766">30.muduo学习笔记之net_Channel.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99938635">31.muduo学习笔记之net_EventLoopThread.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99939239">32.muduo学习笔记之net_Acceptor.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99939342">33.muduo学习笔记之net_TcpConnection.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99939509">34.muduo学习笔记之net_TcpServer.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99939602">35.muduo学习笔记之net_EventLoopThreadPool.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99939751">36.muduo学习笔记之net_Buffer.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99943070">37.muduo学习笔记之net_Connector.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99943205">38.muduo学习笔记之net_TcpClient.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99943531">39.muduo学习笔记之net_Poller.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99944585">40.muduo学习笔记之net_PollPoller.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99944668">41.muduo学习笔记之net_EPollPoller.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99944815">42.muduo学习笔记之http_HttpRequest.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99945049">43.muduo学习笔记之http_HttpResponse.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99945241">44.muduo学习笔记之http_HttpContext.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99945335">45.muduo学习笔记之http_HttpServer.{h&amp;cc}</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99945447">46.muduo学习笔记之example_discard例子</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99945554">47.muduo学习笔记之example_下载文件例子</a></li>
<li><a href="https://blog.csdn.net/LvPartner/article/details/99945621">48.muduo学习笔记之example_聊天服务器例子</a></li>
</ul>
</li>
</ol>
<h1 id="2-muduo安装使用"><a href="#2-muduo安装使用" class="headerlink" title="2. muduo安装使用"></a>2. muduo安装使用</h1><ol>
<li>这里讲一下muduo如何使用,可以先运行一下再看源码,也可以看完源码在来使用…我是看完源码才用的,使用中也对源码整个框架有了更好的理解</li>
</ol>
<h3 id="1-下载编译"><a href="#1-下载编译" class="headerlink" title="1. 下载编译"></a>1. 下载编译</h3><ol>
<li><p>muduo在github上有开源代码,作者也写的有README介绍如何运行,但是还是有些不理想,这里结合自身经历更详细的说一下如何编译安装</p>
</li>
<li><p>首先从<a href="https://github.com/chenshuo/muduo">muduo(github)</a>下载源码,解压</p>
</li>
<li><p>进入解压的文件夹运行bash文件</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;build.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>会在上一层目录多个build文件夹,进去后的bin文件夹内都是作者写好的测试例子程序,可以直接运行</li>
</ul>
</li>
</ol>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><ol>
<li><p>作者的README就是到上面这一步,但是这样只能运行测试作者写好的例子,想自己写代码使用的话,需要继续运行</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bulid.sh install</span><br></pre></td></tr></table></figure>
<ul>
<li>这样会在build文件夹内生成一个”release-install-cpp11”文件夹,里面是头文件和静态库,编译的时候就要指定链接库</li>
</ul>
</li>
<li><p>可以参考作者陈硕的<a href="https://github.com/chenshuo/muduo-tutorial">教程</a>,这里有一个echo.cc服务例子和几种编译方法,我只关注了makefile文件,直接make不行,需要做一些修改</p>
</li>
<li><p>可以把echo.cc文件放到上面说的”release-install-cpp11”目录下,然后通过下面的命令编译</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ echo.cc -I .&#x2F;include -L .&#x2F;lib -lmuduo_net -lmuduo_base -lpthread</span><br></pre></td></tr></table></figure>
<ul>
<li>这个本质就是要指定头文件和库文件所在位置,都在本目录下的include和lib文件夹下,如果在其他地方写程序,也需要指定这两个文件夹的目录,也可以放到系统path指定的目录中…</li>
</ul>
</li>
<li><p>自己的代码要使用muduo的话,就需要这个include和lib文件夹,我为了方便使用就把这两个文件夹内的内容移动到了/usr/local/include和/usr/local/lib目录下,这样编译的时候就不用指定目录了</p>
</li>
<li><p>编程方面,主要是写三个回调函数,也就是关注作者所说的三个半事件</p>
<ul>
<li>onMessage() 当消息到来(1)时做什么</li>
<li>onConnection() 当连接建立(2)和断开(3)的时候做什么</li>
<li>onWriteComplete() 当写完后(第三个半事件)做什么</li>
</ul>
</li>
</ol>
<h1 id="3-muduo各类总览"><a href="#3-muduo各类总览" class="headerlink" title="3. muduo各类总览"></a>3. muduo各类总览</h1><ol>
<li>这个实际是摘抄&lt;muduo网络库使用手册&gt;中的部分内容,能帮助快速理解muduo类</li>
</ol>
<h3 id="1-内部实现类"><a href="#1-内部实现类" class="headerlink" title="1. 内部实现类"></a>1. 内部实现类</h3><ol>
<li>Channel<ul>
<li>是selectable IO channel,负责注册与响应IO事件,它不拥有file descriptor.它是Acceptor,Connector,EventLoop,TimeQueue,TcpConnection的成员,生命周期由后者控制</li>
</ul>
</li>
<li>Socket<ul>
<li>封装一个file descriptor,并在析构的时候关闭fd.它是Acceptor,TcpConnection的成员,生命期由后者控制.EventLoop,TimerQueue也拥有fd,但是不封装为Socket.</li>
</ul>
</li>
<li>SocketsOps<ul>
<li>封装各种sockets系统调用</li>
</ul>
</li>
<li>Poller<ul>
<li>是PollPoller和EPollPoller的基类,采用”电平触发”的语意.它是EventLoop的成员,生命期由后者控制.</li>
</ul>
</li>
<li>PollPoller,EPollPoller<ul>
<li>这两个封装poll(2)和epoll(4)两种IO Multiplexing后端.Poll的存在价值是便于调试,因为poll(2)调用是上下文无关的,用strace(1)很容易知道库的行为是否准确.</li>
</ul>
</li>
<li>Connector<ul>
<li>用于发起TCP连接,它是TcpClient的成员,生命期由后者控制.</li>
</ul>
</li>
<li>Acceptor <ul>
<li>用于接受TCP连接,它是TcpServer的成员,生命期由后者控制.</li>
</ul>
</li>
<li>TimerQueue   <ul>
<li>用timerfd实现定时,这有别于传统的设置poll/epoll_wait的等待时长的方法.TimerQueue用std::map来管理Timer,常用操作的复杂度是O(lnN),N为定时器数目.它是EventLoop的成员,生命期由后者控制.</li>
</ul>
</li>
<li>EventLoopThreadPool<ul>
<li>用于创建IO线程池,用于把TcpConnection分派到某个EventLoop线程上.它是TcpServer的成员,生命期由后者控制.</li>
</ul>
</li>
</ol>
<h3 id="2-公开接口类"><a href="#2-公开接口类" class="headerlink" title="2. 公开接口类"></a>2. 公开接口类</h3><ol>
<li>Buffer<ul>
<li>仿Netty ChannelBuffer的buffer class,数据的读写透过buffer进行.用户代码不需要调用read(2)/write(2),只需要处理收到的数据和准备好要发送的数据.</li>
</ul>
</li>
<li>InetAddress<ul>
<li>封装IP地址,muduo目前不能解析域名,只认IP地址</li>
</ul>
</li>
<li>EventLoop<ul>
<li>事件循环(反应器Reactor),每个线程只能有一个EventLoop实体,它负责IO和定时器事件的分派.它用eventfd(2)来异步唤醒,者有别于传统的用一对pipe(2)的办法.它用TimerQueue作为计时器管理,用Poller作为IO Multiplexing.</li>
</ul>
</li>
<li>EventLoopThread<ul>
<li>启动一个线程,在其中运行EventLoop::loop().</li>
</ul>
</li>
<li>TcpConnection<ul>
<li>整个网络库的核心,封装一次TCP连接</li>
</ul>
</li>
<li>TcpClient<ul>
<li>用于编写网络客户端,能发起连接,并且有重试功能</li>
</ul>
</li>
<li>TcpServer<ul>
<li>用于编写网络服务端,接受客户的连接</li>
</ul>
</li>
</ol>
<ul>
<li>在这些类中,TcpConnection的生命期依靠share_ptr管理(即用户和库共同控制),Buffer的生命期由TcpConnection控制.其余类的生命期由用户控制.Buffer和InetAddress具有值语义,可以拷贝;其他class都是对象语义,不可以拷贝.</li>
</ul>
<h3 id="3-类图"><a href="#3-类图" class="headerlink" title="3. 类图"></a>3. 类图</h3><!-- ![muduo类图](./muduo类图.png) -->
<img src="/1-muduo%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AF%B4%E6%98%8E/muduo%E7%B1%BB%E5%9B%BE.png" class="" title="muduo类图.png">
<ul>
<li>白三角表示继承,图中的Poller和PollPoller,EPollPoller的关系</li>
<li>白菱形表示聚合,菱形指向整体,部分能脱离整体存在</li>
<li>黑菱形表示组合,菱形指向整体,部分不能脱离整体存在</li>
<li>实线表示关联,一个类知道另一个类的属性和方法</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>linux</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>API网关</title>
    <url>/API%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<h1 id="网易解读"><a href="#网易解读" class="headerlink" title="网易解读"></a>网易解读</h1><p>API 网关并不是微服务场景中必须的组件，如下图，不管有没有 API 网关，后端微服务都可以通过 API 很好地支持客户端的访问。</p>
<a id="more"></a>
<h3 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h3><p>作者：网易数帆<br>链接：<a href="https://www.zhihu.com/question/309582197/answer/578705309">https://www.zhihu.com/question/309582197/answer/578705309</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>API 网关并不是微服务场景中必须的组件，如下图，不管有没有 API 网关，后端微服务都可以通过 API 很好地支持客户端的访问。</p>
<!-- ![api网关](/Users/dxm/Documents/公司记录/9月/img/api网关.png) -->
<img src="/API%E7%BD%91%E5%85%B3/api%E7%BD%91%E5%85%B3.png" class="" title="api网关.png">

<p>但对于服务数量众多、复杂度比较高、规模比较大的业务来说，引入 API 网关也有一系列的好处：</p>
<ul>
<li>  聚合接口使得服务对调用者透明，客户端与后端的耦合度降低</li>
<li>  聚合后台服务，节省流量，提高性能，提升用户体验</li>
<li>  提供安全、流控、过滤、缓存、计费、监控等 API 管理功能</li>
</ul>
<p>在网易云与客户合作的技术实践中，客户往往需要通过统一的 API 网关进行服务能力的共享，提供发布、管理、保护和监控 API的能力，实现跨系统、跨协议的服务能力互通。以德邦快递为例：</p>
<ul>
<li>  一是客户需要通过 API 网关的熔断/限流/降级服务治理等能力和服务治理框架层相结合，来保证物流系统更好地支撑峰值流量的冲击；</li>
<li>  二是有些特殊场景的接口，比如支付接口，需要设置调用权限，API 网关配合中间框架更好实现黑白名单和权限的控制；</li>
<li>  三是网关的流量镜像能力，可以转发到压测环境，客户能够更好地估计系统能够承载的最大量；</li>
<li>  此外，API 网关通过流量的控制，还可以让客户更快地做好灰度发布、A/B 测试。</li>
</ul>
<p>基于这样的需求，网易云<a href="https://link.zhihu.com/?target=https://www.163yun.com/product-nsf?tag=M_zhihu_309582197_jd">轻舟微服务平台</a>的设计也包含了 API 网关组件的设计，采用插件式流量复制与分流实现，以提高系统的稳定性和响应效率，不过团队提供了可拆卸的模式，供用户按照实际的应用场景来选择。</p>
<h3 id="轻舟微服务平台的一些相关设计"><a href="#轻舟微服务平台的一些相关设计" class="headerlink" title="轻舟微服务平台的一些相关设计"></a>轻舟微服务平台的一些相关设计</h3><ol>
<li>API 网关中的服务路由和服务治理：</li>
</ol>
<ul>
<li><p>服务路由</p>
<ul>
<li>  静态路由策略配置</li>
<li>  后端服务的软负载均衡</li>
<li>  后端服务的心跳检查</li>
<li>  参数分流</li>
<li>  流量的镜像复制</li>
</ul>
</li>
<li><p>服务治理</p>
<ul>
<li>  后端服务的故障隔离</li>
<li>  网关、服务、API 级别的限流和熔断</li>
<li>  固定时段和周期时段的 API 维护开关</li>
</ul>
</li>
</ul>
<ol start="2">
<li>服务治理框架层的服务治理和流量管理：</li>
</ol>
<ul>
<li><p>服务治理</p>
<ul>
<li>  服务限流，支持 QPS、Thread 等多种限流方式</li>
<li>  降级与熔断，支持基于RT、错误率的熔断策略以及手动降级策略</li>
<li>  服务容错，支持 failover、failfast、failback等多种容错机制</li>
</ul>
</li>
<li><p>流量管理</p>
<ul>
<li>  路由管理，支持基于黑白名单的路由规则</li>
<li>  负载均衡，支持多种负载均衡规则，兼容 Spring Cloud Ribbon</li>
<li>  参数分流，支持参数取模、名单分流、权重分流等</li>
</ul>
</li>
</ul>
<h1 id="某公众号"><a href="#某公众号" class="headerlink" title="某公众号"></a>某公众号</h1><p>作者：JavaGuide<br>链接：<a href="https://zhuanlan.zhihu.com/p/90755546">https://zhuanlan.zhihu.com/p/90755546</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a><strong>1.背景</strong></h2><h3 id="1-1-什么是API网关"><a href="#1-1-什么是API网关" class="headerlink" title="1.1 什么是API网关"></a><strong>1.1 什么是API网关</strong></h3><p>API网关可以看做系统与外界联通的入口，我们可以在网关进行处理一些非业务逻辑的逻辑，比如权限验证，监控，缓存，请求路由等等。</p>
<h3 id="1-2-为什么需要API网关"><a href="#1-2-为什么需要API网关" class="headerlink" title="1.2 为什么需要API网关"></a><strong>1.2 为什么需要API网关</strong></h3><ul>
<li>  RPC协议转成HTTP。</li>
</ul>
<p>由于在内部开发中我们都是以RPC协议(thrift or dubbo)去做开发，暴露给内部服务，当外部服务需要使用这个接口的时候往往需要将RPC协议转换成HTTP协议。</p>
<ul>
<li>  请求路由</li>
</ul>
<p>在我们的系统中由于同一个接口新老两套系统都在使用，我们需要根据请求上下文将请求路由到对应的接口。</p>
<ul>
<li>  统一鉴权</li>
</ul>
<p>对于鉴权操作不涉及到业务逻辑，那么可以在网关层进行处理，不用下沉到业务逻辑。</p>
<ul>
<li>  统一监控</li>
</ul>
<p>由于网关是外部服务的入口，所以我们可以在这里监控我们想要的数据，比如入参出参，链路时间。</p>
<ul>
<li>  流量控制，熔断降级</li>
</ul>
<p>对于流量控制，熔断降级非业务逻辑可以统一放到网关层。</p>
<p>有很多业务都会自己去实现一层网关层，用来接入自己的服务，但是对于整个公司来说这还不够。</p>
<h3 id="1-3-统一API网关"><a href="#1-3-统一API网关" class="headerlink" title="1.3 统一API网关"></a><strong>1.3 统一API网关</strong></h3><p>统一的API网关不仅有API网关的所有的特点，还有下面几个好处:</p>
<ul>
<li>  统一技术组件升级</li>
</ul>
<p>在公司中如果有某个技术组件需要升级，那么是需要和每个业务线沟通，通常几个月都搞不定。举个例子如果对于入口的安全鉴权有重大安全隐患需要升级，如果速度还是这么慢肯定是不行，那么有了统一的网关升级是很快的。</p>
<ul>
<li>  统一服务接入</li>
</ul>
<p>对于某个服务的接入也比较困难，比如公司已经研发出了比较稳定的服务组件，正在公司大力推广，这个周期肯定也特别漫长，由于有了统一网关，那么只需要统一网关统一接入。</p>
<ul>
<li>  节约资源</li>
</ul>
<p>不同业务不同部门如果按照我们上面的做法应该会都自己搞一个网关层，用来做这个事，可以想象如果一个公司有100个这种业务，每个业务配备4台机器，那么就需要400台机器。并且每个业务的开发RD都需要去开发这个网关层，去随时去维护，增加人力。如果有了统一网关层，那么也许只需要50台机器就可以做这100个业务的网关层的事，并且业务RD不需要随时关注开发，上线的步骤。</p>
<h2 id="2-统一网关的设计"><a href="#2-统一网关的设计" class="headerlink" title="2.统一网关的设计"></a><strong>2.统一网关的设计</strong></h2><h3 id="2-1-异步化请求"><a href="#2-1-异步化请求" class="headerlink" title="2.1 异步化请求"></a><strong>2.1 异步化请求</strong></h3><p>对于我们自己实现的网关层，由于只有我们自己使用，对于吞吐量的要求并不高所以，我们一般同步请求调用即可。</p>
<p>对于我们统一的网关层，如何用少量的机器接入更多的服务，这就需要我们的异步，用来提高更多的吞吐量。对于异步化一般有下面两种策略：</p>
<ul>
<li>  Tomcat/Jetty+NIO+servlet3</li>
</ul>
<p>这种策略使用的比较普遍，京东，有赞，Zuul，都选取的是这个策略，这种策略比较适合HTTP。在Servlet3中可以开启异步。</p>
<ul>
<li>  Netty+NIO</li>
</ul>
<p>Netty为高并发而生，目前唯品会的网关使用这个策略，在唯品会的技术文章中在相同的情况下Netty是每秒30w+的吞吐量，Tomcat是13w+,可以看出是有一定的差距的，但是Netty需要自己处理HTTP协议，这一块比较麻烦。</p>
<p>对于网关是HTTP请求场景比较多的情况可以采用Servlet，毕竟有更加成熟的处理HTTP协议。如果更加重视吞吐量那么可以采用Netty。</p>
<h3 id="2-1-1-全链路异步"><a href="#2-1-1-全链路异步" class="headerlink" title="2.1.1 全链路异步"></a><strong>2.1.1 全链路异步</strong></h3><p>对于来的请求我们已经使用异步了，为了达到全链路异步所以我们需要对去的请求也进行异步处理，对于去的请求我们可以利用我们rpc的异步支持进行异步请求所以基本可以达到下图:</p>
<!-- ![全链路同步](/Users/dxm/Documents/公司记录/9月/img/API网关-全链路同步.jpg) -->
<img src="/API%E7%BD%91%E5%85%B3/API%E7%BD%91%E5%85%B3-%E5%85%A8%E9%93%BE%E8%B7%AF%E5%90%8C%E6%AD%A5.jpg" class="" title="API网关-全链路同步.jpg">

<p>由在web容器中开启servlet异步，然后进入到网关的业务线程池中进行业务处理，然后进行rpc的异步调用并注册需要回调的业务，最后在回调线程池中进行回调处理。</p>
<h3 id="2-2-链式处理"><a href="#2-2-链式处理" class="headerlink" title="2.2 链式处理"></a><strong>2.2 链式处理</strong></h3><p>在设计模式中有一个模式叫责任链模式，他的作用是避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。通过这种模式将请求的发送者和请求的处理者解耦了。在我们的各个框架中对此模式都有实现，比如servlet里面的filter，springmvc里面的Interceptor。</p>
<p>在Netflix Zuul中也应用了这种模式，如下图所示:</p>
<!-- ![链式处理](/Users/dxm/Documents/公司记录/9月/img/API网关-链式处理.jpg) -->
<img src="/API%E7%BD%91%E5%85%B3/API%E7%BD%91%E5%85%B3-%E9%93%BE%E5%BC%8F%E5%A4%84%E7%90%86.jpg" class="" title="API网关-链式处理.jpg">

<p>这种模式在网关的设计中我们可以借鉴到自己的网关设计:</p>
<ul>
<li>  preFilters：前置过滤器，用来处理一些公共的业务，比如统一鉴权，统一限流，熔断降级，缓存处理等，并且提供业务方扩展。</li>
<li>  routingFilters: 用来处理一些泛化调用，主要是做协议的转换，请求的路由工作。</li>
<li>  postFilters: 后置过滤器，主要用来做结果的处理，日志打点，记录时间等等。</li>
<li>  errorFilters: 错误过滤器，用来处理调用异常的情况。</li>
</ul>
<p>这种设计在有赞的网关也有应用。</p>
<h3 id="2-3-业务隔离"><a href="#2-3-业务隔离" class="headerlink" title="2.3 业务隔离"></a><strong>2.3 业务隔离</strong></h3><p>上面在全链路异步的情况下不同业务之间的影响很小，但是如果在提供的自定义FiIlter中进行了某些同步调用，一旦超时频繁那么就会对其他业务产生影响。所以我们需要采用隔离之术，降低业务之间的互相影响。</p>
<h3 id="2-3-1-信号量隔离"><a href="#2-3-1-信号量隔离" class="headerlink" title="2.3.1 信号量隔离"></a><strong>2.3.1 信号量隔离</strong></h3><p>信号量隔离只是限制了总的并发数，服务还是主线程进行同步调用。这个隔离如果远程调用超时依然会影响主线程，从而会影响其他业务。因此，如果只是想限制某个服务的总并发调用量或者调用的服务不涉及远程调用的话，可以使用轻量级的信号量来实现。有赞的网关由于没有自定义filter所以选取的是信号量隔离。</p>
<h3 id="2-3-2-线程池隔离"><a href="#2-3-2-线程池隔离" class="headerlink" title="2.3.2 线程池隔离"></a><strong>2.3.2 线程池隔离</strong></h3><p>最简单的就是不同业务之间通过不同的线程池进行隔离，就算业务接口出现了问题由于线程池已经进行了隔离那么也不会影响其他业务。在京东的网关实现之中就是采用的线程池隔离，比较重要的业务比如商品或者订单 都是单独的通过线程池去处理。但是由于是统一网关平台，如果业务线众多，大家都觉得自己的业务比较重要需要单独的线程池隔离，如果使用的是Java语言开发的话那么，在Java中线程是比较重的资源比较受限，如果需要隔离的线程池过多不是很适用。如果使用一些其他语言比如Golang进行开发网关的话，线程是比较轻的资源，所以比较适合使用线程池隔离。</p>
<h3 id="2-3-3-集群隔离"><a href="#2-3-3-集群隔离" class="headerlink" title="2.3.3 集群隔离"></a><strong>2.3.3 集群隔离</strong></h3><p>如果有某些业务就需要使用隔离但是统一网关又没有线程池隔离那么应该怎么办呢？那么可以使用集群隔离，如果你的某些业务真的很重要那么可以为这一系列业务单独申请一个集群或者多个集群，通过机器之间进行隔离。</p>
<h3 id="2-4-请求限流"><a href="#2-4-请求限流" class="headerlink" title="2.4 请求限流"></a><strong>2.4 请求限流</strong></h3><p>流量控制可以采用很多开源的实现，比如阿里最近开源的Sentinel和比较成熟的Hystrix。</p>
<p>一般限流分为集群限流和单机限流:</p>
<ul>
<li>  利用统一存储保存当前流量的情况，一般可以采用Redis，这个一般会有一些性能损耗。</li>
<li>  单机限流:限流每台机器我们可以直接利用Guava的令牌桶去做，由于没有远程调用性能消耗较小。</li>
</ul>
<h3 id="2-5-熔断降级"><a href="#2-5-熔断降级" class="headerlink" title="2.5 熔断降级"></a><strong>2.5 熔断降级</strong></h3><p>这一块也可以参照开源的实现Sentinel和Hystrix，这里不是重点就不多提了。</p>
<h3 id="2-6-泛化调用"><a href="#2-6-泛化调用" class="headerlink" title="2.6 泛化调用"></a><strong>2.6 泛化调用</strong></h3><p>泛化调用指的是一些通信协议的转换，比如将HTTP转换成Thrift。在一些开源的网关中比如Zuul是没有实现的，因为各个公司的内部服务通信协议都不同。比如在唯品会中支持HTTP1,HTTP2,以及二进制的协议，然后转化成内部的协议，淘宝的支持HTTPS,HTTP1,HTTP2这些协议都可以转换成，HTTP,HSF,Dubbo等协议。</p>
<h3 id="2-6-1泛化调用"><a href="#2-6-1泛化调用" class="headerlink" title="2.6.1泛化调用"></a><strong>2.6.1泛化调用</strong></h3><p>如何去实现泛化调用呢？由于协议很难自动转换，那么其实每个协议对应的接口需要提供一种映射。简单来说就是把两个协议都能转换成共同语言，从而互相转换。</p>
<!-- ![](/Users/dxm/Documents/公司记录/9月/img/泛化调用.jpg) -->
<img src="/API%E7%BD%91%E5%85%B3/%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8.jpg" class="" title="泛化调用.jpg">

<p>一般来说共同语言有三种方式指定:</p>
<ul>
<li>  json：json数据格式比较简单,解析速度快，较轻量级。在Dubbo的生态中有一个HTTP转Dubbo的项目是用JsonRpc做的，将HTTP转化成JsonRpc再转化成Dubbo。</li>
</ul>
<p>比如可以将一个 <strong><a href="https://link.zhihu.com/?target=http://www.baidu.com/id">www.baidu.com/id</a></strong> = 1 GET 可以映射为json：</p>
<p>代码块</p>
<ul>
<li>  xml:xml数据比较重，解析比较困难，这里不过多讨论。</li>
<li>  自定义描述语言:一般来说这个成本比较高需要自己定义语言来进行描述并进行解析，但是其扩展性，自定义个性化性都是最高。例:spring自定义了一套自己的SPEL表达式语言</li>
</ul>
<p>对于泛化调用如果要自己设计的话JSON基本可以满足，如果对于个性化的需要特别多的话倒是可以自己定义一套语言。</p>
<h3 id="2-7-管理平台"><a href="#2-7-管理平台" class="headerlink" title="2.7 管理平台"></a><strong>2.7 管理平台</strong></h3><p>上面介绍的都是如何实现一个网关的技术关键。这里需要介绍网关的一个业务关键。有了网关之后，需要一个管理平台如何去对我们上面所描述的技术关键进行配置,包括但不限于下面这些配置:</p>
<ul>
<li>  限流</li>
<li>  熔断</li>
<li>  缓存</li>
<li>  日志</li>
<li>  自定义filter</li>
<li>  泛化调用</li>
</ul>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a><strong>3.总结</strong></h2><p>最后一个合理的标准网关应该按照如下去实现:</p>
<!-- ![](/Users/dxm/Documents/公司记录/9月/img/API网关-标准网关.jpg) -->
<img src="/API%E7%BD%91%E5%85%B3/API%E7%BD%91%E5%85%B3-%E6%A0%87%E5%87%86%E7%BD%91%E5%85%B3.jpg" class="" title="API网关-标准网关.jpg">

<p><strong>—京东唯品会有赞阿里Zuul</strong>实现关键servlet3.0nettyservlet3.0servlet3.0servlet3.0异步情况servlet异步，rpc是否异步不清楚全链路异步全链路异步全链路异步Zuul1同步阻塞,Zuul2异步非阻塞限流——平滑限流。最初是codis，后续换到每个单机的令牌桶限流。1.基本流控:基于API的QPS做限流。2.运营流控:支持APP流量包，APP+API+USER的流控33.大促流控:APP访问API的权重流控。阿里开源:Sentinel提供了jar包:spring-cloud-zuul-ratelimit。1.对请求的目标URL进行限流（例如：某个URL每分钟只允许调用多少次)。2.对客户端的访问IP进行限流（例如：某个IP每分钟只允许请求多少次）3.对某些特定用户或者用户组进行限流（例如：非VIP用户限制每分钟只允许调用100次某个API等）4.多维度混合的限流。此时，就需要实现一些限流规则的编排机制。与、或、非等关系。支持四种存储方式ConcurrentHashMap,Consul,Redis,数据库。熔断降级——Hystrix—只支持服务级别熔断，不支持URL级别。隔离线程池隔离—信号量隔离—线程池隔离，信号量隔离缓存redis—二级缓存，本地缓存+CodisHDCC 本地缓存，远程缓存，数据库需要自己开发泛化调用—http,https,http1,http2,二进制dubbo,http,novahsf,dubbo,http,https,http2,http1只支持http</p>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a><strong>4.参考</strong></h2><ul>
<li>  京东:<a href="https://link.zhihu.com/?target=http://www.yunweipai.com/archives/23653.html">http://www.yunweipai.com/archives/23653.html</a></li>
<li>  有赞网关:<a href="https://link.zhihu.com/?target=https://tech.youzan.com/api-gateway-in-practice/">https://tech.youzan.com/api-gateway-in-practice/</a></li>
<li>  唯品会:<a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s/gREMe-G7nqNJJLzbZ3ed3A">https://mp.weixin.qq.com/s/gREMe-G7nqNJJLzbZ3ed3A</a></li>
<li>  Zuul:<a href="https://link.zhihu.com/?target=http://www.scienjus.com/api-gateway-and-netflix-zuul/">http://www.scienjus.com/api-gateway-and-netflix-zuul/</a></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>网关</tag>
        <tag>微服务</tag>
        <tag>服务端</tag>
      </tags>
  </entry>
  <entry>
    <title>API网关开源库gateway</title>
    <url>/API%E7%BD%91%E5%85%B3%E5%BC%80%E6%BA%90%E5%BA%93gateway/</url>
    <content><![CDATA[<h3 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h3><ol>
<li>安装源码 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;fagongzi&#x2F;gateway.git</span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li>使用docker-compose运行<ul>
<li>如何安装docker和docker-compose略过</li>
<li>需要先修改下docker-compose.yml文件，把镜像 gcr.io/etcd-development/etcd 改成 quay.io/coreos/etcd 。前者下载不了。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>查看<ul>
<li>使用 <code>http://127.0.0.1:9093/ui/index.html</code> 访问 <code>apiserver</code></li>
<li>使用 <code>http://127.0.0.1</code> 访问你的API</li>
</ul>
</li>
</ol>
<h3 id="启动的服务介绍"><a href="#启动的服务介绍" class="headerlink" title="启动的服务介绍"></a>启动的服务介绍</h3><ul>
<li>一共启动了六个服务</li>
</ul>
<ol>
<li><p>pushgateway</p>
<ul>
<li>使用端口：9091</li>
</ul>
</li>
<li><p>prometheus</p>
<ul>
<li>使用端口：9090</li>
<li>依赖服务：pushgateway</li>
</ul>
</li>
<li><p>grafana</p>
<ul>
<li>使用端口：3000</li>
<li>依赖服务：prometheus</li>
</ul>
</li>
<li><p>etcd</p>
<ul>
<li>使用端口：2379</li>
<li>依赖服务：prometheus</li>
</ul>
</li>
<li><p>apiserver</p>
<ul>
<li>本地端口：9093(HTTP)、9092(GRPC)</li>
<li>依赖服务：etcd</li>
</ul>
</li>
<li><p>proxy</p>
<ul>
<li>使用端口：80</li>
<li>依赖服务：etcd、apiserver</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>网关</tag>
        <tag>微服务</tag>
        <tag>服务端</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++静态变量</title>
    <url>/C++%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="一、静态变量"><a href="#一、静态变量" class="headerlink" title="一、静态变量"></a>一、静态变量</h3><h4 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1. 作用域"></a>1. 作用域</h4><pre><code>      1. 局部静态变量的作用域在它所在的&#123; &#125;内
      2. 全局静态变量在整个文件</code></pre>
<h4 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h4><pre><code>      不管全局还是局部的静态变量，生命周期都是整个程序运行过程</code></pre>
<h3 id="二、静态函数"><a href="#二、静态函数" class="headerlink" title="二、静态函数"></a>二、静态函数</h3><h4 id="1-C-中类的静态函数"><a href="#1-C-中类的静态函数" class="headerlink" title="1. C++中类的静态函数"></a>1. C++中类的静态函数</h4><pre><code>    1. 必须在类外初始化
    2. 函数内只能使用类的静态成员变量</code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>静态变量</tag>
      </tags>
  </entry>
  <entry>
    <title>CGI</title>
    <url>/CGI/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>CGI，Common gateway interface 公共网关接口<img src="/CGI/CGI.png" class="" title="CGI.png">
<a id="more"></a></li>
<li>作用：<ul>
<li>Nginx响应静态资源的时候，直接返回就行了。但nginx不能执行动态请求，只能转发到后端服务上，这个后端服务可能是用php写的，nginx和php不能直接交流，需要一个中间的翻译，就是cgi。Cgi将请求的数据转换成php能理解的形式传给后端，php处理过后，cgi再将php处理结果转换成nginx能理解的形式传给nginx，再由nginx响应给请求方。</li>
</ul>
</li>
</ul>
<h3 id="Fast-cgi："><a href="#Fast-cgi：" class="headerlink" title="Fast-cgi："></a>Fast-cgi：</h3><ul>
<li>传统cgi协议对每次连接请求，会开启一个进程处理，执行完关闭进程，有多少个连接就有多少cgi进程，所以传统的cgi很缓慢，会消耗很多资源和内存。</li>
<li>Fast-cgi可以一个进程接收多个请求（请求处理完了进程不关闭，继续处理下一个请求），即进程池。（池子技术是一种很常见的后端性能优化技术。）</li>
</ul>
<h3 id="Php-cgi："><a href="#Php-cgi：" class="headerlink" title="Php-cgi："></a>Php-cgi：</h3><ul>
<li>Php-cgi是php提供给web server也就是http前端服务器的cgi协议接口程序，当每次接到http前端服务器的请求都会开启一个php-cgi进程进行处理。而且开启的php-cgi的过程中会先要重载配置，数据结构以及初始化运行环境，如果更新了php配置，那就需要重启php-cgi才能生效。</li>
</ul>
<h3 id="Php-fpm："><a href="#Php-fpm：" class="headerlink" title="Php-fpm："></a>Php-fpm：</h3><ul>
<li>Php-fpm就是php的fast-cgi，可以说是多个php-cgi的管理器。<ul>
<li>还有其他功能，比如更改php配置不需要重启php-fpm</li>
</ul>
</li>
<li>Cgi如何实现的：<ul>
<li>将http的请求信息以环境变量的方式写入OS，CGI本质是OS上一个普通的可执行程序，除环境变量外，另一个CGI程序获取数据的方式是标准输入。将数据输出到标准输出就能传送给客户端，Web服务器已经把标准输出重定向给Web服务器与浏览器连接的socket。</li>
</ul>
</li>
<li>Cgi如今的处境：<ul>
<li>之前cgi还作为web服务端直接返回给前端html页面。但cgi缺乏URL路由功能。</li>
<li>现在cgi不再用于直接返回html页面，其他复杂的计算和IO任务也下沉到后端，cgi作为前后端之间的中间层。此时的cgi的职能是完成基本的鉴权和数据交换。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>将cgi原理<ul>
<li>环境变量，输入输出，返回html。</li>
</ul>
</li>
<li>缺点<ul>
<li>进程多，没有url路由。Fastcgi</li>
</ul>
</li>
<li>   Nginx和php的交互中对cgi的使用，数据转换的功能</li>
<li>Cgi目前的使用场景<ul>
<li>中间层，鉴权与数据转换。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>服务端</tag>
        <tag>php</tag>
        <tag>cgi</tag>
      </tags>
  </entry>
  <entry>
    <title>C中对结构体sizeof</title>
    <url>/C%E4%B8%AD%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93sizeof/</url>
    <content><![CDATA[<h3 id="唉"><a href="#唉" class="headerlink" title="唉"></a>唉</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1 Byte</span><br><span class="line">struct test</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* data *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;8 Byte</span><br><span class="line">struct test2</span><br><span class="line">&#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;8 Byte</span><br><span class="line">struct test3</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;12 Byte</span><br><span class="line">struct test4</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;8 Byte</span><br><span class="line">struct test5</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    char b;</span><br><span class="line">    int a;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;2 Byte</span><br><span class="line">struct test6</span><br><span class="line">&#123;</span><br><span class="line">    char a;</span><br><span class="line">    char b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;16 Byte</span><br><span class="line">struct test7</span><br><span class="line">&#123;</span><br><span class="line">    double a;</span><br><span class="line">    char b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;sizeof(test)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;sizeof(test2)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;sizeof(test3)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;sizeof(test4)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;sizeof(test5)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;sizeof(test6)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;sizeof(test7)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>字节数据是存在内存中的，字节对齐能加快内存的访问速度。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>结构体</tag>
        <tag>sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS一些问题</title>
    <url>/DNS%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ol>
<li>为什么只有13个根域名服务器（根DNS）?UDP包限制，512字节以内，13个最好，其中10个在美国，一个瑞典一个英国一个日本</li>
<li>LDNS</li>
<li>DNS三种记录，A(域名-ip),CNAME(域名-别名),NS（域名-能解析的权威DNS）</li>
<li>根镜像，和根起到一样的功能。根镜像共享13个ip，也就是全球1000多跟镜像使用13个ip，这里使用到了任播（也叫泛播）技术。对于中国用户，对根的请求一般不会跑到美国去，而是通过任播技术路由到中国境内的根镜像上。</li>
<li>任播是指在IP网络上通过一个IP地址标识一组提供特定服务的主机，服务访问方并不关心提供服务具体是哪一台主机提供的，访问该地址的报文可以被IP网络路由到“最近”的一个（最好也只是一个，别送到多个）服务器上。这里“最近”可以是指路由器跳数、服务器负载、服务器吞吐量、客户和服务器之间的往返时间（ RTT，round trip time ）、链路的可用带宽等特征值。和负载均衡有点像。</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>ETCD尝试</title>
    <url>/ETCD%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/f68028682192">https://www.jianshu.com/p/f68028682192</a></p>
<a id="more"></a>

<h3 id="本地Docker运行"><a href="#本地Docker运行" class="headerlink" title="本地Docker运行"></a>本地Docker运行</h3><ol>
<li><p>准备数据目录</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf &#x2F;tmp&#x2F;etcd-data.tmp &amp;&amp; mkdir -p &#x2F;tmp&#x2F;etcd-data.tmp</span><br></pre></td></tr></table></figure></li>
<li><p>下载镜像</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull quay.io&#x2F;coreos&#x2F;etcd</span><br></pre></td></tr></table></figure></li>
<li><p>运行容器</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  -p 2379:2379 \</span><br><span class="line">  -p 2380:2380 \</span><br><span class="line">  --mount type&#x3D;bind,source&#x3D;&#x2F;tmp&#x2F;etcd-data.tmp,destination&#x3D;&#x2F;etcd-data \</span><br><span class="line">  --name etcd-lv \</span><br><span class="line">  quay.io&#x2F;coreos&#x2F;etcd \</span><br><span class="line">  &#x2F;usr&#x2F;local&#x2F;bin&#x2F;etcd \</span><br><span class="line">  --name s1 \</span><br><span class="line">  --data-dir &#x2F;etcd-data \</span><br><span class="line">  --listen-client-urls http:&#x2F;&#x2F;0.0.0.0:2379 \</span><br><span class="line">  --advertise-client-urls http:&#x2F;&#x2F;0.0.0.0:2379 \</span><br><span class="line">  --listen-peer-urls http:&#x2F;&#x2F;0.0.0.0:2380 \</span><br><span class="line">  --initial-advertise-peer-urls http:&#x2F;&#x2F;0.0.0.0:2380 \</span><br><span class="line">  --initial-cluster s1&#x3D;http:&#x2F;&#x2F;0.0.0.0:2380 \</span><br><span class="line">  --initial-cluster-token tkn \</span><br><span class="line">  --initial-cluster-state new</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行etcd</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 产看版本</span><br><span class="line">  	docker exec etcd-lv &#x2F;bin&#x2F;sh -c &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;etcd --version&quot;</span><br><span class="line">  	docker exec etcd-lv &#x2F;bin&#x2F;sh -c &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;etcdctl --version&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>服务端</tag>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>GOExcel处理库excelize</title>
    <url>/GOExcel%E5%A4%84%E7%90%86%E5%BA%93excelize/</url>
    <content><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ol>
<li>go语言的一种操作xlsx文件的库<a id="more"></a>

</li>
</ol>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><h5 id="1-导入路径"><a href="#1-导入路径" class="headerlink" title="1. 导入路径"></a>1. 导入路径</h5><ul>
<li>“github.com/360EntSecGroup-Skylar/excelize”</li>
</ul>
<h5 id="2-创建"><a href="#2-创建" class="headerlink" title="2. 创建"></a>2. 创建</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">       f :&#x3D; excelize.NewFile()</span><br><span class="line">       &#x2F;&#x2F; 创建一个工作表</span><br><span class="line">       index :&#x3D; f.NewSheet(&quot;Sheet2&quot;)</span><br><span class="line">       &#x2F;&#x2F; 设置单元格的值</span><br><span class="line">       f.SetCellValue(&quot;Sheet2&quot;, &quot;A2&quot;, &quot;Hello world.&quot;)</span><br><span class="line">       f.SetCellValue(&quot;Sheet1&quot;, &quot;B2&quot;, 100)</span><br><span class="line">       &#x2F;&#x2F; 设置工作簿的默认工作表</span><br><span class="line">       f.SetActiveSheet(index)</span><br><span class="line">       &#x2F;&#x2F; 根据指定路径保存文件</span><br><span class="line">       if err :&#x3D; f.SaveAs(&quot;Book1.xlsx&quot;); err !&#x3D; nil &#123;</span><br><span class="line">           fmt.Println(err)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-修改单元格值"><a href="#3-修改单元格值" class="headerlink" title="3. 修改单元格值"></a>3. 修改单元格值</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f.SetCellValue(&quot;Sheet2&quot;, &quot;A2&quot;, &quot;Hello world.&quot;)</span><br></pre></td></tr></table></figure>

<h5 id="4-读excel"><a href="#4-读excel" class="headerlink" title="4. 读excel"></a>4. 读excel</h5><ol>
<li>获取工作表中指定单元格的值 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f, err :&#x3D; excelize.OpenFile(&quot;Book1.xlsx&quot;)</span><br><span class="line">  cell, err :&#x3D; f.GetCellValue(&quot;Sheet1&quot;, &quot;B2&quot;)</span><br></pre></td></tr></table></figure></li>
<li>获取 Sheet1 上所有单元格 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rows, err :&#x3D; f.GetRows(&quot;Sheet1&quot;)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h5 id="5-保存"><a href="#5-保存" class="headerlink" title="5. 保存"></a>5. 保存</h5><ol>
<li><p>保存</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (f *File) Save() error</span><br></pre></td></tr></table></figure>
</li>
<li><p>另存为</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (f *File) SaveAs(name string) error</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GOJson库gjson</title>
    <url>/GOJson%E5%BA%93gjson/</url>
    <content><![CDATA[<h3 id="gjson"><a href="#gjson" class="headerlink" title="gjson"></a>gjson</h3><a id="more"></a>
<ol>
<li>直接使用json库，需要自己构建结构体。</li>
<li>gjson可以直接解析json字符串，不用unmar..成结构体。</li>
<li>包路径：github.com/tidwall/gjson</li>
</ol>
<h3 id="一些使用"><a href="#一些使用" class="headerlink" title="一些使用"></a>一些使用</h3><h5 id="1-通过key获得对象"><a href="#1-通过key获得对象" class="headerlink" title="1. 通过key获得对象"></a>1. 通过key获得对象</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bns :&#x3D; gjson.Get(jsonData, &quot;Bns&quot;)</span><br></pre></td></tr></table></figure>


<h5 id="2-遍历数组"><a href="#2-遍历数组" class="headerlink" title="2. 遍历数组"></a>2. 遍历数组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp:&#x3D;gjson.Parse(jsonData)</span><br><span class="line">temp.ForEach(func(key, value gjson.Result) bool &#123;</span><br><span class="line">	localIpPort :&#x3D; gjson.Get(value.String(), &quot;LocalIpPort&quot;)</span><br><span class="line">	remoteIpPort :&#x3D; gjson.Get(value.String(), &quot;RemoteIpPort&quot;)</span><br><span class="line">	cwd :&#x3D; gjson.Get(value.String(), &quot;Cwd&quot;)</span><br><span class="line">	bns :&#x3D; gjson.Get(value.String(), &quot;Bns&quot;)</span><br><span class="line">	direction :&#x3D; gjson.Get(value.String(), &quot;Direction&quot;)</span><br><span class="line"></span><br><span class="line">	return true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><h5 id="json格式"><a href="#json格式" class="headerlink" title="json格式"></a>json格式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;enable&quot;:[&quot;bbb&quot;],&quot;idc_mapping_rule&quot;:&#123;&quot;aaa&quot;:&#123;&quot;prefer&quot;:[&quot;aaa&quot;],&quot;backup&quot;:[&quot;bbb&quot;],&quot;min_instance_need&quot;:1&#125;,&quot;bbb&quot;:&#123;&quot;prefer&quot;:[&quot;bbb&quot;],&quot;backup&quot;:[&quot;aaa&quot;],&quot;min_instance_need&quot;:1&#125;,&quot;hbf&quot;:&#123;&quot;prefer&quot;:[&quot;hbf&quot;],&quot;backup&quot;:[&quot;aaa&quot;],&quot;min_instance_need&quot;:1&#125;,&quot;hbg&quot;:&#123;&quot;prefer&quot;:[&quot;hbg&quot;],&quot;backup&quot;:[&quot;bbb&quot;],&quot;min_instance_need&quot;:1&#125;,&quot;default&quot;:&#123;&quot;prefer&quot;:[&quot;aaa&quot;,&quot;bbb&quot;]&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="主要解析代码"><a href="#主要解析代码" class="headerlink" title="主要解析代码"></a>主要解析代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 规则1：enable不为1</span><br><span class="line">		enable :&#x3D; gjson.Get(temp.String(), &quot;enable&quot;)</span><br><span class="line">		if !enable.Exists() || enable.String() !&#x3D; &quot;1&quot; &#123;</span><br><span class="line">			fdWriter.WriteString(line + &quot;\n&quot;)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		idc_mapping_rule :&#x3D; gjson.Get(temp.String(), &quot;idc_mapping_rule&quot;)</span><br><span class="line">		idc_mapping_rule.ForEach(func(key, value gjson.Result) bool &#123;</span><br><span class="line">			if key.String() &#x3D;&#x3D; &quot;default&quot; &#123;</span><br><span class="line">				return true</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F; 规则2：prefer backup min 不全，必须三个都有</span><br><span class="line">			prefer :&#x3D; gjson.Get(value.String(), &quot;prefer&quot;)</span><br><span class="line">			backup :&#x3D; gjson.Get(value.String(), &quot;backup&quot;)</span><br><span class="line">			min_instance_need :&#x3D; gjson.Get(value.String(), &quot;min_instance_need&quot;)</span><br><span class="line">			if !prefer.Exists() || !backup.Exists() || !min_instance_need.Exists() &#123;</span><br><span class="line">				fdWriter.WriteString(line + &quot;\n&quot;)</span><br><span class="line">				return true</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; 规则3: hbg-&gt;aaa hbf-&gt;bbb &#x2F;&#x2F;TODO 这里的backup是列表</span><br><span class="line">			if key.String() &#x3D;&#x3D; &quot;hbf&quot; &amp;&amp; backup.String() !&#x3D; &quot;[\&quot;bbb\&quot;]&quot; &#123;</span><br><span class="line">				fdWriter.WriteString(line + &quot;\n&quot;)</span><br><span class="line">				return true</span><br><span class="line">			&#125;</span><br><span class="line">			if key.String() &#x3D;&#x3D; &quot;hbg&quot; &amp;&amp; backup.String() !&#x3D; &quot;[\&quot;aaa\&quot;]&quot; &#123;</span><br><span class="line">				fdWriter.WriteString(line + &quot;\n&quot;)</span><br><span class="line">				return true</span><br><span class="line">			&#125;</span><br><span class="line">			return true</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title>GOWeb框架Beego</title>
    <url>/GOWeb%E6%A1%86%E6%9E%B6Beego/</url>
    <content><![CDATA[<h3 id="1-Beego"><a href="#1-Beego" class="headerlink" title="1. Beego"></a>1. Beego</h3><ol>
<li>主要分为以下两种项目：api项目，web项目<a id="more"></a></li>
<li>增加CORS支持<ul>
<li>在main中增加：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 允许跨域</span><br><span class="line">beego.InsertFilter(&quot;*&quot;, beego.BeforeRouter, cors.Allow(&amp;cors.Options&#123;</span><br><span class="line">  AllowAllOrigins:  true,</span><br><span class="line">  AllowMethods:     []string&#123;&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;&#125;,</span><br><span class="line">  AllowHeaders:     []string&#123;&quot;Origin&quot;, &quot;X-Requested-With&quot;, &quot;Authorization&quot;, &quot;Access-Control-Allow-Origin&quot;, &quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;&#125;,</span><br><span class="line">  ExposeHeaders:    []string&#123;&quot;Content-Length&quot;, &quot;X-Requested-With&quot;, &quot;Access-Control-Allow-Origin&quot;, &quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;&#125;,</span><br><span class="line">  AllowCredentials: true,</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li>
<li>在函数中增加<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctx.Output.Header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="2-restful-api项目"><a href="#2-restful-api项目" class="headerlink" title="2. restful api项目"></a>2. restful api项目</h3><h5 id="1-创建"><a href="#1-创建" class="headerlink" title="1. 创建"></a>1. 创建</h5><ol>
<li>bee api xxx</li>
</ol>
<h5 id="2-路由解析"><a href="#2-路由解析" class="headerlink" title="2. 路由解析"></a>2. 路由解析</h5><ol start="0">
<li><p>在router.go中配置路由，写法如下。commentsRouter_controllers.go中会根据 controller 里面的注释内容自动生成。</p>
</li>
<li><p>目前自动化文档只支持如下的写法的解析，其他写法函数不会自动解析，即 namespace+Include 的写法，而且只支持二级解析，一级版本号，二级分别表示应用模块。/v1/xxx/ 这是遵循了RESTful风格的名字和路径。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; router.go文件</span><br><span class="line">func init() &#123;</span><br><span class="line">    ns :&#x3D; beego.NewNamespace(&quot;&#x2F;v1&quot;,</span><br><span class="line">      beego.NSNamespace(&quot;&#x2F;object&quot;,</span><br><span class="line">        beego.NSInclude(</span><br><span class="line">          &amp;controllers.ObjectController&#123;&#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      beego.NSNamespace(&quot;&#x2F;user&quot;,</span><br><span class="line">        beego.NSInclude(</span><br><span class="line">          &amp;controllers.UserController&#123;&#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    )</span><br><span class="line">    beego.AddNamespace(ns)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>应用注释</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; @Title CreateUser</span><br><span class="line">  &#x2F;&#x2F; @Description create users</span><br><span class="line">  &#x2F;&#x2F; @Param	body		body 	models.User	true		&quot;body for user content&quot;</span><br><span class="line">  &#x2F;&#x2F; @Success 200 &#123;int&#125; models.User.Id</span><br><span class="line">  &#x2F;&#x2F; @Failure 403 body is empty</span><br><span class="line">  &#x2F;&#x2F; @router &#x2F; [post]</span><br><span class="line">  func (u *UserController) Post() &#123;</span><br><span class="line">    var user models.User</span><br><span class="line">    json.Unmarshal(u.Ctx.Input.RequestBody, &amp;user)</span><br><span class="line">    uid :&#x3D; models.AddUser(user)</span><br><span class="line">    u.Data[&quot;json&quot;] &#x3D; map[string]string&#123;&quot;uid&quot;: uid&#125;</span><br><span class="line">    u.ServeJSON()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; @Title GetAll</span><br><span class="line">  &#x2F;&#x2F; @Description get all Users</span><br><span class="line">  &#x2F;&#x2F; @Success 200 &#123;object&#125; models.User</span><br><span class="line">  &#x2F;&#x2F; @router &#x2F; [get]</span><br><span class="line">  func (u *UserController) GetAll() &#123;</span><br><span class="line">    users :&#x3D; models.GetAllUsers()</span><br><span class="line">    u.Data[&quot;json&quot;] &#x3D; users</span><br><span class="line">    u.ServeJSON()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>问题</p>
<ul>
<li>beego如果发现修改了API，重新bee run -gendoc=true之后而swagger并没有更新改变，请清除浏览器的缓存(或chrome的Ctrl+F5)再试。</li>
</ul>
</li>
</ol>
<h5 id="使用swagger文档"><a href="#使用swagger文档" class="headerlink" title="使用swagger文档"></a>使用swagger文档</h5><ol>
<li>swagger是对api的一种汇总。</li>
<li>需要在 conf/app.conf 打开开关：EnableDocs = true</li>
<li>运行项目的时候指定：bee run -gendoc=true -downdoc=true</li>
<li>默认文档路径是：<a href="http://localhost:8080/swagger/">http://localhost:8080/swagger/</a></li>
</ol>
<h3 id="3-web项目"><a href="#3-web项目" class="headerlink" title="3. web项目"></a>3. web项目</h3><h5 id="1-创建-1"><a href="#1-创建-1" class="headerlink" title="1. 创建"></a>1. 创建</h5><ol>
<li>bee create xxx</li>
<li>没啥说的，以后估计不常用</li>
</ol>
<h5 id="2-路由"><a href="#2-路由" class="headerlink" title="2. 路由"></a>2. 路由</h5><ol>
<li>直接在router中修改</li>
</ol>
<h5 id="3-视图"><a href="#3-视图" class="headerlink" title="3. 视图"></a>3. 视图</h5><ol>
<li>view中编写，使用模板</li>
</ol>
<h5 id="4-MC"><a href="#4-MC" class="headerlink" title="4. MC"></a>4. MC</h5><ol>
<li>model里写业务逻辑</li>
<li>controlers中写处理get post等的逻辑</li>
</ol>
<h3 id="4-特性模块说明"><a href="#4-特性模块说明" class="headerlink" title="4. 特性模块说明"></a>4. 特性模块说明</h3><h5 id="4-1-session模块"><a href="#4-1-session模块" class="headerlink" title="4.1 session模块"></a>4.1 session模块</h5><h5 id="4-2-grace模块"><a href="#4-2-grace模块" class="headerlink" title="4.2 grace模块"></a>4.2 grace模块</h5><h5 id="4-3-cache模块"><a href="#4-3-cache模块" class="headerlink" title="4.3 cache模块"></a>4.3 cache模块</h5><h5 id="4-4-logs模块"><a href="#4-4-logs模块" class="headerlink" title="4.4 logs模块"></a>4.4 logs模块</h5><h5 id="4-5-httplib模块"><a href="#4-5-httplib模块" class="headerlink" title="4.5 httplib模块"></a>4.5 httplib模块</h5><h5 id="4-6-context模块"><a href="#4-6-context模块" class="headerlink" title="4.6 context模块"></a>4.6 context模块</h5><h5 id="4-7-toolbox模块"><a href="#4-7-toolbox模块" class="headerlink" title="4.7 toolbox模块"></a>4.7 toolbox模块</h5><h5 id="4-8-config模块"><a href="#4-8-config模块" class="headerlink" title="4.8 config模块"></a>4.8 config模块</h5><h5 id="4-9-i18n模块"><a href="#4-9-i18n模块" class="headerlink" title="4.9 i18n模块"></a>4.9 i18n模块</h5><h3 id="5-beego高级编程"><a href="#5-beego高级编程" class="headerlink" title="5. beego高级编程"></a>5. beego高级编程</h3><h5 id="5-1-进程内监控"><a href="#5-1-进程内监控" class="headerlink" title="5.1 进程内监控"></a>5.1 进程内监控</h5><ol>
<li>8080对外提供服务，8088端口对内用于监控进程内的信息，执行定时任务等。</li>
</ol>
<h5 id="5-2-过滤器"><a href="#5-2-过滤器" class="headerlink" title="5.2 过滤器"></a>5.2 过滤器</h5><h5 id="5-3-热升级"><a href="#5-3-热升级" class="headerlink" title="5.3 热升级"></a>5.3 热升级</h5><h5 id="5-4-API自动化文档"><a href="#5-4-API自动化文档" class="headerlink" title="5.4 API自动化文档"></a>5.4 API自动化文档</h5><h3 id="6-应用部署"><a href="#6-应用部署" class="headerlink" title="6. 应用部署"></a>6. 应用部署</h3><h5 id="6-1-Nginx部署"><a href="#6-1-Nginx部署" class="headerlink" title="6.1 Nginx部署"></a>6.1 Nginx部署</h5>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>beego</tag>
      </tags>
  </entry>
  <entry>
    <title>GO一些问题</title>
    <url>/GO%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1. 基础篇"></a>1. 基础篇</h1><h3 id="1-如何高效的拼接字符串"><a href="#1-如何高效的拼接字符串" class="headerlink" title="1. 如何高效的拼接字符串"></a>1. 如何高效的拼接字符串</h3><a id="more"></a>
<ul>
<li>Go 语言中，字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串。如果需要拼接多次，应使用 strings.Builder，最小化内存拷贝次数。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str strings.Builder</span><br><span class="line">for i :&#x3D; 0; i &lt; 1000; i++ &#123;</span><br><span class="line">    str.WriteString(&quot;a&quot;)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(str.String())</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-Go-支持默认参数或可选参数吗"><a href="#2-Go-支持默认参数或可选参数吗" class="headerlink" title="2. Go 支持默认参数或可选参数吗"></a>2. Go 支持默认参数或可选参数吗</h3><ul>
<li>都不支持</li>
</ul>
<h3 id="3-defer-的执行顺序"><a href="#3-defer-的执行顺序" class="headerlink" title="3. defer 的执行顺序"></a>3. defer 的执行顺序</h3><ul>
<li>栈型，先进后出</li>
</ul>
<h3 id="4-Go-语言-tag-的用处"><a href="#4-Go-语言-tag-的用处" class="headerlink" title="4. Go 语言 tag 的用处"></a>4. Go 语言 tag 的用处</h3><ul>
<li>tag 可以理解为 struct 字段的注解，可以用来定义字段的一个或多个属性。框架/工具可以通过反射获取到某个字段定义的属性，采取相应的处理方式。tag 丰富了代码的语义，增强了灵活性。</li>
<li>下面这个例子使用 tag 定义了结构体字段与 json 字段的转换关系，Name -&gt; stu_name, ID -&gt; stu_id，忽略 Age 字段。很方便地实现了 Go 结构体与不同规范的 json 文本之间的转换。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">  import &quot;fmt&quot;</span><br><span class="line">  import &quot;encoding&#x2F;json&quot;</span><br><span class="line"></span><br><span class="line">  type Stu struct &#123;</span><br><span class="line">    Name string &#96;json:&quot;stu_name&quot;&#96;</span><br><span class="line">    ID   string &#96;json:&quot;stu_id&quot;&#96;</span><br><span class="line">    Age  int    &#96;json:&quot;-&quot;&#96;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func main() &#123;</span><br><span class="line">    buf, _ :&#x3D; json.Marshal(Stu&#123;&quot;Tom&quot;, &quot;t001&quot;, 18&#125;)</span><br><span class="line">    fmt.Printf(&quot;%s\n&quot;, buf)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-如何判断-2-个字符串切片（slice-是相等的"><a href="#5-如何判断-2-个字符串切片（slice-是相等的" class="headerlink" title="5. 如何判断 2 个字符串切片（slice) 是相等的"></a>5. 如何判断 2 个字符串切片（slice) 是相等的</h3><ul>
<li>遍历一个个比较</li>
<li>通过反射reflect.DeepEqual(a, b)，但是性能较低，不推荐。</li>
</ul>
<h3 id="6-字符串打印时，-v-和-v-的区别"><a href="#6-字符串打印时，-v-和-v-的区别" class="headerlink" title="6. 字符串打印时，%v 和 %+v 的区别"></a>6. 字符串打印时，%v 和 %+v 的区别</h3><ul>
<li>%v 和 %+v 都可以用来打印 struct 的值，区别在于 %v 仅打印各个字段的值，%+v 还会打印各个字段的名称。</li>
</ul>
<h3 id="7-Go-语言中如何表示枚举值-enums"><a href="#7-Go-语言中如何表示枚举值-enums" class="headerlink" title="7. Go 语言中如何表示枚举值(enums)"></a>7. Go 语言中如何表示枚举值(enums)</h3><ul>
<li>通常使用常量(const) 来表示枚举值。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    Type1 StuType &#x3D; iota</span><br><span class="line">    Type2</span><br><span class="line">    Type3</span><br><span class="line">    Type4</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="8-空-struct-的用途"><a href="#8-空-struct-的用途" class="headerlink" title="8. 空 struct{} 的用途"></a>8. 空 struct{} 的用途</h3><ul>
<li>使用空结构体 struct{} 可以节省内存，一般作为占位符使用，表明这里并不需要一个值。</li>
</ul>
<ol>
<li>比如使用 map 表示集合时，只关注 key，value 可以使用 struct{} 作为占位符。如果使用其他类型作为占位符，例如 int，bool，不仅浪费了内存，而且容易引起歧义。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Set map[string]struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">  func main() &#123;</span><br><span class="line">    set :&#x3D; make(Set)</span><br><span class="line"></span><br><span class="line">    for _, item :&#x3D; range []string&#123;&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125; &#123;</span><br><span class="line">      set[item] &#x3D; struct&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(len(set)) &#x2F;&#x2F; 3</span><br><span class="line">    if _, ok :&#x3D; set[&quot;A&quot;]; ok &#123;</span><br><span class="line">      fmt.Println(&quot;A exists&quot;) &#x2F;&#x2F; A exists</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。</li>
<li>声明只包含方法的结构体。</li>
</ol>
<h3 id="9-map多键索引"><a href="#9-map多键索引" class="headerlink" title="9. map多键索引"></a>9. map多键索引</h3><ul>
<li>map类型的key可以是个对象，支持对对象中每个字段的多键索引。</li>
</ul>
<h1 id="2-进阶（实现原理）"><a href="#2-进阶（实现原理）" class="headerlink" title="2. 进阶（实现原理）"></a>2. 进阶（实现原理）</h1><h3 id="1-init-函数是什么时候执行的"><a href="#1-init-函数是什么时候执行的" class="headerlink" title="1. init() 函数是什么时候执行的"></a>1. init() 函数是什么时候执行的</h3><ol>
<li>Go 程序初始化先于 main 函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。</li>
<li>每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 init() 函数。</li>
<li>同一个包，甚至是同一个源文件可以有多个 init() 函数。init() 函数没有入参和返回值，不能被其他函数调用，同一个包内多个 init() 函数的执行顺序不作保证。</li>
<li>执行顺序：import –&gt; const –&gt; var –&gt; init() –&gt; main()。其中不被依赖的包的init()最先执行，同一个包中的多个init()执行顺序没有保证。</li>
</ol>
<h3 id="2-Go-语言的局部变量分配在栈上还是堆上（逃逸分析）"><a href="#2-Go-语言的局部变量分配在栈上还是堆上（逃逸分析）" class="headerlink" title="2. Go 语言的局部变量分配在栈上还是堆上（逃逸分析）"></a>2. Go 语言的局部变量分配在栈上还是堆上（逃逸分析）</h3><ol>
<li>由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有超出函数范围，就可以在栈上，反之则必须分配在堆上。</li>
</ol>
<h3 id="3-2-个-interface-可以比较吗"><a href="#3-2-个-interface-可以比较吗" class="headerlink" title="3. 2 个 interface 可以比较吗"></a>3. 2 个 interface 可以比较吗</h3><ol>
<li>Go 语言中，interface 的内部实现包含了 2 个字段，类型 T 和 值 V，interface 可以使用 == 或 != 比较。2 个 interface 相等有以下 2 种情况：<ol>
<li>两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）</li>
<li>类型 V 相同，且对应的值 V 相等。</li>
</ol>
</li>
</ol>
<h3 id="4-接口与非接口的比较"><a href="#4-接口与非接口的比较" class="headerlink" title="4. 接口与非接口的比较"></a>4. 接口与非接口的比较</h3><ol>
<li><p>接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型 T 和 值 V。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T=nil，V is unset）：</p>
<ul>
<li>两个接口值比较时，会先比较 T，再比较 V。</li>
<li>接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较。</li>
</ul>
</li>
<li><p>下面这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为(T=*int, V=nil)，i 与 p 作比较时，将 p 转换为接口后再比较，因此 i == p，p 与 nil 比较，直接比较值，所以 p == nil。但是当 i 与 nil 比较时，会将 nil 转换为接口 (T=nil, V=nil)，与i (T=*int, V=nil) 不相等，因此 i != nil。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">  var p *int &#x3D; nil</span><br><span class="line">  var i interface&#123;&#125; &#x3D; p</span><br><span class="line">  fmt.Println(i &#x3D;&#x3D; p) &#x2F;&#x2F; true</span><br><span class="line">  fmt.Println(p &#x3D;&#x3D; nil) &#x2F;&#x2F; true</span><br><span class="line">  fmt.Println(i &#x3D;&#x3D; nil) &#x2F;&#x2F; false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="5-Go-语言GC-垃圾回收-的工作原理"><a href="#5-Go-语言GC-垃圾回收-的工作原理" class="headerlink" title="5. Go 语言GC(垃圾回收)的工作原理"></a>5. Go 语言GC(垃圾回收)的工作原理</h3><ol>
<li><p>最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。</p>
</li>
<li><p>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p>
<ol>
<li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象</li>
<li>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表</li>
</ol>
</li>
<li><p>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。</p>
</li>
<li><p>三色标记法：</p>
<ol>
<li>三色标记算法将程序中的对象分成白色、黑色和灰色三类。<ul>
<li>白色：不确定对象。</li>
<li>灰色：存活对象，子对象待处理。</li>
<li>黑色：存活对象。</li>
</ul>
</li>
<li>标记开始时，所有对象加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。</li>
<li>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。</li>
<li>三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A (黑) -&gt; B (灰) -&gt; C (白) -&gt; D (白)</span><br><span class="line"></span><br><span class="line">A (黑) -&gt; B (灰) -&gt; C (白) </span><br><span class="line">    ↓</span><br><span class="line">   D (白)</span><br></pre></td></tr></table></figure></li>
<li>为了解决这个问题，Go 使用了内存屏障技术。</li>
</ol>
</li>
<li><p>内存屏障技术：</p>
</li>
<li><p>它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。</p>
</li>
<li><p>一次完整的 GC 分为四个阶段：</p>
<ol>
<li>标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)</li>
<li>使用三色标记法标记（Marking, 并发）</li>
<li>标记结束(Mark Termination，需 STW)，关闭写屏障。</li>
<li>清理(Sweeping, 并发)</li>
</ol>
</li>
</ol>
<h3 id="6-函数返回局部变量的指针是否安全"><a href="#6-函数返回局部变量的指针是否安全" class="headerlink" title="6. 函数返回局部变量的指针是否安全"></a>6. 函数返回局部变量的指针是否安全</h3><ol>
<li>这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上。</li>
</ol>
<h3 id="7-非接口的任意类型-T都能够调用-T-的方法吗？反过来呢？"><a href="#7-非接口的任意类型-T都能够调用-T-的方法吗？反过来呢？" class="headerlink" title="7. 非接口的任意类型 T都能够调用 *T 的方法吗？反过来呢？"></a>7. 非接口的任意类型 T都能够调用 *T 的方法吗？反过来呢？</h3><ol>
<li><p>一个T类型的值可以调用为<em>T类型声明的方法，但是仅当此T的值是可寻址(addressable) 的情况下。编译器在调用指针属主方法前，会自动取此T值的地址。因为不是任何T值都是可寻址的，所以并非任何T值都能够调用为类型</em>T声明的方法。</p>
</li>
<li><p>反过来，一个<em>T类型的值可以调用为类型T声明的方法，这是因为解引用指针总是合法的。事实上，你可以认为对于每一个为类型 T 声明的方法，编译器都会为类型</em>T自动隐式声明一个同名和同签名的方法。</p>
</li>
<li><p>哪些值是不可寻址的</p>
<ol>
<li>字符串中的字节；</li>
<li>map 对象中的元素（slice 对象中的元素是可寻址的，slice的底层是数组）；</li>
<li>常量；</li>
<li>包级别的函数等。</li>
</ol>
</li>
<li><p>举一个例子，定义类型 T，并为类型 *T 声明一个方法 hello()，变量 t1 可以调用该方法，但是常量 t2 调用该方法时，会产生编译错误。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type T string</span><br><span class="line"></span><br><span class="line">  func (t *T) hello() &#123;</span><br><span class="line">    fmt.Println(&quot;hello&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func main() &#123;</span><br><span class="line">    var t1 T &#x3D; &quot;ABC&quot;</span><br><span class="line">    t1.hello() &#x2F;&#x2F; hello</span><br><span class="line">    const t2 T &#x3D; &quot;ABC&quot;</span><br><span class="line">    t2.hello() &#x2F;&#x2F; error: cannot call pointer method on t</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-go-在defer中修改return的内容会生效吗"><a href="#8-go-在defer中修改return的内容会生效吗" class="headerlink" title="8. go 在defer中修改return的内容会生效吗"></a>8. go 在defer中修改return的内容会生效吗</h3></li>
<li><p>执行顺序：defer在return赋值之后</p>
</li>
<li><p>分为无名返回值、有名返回值、返回指针</p>
</li>
<li><p>如果是无名返回值，在defer中的修改不影响返回值，有名返回值和返回指针，return的内容会修改</p>
</li>
</ol>
<h3 id="9-append扩容"><a href="#9-append扩容" class="headerlink" title="9. append扩容"></a>9. append扩容</h3><ol>
<li>   切片append()的时候，如果容量不够会扩容，重新分配空间，所以指针地址就变化了，在函数中修改slice显得外面没有变，应该返回这个新的slice，不过它复制的是指针地址，所以开销也不大</li>
</ol>
<h3 id="10-协程："><a href="#10-协程：" class="headerlink" title="10. 协程："></a>10. 协程：</h3><ol>
<li>协程是程序层面的，不由操作系统控制。比如python的yield</li>
<li>线程调度是这个线程让出cpu使用权，下次还能抢到。协程是程序真正的暂停，等到对方执行完自己才会继续执行。</li>
<li>一个线程里可以有多个协程，一个协成阻塞了，就全部阻塞了。但是goruntine通过一个逻辑处理器解决了这个问题。</li>
</ol>
<h3 id="11-Go语言逻辑处理器（GPM）"><a href="#11-Go语言逻辑处理器（GPM）" class="headerlink" title="11. Go语言逻辑处理器（GPM）"></a>11. Go语言逻辑处理器（GPM）</h3><ol>
<li>每个线程有一个逻辑处理器，一个逻辑处理器管理很多协程，如果这个协程需要阻塞（比如IO操作），就把这个协程从逻辑处理器中剔除，新建一个线程管理这个逻辑处理器。</li>
<li>Go也有一个goruntime来进行内存管理垃圾回收等操作，只是生成可执行文件的时候包含进去了，所以可执行文件比较大。</li>
</ol>
<h1 id="3-并发"><a href="#3-并发" class="headerlink" title="3. 并发"></a>3. 并发</h1><h3 id="1-无缓冲的-channel-和-有缓冲的-channel"><a href="#1-无缓冲的-channel-和-有缓冲的-channel" class="headerlink" title="1. 无缓冲的 channel 和 有缓冲的 channel"></a>1. 无缓冲的 channel 和 有缓冲的 channel</h3><ol>
<li>对于无缓冲的 channel，发送方将阻塞该信道，直到接收方从该信道接收到数据为止，而接收方也将阻塞该信道，直到发送方将数据发送到该信道中为止。</li>
<li>对于有缓存的 channel，发送方在没有空插槽（缓冲区使用完）的情况下阻塞，而接收方在信道为空的情况下阻塞。</li>
</ol>
<h3 id="2-什么是协程泄露-Goroutine-Leak"><a href="#2-什么是协程泄露-Goroutine-Leak" class="headerlink" title="2. 什么是协程泄露(Goroutine Leak)"></a>2. 什么是协程泄露(Goroutine Leak)</h3><ol>
<li>协程泄露是指协程创建后，长时间得不到释放，并且还在不断地创建新的协程，最终导致内存耗尽，程序崩溃。</li>
<li>常见的导致协程泄露的场景有以下几种：<ol>
<li>缺少接收器，导致发送阻塞</li>
<li>缺少发送器，导致接收阻塞</li>
<li>死锁(dead lock)</li>
<li>无限循环(infinite loops)</li>
</ol>
</li>
</ol>
<h3 id="3-Go-限制运行时操作系统线程的数量"><a href="#3-Go-限制运行时操作系统线程的数量" class="headerlink" title="3. Go 限制运行时操作系统线程的数量"></a>3. Go 限制运行时操作系统线程的数量</h3><ol>
<li><p>可以使用环境变量 GOMAXPROCS 或 runtime.GOMAXPROCS(num int) 设置。</p>
<ul>
<li>runtime.GOMAXPROCS(1) // 限制同时执行Go代码的操作系统线程数为 1</li>
</ul>
</li>
<li><p>GOMAXPROCS 限制的是同时执行用户态 Go 代码的操作系统线程的数量，但是对于被系统调用阻塞的线程数量是没有限制的。GOMAXPROCS 的默认值等于 CPU 的逻辑核数，同一时间，一个核只能绑定一个线程，然后运行被调度的协程。因此对于 CPU 密集型的任务，若该值过大，例如设置为 CPU 逻辑核数的 2 倍，会增加线程切换的开销，降低性能。对于 I/O 密集型应用，适当地调大该值，可以提高 I/O 吞吐率。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO定时任务库cron</title>
    <url>/GO%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%BA%93cron/</url>
    <content><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><ol>
<li>包地址：github.com/robfig/cron/v3</li>
<li>介绍：<a href="https://darjun.github.io/2020/06/25/godailylib/cron/">https://darjun.github.io/2020/06/25/godailylib/cron/</a></li>
<li>类似Linux的crontab</li>
</ol>
<h3 id="2-简单例子"><a href="#2-简单例子" class="headerlink" title="2. 简单例子"></a>2. 简单例子</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line"></span><br><span class="line">&quot;github.com&#x2F;robfig&#x2F;cron&#x2F;v3&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c :&#x3D; cron.New()</span><br><span class="line"></span><br><span class="line">c.AddFunc(&quot;@every 1s&quot;, func() &#123;</span><br><span class="line">fmt.Println(&quot;tick every 1 second&quot;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">c.Start()</span><br><span class="line">time.Sleep(time.Second * 5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<h3 id="3-job，实现Run-接口"><a href="#3-job，实现Run-接口" class="headerlink" title="3. job，实现Run()接口"></a>3. job，实现Run()接口</h3><ol>
<li>对于结构体，实现了Run接口，就可以直接当做job使用，直接调用Run()方法，jobrunner库中就是使用了这个特性。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; cron.go</span><br><span class="line">  type Job interface &#123;</span><br><span class="line">    Run()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type GreetingJob struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func (g GreetingJob) Run() &#123;</span><br><span class="line">    fmt.Println(&quot;Hello &quot;, g.Name)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func main() &#123;</span><br><span class="line">    c :&#x3D; cron.New()</span><br><span class="line">    c.AddJob(&quot;@every 1s&quot;, GreetingJob&#123;&quot;dj&quot;&#125;)</span><br><span class="line">    c.Start()</span><br><span class="line"></span><br><span class="line">    time.Sleep(5 * time.Second)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="4-时间格式"><a href="#4-时间格式" class="headerlink" title="4. 时间格式"></a>4. 时间格式</h3><h5 id="1-五种"><a href="#1-五种" class="headerlink" title="1. 五种"></a>1. 五种</h5><pre><code>Minutes：分钟，取值范围[0-59]，支持特殊字符* / , -；
Hours：小时，取值范围[0-23]，支持特殊字符* / , -；
Day of month：每月的第几天，取值范围[1-31]，支持特殊字符* / , - ?；
Month：月，取值范围[1-12]或者使用月份名字缩写[JAN-DEC]，支持特殊字符* / , -；
Day of week：周历，取值范围[0-6]或名字缩写[JUN-SAT]，支持特殊字符* / , - ?。</code></pre>
<h5 id="2-特殊字符含义"><a href="#2-特殊字符含义" class="headerlink" title="2. 特殊字符含义"></a>2. 特殊字符含义</h5><pre><code>*：使用*的域可以匹配任何值，例如将月份域（第 4 个）设置为*，表示每个月；
/：用来指定范围的步长，例如将小时域（第 2 个）设置为3-59/15表示第 3 分钟触发，以后每隔 15 分钟触发一次，因此第 2 次触发为第 18 分钟，第 3 次为 33 分钟。。。直到分钟大于 59；
,：用来列举一些离散的值和多个范围，例如将周历的域（第 5 个）设置为MON,WED,FRI表示周一、三和五；
-：用来表示范围，例如将小时的域（第 1 个）设置为9-17表示上午 9 点到下午 17 点（包括 9 和 17）；
?：只能用在月历和周历的域中，用来代替*，表示每月/周的任意一天。</code></pre>
<h5 id="3-时间格式例子"><a href="#3-时间格式例子" class="headerlink" title="3. 时间格式例子"></a>3. 时间格式例子</h5><pre><code>30 * * * *：分钟域为 30，其他域都是*表示任意。每小时的 30 分触发；
30 3-6,20-23 * * *：分钟域为 30，小时域的3-6,20-23表示 3 点到 6 点和 20 点到 23 点。3,4,5,6,20,21,22,23 时的 30 分触发；
0 0 1 1 *：1（第 4 个） 月 1（第 3 个） 号的 0（第 2 个） 时 0（第 1 个） 分触发。</code></pre>
<h5 id="4-代码例子"><a href="#4-代码例子" class="headerlink" title="4. 代码例子"></a>4. 代码例子</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	func main() &#123;</span><br><span class="line">  c :&#x3D; cron.New()</span><br><span class="line"></span><br><span class="line">  c.AddFunc(&quot;30 * * * *&quot;, func() &#123;</span><br><span class="line">    fmt.Println(&quot;Every hour on the half hour&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.AddFunc(&quot;30 3-6,20-23 * * *&quot;, func() &#123;</span><br><span class="line">    fmt.Println(&quot;On the half hour of 3-6am, 8-11pm&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.AddFunc(&quot;0 0 1 1 *&quot;, func() &#123;</span><br><span class="line">    fmt.Println(&quot;Jun 1 every year&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  for &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<h3 id="5-固定时间间隔"><a href="#5-固定时间间隔" class="headerlink" title="5. 固定时间间隔"></a>5. 固定时间间隔</h3><h5 id="1-格式"><a href="#1-格式" class="headerlink" title="1. 格式"></a>1. 格式</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@every &lt;duration&gt;</span><br></pre></td></tr></table></figure></code></pre>
<h5 id="2-duration格式"><a href="#2-duration格式" class="headerlink" title="2. duration格式"></a>2. duration格式</h5><ol>
<li>1h15m10s，每隔一小时15分10秒</li>
<li>1m1s</li>
<li>10s</li>
</ol>
<h3 id="6-线程安全"><a href="#6-线程安全" class="headerlink" title="6. 线程安全"></a>6. 线程安全</h3><ul>
<li>cron会创建一个新的 goroutine 来执行触发回调。如果这些回调需要并发访问一些资源、数据，需要显式地做同步。</li>
<li>如果每个都创建一个新的goroutine的话，如果需要大量定时任务，要考虑其他解决方案。</li>
</ul>
<h3 id="7-其他特性"><a href="#7-其他特性" class="headerlink" title="7. 其他特性"></a>7. 其他特性</h3><ul>
<li>暂不深入</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO日志库logrus</title>
    <url>/GO%E6%97%A5%E5%BF%97%E5%BA%93logrus/</url>
    <content><![CDATA[<h3 id="1-logrus"><a href="#1-logrus" class="headerlink" title="1. logrus"></a>1. logrus</h3><ol>
<li>日志库</li>
<li>包路径：”github.com/sirupsen/logrus”<a id="more"></a></li>
<li>快速入门例子： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">  import (</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    log &quot;github.com&#x2F;sirupsen&#x2F;logrus&quot;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  func init() &#123;</span><br><span class="line">    &#x2F;&#x2F; Log as JSON instead of the default ASCII formatter.</span><br><span class="line">    log.SetFormatter(&amp;log.JSONFormatter&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Output to stdout instead of the default stderr</span><br><span class="line">    &#x2F;&#x2F; Can be any io.Writer, see below for File example</span><br><span class="line">    log.SetOutput(os.Stdout)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Only log the warning severity or above.</span><br><span class="line">    log.SetLevel(log.WarnLevel)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func main() &#123;</span><br><span class="line">    log.WithFields(log.Fields&#123;</span><br><span class="line">      &quot;animal&quot;: &quot;walrus&quot;,</span><br><span class="line">      &quot;size&quot;:   10,</span><br><span class="line">    &#125;).Info(&quot;A group of walrus emerges from the ocean&quot;)</span><br><span class="line"></span><br><span class="line">    log.WithFields(log.Fields&#123;</span><br><span class="line">      &quot;omg&quot;:    true,</span><br><span class="line">      &quot;number&quot;: 122,</span><br><span class="line">    &#125;).Warn(&quot;The group&#39;s number increased tremendously!&quot;)</span><br><span class="line"></span><br><span class="line">    log.WithFields(log.Fields&#123;</span><br><span class="line">      &quot;omg&quot;:    true,</span><br><span class="line">      &quot;number&quot;: 100,</span><br><span class="line">    &#125;).Fatal(&quot;The ice breaks!&quot;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; A common pattern is to re-use fields between logging statements by re-using</span><br><span class="line">    &#x2F;&#x2F; the logrus.Entry returned from WithFields()</span><br><span class="line">    contextLogger :&#x3D; log.WithFields(log.Fields&#123;</span><br><span class="line">      &quot;common&quot;: &quot;this is a common field&quot;,</span><br><span class="line">      &quot;other&quot;: &quot;I also should be logged always&quot;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    contextLogger.Info(&quot;I&#39;ll be logged with common and other field&quot;)</span><br><span class="line">    contextLogger.Info(&quot;Me too&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><h5 id="1-设置输出格式"><a href="#1-设置输出格式" class="headerlink" title="1. 设置输出格式"></a>1. 设置输出格式</h5><ol>
<li>json格式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    log.SetFormatter(&amp;log.JSONFormatte</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; example</span><br><span class="line">    &#123;&quot;level&quot;:&quot;fatal&quot;,&quot;msg&quot;:&quot;The ice breaks!&quot;,&quot;number&quot;:100,&quot;omg&quot;:true,</span><br><span class="line">&quot;time&quot;:&quot;2014-03-10 19:57:38.562543128 -0400 EDT&quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li>文本格式 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log.SetFormatter(&amp;log.TextFormatter&#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; example</span><br><span class="line">time&#x3D;&quot;2015-03-26T01:27:38-04:00&quot; level&#x3D;debug msg&#x3D;&quot;Started observing beach&quot; animal&#x3D;walrus number&#x3D;8</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-更多见文档"><a href="#2-更多见文档" class="headerlink" title="2. 更多见文档"></a>2. 更多见文档</h5><ol>
<li><a href="https://github.com/sirupsen/logrus">https://github.com/sirupsen/logrus</a></li>
</ol>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO编码规范</title>
    <url>/GO%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h1><a id="more"></a>
<h3 id="1-true-false求值"><a href="#1-true-false求值" class="headerlink" title="1. true/false求值"></a>1. true/false求值</h3><ol>
<li>当明确expr为bool类型时，禁止使用==或!=与true/false比较，应该使用expr或!expr</li>
<li>判断某个整数表达式expr是否为零时，禁止使用!expr，应该使用expr == 0<ul>
<li>示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GOOD:</span><br><span class="line">  var isWhiteCat bool</span><br><span class="line">  var num int</span><br><span class="line"></span><br><span class="line">  if isWhiteCat &#123;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if num &#x3D;&#x3D; 0 &#123;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  BAD:</span><br><span class="line">  var isWhiteCat bool</span><br><span class="line">  var num int</span><br><span class="line"></span><br><span class="line">  if isWhite &#x3D;&#x3D; true &#123;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if !num &#123;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<h3 id="2-Receiver"><a href="#2-Receiver" class="headerlink" title="2. Receiver"></a>2. Receiver</h3><ul>
<li>receiver是什么就不用说了。</li>
</ul>
<ol>
<li><p>Receiver Type </p>
<ul>
<li>如果receiver是map、函数或者chan类型，类型不可以是指针</li>
<li>如果receiver是slice，并且方法不会进行reslice或者重新分配slice，类型不可以是指针</li>
<li>如果receiver是struct，且包含sync.Mutex类型字段，则必须使用指针避免拷贝。</li>
<li>如果receiver是比较大的struct/array，建议使用指针，这样会更有效率</li>
<li>如果receiver是struct、array或slice，其中指针元素所指的内容可能在方法内被修改，建议使用指针类型（注意第二条，和这条不冲突）</li>
<li>如果receiver是比较小的struct/array，建议使用value类型</li>
</ul>
</li>
<li><p>receiver命名 </p>
<ul>
<li>尽量简短并有意义。</li>
<li>禁止使用“this”、”self“等面向对象语言中特定的叫法。</li>
<li>receiver的命名要保持一致性</li>
</ul>
</li>
</ol>
<h3 id="3-embedding的使用"><a href="#3-embedding的使用" class="headerlink" title="3. embedding的使用"></a>3. embedding的使用</h3><ol>
<li><p>embedding只用于”is a”的语义下，而不用于”has a”的语义下</p>
</li>
<li><p>一个定义内，多于一个的embedding尽量少用</p>
<ul>
<li>语义上embedding是一种“继承关系“，而不是”成员关系“</li>
<li>一个定义内有多个embedding，则很难判断某个成员变量或函数是从哪里继承得到的</li>
<li>一个定义内有多个embedding，危害和在python中使用”from xxx import *”是类似的</li>
</ul>
</li>
<li><p>示例</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GOOD:</span><br><span class="line">  type Automobile struct &#123;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  type Engine struct &#123;</span><br><span class="line">      &#x2F;&#x2F; ....</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 正确的定义</span><br><span class="line">  type Car struct &#123;</span><br><span class="line">      Automobile         &#x2F;&#x2F;  Car is a Automobile</span><br><span class="line">      engine Engine      &#x2F;&#x2F;  Car has a Engine</span><br><span class="line">  &#125;</span><br><span class="line">  BAD:</span><br><span class="line">  type Car struct &#123;</span><br><span class="line">      Automobile      &#x2F;&#x2F;  Car is a Automobile</span><br><span class="line">      Engine          &#x2F;&#x2F;  Car has a Engine, but Car is NOT a Engine</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="4-枚举类型的使用"><a href="#4-枚举类型的使用" class="headerlink" title="4. 枚举类型的使用"></a>4. 枚举类型的使用</h3><ol>
<li><p>go没有自带的枚举类型，通常的用法为：使用自增长常量来自定义一个枚举类型，允许你依靠编译器完成自增设置。</p>
</li>
<li><p>示例</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type ErrorType int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">SIOD_RETURN_OK ErrorType &#x3D; iota &#x2F;&#x2F; 0</span><br><span class="line">SIOD_RETURN_FAIL &#x2F;&#x2F; 1</span><br><span class="line">SIOD_RETURN_TIMEOUT &#x2F;&#x2F; 2</span><br><span class="line">SIOD_RETURN_REFUSE &#x2F;&#x2F; 3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="5-文件风格规范"><a href="#5-文件风格规范" class="headerlink" title="5. 文件风格规范"></a>5. 文件风格规范</h3><ol>
<li><p>Go文件Layout，建议文件按以下顺序进行布局</p>
<ul>
<li>General Documentation： 对整个模块和功能的完整描述注释，写在文件头部。</li>
<li>package：当前package定义</li>
<li>imports：包含的头文件</li>
<li>Constants：常量</li>
<li>Typedefs： 类型定义</li>
<li>Globals：全局变量定义</li>
<li>functions：函数实现</li>
</ul>
</li>
<li><p>General Documentation Layout </p>
<ul>
<li><p>建议每个文件开头部分包括文件copyright说明（copyright）。</p>
</li>
<li><p>建议每个文件开头部分包括文件标题（Title），Title应该在一行内完成。</p>
</li>
<li><p>建议每个文件开头部分包括修改记录（Modification History），记录文件的修改过程，并且只记录最主要的修改。</p>
</li>
<li><p>建议每个文件开头部分包括文件描述（Description），详细描述文件的功能和作用。</p>
</li>
<li><p>示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GOOD:</span><br><span class="line">   &#x2F;* Copyright 2015 Inc. All Rights Reserved. *&#x2F;</span><br><span class="line">   &#x2F;* server.go - the main structure of server  *&#x2F;</span><br><span class="line">   &#x2F;*</span><br><span class="line">   modification history</span><br><span class="line">   --------------------</span><br><span class="line">   2014&#x2F;6&#x2F;5, by Zhang San, create</span><br><span class="line">   *&#x2F;</span><br><span class="line">   &#x2F;*</span><br><span class="line">   DESCRIPTION</span><br><span class="line">   This file contains the most important struct &#39;Server&#39; of go and new&#x2F;init method of the struct.</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">   package server</span><br><span class="line"></span><br><span class="line">   func func1() &#123;</span><br><span class="line">       &#x2F;&#x2F; ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>import规范 </p>
<ul>
<li>需要按照如下顺序进行头文件import，并且每个import部分内的package需按照字母升序排列<ul>
<li>系统package</li>
<li>第三方的package</li>
<li>程序自己的package</li>
</ul>
</li>
<li>每部分import间用单个空行进行分隔</li>
</ul>
</li>
<li><p>函数注释，建议包括以下内容</p>
<ul>
<li>Description：对函数的完整描述，主要包括函数功能和使用方法</li>
<li>Params：对参数的说明</li>
<li>Returns：对返回值的说明</li>
</ul>
</li>
</ol>
<h3 id="6-函数返回值"><a href="#6-函数返回值" class="headerlink" title="6. 函数返回值"></a>6. 函数返回值</h3><ol>
<li>对于“逻辑判断型”的函数，返回值的意义代表“真”或“假”，返回值类型定义为bool</li>
<li>对于“操作型”的函数，返回值的意义代表“成功”或“失败”，返回值类型定义为error<ul>
<li>如果成功，则返回nil</li>
<li>如果失败，则返回对应的error值</li>
</ul>
</li>
<li>对于“获取数据型”的函数，返回值的意义代表“有数据”或“无数据/获取数据失败”，返回值类型定义为（data, error）<ul>
<li>正常情况下，返回为：（data, nil）</li>
<li>异常情况下，返回为：（data, error）</li>
</ul>
</li>
<li>函数返回值小于等于3个，大于3个时必须通过struct进行包装</li>
<li>函数参数不建议超过3个，大于3个时建议通过struct进行包装</li>
</ol>
<h3 id="7-程序规模"><a href="#7-程序规模" class="headerlink" title="7. 程序规模"></a>7. 程序规模</h3><ol>
<li>每行代码不超过100个字符。</li>
<li>每行注释不超过100个字符。</li>
<li>函数不超过100行。</li>
<li>文件不超过2000行。</li>
</ol>
<h3 id="8-命名规范"><a href="#8-命名规范" class="headerlink" title="8. 命名规范"></a>8. 命名规范</h3><ol>
<li><p>文件名</p>
<ul>
<li>文件名都使用小写字母，如果需要，可以使用下划线分割</li>
<li>文件名的后缀使用小写字母</li>
</ul>
</li>
<li><p>函数名/变量名</p>
<ul>
<li>采用驼峰方式命名，禁止使用下划线命名。首字母是否大写，根据是否需要外部访问来决定</li>
</ul>
</li>
<li><p>常量 </p>
<ul>
<li>常量建议使用const枚举类型</li>
<li>禁止直接使用类似0、1、2、str、a、b这种含义不明的数字或字母</li>
<li>建议都使用大写字母，如果需要，可以使用下划线分割</li>
<li>尽量不要在程序中直接写数字，特殊字符串，全部用常量替代</li>
</ul>
</li>
</ol>
<h3 id="9-编程实践"><a href="#9-编程实践" class="headerlink" title="9. 编程实践"></a>9. 编程实践</h3><ol>
<li><p>error string</p>
<ul>
<li> error string尽量使用小写字母，并且结尾不带标点符号，因为可能error string会用于其它上下文中。</li>
</ul>
</li>
<li><p>Don’t panic</p>
<ul>
<li>除非出现不可恢复的程序错误，不要使用panic，用多返回值和error。</li>
</ul>
</li>
<li><p>关于lock的保护 </p>
<ul>
<li>如果临界区内的逻辑较复杂、无法完全避免panic的发生，则要求适用defer来调用Unlock，即使在临界区过程中发生了panic，也会在函数退出时调用Unlock释放锁</li>
<li>go提供了recover，可以对panic进行捕获，但如果panic发生在临界区内，则可能导致对锁的使用没有释放。这种情况下，即使panic不会导致整个程序的奔溃，也会由于”锁不释放“的问题而使临界区无法被后续的调用访问。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GOOD：</span><br><span class="line">func doDemo() &#123;</span><br><span class="line">    lock.Lock()</span><br><span class="line">    defer lock.Unlock()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 访问临界区</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BAD:</span><br><span class="line">func doDemo() &#123;</span><br><span class="line"> lock.Lock()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 访问临近区</span><br><span class="line"></span><br><span class="line">   lock.Unlock()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述操作如果造成临界区扩大后，需要建立单独的一个函数访问临界区。</li>
<li>对于如下的代码：<pre><code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func doDemo() &#123;</span><br><span class="line"> lock.Lock()</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; step1: 临界区内的操作</span><br><span class="line"></span><br><span class="line">	lock.Unlock()</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; step2: 临界区外的操作</span><br><span class="line">    	&#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li>如果改造为defer的方式，变为如下代码，实际上扩大了临界区的范围（step2的操作也被放置在临界区了）  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func doDemo() &#123;</span><br><span class="line">  lock.Lock()</span><br><span class="line">	defer lock.Unlock()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; step1: 临界区内的操作</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; step2: 临界区外的操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>需要使用单独的匿名函数，专门用于访问临界区：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func doDemo() &#123;</span><br><span class="line">   func() &#123;</span><br><span class="line">     lock.Lock()</span><br><span class="line">     defer lock.Unlock()</span><br><span class="line">     &#x2F;&#x2F; step1: 临界区内的操作操作</span><br><span class="line"></span><br><span class="line">    &#125;()</span><br><span class="line"> &#x2F;&#x2F; step2: 临界区外的操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>LDAP目录访问协议</title>
    <url>/LDAP%E7%9B%AE%E5%BD%95%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>LDAP是Lightweight Directory Access Protocol ， 即轻量级目录访问协议， 用这个协议可以访问提供目录服务的产品，例如OpenLDAP。</p>
<p>LDAP主要的应用于查询多而修改极少的场景。</p>
<p>小白科普文：<a href="https://www.sohu.com/a/194197808_465221">LDAP有什么用？</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>ldap</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux性能优化</title>
    <url>/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h1><a id="more"></a>
<h1 id="1-产看性能的命令"><a href="#1-产看性能的命令" class="headerlink" title="1. 产看性能的命令"></a>1. 产看性能的命令</h1><h3 id="1-CPU相关"><a href="#1-CPU相关" class="headerlink" title="1. CPU相关"></a>1. CPU相关</h3><ol>
<li>ps aux|head -1;ps aux|grep -v PID|sort -rn -k +3|head</li>
</ol>
<h3 id="2-内存相关"><a href="#2-内存相关" class="headerlink" title="2. 内存相关"></a>2. 内存相关</h3><ol>
<li>ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|head</li>
</ol>
<h3 id="3-ps命令内容解释"><a href="#3-ps命令内容解释" class="headerlink" title="3. ps命令内容解释"></a>3. ps命令内容解释</h3><pre><code>PID：进程的ID
USER：进程所有者
PR：进程的优先级别，越小越优先被执行
NInice：值
VIRT：进程占用的虚拟内存
RES：进程占用的物理内存
SHR：进程使用的共享内存
S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数
%CPU：进程占用CPU的使用率
%MEM：进程使用的物理内存和总内存的百分比
TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。
COMMAND：进程启动命令名称</code></pre>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>RAID备份</title>
    <url>/RAID%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<img src="/RAID%E5%A4%87%E4%BB%BD/RAID.png" class="" title="RAID.png">
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>RAID</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA加密</title>
    <url>/RSA%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h3 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h3><ol>
<li>   服务端有公钥私钥，放出公钥。</li>
<li>   客户端用公钥加密一个秘钥，并传给服务端。</li>
<li>   服务端用私钥解密，得到秘钥，这样就能对称加密传输了。</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>SIGPIPE信号产生原因</title>
    <url>/SIGPIPE%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<p>如果客户端关闭套接字之后(调用close)<br>服务器调用了一次write,服务器会收到一个RST segment(TCP层)<br>如果服务器再次调用了write,这个时候就会产生SIGPIPE信号.<br>SIGPIPE信号的默认处理方式是终止进程,所以要想忽略这个信号,需要加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signal(SIGPIPE,SIG_IGN);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>linux</tag>
        <tag>信号</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>ServiceMesh了解一下</title>
    <url>/ServiceMesh%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/</url>
    <content><![CDATA[<ol>
<li>知乎大佬：<a href="https://zhuanlan.zhihu.com/p/61901608">https://zhuanlan.zhihu.com/p/61901608</a></li>
<li>蚂蚁：<a href="https://zhuanlan.zhihu.com/p/94256999">https://zhuanlan.zhihu.com/p/94256999</a></li>
<li>蚂蚁开源Service Mesh框架：<a href="https://github.com/mosn/mosn">https://github.com/mosn/mosn</a></li>
<li>mosn文档：<a href="https://mosn.io/docs/">https://mosn.io/docs/</a></li>
</ol>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>服务端</tag>
        <tag>servicemesh</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04下MySQL安装</title>
    <url>/Ubuntu18-04%E4%B8%8BMySQL%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql-apt-config_0.8.11-1_all.deb</span><br><span class="line">dpkg -i mysql-apt-config_0.8.11-1_all.deb</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure>
<ol>
<li>上面第一条后面的网址是 <a href="https://dev.mysql.com/downloads/file/?id=482263">https://dev.mysql.com/downloads/file/?id=482263</a> 里下方的 “No thanks, just start my download.” 的链接</li>
<li>在某些命令执行过程中会出界面提示，一个是输入root密码，剩下的全按“确定”就行</li>
<li>最后有个选择密码的强度，第一个是高强度密码，自己写着练习的画选第二个吧。</li>
<li>最后就安装好了，可以尝试进入数据库： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
 再输入密码</li>
</ol>
<h3 id="MySQL可视化工具安装"><a href="#MySQL可视化工具安装" class="headerlink" title="MySQL可视化工具安装"></a>MySQL可视化工具安装</h3><ol>
<li>若以上执行正确，此时只要这一句就行了 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-workbench</span><br></pre></td></tr></table></figure></li>
<li>最后就能发现MySQL workbench软件，和在Windows下的一样</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Web服务器</title>
    <url>/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><ol>
<li><p>处理web请求常见的三种方式</p>
<ul>
<li>一个线程处理所有连接，效率及其低</li>
<li>一个连接一个线程，处理不了大量连接</li>
<li>Epoll方式，少量线程来处理大量连接<a id="more"></a></li>
</ul>
</li>
<li><p>Nginx作为代理服务器</p>
<ul>
<li>以epoll的方式处理HTTP请求</li>
<li>静态资源请求（HTML、js、css文件、图片等），也许自己就能搞定，也许转发到别的缓存服务器（根据配置），读取相关文件直接返回。</li>
<li>动态请求需要后端服务器处理以后才能返回，如Tomcat，那就需要像tomcat转发，如果不止一个tomcat就按照某种策略选择一个。</li>
</ul>
</li>
<li><p>Nginx支持的几种策略：</p>
<ul>
<li>轮询：按照次序挨个向后端服务器转发</li>
<li>权重：给每个后端服务器指定一个权重，相当于向后端服务器转发的几率。</li>
<li>ip_hash： 根据ip做一个hash操作，然后找个服务器转发，这样的话同一个客户端ip总是会转发到同一个后端服务器。</li>
<li>fair：根据后端服务器的响应时间来分配请求，响应时间段的优先分配。</li>
</ul>
</li>
<li><p>BIO/NIO</p>
<ul>
<li>Bio即阻塞IO，一个线程处理一个连接</li>
<li>Nio是使用IO多路复用技术，仅使用若干线程来处理所有请求。Select,epoll</li>
</ul>
</li>
<li><p>处理完http请求的TCP会关闭吗</p>
<ul>
<li>如果http1.1，默认是keep-alive的，不关闭</li>
<li>如果是http1.0，看request header中有没有Connection:keep-alive，如果有就不关闭。</li>
</ul>
</li>
</ol>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ol>
<li>浏览器收到服务端返回的html，准备读取这个页面，然后发现其中引用了很多其他静态资源，如js，图片等，这些资源也位于服务器端，并且可能在另一个域名下，于是浏览器开始一个个下载。</li>
<li>但同一个时间同一域名下的请求数量不能太多，例如Chrome在Http1.1下只能并行地下载6个资源。</li>
<li>服务器发送这些资源的时候，会告诉浏览器这些文件什么时候过期（使用Cache-Control或Expire），浏览器可以把文件缓存到本地，第二次请求如果不过期就直接从本地取。</li>
<li>如果过期了就问服务器这个文件有没有修改（依据是上一次服务器发送的Last-Modified和ETag），如果没有修改过（304 Not Modified），还可以使用缓存。否则服务器就发送最新的文件给浏览器。</li>
<li>如果按了ctrl f5，会强制发送get请求，无视缓存。</li>
</ol>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>服务端</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>asio几种异步编程模型</title>
    <url>/asio%E5%87%A0%E7%A7%8D%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0. 前置知识"></a>0. 前置知识</h3><ol>
<li>asio中io_server是一个很重要的东西,任何操作都需要它,在异步编程的时候,需要io_server.run()启动, 有点像事件驱动模型中的 event.loop().(原理不一样,只是说编程类似)</li>
</ol>
<a id="more"></a>

<h3 id="1-一个io-server和一个线程"><a href="#1-一个io-server和一个线程" class="headerlink" title="1. 一个io_server和一个线程"></a>1. 一个io_server和一个线程</h3><ol>
<li>就是主线程一个io_server.run(),这样加入这里面有三个回调函数调用,如果第一个响应了,正在处理过程中,第二个回调函数响应,要等第一个执行完才行.</li>
</ol>
<h3 id="2-一个io-server和多个线程"><a href="#2-一个io-server和多个线程" class="headerlink" title="2. 一个io_server和多个线程"></a>2. 一个io_server和多个线程</h3><ol>
<li>启动多个线程,每个线程都调用 io_server.run(), 这里各线程中的io_server是同一个</li>
<li>这样碰到上面那种情况,第二个回调函数就会找一个空闲线程去运行,会提高效率</li>
</ol>
<h3 id="3-多个io-server和多个线程"><a href="#3-多个io-server和多个线程" class="headerlink" title="3. 多个io_server和多个线程"></a>3. 多个io_server和多个线程</h3><ol>
<li>就是每个线程有自己的io_server, 这样和第一种情况有些类似, 不过可以对不同的套接字绑定到不同的线程io_server上, 然后各线程只处理自己关注的套接字</li>
</ol>
<ul>
<li>目前个人感觉还是第二种情况更好用</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>linux</tag>
        <tag>网络编程</tag>
        <tag>asio</tag>
      </tags>
  </entry>
  <entry>
    <title>boost::system::error_code在异步编程中的使用----使用boost::asio::placeholders::error编译报错问题 </title>
    <url>/boost-system-error-code%E5%9C%A8%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8-%E4%BD%BF%E7%94%A8boost-asio-placeholders-error%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><ol>
<li>使用asio避不开boost::system::error_code的使用,在同步编程中很好使用,我主要记录一下异步编程中的用法<a id="more"></a>

</li>
</ol>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><ul>
<li>看一些教程按如下方法使用  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async_read(socket_,buffer(read_buf,4),</span><br><span class="line">      bind(&amp;ChatSession::read_header_handle,shared_from_this(),boost::asio::placeholders::error)</span><br><span class="line">      );</span><br></pre></td></tr></table></figure></li>
<li>但我用如上方法会编译错误, 去掉boost::asio::placeholders::error就可以编译通过,但又需要使用boost::system::error_code,最后找到如下解决方案(原来只要是占位符就行)  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async_read(socket_,buffer(read_buf,4),</span><br><span class="line">       bind(&amp;ChatSession::read_header_handle,shared_from_this(),std::placeholders::_1)</span><br><span class="line">       );</span><br></pre></td></tr></table></figure></li>
<li>以上解决方案参考<a href="http://www.itkeyword.com/doc/6174144975026339x751/cant-use-asioplaceholderserror-in-non-boost-version-of-asio">www.itkeyword.com</a>, 十分感谢大佬</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title>git基础</title>
    <url>/git%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ol>
<li>有必要把git整理一下了</li>
</ol>
<h1 id="一、起步"><a href="#一、起步" class="headerlink" title="一、起步"></a>一、起步</h1><a id="more"></a>
<h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h3><ol>
<li><p>用户信息</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;John Doe&quot;</span><br><span class="line">$ git config --global user.email johndoe@example.com </span><br></pre></td></tr></table></figure>
<ul>
<li>远程提交时，commit的用户一定要有远程提交的权限，之前我就是这个问题，一直提交不了</li>
</ul>
</li>
<li><p>文本编辑器</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global core.editor &quot;\&quot;D:\应用程序\Sublime Text3\sublime_text.exe\&quot;&quot;</span><br><span class="line">$ git config --global core.editor emacs&#x2F;vim</span><br></pre></td></tr></table></figure>
<ul>
<li>修改config文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;...略</span><br><span class="line">[core]</span><br><span class="line">    editor &#x3D; \&quot;D:\\应用程序\\Sublime Text3\\sublime_text.exe\&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>检查配置信息</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">user.name&#x3D;John Doe</span><br><span class="line">user.email&#x3D;johndoe@example.com</span><br><span class="line">color.status&#x3D;auto</span><br><span class="line">color.branch&#x3D;auto</span><br><span class="line">color.interactive&#x3D;auto</span><br><span class="line">color.diff&#x3D;auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="2-license"><a href="#2-license" class="headerlink" title="2. license"></a>2. license</h3><!-- ![github证书.png](/github证书.png) -->
<img src="/git%E5%9F%BA%E7%A1%80/github%E8%AF%81%E4%B9%A6.png" class="" title="github证书">

</li>
</ol>
<h1 id="二、git基础"><a href="#二、git基础" class="headerlink" title="二、git基础"></a>二、git基础</h1><h3 id="1-获取-Git-仓库"><a href="#1-获取-Git-仓库" class="headerlink" title="1. 获取 Git 仓库"></a>1. 获取 Git 仓库</h3><ol>
<li>本地初始化 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在项目目录</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;信息&quot;</span><br></pre></td></tr></table></figure></li>
<li>克隆现有的仓库<ul>
<li>当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。</li>
<li>从github上clone项目<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;xtlvlv&#x2F;Algorithm.git newname</span><br><span class="line">&#x2F;&#x2F;newname是自定义本地仓库名，可以省略</span><br></pre></td></tr></table></figure></li>
<li>也可以自己在服务器搭建git，详见第四章。</li>
</ul>
</li>
</ol>
<h3 id="2-记录每次更新到仓库"><a href="#2-记录每次更新到仓库" class="headerlink" title="2. 记录每次更新到仓库"></a>2. 记录每次更新到仓库</h3><ol>
<li>检查当前文件状态 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git status -s   &#x2F;&#x2F;更简洁的查看</span><br></pre></td></tr></table></figure></li>
<li>跟踪新文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add README</span><br></pre></td></tr></table></figure>
<ul>
<li>这个也用于暂存修改</li>
<li>若一个文件git add后，又修改了，commit时提交的是修改前的状态，必须再次git add</li>
</ul>
</li>
<li>忽略文件<ul>
<li>创建一个名为 .gitignore 的文件，列出要忽略的文件模式。例如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.[oa]  &#x2F;&#x2F;忽略所有以.o或.a结尾的文件</span><br><span class="line">*~  &#x2F;&#x2F;忽略所有～结尾的文件</span><br></pre></td></tr></table></figure></li>
<li>文件 .gitignore 的格式规范如下：<ul>
<li>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（/）开头防止递归。</li>
<li>匹配模式可以以（/）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ul>
</li>
</ul>
</li>
<li>查看已暂存和未暂存的修改<ul>
<li>当git add 后又修改了文件，git status就会显示已暂存和未暂存的文件</li>
<li>查看都修改了哪些<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>提交更新 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit  &#x2F;&#x2F;这种方式会启动文本编辑器以便输入本次提交的说明。</span><br><span class="line">git commit -m &quot;说明&quot;    &#x2F;&#x2F;简短说明，快速提交</span><br></pre></td></tr></table></figure></li>
<li>跳过使用暂存区域 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure>
<ul>
<li>这种方式 Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</li>
</ul>
</li>
<li>移除文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm README</span><br></pre></td></tr></table></figure></li>
<li>移动文件<ul>
<li>改名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git mv file_from file_to</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">$ mv README.md README</span><br><span class="line">$ git rm README.md</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="3-查看提交历史-git-log"><a href="#3-查看提交历史-git-log" class="headerlink" title="3. 查看提交历史,git log"></a>3. 查看提交历史,git log</h3><ol>
<li><p>常用</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">git log -g -2</span><br></pre></td></tr></table></figure>
<ul>
<li> -p 用来显示每次提交的内容差异。 加上 -2 仅显示最近两次提交</li>
</ul>
</li>
<li><p>每次提交的简略的统计信息，你可以使用 –stat 选项</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure></li>
<li><p>输出限制</p>
<ul>
<li>用时查文档吧</li>
</ul>
</li>
</ol>
<h3 id="4-撤消操作"><a href="#4-撤消操作" class="headerlink" title="4. 撤消操作"></a>4. 撤消操作</h3><ol>
<li>重新提交 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<ul>
<li>若git commit 后没有做任何修改，执行这条命令没有改变</li>
<li>若git commit 后修改了，执行这条命令改变之前的提交，不是重新提交，也就是只有一条提交记录</li>
</ul>
</li>
<li>取消暂存的文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD README.md</span><br></pre></td></tr></table></figure>
<ul>
<li>把 README.md 从暂存区取消，commit时就不会提交这个文件</li>
</ul>
</li>
<li>撤消对文件的修改 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- README.md</span><br></pre></td></tr></table></figure>
<ul>
<li>可以将 README.md 还原成上次提交时的样子</li>
<li> git checkout – [file] 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。</li>
<li>在 Git 中任何 已提交的 东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 –amend 选项覆盖的提交也可以恢复。 然而，任何你未提交的东西丢失后很可能再也找不到了。</li>
</ul>
</li>
</ol>
<h3 id="5-远程仓库的使用-git-remote"><a href="#5-远程仓库的使用-git-remote" class="headerlink" title="5. 远程仓库的使用,git remote"></a>5. 远程仓库的使用,git remote</h3><ol>
<li>查看远程仓库 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote  &#x2F;&#x2F;如果是clone下来的，至少有个origin</span><br><span class="line">$ git remote -v   &#x2F;&#x2F;显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</span><br><span class="line">bakkdoor  https:&#x2F;&#x2F;github.com&#x2F;bakkdoor&#x2F;grit (fetch)</span><br><span class="line">bakkdoor  https:&#x2F;&#x2F;github.com&#x2F;bakkdoor&#x2F;grit (push)</span><br><span class="line">cho45     https:&#x2F;&#x2F;github.com&#x2F;cho45&#x2F;grit (fetch)</span><br><span class="line">cho45     https:&#x2F;&#x2F;github.com&#x2F;cho45&#x2F;grit (push)</span><br><span class="line">defunkt   https:&#x2F;&#x2F;github.com&#x2F;defunkt&#x2F;grit (fetch)</span><br><span class="line">defunkt   https:&#x2F;&#x2F;github.com&#x2F;defunkt&#x2F;grit (push)</span><br><span class="line">koke      git:&#x2F;&#x2F;github.com&#x2F;koke&#x2F;grit.git (fetch)</span><br><span class="line">koke      git:&#x2F;&#x2F;github.com&#x2F;koke&#x2F;grit.git (push)</span><br><span class="line">origin    git@github.com:mojombo&#x2F;grit.git (fetch)</span><br><span class="line">origin    git@github.com:mojombo&#x2F;grit.git (push)</span><br></pre></td></tr></table></figure></li>
<li>添加远程仓库 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote add pb https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit</span><br><span class="line">$ git remote -v</span><br><span class="line">origin	https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (fetch)</span><br><span class="line">origin	https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (push)</span><br><span class="line">pb	https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit (fetch)</span><br><span class="line">pb	https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit (push)</span><br></pre></td></tr></table></figure>
<ul>
<li>pb 代表URL的简写</li>
</ul>
</li>
<li>从远程仓库中抓取与拉取<ul>
<li>git fetch [remote-name]</li>
<li>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch pb</span><br></pre></td></tr></table></figure></li>
<li>如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。</li>
<li> git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</li>
<li>如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）</li>
</ul>
</li>
<li>推送到远程仓库<ul>
<li>git push [remote-name] [branch-name]<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin master    &#x2F;&#x2F;克隆时通常会自动帮你设置好这两个名字</span><br></pre></td></tr></table></figure></li>
<li>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。</li>
<li>当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。</li>
</ul>
</li>
<li>查看远程仓库<ul>
<li>git remote show [remote-name]<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote show origin</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>远程仓库的移除与重命名<ul>
<li>重命名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure></li>
<li>移除<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="6-打标签-git-tag"><a href="#6-打标签-git-tag" class="headerlink" title="6. 打标签,git tag"></a>6. 打标签,git tag</h3><ol>
<li>列出标签 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></li>
<li>创建标签<ul>
<li>轻量标签（lightweight）<br>  轻量标签本质上是将提交校验和存储到一个文件中，没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag v1.4-lw</span><br><span class="line">$ git tag</span><br><span class="line">v1.4-lw</span><br></pre></td></tr></table></figure></li>
<li>附注标签（annotated）<br>  附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.4 -m &#39;my version 1.4&#39;</span><br><span class="line">$ git tag</span><br><span class="line">v1.4</span><br><span class="line">&#x2F;&#x2F;查看标签信息与对应的提交信息</span><br><span class="line">$ git show v1.4</span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:19:12 2014 -0700</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li>
<li>对过去的提交打标签<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查看历史</span><br><span class="line">$ git log --pretty&#x3D;oneline</span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">&#x2F;&#x2F;加标签</span><br><span class="line">$ git tag -a v1.2 9fceb02</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>共享标签<ul>
<li>默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行 git push origin [tagname]。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin v1.5</span><br><span class="line">$ git push origin --tags    &#x2F;&#x2F;把所有不在远程仓库服务器上的标签全部传送到那里。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>删除标签 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -d v1.4-lw  &#x2F;&#x2F;加上 -d 删除，但不会更新远程仓库的</span><br></pre></td></tr></table></figure>
<ul>
<li>远程仓库移除标签<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;git push &lt;remote&gt; :refs&#x2F;tags&#x2F;&lt;tagname&gt;</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;v1.4-lw</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>检出标签 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout 2.0.0</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="三、git分支"><a href="#三、git分支" class="headerlink" title="三、git分支"></a>三、git分支</h1><h3 id="1-分支简介"><a href="#1-分支简介" class="headerlink" title="1. 分支简介"></a>1. 分支简介</h3><ol>
<li><p>分支创建</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure>
<ul>
<li>Git 又是怎么知道当前在哪一个分支上呢？<br>  它有一个名为 HEAD 的特殊指针。在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。</li>
</ul>
</li>
<li><p>分支切换</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout testing</span><br></pre></td></tr></table></figure>
<ul>
<li>HEAD就会指向testing，此时做的更改是在testing分支上，HEAD一直跟着testing,切换为master的话就会回到之前的分支</li>
</ul>
</li>
<li><p>查看各个分支当前所指的对象</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --oneline --decorate</span><br></pre></td></tr></table></figure>
<h3 id="2-分支的新建与合并-git-checkout"><a href="#2-分支的新建与合并-git-checkout" class="headerlink" title="2. 分支的新建与合并,git checkout"></a>2. 分支的新建与合并,git checkout</h3></li>
<li><p>新建分支</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br><span class="line">&#x2F;&#x2F;并将HEAD指向iss53, 等价于</span><br><span class="line">$ git branch iss53</span><br><span class="line">$ git checkout iss53</span><br></pre></td></tr></table></figure></li>
<li><p>删除分支</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d hotfix</span><br></pre></td></tr></table></figure></li>
<li><p>合并分支</p>
<ul>
<li><p>要先移动到被合并的分支，比如想把hotfix合并到master上，要先移动到master分支上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br></pre></td></tr></table></figure></li>
<li><p>不同的合并情况</p>
<ul>
<li><p>快进合并：master和hotfix在一条线上，只是把master往前移动到hotfix上</p>
</li>
<li><p>分叉合并: master和hotfix不在一条线上，复杂一些</p>
<ul>
<li>解决冲突</li>
</ul>
<ol>
<li>直接在文件中修改冲突的地方</li>
<li>git checkout –theirs 文件名 // 在本例中是使hotfix的文件覆盖master的文件</li>
<li>git checkout –ours 文件名 // 在本例中是使master的文件覆盖hotfix的文件</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>遇到冲突时的分支合并</p>
<ul>
<li>如果在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。</li>
<li>若遇到冲突后，只能把冲突解决才能合并，即把连个分支都修改的某个文件，变为相同的修改</li>
</ul>
</li>
</ol>
<h3 id="3-分支管理-git-branch"><a href="#3-分支管理-git-branch" class="headerlink" title="3. 分支管理,git branch"></a>3. 分支管理,git branch</h3><ol>
<li><p>查看分支</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">iss53</span><br><span class="line">* master    &#x2F;&#x2F;表示当前在这个分支上</span><br><span class="line">testing</span><br></pre></td></tr></table></figure></li>
<li><p>查看每一个分支的最后一次提交</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -v </span><br></pre></td></tr></table></figure></li>
<li><p>要查看哪些分支已经合并到当前分支</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch --merged</span><br><span class="line">iss53   &#x2F;&#x2F;表明iss53已经合并到master,可以删除了</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</li>
</ul>
</li>
<li><p>查看所有包含未合并工作的分支</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch --no-merged</span><br><span class="line">testing</span><br></pre></td></tr></table></figure>
<ul>
<li>删除未合并的分支会失败<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d testing</span><br><span class="line">error: The branch &#39;testing&#39; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#39;git branch -D testing&#39;.</span><br></pre></td></tr></table></figure>
<h3 id="4-远程分支-git-fetch-push-pull"><a href="#4-远程分支-git-fetch-push-pull" class="headerlink" title="4. 远程分支,git fetch push pull"></a>4. 远程分支,git fetch push pull</h3></li>
</ul>
</li>
<li><p>更新远程仓库引用</p>
<ul>
<li>如果git clone之后，自己做了一些修改后commit后，本地就会领先远程分支，这时万一有其他人提交远程分支了，在clone那个节点就出现了分叉</li>
<li>这时可以用git fetch拉去远程更新的分支，变成本地的一个分支，合并后再提交<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>推送</p>
<ul>
<li>推送到有写入权限的远程仓库</li>
<li>git push (remote) (branch)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin serverfix</span><br></pre></td></tr></table></figure></li>
<li>这里有些工作被简化了。 Git 自动将 serverfix 分支名字展开为 refs/heads/serverfix:refs/heads/serverfix，那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” </li>
</ul>
</li>
<li><p>跟踪分支</p>
<ul>
<li>跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</li>
<li>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。</li>
<li>创建跟踪分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b sf origin&#x2F;serverfix</span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#39;sf&#39;</span><br><span class="line">&#x2F;&#x2F;现在，本地分支 sf 会自动从 origin&#x2F;serverfix 拉取。</span><br></pre></td></tr></table></figure></li>
<li>修改正在跟踪的上游分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -u origin&#x2F;serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li><ol start="4">
<li>git pull</li>
</ol>
<ul>
<li>git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令</li>
<li>由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。    </li>
</ul>
</li>
<li><ol start="5">
<li>删除远程分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete serverfix</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit</span><br><span class="line">- [deleted]         serverfix</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</li>
</ul>
</li>
<li><ol start="6">
<li>用本地分支创建远程分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin localBranch:remoteBranch</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="5-变基rebase"><a href="#5-变基rebase" class="headerlink" title="5. 变基rebase"></a>5. 变基rebase</h3><ol>
<li><p>和合并merge功能一样</p>
<ul>
<li>无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</li>
</ul>
</li>
<li><p>合并merge好还是变基rebase好？</p>
<ul>
<li>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作</li>
</ul>
</li>
<li><p>rebase的使用</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout experiment</span><br><span class="line">$ git rebase master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br><span class="line">&#x2F;&#x2F;先rebase,然后再合并，这里的合并只是移动指针，如果不变基就合并的话，要做的工作更多</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge experiment</span><br></pre></td></tr></table></figure></li>
<li><p>这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p>
</li>
</ol>
<h1 id="四、服务器上的git"><a href="#四、服务器上的git" class="headerlink" title="四、服务器上的git"></a>四、服务器上的git</h1><ul>
<li>可以自己建立git服务器，但现在用好github就行了，以后需要的时候再说</li>
</ul>
<h1 id="之后"><a href="#之后" class="headerlink" title="之后"></a>之后</h1><ul>
<li>后面的略览了一下，使用基本的git，以上就够了，后面先不看了，有需要再说吧。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>go微服务框架micro</title>
    <url>/go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6micro/</url>
    <content><![CDATA[<ol>
<li>架构<img src="/go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6micro/micro%E6%9E%B6%E6%9E%84.png" class="" title="micro架构.png">
<a id="more"></a></li>
<li>微服务提供服务能力的三种方式：<ul>
<li>RPC</li>
<li>OpenAPI</li>
<li>HTTP</li>
</ul>
</li>
<li>Go-Micro提供服务的方案<ul>
<li>SRV：内部RPC服务</li>
<li>API：对外API服务</li>
<li>Web：对外HTTP服务</li>
</ul>
</li>
<li>微服务面临的问题<ul>
<li>服务的注册与发现<ul>
<li>支持Etcd、MDNS、Consul、ZK、Eureka…</li>
</ul>
</li>
<li>服务之间的通信<ul>
<li>http,tcp,udp,MQ(同步，Transport)，MQ(异步,Broker)</li>
</ul>
</li>
<li>服务的可靠性<ul>
<li>TTL/Interval，基于Wrapper的限流、熔断等特性</li>
</ul>
</li>
<li>服务的部署<ul>
<li>K8s</li>
</ul>
</li>
</ul>
</li>
<li>流程<ul>
<li>定义接口<ul>
<li>基于Proto协议</li>
<li>使用portoc-gen-micro插件生成Micro代码(srv)</li>
</ul>
</li>
<li>实现接口<ul>
<li>定义Hanlder</li>
</ul>
</li>
<li>创建服务<ul>
<li>NewService服务</li>
<li>Init初始化</li>
<li>挂载接口</li>
<li>运行</li>
</ul>
</li>
</ul>
</li>
<li>程序通用架构<img src="/go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6micro/micro%E5%BA%94%E7%94%A8.png" class="" title="micro应用.png"></li>
</ol>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>go</tag>
        <tag>micro</tag>
      </tags>
  </entry>
  <entry>
    <title>linux日志服务</title>
    <url>/linux%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="日志监控技术栈"><a href="#日志监控技术栈" class="headerlink" title="日志监控技术栈"></a>日志监控技术栈</h3><img src="/linux%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E6%8A%80%E6%9C%AF%E6%A0%88.png" class="" title="日志监控技术栈.png">

<a id="more"></a>
<ol>
<li>日志源<ul>
<li>日志一般存储在三个位置：数据库、操作系统日志、日志文件。一般操作日志会习惯于存储在数据库中，在这里暂且不提。Syslog、Rsyslog、Journald都是linux系统的日志服务。</li>
<li>syslog 守护进程的任务是记录系统日志。它从应用程序和服务中获取格式各异的日志消息并保存到磁盘上，消息的元数据是组件名、优先级、时间戳、进程标签和 PID，日志格式很是宽泛，没有定义结构化的格式，所以系统的分析和日志消息处理也就变得十分混乱，同时性能和其他的一些缺点随着时间推移也慢慢被放大，后来慢慢被Rsyslog所取代。</li>
<li>Rsyslog可以说是Syslog的升级版，它涵盖SysLog的常用功能，不过在功能和性能上更为出色。</li>
<li>Red Hat Enterprise Linux 7与SUSE Linux Enterprise Server 12这些新一代的Linux发行版本使用systemd管理服务。</li>
<li>journal是systemd的一个组件，由journald处理。Journald是为Linux服务器打造的新系统日志方式，它标志着文本日志文件的终结，它不再存储日志文件，而是将日志信息写入到二进制文件，使用journalctl阅读。它捕获系统日志信息、内核日志信息，以及来自原始RAM磁盘的信息，早期启动信息以及所有服务中写入STDOUT和STDERR数据流的信息。Journald快速改变着服务器如何处理日志信息与管理员如何访问的方式。</li>
</ul>
</li>
</ol>
<h3 id="Linux两种系统日志服务"><a href="#Linux两种系统日志服务" class="headerlink" title="Linux两种系统日志服务"></a>Linux两种系统日志服务</h3><ol>
<li><p>Rsyslogd：</p>
<ul>
<li>Linux提供一个守护进程来处理系统日志-syslogd，升级版是rsyslogd</li>
<li>记录系统级日志的服务，配置文件为/etc/rsyslog.conf，重点看/var/log/messages的配置<!--more--></li>
<li>用户进程通过调用syslog函数生成系统日志，该函数将日志输出到一个unix本地域socket类型(AF_UNIX)的文件/dev/log中，rsyslogd则监听该文件以获取用户进程的输出。</li>
<li>内核日志在以前的系统上时通过另一个守护进程rklogd来管理的，rsyslogd利用额外的模块实现了相同的功能。内核日志由printk等换树打印至内核环状缓存中。环状缓存的内容直接映射到/proc/kmsg。</li>
<li>rsyslogd通过读取该文件获得内核日志，默认调试信息保存在/var/log/debug，普通信息保存至/var/log/messages，内核信息：/var/log/kern.log。配置文件：/etc/rsyslog.conf，主要设置内核日志输入路径，是否接受UDP日志，及其监听端口（默认514 /etc/services）是否接受TCP日志及其监听端口，日志文件权限，包含哪些配置文件。<img src="/linux%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1/%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" class="" title="日志配置文件.png">
</li>
</ul>
</li>
<li><p>System journald</p>
<ul>
<li>如上述</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx和uwsgi启停</title>
    <url>/nginx%E5%92%8Cuwsgi%E5%90%AF%E5%81%9C/</url>
    <content><![CDATA[<h3 id="1-Nginx-开启"><a href="#1-Nginx-开启" class="headerlink" title="1. Nginx 开启"></a>1. Nginx 开启</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -c &#x2F;home&#x2F;www&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>-c是指定配置文件,不然用默认的配置,后面的文件路径最好从根目录开始,不然会有一个默认目录,试一下就知道了<h3 id="2-Nginx-关闭"><a href="#2-Nginx-关闭" class="headerlink" title="2. Nginx 关闭:"></a>2. Nginx 关闭:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure>
<h3 id="3-Uwsgi-开启"><a href="#3-Uwsgi-开启" class="headerlink" title="3. Uwsgi 开启"></a>3. Uwsgi 开启</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uwsgi -d --ini uwsgi.ini</span><br></pre></td></tr></table></figure></li>
<li>-d是表示在后台运行<h3 id="4-Uwsig-关闭"><a href="#4-Uwsig-关闭" class="headerlink" title="4. Uwsig 关闭"></a>4. Uwsig 关闭</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uwsgi --stop uwsgi.pid</span><br><span class="line">pkill -f uwsgi -9</span><br></pre></td></tr></table></figure></li>
<li>这个uwsgi.pid是uwsgi.ini中指定的文件,运行后存的是uwsgi进程的pid<h3 id="5-Uwsig-重启"><a href="#5-Uwsig-重启" class="headerlink" title="5. Uwsig 重启"></a>5. Uwsig 重启</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uwsgi --reload uwsgi.pid</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>uwsgi</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf不能单独发送一个0</title>
    <url>/protobuf%E4%B8%8D%E8%83%BD%E5%8D%95%E7%8B%AC%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA0/</url>
    <content><![CDATA[<h3 id="1-protobuf使用过程中遇到一个问题-记录一下"><a href="#1-protobuf使用过程中遇到一个问题-记录一下" class="headerlink" title="1. protobuf使用过程中遇到一个问题,记录一下"></a>1. protobuf使用过程中遇到一个问题,记录一下</h3><ul>
<li>定义消息如下  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message RegisterResponse&#123;</span><br><span class="line">    int32 result&#x3D;1; &#x2F;&#x2F; 1表示成功,&gt;1表示账号重复,注意不能为0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li>在服务端使用asio库如下  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res.set_result(0);	&#x2F;&#x2F; 注意这里把result设置为0</span><br><span class="line">...</span><br><span class="line">string send_str;</span><br><span class="line">   res.SerializeToString(&amp;send_str);</span><br><span class="line">   sock_ptr-&gt;write_some(buffer(send_str));</span><br></pre></td></tr></table></figure></li>
<li>客户端如下:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sock.read_some(buffer(buf));</span><br></pre></td></tr></table></figure></li>
<li>上面的把result变量设置为0是问题所在</li>
<li>问题是上述服务端代码把消息发给client,client应该能接收到,但是client却一直阻塞在read_some上,如果把send_str改为char[1024]数组就没问题,于是抓包分析了一下, 发现如果send是string类型,server–&gt;client的包长度为0, 把result设置为其他值,包长就不为0,能正确发送.</li>
<li>可能是protobuf在序列化成字符串的时候,因为值只有一个0,所以被误认为为null了吧,记录一下,以后尽量不用0作为一个结果</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础</title>
    <url>/python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h3><ol>
<li>不全，随便做一下笔记，以后可以快速浏览复习</li>
</ol>
<h3 id="1-标准数据类型"><a href="#1-标准数据类型" class="headerlink" title="1. 标准数据类型"></a>1. 标准数据类型</h3><ul>
<li><p>Python3 中有六个标准的数据类型：</p>
<a id="more"></a>
<ul>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
</ul>
</li>
<li><p>Python3 的六个标准数据类型中：</p>
<ul>
<li>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；</li>
<li>可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。</li>
</ul>
</li>
</ul>
<h3 id="2-Python字符串格式化"><a href="#2-Python字符串格式化" class="headerlink" title="2. Python字符串格式化"></a>2. Python字符串格式化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print (&quot;我叫 %s 今年 %d 岁!&quot; % (&#39;小明&#39;,10))</span><br><span class="line"></span><br><span class="line">print(&quot;我叫 &#123;0&#125; 今年 &#123;1&#125; 岁！&quot;。format(&quot;小明&quot;,10))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-Python列表"><a href="#3-Python列表" class="headerlink" title="3. Python列表"></a>3. Python列表</h3><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><table>
<thead>
<tr>
<th>序号</th>
<th>函数</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>len(list)</td>
<td>列表元素个数</td>
</tr>
<tr>
<td>2</td>
<td>max(list)</td>
<td>返回列表元素最大值</td>
</tr>
<tr>
<td>3</td>
<td>min(list)</td>
<td>返回列表元素最小值</td>
</tr>
<tr>
<td>4</td>
<td>list(seq)</td>
<td>将元组转换为列表</td>
</tr>
</tbody></table>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><table>
<thead>
<tr>
<th>序号</th>
<th>函数</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>list.append(obj)</td>
<td>在列表末尾添加新的对象</td>
</tr>
<tr>
<td>2</td>
<td>list.count(obj)</td>
<td>统计某个元素在列表中出现的次数</td>
</tr>
<tr>
<td>3</td>
<td>list.extend(seq)</td>
<td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td>
</tr>
<tr>
<td>4</td>
<td>list.index(obj)</td>
<td>从列表中找出某个值第一个匹配项的索引位置</td>
</tr>
<tr>
<td>5</td>
<td>list.insert(index, obj)</td>
<td>将对象插入列表</td>
</tr>
<tr>
<td>6</td>
<td>list.pop([index=-1])</td>
<td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>
</tr>
<tr>
<td>7</td>
<td>list.remove(obj)</td>
<td>移除列表中某个值的第一个匹配项</td>
</tr>
<tr>
<td>8</td>
<td>list.reverse()</td>
<td>反向列表中元素</td>
</tr>
<tr>
<td>9</td>
<td>list.sort( key=None, reverse=False)</td>
<td>对原列表进行排序</td>
</tr>
<tr>
<td>10</td>
<td>list.clear()</td>
<td>清空列表</td>
</tr>
<tr>
<td>11</td>
<td>list.copy()</td>
<td>复制列表</td>
</tr>
</tbody></table>
<h3 id="4-元组"><a href="#4-元组" class="headerlink" title="4. 元组"></a>4. 元组</h3><ul>
<li>创建空元组</li>
<li>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tup1 &#x3D; ();</span><br><span class="line">tup1 &#x3D; (50,)</span><br></pre></td></tr></table></figure></li>
<li>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合</li>
<li>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组</li>
</ul>
<h5 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h5><ul>
<li><ol>
<li>len(tuple)<br>计算元组元素个数。    <blockquote>
<blockquote>
<blockquote>
<p>tuple1 = (‘Google’, ‘Runoob’, ‘Taobao’)<br>len(tuple1)<br>3</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</li>
<li><ol start="2">
<li>max(tuple)<br>返回元组中元素最大值。    <blockquote>
<blockquote>
<blockquote>
<p>tuple2 = (‘5’, ‘4’, ‘8’)<br>max(tuple2)<br>‘8’</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</li>
<li><ol start="3">
<li>min(tuple)<br>返回元组中元素最小值。    <blockquote>
<blockquote>
<blockquote>
<p>tuple2 = (‘5’, ‘4’, ‘8’)<br>min(tuple2)<br>‘4’</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</li>
<li><ol start="4">
<li>tuple(seq)<br>将列表转换为元组。    <blockquote>
<blockquote>
<blockquote>
<p>list1= [‘Google’, ‘Taobao’, ‘Runoob’, ‘Baidu’]<br>tuple1=tuple(list1)<br>tuple1<br>(‘Google’, ‘Taobao’, ‘Runoob’, ‘Baidu’)</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="5-字典"><a href="#5-字典" class="headerlink" title="5. 字典"></a>5. 字典</h3><ul>
<li><p>字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中 ,格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;key1 : value1, key2 : value2 &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>键必须是唯一的，但值则不必。</p>
</li>
<li><p>能删单一的元素也能清空字典，清空只需一项操作。</p>
</li>
<li><p>显示删除一个字典用del命令，如下实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del dict[&#39;Name&#39;] # 删除键 &#39;Name&#39;</span><br><span class="line">dict.clear()     # 清空字典</span><br><span class="line">del dict         # 删除字典</span><br></pre></td></tr></table></figure>
</li>
<li><p>不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住 </p>
</li>
<li><p>键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行</p>
</li>
</ul>
<h5 id="内置函数："><a href="#内置函数：" class="headerlink" title="内置函数："></a>内置函数：</h5><ul>
<li><ol>
<li>len(dict)<br>计算字典元素个数，即键的总数。    <blockquote>
<blockquote>
<blockquote>
<p>dict = {‘Name’: ‘Runoob’, ‘Age’: 7, ‘Class’: ‘First’}<br>len(dict)<br>3</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</li>
<li><ol start="2">
<li>str(dict)<br>输出字典，以可打印的字符串表示。    <blockquote>
<blockquote>
<blockquote>
<p>dict = {‘Name’: ‘Runoob’, ‘Age’: 7, ‘Class’: ‘First’}<br>str(dict)<br>“{‘Name’: ‘Runoob’, ‘Class’: ‘First’, ‘Age’: 7}”</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</li>
<li><ol start="3">
<li>type(variable)<br>返回输入的变量类型，如果变量是字典就返回字典类型。    <blockquote>
<blockquote>
<blockquote>
<p>dict = {‘Name’: ‘Runoob’, ‘Age’: 7, ‘Class’: ‘First’}<br>type(dict)<br>&lt;class ‘dict’&gt;</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</li>
</ul>
<h5 id="内置方法："><a href="#内置方法：" class="headerlink" title="内置方法："></a>内置方法：</h5><ul>
<li><ol>
<li>radiansdict.clear()<br>删除字典内所有元素</li>
</ol>
</li>
<li><ol start="2">
<li>radiansdict.copy()<br>返回一个字典的浅复制</li>
</ol>
</li>
<li><ol start="3">
<li>radiansdict.fromkeys()<br>创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</li>
</ol>
</li>
<li><ol start="4">
<li>radiansdict.get(key, default=None)<br>返回指定键的值，如果值不在字典中返回default值</li>
</ol>
</li>
<li><ol start="5">
<li>key in dict<br>如果键在字典dict里返回true，否则返回false</li>
</ol>
</li>
<li><ol start="6">
<li>radiansdict.items()<br>以列表返回可遍历的(键, 值) 元组数组</li>
</ol>
</li>
<li><ol start="7">
<li>radiansdict.keys()<br>返回一个迭代器，可以使用 list() 来转换为列表</li>
</ol>
</li>
<li><ol start="8">
<li>radiansdict.setdefault(key, default=None)<br>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</li>
</ol>
</li>
<li><ol start="9">
<li>radiansdict.update(dict2)<br>把字典dict2的键/值对更新到dict里</li>
</ol>
</li>
<li><ol start="10">
<li>radiansdict.values()<br>返回一个迭代器，可以使用 list() 来转换为列表</li>
</ol>
</li>
<li><ol start="11">
<li>pop(key[,default])<br>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</li>
</ol>
</li>
<li><ol start="12">
<li>popitem()<br>随机返回并删除字典中的一对键和值(一般删除末尾对)</li>
</ol>
</li>
</ul>
<h3 id="6-集合"><a href="#6-集合" class="headerlink" title="6. 集合"></a>6. 集合</h3><ul>
<li><p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>
</li>
<li><p>集合内置方法完整列表</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>add()</td>
<td>为集合添加元素</td>
</tr>
<tr>
<td>clear()</td>
<td>移除集合中的所有元素</td>
</tr>
<tr>
<td>copy()</td>
<td>拷贝一个集合</td>
</tr>
<tr>
<td>difference()</td>
<td>返回多个集合的差集</td>
</tr>
<tr>
<td>difference_update()</td>
<td>移除集合中的元素，该元素在指定的集合也存在。</td>
</tr>
<tr>
<td>discard()</td>
<td>删除集合中指定的元素</td>
</tr>
<tr>
<td>intersection()</td>
<td>返回集合的交集</td>
</tr>
<tr>
<td>intersection_update()</td>
<td>删除集合中的元素，该元素在指定的集合中不存在。</td>
</tr>
<tr>
<td>isdisjoint()</td>
<td>判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td>
</tr>
<tr>
<td>issubset()</td>
<td>判断指定集合是否为该方法参数集合的子集。</td>
</tr>
<tr>
<td>issuperset()</td>
<td>判断该方法的参数集合是否为指定集合的子集</td>
</tr>
<tr>
<td>pop()</td>
<td>随机移除元素</td>
</tr>
<tr>
<td>remove()</td>
<td>移除指定元素</td>
</tr>
<tr>
<td>symmetric_difference()</td>
<td>返回两个集合中不重复的元素集合。</td>
</tr>
<tr>
<td>symmetric_difference_update()</td>
<td>移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td>
</tr>
<tr>
<td>union()</td>
<td>返回两个集合的并集</td>
</tr>
<tr>
<td>update()</td>
<td>给集合添加元素</td>
</tr>
</tbody></table>
<h3 id="7-循环"><a href="#7-循环" class="headerlink" title="7. 循环"></a>7. 循环</h3><ul>
<li>for<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for &lt;variable&gt; in &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure></li>
<li>while<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while count &lt; 5:</span><br><span class="line">   print (count, &quot; 小于 5&quot;)</span><br><span class="line">   count &#x3D; count + 1</span><br><span class="line">else:</span><br><span class="line">   print (count, &quot; 大于或等于 5&quot;)</span><br></pre></td></tr></table></figure></li>
<li>range()函数<ul>
<li>如果你需要遍历数字序列，可以使用内置range()函数。它会生成数列</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp C/S模型 3个必要设置:SO_REUSEADDR,SIGPIPE,TCP_NODELAY</title>
    <url>/tcp-C-S%E6%A8%A1%E5%9E%8B-3%E4%B8%AA%E5%BF%85%E8%A6%81%E8%AE%BE%E7%BD%AE-SO-REUSEADDR-SIGPIPE-TCP-NODELAY/</url>
    <content><![CDATA[<h3 id="1-SO-REUSEADDR"><a href="#1-SO-REUSEADDR" class="headerlink" title="1. SO_REUSEADDR"></a>1. SO_REUSEADDR</h3><ul>
<li>设置套接字的SO_REUSEADDR选项</li>
<li>一般来说，客户端调用close()后会进入TIME_WAIT状态, 监听的端口仍被占用着，SO_REUSEADDR是让端口释放后立即就可以被再次使用。</li>
</ul>
<a id="more"></a>

<h3 id="2-SIGPIPE"><a href="#2-SIGPIPE" class="headerlink" title="2. SIGPIPE"></a>2. SIGPIPE</h3><ul>
<li>忽略SIGPIPE信号</li>
<li>连接建立，若某一端关闭连接，而另一端仍然向它写数据，第一次写数据后会收到RST响应，此后再写数据，内核将向进程发出SIGPIPE信号，通知进程此连接已经断开。而SIGPIPE信号的默认处理是终止程序.</li>
<li>如果服务器端没有忽略SIGPIPE信号,那如果有一个客户端断开连接,服务器对其因其产生SIGPIPE信号,那么服务器进程就会终止,影响其他客户端,所以要忽略这个信号.</li>
</ul>
<h3 id="3-TCP-NODELAY"><a href="#3-TCP-NODELAY" class="headerlink" title="3. TCP_NODELAY"></a>3. TCP_NODELAY</h3><ul>
<li><p>设置套接字的TCP_NODELAY选项</p>
</li>
<li><p>主要是忽略Nagle算法, 这个算法大致就是send()后,收到ack确认,才会发下一个包, 完整描述如下    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP_NODELAY选项是用来控制是否开启Nagle算法，该算法是为了提高较慢的广域网传输效率，减小小分组的报文个数，</span><br><span class="line"></span><br><span class="line">该算法要求一个TCP连接上最多只能有一个未被确认的小分组，在该小分组的确认到来之前，不能发送其他小分组。</span><br><span class="line"></span><br><span class="line">这里的小分组指的是报文长度小于MSS(Max Segment Size)长度的分组（MSS是在TCP握手的时候在报文选项里面进行通告的大小，</span><br><span class="line">主要是用来限制另一端发送数据的长度，防止IP数据包被分段，提高效率，</span><br><span class="line">一般是链路层的传输最大传输单元大小减去IP首部与TCP首部大小）。</span><br><span class="line"></span><br><span class="line">如果小分组的确认ACK一直没有回来，那么就可能会触发TCP超时重传的定时器。</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个选项不是必须打开的,根据应用场景选择,但很多时候是打开的</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实时性要求比较高的场景，类似用户鼠标操作，键盘输入，触摸屏事件输入，</span><br><span class="line">状态更新等这种连续的小分组数据，需要在对端立刻呈现，让用户尽可能感受不到延迟。</span><br><span class="line">但是如果网络延迟比较高，采用这种方式，那么会导致网路利用率下降。</span><br><span class="line"></span><br><span class="line">一般类似HTTP协议请求响应的模型的场景不太需要考虑禁用这个算法，</span><br><span class="line">因为在一条TCP连接上发送小报文，不管多小都代表了服务端任务执行的指示，</span><br><span class="line">完成了这个请求之后才能继续执行下一个请求，即使Sender端提前发送过去也没有作用，</span><br><span class="line">所以开启Nagle算法是能够优化网络传输的，并且在Receiver端有捎带延迟确认，省掉单独的ACK确认进一步优化小分组传输。</span><br><span class="line">但有时候也需要,可能需要。即使对于那种只需要使用单个连接下载大量数据的客户端实现，</span><br><span class="line">一些数据包仍然需要反向发回以达到最大的传送速度。没有 TCP_NODELAY（但仍然允许 Nagle 算法），</span><br><span class="line">要发出去的数据包可能会被阻塞一会儿，以达到与后续数据包合并的目的</span><br><span class="line">如果有这样一个数据包，它的目的是告诉对方仍有增加发送窗口的空间，</span><br><span class="line">延迟它的发送几百毫秒（或更多）将会对高速连接产生负面的影响。</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>linux</tag>
        <tag>网络编程</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>unterminated conditional directive错误</title>
    <url>/unterminated-conditional-directive%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef XXX</span><br><span class="line">#define XXX</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<ol>
<li>可能是没写#endif</li>
<li>在有#endif的情况下还报错,是头文件互相包含的问题</li>
</ol>
<h3 id="解决头文件互相包含的需求"><a href="#解决头文件互相包含的需求" class="headerlink" title="解决头文件互相包含的需求"></a>解决头文件互相包含的需求</h3><ol>
<li>比如A要使用B,B又使用了A,可以在A.h中声明B,然后在A.cpp中包含B的头文件B.h,不过要注意代码逻辑不要循环递归调用了……</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>循环引用</tag>
      </tags>
  </entry>
  <entry>
    <title>webgl threejs</title>
    <url>/webgl-threejs/</url>
    <content><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><h3 id="1-WebGL"><a href="#1-WebGL" class="headerlink" title="1. WebGL"></a>1. WebGL</h3><ul>
<li>WebGL是基于OpenGL ES 2.0的Web标准，可以通过HTML5 Canvas元素作为DOM接口访问。</li>
<li>WebGL是一个底层的标准，在这些标准被定义之后，Chrome、Firefox之类的浏览器实现了这些标准。然后，程序员就能通过JavaScript代码，在网页上实现三维图形的渲染了。<a id="more"></a>

</li>
</ul>
<h3 id="2-Three-js"><a href="#2-Three-js" class="headerlink" title="2. Three.js"></a>2. Three.js</h3><ul>
<li>Three.js封装了底层的图形接口，使得程序员能够在无需掌握繁冗的图形学知识的情况下，也能用简单的代码实现三维场景的渲染。</li>
<li>更高的封装程度往往意味着灵活性的牺牲，但是Three.js在这方面做得很好。几乎不会有WebGL支持而Three.js实现不了的情况，而且就算真的遇到这种情况，还是能同时使用WebGL去实现，而不会有冲突。</li>
<li>除了WebGL之外，Three.js还提供了基于Canvas、SVG标签的渲染器，但由于通常WebGL能够实现更灵活的渲染效果。</li>
</ul>
<h3 id="3-基础概念"><a href="#3-基础概念" class="headerlink" title="3. 基础概念"></a>3. 基础概念</h3><h5 id="1-render-渲染器"><a href="#1-render-渲染器" class="headerlink" title="1. render(渲染器)"></a>1. render(渲染器)</h5><ul>
<li>渲染相机视角和场景</li>
</ul>
<h5 id="2-camera-相机"><a href="#2-camera-相机" class="headerlink" title="2. camera(相机)"></a>2. camera(相机)</h5><ul>
<li>视角</li>
</ul>
<h5 id="3-scene-场景"><a href="#3-scene-场景" class="headerlink" title="3. scene(场景)"></a>3. scene(场景)</h5><ul>
<li>把物体存到场景中</li>
</ul>
<h1 id="二、照相机"><a href="#二、照相机" class="headerlink" title="二、照相机"></a>二、照相机</h1><h3 id="1-理解"><a href="#1-理解" class="headerlink" title="1. 理解"></a>1. 理解</h3><ul>
<li>照相机是一个抽象，它定义了三维空间到二维屏幕的投影方式，用“照相机”这样一个类比，可以使我们直观地理解这一投影方式。</li>
<li>针对投影方式的不同，照相机又分为正交投影照相机与透视投影照相机。需要为自己的程序选择合适的照相机。</li>
</ul>
<h3 id="2-正交投影"><a href="#2-正交投影" class="headerlink" title="2. 正交投影"></a>2. 正交投影</h3><h5 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h5><ul>
<li>使用正交投影照相机获得的结果就像我们在数学几何学课上老师教我们画的效果，对于在三维空间内平行的线，投影到二维空间中也一定是平行的。</li>
<li>一般说来，对于制图、建模软件通常使用正交投影，这样不会因为投影而改变物体比例  <!-- ![image-20201105211051845](../img/正交投影.png) -->
  <img src="/webgl-threejs/%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1.png" class="" title="正交投影.png">

</li>
</ul>
<h5 id="2-正交投影照相机（Orthographic-Camera）"><a href="#2-正交投影照相机（Orthographic-Camera）" class="headerlink" title="2. 正交投影照相机（Orthographic Camera）"></a>2. 正交投影照相机（Orthographic Camera）</h5><ol>
<li><p>构造函数</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THREE.OrthographicCamera(left, right, top, bottom, near, far)</span><br></pre></td></tr></table></figure></li>
<li><p>这六个参数分别代表正交投影照相机拍摄到的空间的六个面的位置，这六个面围成一个长方体，我们称其为视景体（Frustum）。只有在视景体内部（下图中的灰色部分）的物体才可能显示在屏幕上，而视景体外的物体会在显示之前被裁减掉。</p>
 <!-- ![image-20201105212112920](../img/视景体.png) -->
 <img src="/webgl-threejs/%E8%A7%86%E6%99%AF%E4%BD%93.png" class="" title="视景体.png"></li>
<li><p>为了保持照相机的横竖比例，需要保证(right - left)与(top - bottom)的比例与Canvas宽度与高度的比例一致。</p>
</li>
<li><p>near与far都是指到照相机位置在深度平面的位置，而照相机不应该拍摄到其后方的物体，因此这两个值应该均为正值。为了保证场景中的物体不会因为太近或太远而被照相机忽略，一般near的值设置得较小，far的值设置得较大，具体值视场景中物体的位置等决定。</p>
</li>
</ol>
<h3 id="3-透视投影"><a href="#3-透视投影" class="headerlink" title="3. 透视投影"></a>3. 透视投影</h3><h5 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1. 介绍"></a>1. 介绍</h5><ul>
<li><p>使用透视投影照相机获得的结果是类似人眼在真实世界中看到的有“近大远小”的效果</p>
</li>
<li><p>对于其他大多数应用，通常使用透视投影，因为这更接近人眼的观察效果。</p>
  <!-- ![image-20201105211443743](../img/透视投影.png) -->
  <img src="/webgl-threejs/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1.png" class="" title="透视投影.png">

</li>
</ul>
<h5 id="2-透视投影照相机（Perspective-Camera）"><a href="#2-透视投影照相机（Perspective-Camera）" class="headerlink" title="2. 透视投影照相机（Perspective Camera）"></a>2. 透视投影照相机（Perspective Camera）</h5><ol>
<li><p>构造函数</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THREE.PerspectiveCamera(fov, aspect, near, far)</span><br></pre></td></tr></table></figure></li>
<li><p>透视图中，灰色的部分是视景体，是可能被渲染的物体所在的区域。fov是视景体竖直方向上的张角（是角度制而非弧度制），如侧视图所示。</p>
 <!-- ![image-20201106125441926](../img/透视视景图.png) -->
 <img src="/webgl-threejs/%E9%80%8F%E8%A7%86%E8%A7%86%E6%99%AF%E5%9B%BE.png" class="" title="透视视景图.png">
</li>
<li><p>aspect等于width / height，是照相机水平方向和竖直方向长度的比值，通常设为Canvas的横纵比例。</p>
</li>
<li><p>near和far分别是照相机到视景体最近、最远的距离，均为正值，且far应大于near。</p>
</li>
</ol>
<h1 id="三、基本几何形状"><a href="#三、基本几何形状" class="headerlink" title="三、基本几何形状"></a>三、基本几何形状</h1><h3 id="1-立方体"><a href="#1-立方体" class="headerlink" title="1. 立方体"></a>1. 立方体</h3><ol>
<li>构造函数 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)</span><br></pre></td></tr></table></figure></li>
<li>width是x方向上的长度；height是y方向上的长度；depth是z方向上的长度</li>
<li>后三个参数分别是在三个方向上的分段数，如widthSegments为3的话，代表x方向上水平分为三份。一般情况下不需要分段的话，可以不设置后三个参数，后三个参数的缺省值为1。</li>
</ol>
<h3 id="2-平面"><a href="#2-平面" class="headerlink" title="2. 平面"></a>2. 平面</h3><ol>
<li>构造函数 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THREE.PlaneGeometry(width, height, widthSegments, heightSegments)</span><br></pre></td></tr></table></figure></li>
<li>width是x方向上的长度；height是y方向上的长度；</li>
<li>后两个参数同样表示分段。</li>
</ol>
<h3 id="3-球体"><a href="#3-球体" class="headerlink" title="3. 球体"></a>3. 球体</h3><ol>
<li>构造函数 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THREE.SphereGeometry(radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength)</span><br></pre></td></tr></table></figure></li>
<li>radius是半径；segmentsWidth表示经度上的切片数；segmentsHeight表示纬度上的切片数；phiStart表示经度开始的弧度；phiLength表示经度跨过的弧度；thetaStart表示纬度开始的弧度；thetaLength表示纬度跨过的弧度。</li>
<li>segmentsWidth相当于经度被切成了几瓣，而segmentsHeight相当于纬度被切成了几层。因为在图形底层的实现中，并没有曲线的概念，曲线都是由多个折线近似构成的。对于球体而言，当这两个值较大的时候，形成的多面体就可以近似看做是球体了。</li>
</ol>
<h3 id="4-圆形"><a href="#4-圆形" class="headerlink" title="4. 圆形"></a>4. 圆形</h3><ol>
<li>构造函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THREE.CircleGeometry(radius, segments, thetaStart, thetaLength)</span><br></pre></td></tr></table></figure></li>
<li>这四个参数都是球体一样。</li>
</ol>
<h3 id="5-圆柱体"><a href="#5-圆柱体" class="headerlink" title="5. 圆柱体"></a>5. 圆柱体</h3><ol>
<li>构造函数是： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THREE.CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded)</span><br></pre></td></tr></table></figure></li>
<li>radiusTop与radiusBottom分别是顶面和底面的半径，由此可知，当这两个参数设置为不同的值时，实际上创建的是一个圆台</li>
<li>height是圆柱体的高度；radiusSegments与heightSegments可类比球体中的分段；</li>
<li>openEnded是一个布尔值，表示是否没有顶面和底面，缺省值为false，表示有顶面和底面。</li>
</ol>
<h3 id="6-圆台"><a href="#6-圆台" class="headerlink" title="6. 圆台"></a>6. 圆台</h3><ul>
<li>同圆柱</li>
</ul>
<h3 id="7-正四面体、正八面体、正二十面体"><a href="#7-正四面体、正八面体、正二十面体" class="headerlink" title="7. 正四面体、正八面体、正二十面体"></a>7. 正四面体、正八面体、正二十面体</h3><ol>
<li><p>构造函数分别是</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THREE.TetrahedronGeometry(radius, detail)</span><br><span class="line">  THREE.OctahedronGeometry(radius, detail)</span><br><span class="line">  THREE.IcosahedronGeometry(radius, detail)</span><br></pre></td></tr></table></figure>
</li>
<li><p>radius是半径；detail是细节层次（Level of Detail）的层数，对于大面片数模型，可以控制在视角靠近物体时，显示面片数多的精细模型，而在离物体较远时，显示面片数较少的粗略模型。</p>
</li>
</ol>
<h3 id="8-圆环面"><a href="#8-圆环面" class="headerlink" title="8. 圆环面"></a>8. 圆环面</h3><ol>
<li><p>圆环面（TorusGeometry）就是甜甜圈的形状，其构造函数</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THREE.TorusGeometry(radius, tube, radialSegments, tubularSegments, arc)</span><br></pre></td></tr></table></figure></li>
<li><p>radius是圆环半径；tube是管道半径；radialSegments与tubularSegments分别是两个分段数</p>
</li>
<li><p>arc是圆环面的弧度，缺省值为Math.PI * 2。</p>
 <!-- ![image-20201106131053250](../img/圆环.png) -->
 <img src="/webgl-threejs/%E5%9C%86%E7%8E%AF.png" class="" title="圆环.png">

</li>
</ol>
<h3 id="9-圆环结"><a href="#9-圆环结" class="headerlink" title="9. 圆环结"></a>9. 圆环结</h3><ol>
<li>如果说圆环面是甜甜圈，那么圆环结（TorusKnotGeometry）就是打了结的甜甜圈，其构造参数为 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THREE.TorusKnotGeometry(radius, tube, radialSegments, tubularSegments, p, q, heightScale)</span><br></pre></td></tr></table></figure></li>
<li>heightScale是在z轴方向上的缩放。</li>
</ol>
<h1 id="四、材质"><a href="#四、材质" class="headerlink" title="四、材质"></a>四、材质</h1><h3 id="1-基本材质"><a href="#1-基本材质" class="headerlink" title="1. 基本材质"></a>1. 基本材质</h3><ul>
<li>使用基本材质（BasicMaterial）的物体，渲染后物体的颜色始终为该材质的颜色，而不会由于光照产生明暗、阴影效果。如果没有指定材质的颜色，则颜色是随机的。</li>
</ul>
<h3 id="2-Lambert材质"><a href="#2-Lambert材质" class="headerlink" title="2. Lambert材质"></a>2. Lambert材质</h3><ul>
<li>Lambert材质（MeshLambertMaterial）是符合Lambert光照模型的材质。Lambert光照模型的主要特点是只考虑漫反射而不考虑镜面反射的效果，因而对于金属、镜子等需要镜面反射效果的物体就不适应，对于其他大部分物体的漫反射效果都是适用的。</li>
</ul>
<h3 id="3-Phong材质"><a href="#3-Phong材质" class="headerlink" title="3. Phong材质"></a>3. Phong材质</h3><ul>
<li>Phong材质（MeshPhongMaterial）是符合Phong光照模型的材质。和Lambert不同的是，Phong模型考虑了镜面反射的效果，因此对于金属、镜面的表现尤为适合。</li>
</ul>
<h3 id="4-法向材质"><a href="#4-法向材质" class="headerlink" title="4. 法向材质"></a>4. 法向材质</h3><ul>
<li>法向材质可以将材质的颜色设置为其法向量的方向，有时候对于调试很有帮助。</li>
</ul>
<h3 id="5-材质的纹理贴图"><a href="#5-材质的纹理贴图" class="headerlink" title="5. 材质的纹理贴图"></a>5. 材质的纹理贴图</h3><ul>
<li>导入图像作为纹理贴图，并添加到相应的材质中。</li>
</ul>
<h1 id="五、网格"><a href="#五、网格" class="headerlink" title="五、网格"></a>五、网格</h1><ol>
<li>可以使用几何形状和材质创建物体，最常用的一种物体就是网格（Mesh）。</li>
<li>网格是由顶点、边、面等组成的物体；其他物体包括线段（Line）、骨骼（Bone）、粒子系统（ParticleSystem）等。创建物体需要指定几何形状和材质，其中，几何形状决定了物体的顶点位置等信息，材质决定了物体的颜色、纹理等信息。</li>
</ol>
<h1 id="六、动画"><a href="#六、动画" class="headerlink" title="六、动画"></a>六、动画</h1><h3 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><ol>
<li><p>动画的本质是利用了人眼的视觉暂留特性，快速地变换画面，从而产生物体在运动的假象。而对于Three.js程序而言，动画的实现也是通过在每秒中多次重绘画面实现的。</p>
</li>
<li><p>为了衡量画面切换速度，引入了每秒帧数FPS（Frames Per Second）的概念，是指每秒画面重绘的次数。FPS越大，则动画效果越平滑，当FPS小于20时，一般就能明显感受到画面的卡滞现象。</p>
</li>
<li><p>FPS不是越大越好。当FPS足够大（比如达到60），再增加帧数人眼也不会感受到明显的变化，反而相应地就要消耗更多资源（比如电影的胶片就需要更长了，或是电脑刷新画面需要消耗计算资源等等）。</p>
</li>
<li><p>NTSC标准的电视FPS是30，PAL标准的电视FPS是25，电影的FPS标准为24。而对于Three.js动画而言，一般FPS在30到60之间都是可取的。</p>
</li>
</ol>
<h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><ol>
<li>使用js实现。</li>
</ol>
<h1 id="七、模型"><a href="#七、模型" class="headerlink" title="七、模型"></a>七、模型</h1><ol>
<li>除了自带的立方体这些，其他模型可以通过3dmax制作导入。</li>
</ol>
<h1 id="八、光影"><a href="#八、光影" class="headerlink" title="八、光影"></a>八、光影</h1><h3 id="1-环境光"><a href="#1-环境光" class="headerlink" title="1. 环境光"></a>1. 环境光</h3><ul>
<li>环境光是指场景整体的光照效果，是由于场景内若干光源的多次反射形成的亮度一致的效果，通常用来为整个场景指定一个基础亮度。因此，环境光没有明确的光源位置，在各处形成的亮度也是一致的。</li>
</ul>
<h3 id="2-点源光"><a href="#2-点源光" class="headerlink" title="2. 点源光"></a>2. 点源光</h3><ul>
<li>点光源是不计光源大小，可以看作一个点发出的光源。点光源照到不同物体表面的亮度是线性递减的，因此，离点光源距离越远的物体会显得越暗。</li>
</ul>
<h3 id="3-平行光"><a href="#3-平行光" class="headerlink" title="3. 平行光"></a>3. 平行光</h3><ul>
<li>太阳光常常被看作平行光，这是因为相对地球上物体的尺度而言，太阳离我们的距离足够远。对于任意平行的平面，平行光照射的亮度都是相同的，而与平面所在位置无关。</li>
</ul>
<h3 id="4-聚光灯"><a href="#4-聚光灯" class="headerlink" title="4. 聚光灯"></a>4. 聚光灯</h3><ul>
<li>聚光灯是一种特殊的点光源，它能够朝着一个方向投射光线。聚光灯投射出的是类似圆锥形的光线，这与我们现实中看到的聚光灯是一致的。</li>
</ul>
<h3 id="5-阴影"><a href="#5-阴影" class="headerlink" title="5. 阴影"></a>5. 阴影</h3><ul>
<li>明暗是相对的，阴影的形成也就是因为比周围获得的光照更少。因此，要形成阴影，光源必不可少。</li>
</ul>
<h1 id="九、着色器"><a href="#九、着色器" class="headerlink" title="九、着色器"></a>九、着色器</h1><h3 id="1-渲染"><a href="#1-渲染" class="headerlink" title="1. 渲染"></a>1. 渲染</h3><ul>
<li>简单来说，渲染就是将模型数据在屏幕上显示出来的过程。</li>
</ul>
<h3 id="2-着色器"><a href="#2-着色器" class="headerlink" title="2. 着色器"></a>2. 着色器</h3><ol>
<li><p>在可编程GPU时代到来前，在定义了场景中的物体、照相机、光源等等之后，渲染的结果就确定了。</p>
</li>
<li><p>现在我们已经可以通过着色器程序对GPU编程来控制渲染的结果。着色器是屏幕上呈现画面之前的最后一步，用它可以对先前渲染的结果做修改，包括对颜色、位置等等信息的修改，甚至可以对先前渲染的结果做后处理，实现高级的渲染效果。</p>
</li>
<li><p>例子，比如，我们要渲染一个宇航员，使用同样的模型、同样的光源、同样的照相机，但是不同的着色器，我们就能得到不同的渲染效果：</p>
 <!-- ![image-20201106132526367](../img/着色器.png) -->
 <img src="/webgl-threejs/%E7%9D%80%E8%89%B2%E5%99%A8.png" class="" title="着色器.png">
</li>
<li><p>WebGL是基于OpenGL的，而OpenGL用GLSL（OpenGL Shading Language）这一着色器语言完成着色器工作，因此，WebGL的着色器程序大致与GLSL相同，是一种接近C语言的代码。着色器通常分为几何着色器（Geometry Shader）、顶点着色器（Vertex Shader）、片元着色器（Fragment Shader）等等。</p>
</li>
<li><p>由于WebGL基于OpenGL ES 2.0，因此WebGL支持的着色器只有顶点着色器与片元着色器。</p>
</li>
</ol>
<h3 id="3-顶点着色器"><a href="#3-顶点着色器" class="headerlink" title="3. 顶点着色器"></a>3. 顶点着色器</h3><ol>
<li>顶点着色器中的“顶点”指的正是Mesh中的顶点，对于每个顶点调用一次。因此，如果场景中有一个正方体，那么对八个顶点将各自调用一次顶点着色器，可以修改顶点的位置或者颜色等信息，然后传入片元着色器。</li>
</ol>
<h3 id="4-片元着色器"><a href="#4-片元着色器" class="headerlink" title="4. 片元着色器"></a>4. 片元着色器</h3><ol>
<li>片元是栅格化之后，在形成像素之前的数据。片元着色器是每个片元会调用一次的程序，因此，片元着色器特别适合用来做图像后处理。</li>
</ol>
<h3 id="5-Three-js与着色器"><a href="#5-Three-js与着色器" class="headerlink" title="5. Three.js与着色器"></a>5. Three.js与着色器</h3><ol>
<li>着色器可以用来渲染高级的效果。但是对于很多应用而言，并不需要着色器。</li>
<li>WebGL强制需要程序员定义着色器，即使你只是希望采用默认的渲染方法。</li>
<li>Three.js可以不定义着色器采用默认的方法渲染，而仅在有需要时，才使用自定义的着色器。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webgl</tag>
        <tag>threejs</tag>
      </tags>
  </entry>
  <entry>
    <title>《C Primer Plus》</title>
    <url>/%E3%80%8AC-Primer-Plus%E3%80%8B/</url>
    <content><![CDATA[<h1 id="1-字符串处理"><a href="#1-字符串处理" class="headerlink" title="1. 字符串处理"></a>1. 字符串处理</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. gets(str)&#x2F;puts(str)</span><br><span class="line">2. fgets(str,len,stdin)&#x2F;fputs(str,stdout)</span><br><span class="line">3. strlen(str)</span><br><span class="line">4. strcat(s1,s2)&#x2F;strncat(s1,s2,n)   &#x2F;&#x2F;strcat无法检测s1是否能容纳s2，strncat加上n字节的限制</span><br><span class="line">5. strcmp(s1,s2)strncmp(s1,s2,n)    &#x2F;&#x2F;只比较前n位</span><br><span class="line">6. strcpy(s1,s2)&#x2F;strncpy(s1,s2,n)</span><br><span class="line">7. strchr(str,c)&#x2F;strrchr(str,c)  &#x2F;&#x2F;在字符串中找字符位置,第二个是倒着找</span><br><span class="line">8. strstr(s1,s2)           &#x2F;&#x2F;在字符串中找子串位置</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h1 id="2-存储类别、链接"><a href="#2-存储类别、链接" class="headerlink" title="2. 存储类别、链接"></a>2. 存储类别、链接</h1><table>
<thead>
<tr>
<th>序号</th>
<th>存储类别</th>
<th>作用域</th>
<th>链接</th>
<th>声明方式</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>auto 自动</td>
<td>块</td>
<td>无</td>
<td>块内默认</td>
</tr>
<tr>
<td>2</td>
<td>register 寄存器</td>
<td>块</td>
<td>无</td>
<td>变量前用关键字register</td>
</tr>
<tr>
<td>3</td>
<td>静态无链接</td>
<td>块</td>
<td>无</td>
<td>块内的static</td>
</tr>
<tr>
<td>4</td>
<td>静态内部链接</td>
<td>文件</td>
<td>内部</td>
<td>全局static</td>
</tr>
<tr>
<td>5</td>
<td>静态外部链接</td>
<td>文件</td>
<td>外部</td>
<td>全局变量，不加static</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. extern 说明</span><br><span class="line">    extern 只是变量声明，表明这个变量已经在其他文件中定义过了。</span><br><span class="line">    用extern声明的变量不能再定义。</span><br><span class="line">2. auto 关键字</span><br><span class="line">    C 中的 auto 和C++ 中的完全不一样</span><br><span class="line">    C 中的是存储类别声明</span><br><span class="line">    C++ 中是自动类型</span><br><span class="line">3. 自动即放到栈上，静态即放到数据段，动态放到堆段</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. malloc(size)</span><br><span class="line">2. calloc(n,size)</span><br><span class="line">    二者参数不同。且calloc初始化申请的空间为0，而malloc不初始化</span><br><span class="line">3. relloc</span><br><span class="line">3. free</span><br></pre></td></tr></table></figure>

<h1 id="4-ANSI-C-限定符"><a href="#4-ANSI-C-限定符" class="headerlink" title="4. ANSI C 限定符"></a>4. ANSI C 限定符</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. const   &#x2F;&#x2F;常量限定，注意常量指针和指针常量</span><br><span class="line">2. volatile &#x2F;&#x2F;声明不能被编译器优化</span><br><span class="line">3. restrict &#x2F;&#x2F;只能用于指针，告诉编译器该指针是访问数据的唯一且初始的方式，可以被优化</span><br><span class="line">4. _Atomic  &#x2F;&#x2F;原子操作限定，相当于资源锁了，但是只是可选实现，编译器不一定支持，不建议使用</span><br></pre></td></tr></table></figure>

<h1 id="5-文件操作函数-FILE"><a href="#5-文件操作函数-FILE" class="headerlink" title="5. 文件操作函数 FILE*"></a>5. 文件操作函数 FILE*</h1><table>
<thead>
<tr>
<th>序号</th>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>fopen(filename,model)</td>
<td>打开文件</td>
</tr>
<tr>
<td>2</td>
<td>fclose(FILE*)</td>
<td>关闭文件</td>
</tr>
<tr>
<td>3</td>
<td>EOF</td>
<td>文件结尾，-1</td>
</tr>
<tr>
<td>4</td>
<td>fprintf(FILE*,string,parameter)</td>
<td>写入文件</td>
</tr>
<tr>
<td>5</td>
<td>fscanf(FILE*,string,parameter)</td>
<td>从文件中读取内容到parameter</td>
</tr>
<tr>
<td>6</td>
<td>fgets(buf,len,fp)</td>
<td>读取len-1个字符，或者遇到换行符、文件结尾</td>
</tr>
<tr>
<td>7</td>
<td>fputs(buf,fp)</td>
<td>把buf输入到fp文件</td>
</tr>
<tr>
<td>8</td>
<td>fseek(fp,offset,model)</td>
<td>model确定起点位置，SEEK_SET文件开始处，SEEK_CUR当前位置，SEEK_END文件末尾，成功返回0，失败-1</td>
</tr>
<tr>
<td>9</td>
<td>ftell()</td>
<td>成功返回当前位置，ftell(fp)可以获得fp文件的字节数</td>
</tr>
<tr>
<td>10</td>
<td>fgetpos(fp,pos)/fsetpos(fp,pos)</td>
<td>fseek的增强版,fseek只能操作小文件，这个能操作更大的文件</td>
</tr>
<tr>
<td>11</td>
<td>fflush(fp)</td>
<td>刷新缓冲区</td>
</tr>
<tr>
<td>12</td>
<td>fwrite/fread(str,size,num,fp)</td>
<td>二进制读写，从str中读num个size大小的内存到fp文件中，或从fp读到str</td>
</tr>
<tr>
<td>13</td>
<td>feof(fp)/ferror(fp)</td>
<td>检测是到文件尾返回的EOF还是出错返回的EOF</td>
</tr>
</tbody></table>
<h1 id="6-struct、union、enum"><a href="#6-struct、union、enum" class="headerlink" title="6. struct、union、enum"></a>6. struct、union、enum</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 注意struct成员是数组还是指针的问题</span><br><span class="line">    若是数组，存的是数组的大小</span><br><span class="line">    若是指针，存的是地址，地址指向其他地方，若要使用，记得用malloc</span><br><span class="line">2. 结构体的对齐问题</span><br><span class="line">3. union 中多种类型只占一份空间，可用来判别大端小端</span><br><span class="line">4. enum 枚举，为了增加程序的可读性，最好只使用，不要对其进行算术运算，不推荐使用</span><br></pre></td></tr></table></figure>

<h1 id="7-typedef与-define"><a href="#7-typedef与-define" class="headerlink" title="7. typedef与#define"></a>7. typedef与#define</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. typedef只能用于类型</span><br><span class="line">2. typedef由编译器解释，#define由预处理器处理</span><br></pre></td></tr></table></figure>

<h1 id="8-位操作"><a href="#8-位操作" class="headerlink" title="8. 位操作"></a>8. 位操作</h1><ol>
<li>符号<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">～：取反</span><br><span class="line">&amp; | ^ 与 或 异或</span><br></pre></td></tr></table></figure></li>
<li>掩码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MASK&#x3D;0x02</span><br><span class="line">flags &#x3D; flags &amp; MASK</span><br><span class="line">使用 MASK 中的 0 掩藏 flags 中的相应位</span><br></pre></td></tr></table></figure></li>
<li>打开位<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MASK&#x3D;0x02</span><br><span class="line">flags &#x3D; flags | MASK</span><br><span class="line">使用 MASK 中的 1 打开 flags 中的相应位</span><br></pre></td></tr></table></figure></li>
<li>关闭位<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MASK&#x3D;0x02</span><br><span class="line">flags &#x3D; flags &amp; ～MASK</span><br><span class="line">使用 MASK 中的 1取反后 关闭 flags 中的相应位</span><br></pre></td></tr></table></figure></li>
<li>切换位<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MASK&#x3D;0x02</span><br><span class="line">flags &#x3D; flags ^ MASK</span><br><span class="line">flags中对应 MASK 中的 为1的位置的数全部改变，1变为0,0变为1</span><br></pre></td></tr></table></figure></li>
<li>检查位<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MASK&#x3D;0x02</span><br><span class="line">(flags &amp; MASK)&#x3D;&#x3D;MASK</span><br><span class="line">检查 flags 中的某位或某几位是否为1</span><br></pre></td></tr></table></figure></li>
<li>&lt;&lt; 左移 右移&gt;&gt;</li>
<li>位字段<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主要是在结构体中声明位大小</span><br><span class="line">struct &#123;</span><br><span class="line">    int a:1;</span><br><span class="line">    int b:1;</span><br><span class="line">&#125;</span><br><span class="line">本来应该占8字节，现在只占4字节，因为对齐原则，一个int至少4字节，但只使用了2位，其他的30位为0，不使用</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="9-预处理器"><a href="#9-预处理器" class="headerlink" title="9. 预处理器"></a>9. 预处理器</h1><ol>
<li><p>#include,#ifdef,#ifndef </p>
<ul>
<li>常见就不用强调了</li>
</ul>
</li>
<li><p>#if,#elif,#else,#endif  </p>
<ul>
<li>和if else 差不多，也是后面跟判断条件</li>
</ul>
</li>
<li><p>#define</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不推荐使用</span><br><span class="line">若定义变量，可以用const</span><br><span class="line">若想用宏函数，可以用内联</span><br><span class="line">若想定义类型，可以用typedef</span><br><span class="line">还有一些加 ## 的骚操作，，，感觉不是很必要，需要的时候再看吧</span><br></pre></td></tr></table></figure></li>
<li><p>#undef   </p>
<ul>
<li>取消宏</li>
</ul>
</li>
<li><p>#line和#error</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 预定义宏有 __FILE__,__DATE__,__LINE__,__TIME__。字面意思</span><br><span class="line">2. #line 可以改变__FILE__,__LINE__</span><br><span class="line">3. #error 可以在编译期报错，放在#if等里面</span><br></pre></td></tr></table></figure></li>
<li><p>#pragma  </p>
<ul>
<li>编译器设置，例如可以改变struct的对齐字节数</li>
</ul>
</li>
</ol>
<h1 id="10-C库"><a href="#10-C库" class="headerlink" title="10. C库"></a>10. C库</h1><ol>
<li><p>数学库 math.h</p>
</li>
<li><p>断言库 assert.h  </p>
<ul>
<li>调试的时候用</li>
</ul>
</li>
<li><p>string.h 中的memcpy(dest,src,n)和memmove(dest,src,n)的区别</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传入参数的类别不同，memcpy假定两个字符串没有重叠，用register关键字声明</span><br><span class="line">memmove没有这个限制，所以感觉memmove比较好用</span><br></pre></td></tr></table></figure></li>
<li><p>通用工具库</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. qsort(s1,s2,mycompare);  </span><br><span class="line">    - 自己写比较函数</span><br><span class="line">2. exit()   </span><br><span class="line">    - 退出</span><br><span class="line">3. atexit(函数名) </span><br><span class="line">    - 在exit执行前，退出前执行某个函数，若注册多个函数，是按照栈的方式注册的，即后面注册的先执行。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="11-各种小技巧"><a href="#11-各种小技巧" class="headerlink" title="11. 各种小技巧"></a>11. 各种小技巧</h1><h3 id="1-逗号"><a href="#1-逗号" class="headerlink" title="1. 逗号"></a>1. 逗号</h3><ul>
<li>在C语言中，多个表达式可以用逗号分开，其中用逗号分开的表达式的值分别结算，但整个表达式的值是最后一个表达式的值。</li>
<li>假设b=2,c=7,d=5,  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a1&#x3D;(++b,c--,d+3);</span><br><span class="line">a2&#x3D;++b,c--,d+3;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于第一行代码，有三个表达式，用逗号分开，所以最终的值应该是最后一个表达式的值，也就是d+3，为8，所以a1=8。</li>
<li>对于第二行代码，那么也是有三个表达式，这时的三个表达式为a2=++b、c–、d+3,(这是因为赋值运算符比逗号运算符优先级高)所以最终表达式的值虽然也为8，但a2=3。</li>
</ul>
</li>
<li>注意：逗号运算的结合性是从左至右，完毕之后整个表达式的值是最后一个表达式的值。<ul>
<li>例子：int a[2],x=2,y=5;<br>  a[0]=(x+3,y++,x++);那么最终结果是：a[0]=2 x=3 y=6;<br>  为何a[0]=2：因为(x++)是运算之后再自加<br>  a[1]=(x++,x+3,x+7);那么最终结果是：a[1]=11 ，x=4<br>  逗号运算是从左至右，所以先算x++,x从而变成4了，然后a[1]=4+7=11;</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First Java》</title>
    <url>/%E3%80%8AHead-First-Java%E3%80%8B/</url>
    <content><![CDATA[<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ol>
<li>在写这个笔记的时候已经有了一定的java基础，所以一些极其基础的东西就没有记录</li>
<li>这本书不推荐入门看，说的花里胡哨的。。。没有按照书目录整理笔记，自己按照知识点整理的。<a id="more"></a>
<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1></li>
</ol>
<h3 id="1-编译运行"><a href="#1-编译运行" class="headerlink" title="1. 编译运行"></a>1. 编译运行</h3><ul>
<li>代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译运行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac test.java &#x2F;&#x2F;编译，生成Test.class</span><br><span class="line">java Test   &#x2F;&#x2F;运行，输出hello</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-基本语句"><a href="#2-基本语句" class="headerlink" title="2. 基本语句"></a>2. 基本语句</h3><ul>
<li>顺序选择循环，略</li>
</ul>
<h3 id="3-原始数据类型"><a href="#3-原始数据类型" class="headerlink" title="3. 原始数据类型"></a>3. 原始数据类型</h3><ul>
<li>这些是非引用的<table>
<thead>
<tr>
<th>类型</th>
<th>位数</th>
<th>值域</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>java虚拟机决定</td>
<td>true/false</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>0~65535</td>
</tr>
<tr>
<td>byte</td>
<td>8</td>
<td>-128~127</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>-很大～很大</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>范围规模可变</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>范围规模可变</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="4-引用"><a href="#4-引用" class="headerlink" title="4. 引用"></a>4. 引用</h3><ol>
<li>new的对象都是引用，和C++指针类似</li>
<li>引用占字节大小由java虚拟机决定</li>
<li>把一个对象赋值给另一个同对象变量，增加引用数，不创建新对象</li>
<li>数组也是对象，传数组就是传引用</li>
</ol>
<h3 id="5-静态-static"><a href="#5-静态-static" class="headerlink" title="5. 静态 static"></a>5. 静态 static</h3><ul>
<li>和C++类似</li>
<li>Math类全是静态函数，且它的构造是私有的，不能创建Math实例</li>
<li>静态方法不能调用非静态方法</li>
</ul>
<h3 id="6-常量-final"><a href="#6-常量-final" class="headerlink" title="6. 常量 final"></a>6. 常量 final</h3><ul>
<li>和C++ const类似，必须初始化赋值</li>
<li>final 修饰的方法不能被覆盖，C++的final和这个功能基本一样</li>
<li>final 的类不能被继承</li>
</ul>
<h3 id="7-primitive数据类型的包装"><a href="#7-primitive数据类型的包装" class="headerlink" title="7. primitive数据类型的包装"></a>7. primitive数据类型的包装</h3><ul>
<li>把primitive数据类型当对象来处理<table>
<thead>
<tr>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
</tr>
<tr>
<td>Character</td>
</tr>
<tr>
<td>Byte</td>
</tr>
<tr>
<td>Short</td>
</tr>
<tr>
<td>Integer</td>
</tr>
<tr>
<td>Long</td>
</tr>
<tr>
<td>Float</td>
</tr>
<tr>
<td>Double</td>
</tr>
</tbody></table>
</li>
<li>java5 以后自动装箱</li>
<li>利用上述对象可以实现类型转化  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Double.toString(2.2);</span><br><span class="line">Integer.parseInt(&quot;123&quot;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="8-数字格式化"><a href="#8-数字格式化" class="headerlink" title="8. 数字格式化"></a>8. 数字格式化</h3><ul>
<li>String.format(“asd,%d”,1230);</li>
</ul>
<h1 id="二、类与对象"><a href="#二、类与对象" class="headerlink" title="二、类与对象"></a>二、类与对象</h1><h3 id="1-访问权限"><a href="#1-访问权限" class="headerlink" title="1. 访问权限"></a>1. 访问权限</h3><ul>
<li>java的访问权限有下面四种：<ul>
<li>public–都可访问(公有)</li>
<li>protected–包内和子类可访问（保护）</li>
<li>不写(default)–包内可访问 （默认）</li>
<li>private–类内可访问（私有）</li>
</ul>
</li>
<li>和C++不同，每个变量前都要加private或public声明</li>
</ul>
<h3 id="2-对象方法"><a href="#2-对象方法" class="headerlink" title="2. 对象方法"></a>2. 对象方法</h3><ol>
<li>java方法是通过值传递的，也就是拷贝传递<ul>
<li>对基本类型直接拷贝传递</li>
<li>对引用，传递的是远程控制的拷贝</li>
</ul>
</li>
</ol>
<h3 id="3-实例变量和局部变量"><a href="#3-实例变量和局部变量" class="headerlink" title="3. 实例变量和局部变量"></a>3. 实例变量和局部变量</h3><ul>
<li>实例变量是属于类的，局部变量是方法中的</li>
<li>实例变量有默认值，局部变量没有，必须初始化或赋值</li>
</ul>
<h3 id="3-封装继承多态"><a href="#3-封装继承多态" class="headerlink" title="3. 封装继承多态"></a>3. 封装继承多态</h3><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><ol>
<li>emmm没啥说的，主要是注意访问权限</li>
</ol>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ol>
<li>extends父类</li>
<li>函数重载：参数列表数量和类型不同，权限可以改变，和多态无关</li>
<li>java的继承和C++不一样，不分公有私有保护</li>
</ol>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><ol>
<li>基类对象变量可以被赋值为它的子类</li>
<li>函数覆盖：子类覆盖父类方法，参数列表要相同，返回值类型兼容，函数权限不能改变</li>
</ol>
<h3 id="4-接口和抽象类"><a href="#4-接口和抽象类" class="headerlink" title="4. 接口和抽象类"></a>4. 接口和抽象类</h3><ol>
<li>抽象类<ul>
<li>abstract关键字声明：abstract class student{}</li>
<li>不能初始化，类似于C++的pure virtual</li>
<li>子类可以再被声明为abstract</li>
<li>抽象类的方法无实体</li>
<li>必须实现所有的抽象方法，抽象类也有非抽象方法</li>
</ul>
</li>
<li>具体类<ul>
<li>不是抽象类的就是具体类</li>
<li>调用父类的方法用super.function()</li>
</ul>
</li>
<li>接口<ul>
<li>interface关键字声明接口</li>
<li>implements关键字使用接口</li>
<li>所有接口的方法都是抽象的</li>
<li>接口里方法没有实体，只是定义一种“规则”，使用接口并不是多重继承</li>
<li>不同继承树的类可以使用相同的接口</li>
</ul>
</li>
<li>抽象和接口的主要区别是，子类只能继承一个抽象类，但可以实现很多接口</li>
</ol>
<h3 id="5-构造函数"><a href="#5-构造函数" class="headerlink" title="5. 构造函数"></a>5. 构造函数</h3><ul>
<li>和C++类似</li>
<li>调用父类构造函数:<ul>
<li>super();</li>
</ul>
</li>
<li>java没有析构，把对象置为null，垃圾回收器会自动释放</li>
</ul>
<h1 id="三、Java-API"><a href="#三、Java-API" class="headerlink" title="三、Java API"></a>三、Java API</h1><h3 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1. ArrayList"></a>1. ArrayList</h3><ul>
<li>动态数组</li>
</ul>
<h3 id="2-Calendar"><a href="#2-Calendar" class="headerlink" title="2. Calendar"></a>2. Calendar</h3><ul>
<li>日期类</li>
<li>Date类基本被舍弃不用了</li>
</ul>
<h3 id="3-Math"><a href="#3-Math" class="headerlink" title="3. Math"></a>3. Math</h3><ul>
<li>各种数学函数</li>
<li>构造函数是私有，不能实例化</li>
<li>所有方法都是static</li>
</ul>
<h3 id="4-各种数据结构"><a href="#4-各种数据结构" class="headerlink" title="4. 各种数据结构"></a>4. 各种数据结构</h3><ol>
<li>TreeSet<ul>
<li>有序无重复</li>
</ul>
</li>
<li>HashMap<ul>
<li>键值对</li>
</ul>
</li>
<li>LinkedList<ul>
<li>链表结构</li>
</ul>
</li>
<li>HashSet<ul>
<li>无重复，快速查找</li>
</ul>
</li>
<li>LinkedHashMap<ul>
<li>类似HashMap,但可记住元素的插入顺序</li>
</ul>
</li>
</ol>
<h1 id="四、异常处理"><a href="#四、异常处理" class="headerlink" title="四、异常处理"></a>四、异常处理</h1><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h3><ul>
<li>捕获异常<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    &#x2F;&#x2F;可能产生异常的代码</span><br><span class="line">&#125;catch(异常种类，Exception类对象)&#123;</span><br><span class="line">    &#x2F;&#x2F;处理</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    &#x2F;&#x2F;无论如何都执行</span><br><span class="line">    &#x2F;&#x2F; 有finally的try必须要声明异常，就是在函数名后面加 throws ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>抛出异常<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void test() throws BadException&#123;</span><br><span class="line">    if(aaa)&#123;</span><br><span class="line">        throw new BadException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>由上一级处理异常<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void test() throws BadException&#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="五、图形用户接口"><a href="#五、图形用户接口" class="headerlink" title="五、图形用户接口"></a>五、图形用户接口</h1><h3 id="1-基本框架"><a href="#1-基本框架" class="headerlink" title="1. 基本框架"></a>1. 基本框架</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import javax.swing.*;</span><br><span class="line"></span><br><span class="line">public class helloJFrame&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        JFrame frame&#x3D;new JFrame();</span><br><span class="line">        JButton b1&#x3D;new JButton(&quot;Hello&quot;);</span><br><span class="line">        &#x2F;&#x2F;设置退出窗口时，程序结束</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        frame.getContentPane().add(b1);</span><br><span class="line"></span><br><span class="line">        frame.setSize(300,300);</span><br><span class="line">        frame.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-事件监听"><a href="#2-事件监听" class="headerlink" title="2. 事件监听"></a>2. 事件监听</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.awt.event.*;</span><br><span class="line">import javax.swing.*;</span><br><span class="line"></span><br><span class="line">public class Listen&#123;</span><br><span class="line">    JButton b1;</span><br><span class="line">    &#x2F;&#x2F; JFrame frame;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Listen l&#x3D;new Listen();</span><br><span class="line">        l.init();</span><br><span class="line">    &#125;</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        JFrame frame&#x3D;new JFrame();</span><br><span class="line">        b1&#x3D;new JButton(&quot;Hello&quot;);</span><br><span class="line">        b1.addActionListener(new ActionListener()&#123;</span><br><span class="line">        </span><br><span class="line">            @Override</span><br><span class="line">            public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">                b1.setText(&quot;new&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;设置退出窗口时，程序结束</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        frame.getContentPane().add(b1);</span><br><span class="line"></span><br><span class="line">        frame.setSize(300,300);</span><br><span class="line">        frame.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-swing"><a href="#3-swing" class="headerlink" title="3. swing"></a>3. swing</h1><ul>
<li>布局管理器和各种控件略</li>
</ul>
<h1 id="六、序列化和文件输入输出"><a href="#六、序列化和文件输入输出" class="headerlink" title="六、序列化和文件输入输出"></a>六、序列化和文件输入输出</h1><h3 id="1-让类可序列化"><a href="#1-让类可序列化" class="headerlink" title="1. 让类可序列化"></a>1. 让类可序列化</h3><ul>
<li>实现Serializable接口  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test() implements Serializable&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-把序列化对象写入文件"><a href="#2-把序列化对象写入文件" class="headerlink" title="2. 把序列化对象写入文件"></a>2. 把序列化对象写入文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    FileOutputStream fs&#x3D;new FileOutputStream(&quot;foo.ser&quot;);</span><br><span class="line">    ObjectOutputStream os&#x3D;new ObjectOutputStream(fs);</span><br><span class="line">    os.writeObject(myObj);</span><br><span class="line">    os.close();</span><br><span class="line">&#125;catch(Exception ex)&#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-取消某些变量的序列化"><a href="#3-取消某些变量的序列化" class="headerlink" title="3. 取消某些变量的序列化"></a>3. 取消某些变量的序列化</h3><ul>
<li>使用transient关键字  <!-- ![1.取消序列化.png](./img/1.取消序列化.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/1.%E5%8F%96%E6%B6%88%E5%BA%8F%E5%88%97%E5%8C%96.png" class="" title="1.取消序列化.png"></li>
<li>transient的引用实例会以null返回</li>
</ul>
<h3 id="4-解序列化-Deserializations"><a href="#4-解序列化-Deserializations" class="headerlink" title="4. 解序列化(Deserializations)"></a>4. 解序列化(Deserializations)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    FileInputStream fs&#x3D;new FileInputStream(&quot;foo.ser&quot;);</span><br><span class="line">    ObjectInputStream is&#x3D;new ObjectInputStream(fs);</span><br><span class="line"></span><br><span class="line">    GameCharacter a1&#x3D;(GameCharacter)is.readObject();</span><br><span class="line">    GameCharacter a2&#x3D;(GameCharacter)is.readObject();</span><br><span class="line">    GameCharacter a3&#x3D;(GameCharacter)is.readObject();</span><br><span class="line">    os.close();</span><br><span class="line">&#125;catch(Exception ex)&#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每次调用readObject()会读出一个对象，读出顺序和存入顺序相同，次数超过会报异常</li>
</ul>
<h3 id="5-序列化的识别：Version-ID"><a href="#5-序列化的识别：Version-ID" class="headerlink" title="5. 序列化的识别：Version ID"></a>5. 序列化的识别：Version ID</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final long serialVersionUID&#x3D;546655...651L;</span><br></pre></td></tr></table></figure>
<ul>
<li>略</li>
</ul>
<h3 id="6-文件操作"><a href="#6-文件操作" class="headerlink" title="6. 文件操作"></a>6. 文件操作</h3><ul>
<li>java.io.file</li>
<li>略</li>
</ul>
<h1 id="七、网络与线程"><a href="#七、网络与线程" class="headerlink" title="七、网络与线程"></a>七、网络与线程</h1><h3 id="1-服务器端"><a href="#1-服务器端" class="headerlink" title="1. 服务器端"></a>1. 服务器端</h3><ul>
<li>比Linux原生函数简便很多<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServerSocket server&#x3D;new ServerSocket(12345);</span><br><span class="line">server.accept();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2. 客户端"></a>2. 客户端</h3><ul>
<li>把socket绑定到输入输出流上，更方便的操作  <!-- ![2.Client.png](./img/2.Client.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/2.Client.png" class="" title="2.Client.png">

</li>
</ul>
<h3 id="3-线程"><a href="#3-线程" class="headerlink" title="3. 线程"></a>3. 线程</h3><ul>
<li>启动线程<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Runable threadJob&#x3D;new MyRunable();</span><br><span class="line">Thread myThread&#x3D;new Thread(threadJob);</span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure></li>
<li>MyRunable是自己写的类，实现Runable接口</li>
<li>Runable只有一个run()接口</li>
</ul>
<h3 id="4-同步"><a href="#4-同步" class="headerlink" title="4. 同步"></a>4. 同步</h3><ul>
<li>synchronized</li>
</ul>
<h1 id="八、集合与泛型"><a href="#八、集合与泛型" class="headerlink" title="八、集合与泛型"></a>八、集合与泛型</h1><h3 id="1-集合"><a href="#1-集合" class="headerlink" title="1. 集合"></a>1. 集合</h3><ul>
<li>就是各种数据结构，上面有说</li>
</ul>
<h3 id="2-排序"><a href="#2-排序" class="headerlink" title="2. 排序"></a>2. 排序</h3><ol>
<li>set自动排序</li>
<li>Collections.sort();</li>
<li>Comparator</li>
</ol>
<h3 id="3-泛型"><a href="#3-泛型" class="headerlink" title="3. 泛型"></a>3. 泛型</h3><ul>
<li>和C++的模板差不多吧</li>
</ul>
<h1 id="九、包、jar存档文件和部署"><a href="#九、包、jar存档文件和部署" class="headerlink" title="九、包、jar存档文件和部署"></a>九、包、jar存档文件和部署</h1><h3 id="1-部署的选择"><a href="#1-部署的选择" class="headerlink" title="1. 部署的选择"></a>1. 部署的选择</h3><!-- ![3.部署的选择.png](./img/3.部署的选择.png) -->
<img src="/%E3%80%8AHead-First-Java%E3%80%8B/3.%E9%83%A8%E7%BD%B2%E7%9A%84%E9%80%89%E6%8B%A9.png" class="" title="3.部署的选择.png">

<h3 id="2-本地部署jar"><a href="#2-本地部署jar" class="headerlink" title="2. 本地部署jar"></a>2. 本地部署jar</h3><ol>
<li>javac -d … 可以指定编译生成文件的路径</li>
<li>创建可执行的jar <!-- ![4.可执行jar.png](./img/4.可执行jar.png) -->
 <img src="/%E3%80%8AHead-First-Java%E3%80%8B/4.%E5%8F%AF%E6%89%A7%E8%A1%8Cjar.png" class="" title="4.可执行jar.png">

</li>
</ol>
<h3 id="3-创建与部署Java-Web-Start"><a href="#3-创建与部署Java-Web-Start" class="headerlink" title="3. 创建与部署Java Web Start"></a>3. 创建与部署Java Web Start</h3><!-- ![5.Web部署.png](./img/5.Web部署.png) -->
<img src="/%E3%80%8AHead-First-Java%E3%80%8B/5.Web%E9%83%A8%E7%BD%B2.png" class="" title="5.Web部署.png">

<h1 id="十、远程部署RMI"><a href="#十、远程部署RMI" class="headerlink" title="十、远程部署RMI"></a>十、远程部署RMI</h1><h3 id="1-RMI"><a href="#1-RMI" class="headerlink" title="1. RMI"></a>1. RMI</h3><ul>
<li>调用远程机器上的方法</li>
<li>创建远程服务步骤  <!-- ![6.创建远程服务.png](./img/6.创建远程服务.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/6.%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1.png" class="" title="6.创建远程服务.png"></li>
<li>创建远程接口  <!-- ![7.创建远程接口.png](./img/7.创建远程接口.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/7.%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3.png" class="" title="7.创建远程接口.png"></li>
<li>实现远程接口  <!-- ![8.实现远程接口.png](./img/8.实现远程接口.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/8.%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3.png" class="" title="8.实现远程接口.png"></li>
<li>产生stub和skeleton,启动服务  <!-- ![9.启动服务.png](./img/9.启动服务.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/9.%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1.png" class="" title="9.启动服务.png"></li>
<li>客户端  <!-- ![10.client.png](./img/10.client.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/10.client.png" class="" title="10.client.png"></li>
<li>常见错误  <!-- ![11.error.png](./img/11.error.png) -->
  <img src="/%E3%80%8AHead-First-Java%E3%80%8B/11.error.png" class="" title="11.error.png">

</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《设计数据密集型应用》</title>
    <url>/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E3%80%8B/</url>
    <content><![CDATA[<p>图书链接：<a href="https://vonng.gitbooks.io/ddia-cn/content/">设计数据密集型应用</a></p>
<h1 id="第一部分：数据系统的基石"><a href="#第一部分：数据系统的基石" class="headerlink" title="第一部分：数据系统的基石"></a>第一部分：数据系统的基石</h1><h1 id="第一章：可靠性、可扩展性、可维护性"><a href="#第一章：可靠性、可扩展性、可维护性" class="headerlink" title="第一章：可靠性、可扩展性、可维护性"></a>第一章：可靠性、可扩展性、可维护性</h1><h3 id="1-一个应用程序可能需要的数据系统都有什么？"><a href="#1-一个应用程序可能需要的数据系统都有什么？" class="headerlink" title="1. 一个应用程序可能需要的数据系统都有什么？"></a>1. 一个应用程序可能需要的数据系统都有什么？</h3><ol>
<li>数据库，存储数据，以便自己或其他应用程序之后能再次找到。</li>
<li>缓存，记住开销昂贵操作的结果，加快读取速度。</li>
<li>搜索索引，允许用户按关键字搜索数据，或以各种方式对数据进行过滤。</li>
<li>流处理，向其他进程发送消息，进行异步处理。</li>
<li>批处理，定期处理累积的大批量数据。</li>
</ol>
<a id="more"></a>

<h3 id="2-这三者的定义是什么？"><a href="#2-这三者的定义是什么？" class="headerlink" title="2. 这三者的定义是什么？"></a>2. 这三者的定义是什么？</h3><ol>
<li>可靠性Reliability：系统在困境（adversity）（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。</li>
<li>可扩展性Scalability：有合理的办法应对系统的增长（数据量、流量、复杂性）。</li>
<li>可维护性Maintainability： 许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）。</li>
</ol>
<h3 id="3-可靠性理解"><a href="#3-可靠性理解" class="headerlink" title="3. 可靠性理解"></a>3. 可靠性理解</h3><h5 id="3-1-故障"><a href="#3-1-故障" class="headerlink" title="3.1 故障"></a>3.1 故障</h5><ol>
<li>提高对故障的容错能力，减少故障。</li>
<li>故障不等于失效，要设计容错机制以防因故障而导致失效。</li>
</ol>
<h5 id="3-2-故障大致分为三类：硬件故障、软件错误、人为错误。"><a href="#3-2-故障大致分为三类：硬件故障、软件错误、人为错误。" class="headerlink" title="3.2 故障大致分为三类：硬件故障、软件错误、人为错误。"></a>3.2 故障大致分为三类：硬件故障、软件错误、人为错误。</h5><ol>
<li>硬件故障比较不可预测，云平台的设计就是优先考虑灵活性（flexibility）和弹性（elasticity），而不是单机可靠性。在硬件冗余的基础上进一步引入软件容错机制，那么系统在容忍整个（单台）机器故障的道路上就更进一步了。</li>
<li>软件错误，彻底测试减少bug；进程隔离，允许进程崩溃并重启；监控生产环境的系统行为，及时报警。</li>
<li>人为错误，如配置错误，要能方便回滚，及时全面的监控。</li>
</ol>
<h3 id="4-可扩展性理解"><a href="#4-可扩展性理解" class="headerlink" title="4. 可扩展性理解"></a>4. 可扩展性理解</h3><ol>
<li>可扩展性（Scalability） 是用来描述系统应对负载增长能力的术语，服务 降级（degradation） 的一个常见原因是负载增加。</li>
</ol>
<h5 id="4-1-怎样描述负载？"><a href="#4-1-怎样描述负载？" class="headerlink" title="4.1 怎样描述负载？"></a>4.1 怎样描述负载？</h5><ol>
<li>负载可以用一些称为 负载参数（load parameters） 的数字来描述。参数的最佳选择取决于系统架构，它可能是每秒向Web服务器发出的请求、数据库中的读写比率、聊天室中同时活跃的用户数量、缓存命中率或其他东西。除此之外，也许平均情况很重要，也许瓶颈是少数极端情况</li>
<li>推特推文设计</li>
</ol>
<h5 id="4-2-怎么描述性能？"><a href="#4-2-怎么描述性能？" class="headerlink" title="4.2 怎么描述性能？"></a>4.2 怎么描述性能？</h5><ol>
<li><p>从两种角度来看： </p>
<ul>
<li>增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？ </li>
<li>增加负载参数并希望保持性能不变时，需要增加多少系统资源？</li>
</ul>
</li>
<li><p>常见的是”吞吐量“和”响应时间“</p>
<ul>
<li>对于Hadoop这样的批处理系统，通常关心的是吞吐量（throughput），即每秒可以处理的记录数量，或者在特定规模数据集上运行作业的总时间。理想情况下，批量作业的运行时间是数据集的大小除以吞吐量。 在实践中由于数据倾斜（数据不是均匀分布在每个工作进程中），需要等待最慢的任务完成，所以运行时间往往更长。</li>
<li>对于在线系统，通常更重要的是服务的响应时间（response time），即客户端发送请求到接收响应之间的时间。</li>
<li>延迟latency 和响应时间response time经常用作同义词，但实际上它们并不一样。响应时间是客户所看到的，除了实际处理请求的时间服务时间service time之外，还包括网络延迟和排队延迟。延迟是某个请求等待处理的持续时长，在此期间它处于 休眠（latent)状态并等待服务</li>
</ul>
</li>
</ol>
<h5 id="4-3-响应时间的讨论"><a href="#4-3-响应时间的讨论" class="headerlink" title="4.3 响应时间的讨论"></a>4.3 响应时间的讨论</h5><ol>
<li>通常报表都会展示服务的平均响应时间。然而如果你想知道“典型（typical）”响应时间，那么平均值并不是一个非常好的指标，因为它不能告诉你有多少用户实际上经历了这个延迟。 通常使用百分位点（percentiles）会更好。</li>
<li>如果将响应时间列表按最快到最慢排序，那么中位数（median）就在正中间：举个例子，如果你的响应时间中位数是200毫秒，这意味着一半请求的返回时间少于200毫秒，另一半比这个要长。</li>
<li>响应时间的高百分位点（也称为尾部延迟（tail latencies））非常重要</li>
<li>百分位点通常用于服务级别目标（SLO, service level objectives）和服务级别协议（SLA, service level agreements）</li>
<li>SLA可能会声明，如果服务响应时间的中位数小于200毫秒，且99.9百分位点低于1秒，则认为服务工作正常（如果响应时间更长，就认为服务不达标）。这些指标为客户设定了期望值，并允许客户在SLA未达标的情况下要求退款。</li>
</ol>
<h5 id="4-4-应对负载的方法"><a href="#4-4-应对负载的方法" class="headerlink" title="4.4 应对负载的方法"></a>4.4 应对负载的方法</h5><ol>
<li><p>纵向扩展（scaling up）（垂直扩展（vertical scaling），转向更强大的机器）和横向扩展（scaling out） （水平扩展（horizontal scaling），将负载分布到多台小机器上）</p>
</li>
<li><p>跨多台机器分配负载也称为“无共享（shared-nothing）”架构。</p>
<ul>
<li>可以在单台机器上运行的系统通常更简单，但高端机器可能非常贵，所以非常密集的负载通常无法避免地需要横向扩展。现实世界中的优秀架构需要将这两种方法务实地结合，因为使用几台足够强大的机器可能比使用大量的小型虚拟机更简单也更便宜。</li>
</ul>
</li>
<li><p>弹性</p>
<ul>
<li>有些系统是 弹性（elastic） 的，这意味着可以在检测到负载增加时自动增加计算资源，而其他系统则是手动扩展（人工分析容量并决定向系统添加更多的机器）。如果负载极难预测（highly unpredictable），则弹性系统可能很有用，但手动扩展系统更简单，并且意外操作可能会更少</li>
</ul>
</li>
<li><p>数据库应该单节点（纵向扩展）</p>
<ul>
<li>跨多台机器部署无状态服务（stateless services）非常简单，但将带状态的数据系统从单节点变为分布式配置则可能引入许多额外复杂度。出于这个原因，常识告诉我们应该将数据库放在单个节点上（纵向扩展），直到扩展成本或可用性需求迫使其改为分布式。</li>
</ul>
</li>
</ol>
<h3 id="5-可维护性理解"><a href="#5-可维护性理解" class="headerlink" title="5. 可维护性理解"></a>5. 可维护性理解</h3><h5 id="5-1-软件系统的三个设计原则"><a href="#5-1-软件系统的三个设计原则" class="headerlink" title="5.1 软件系统的三个设计原则"></a>5.1 软件系统的三个设计原则</h5><ol>
<li><p>可操作性（Operability）</p>
<ul>
<li>便于运维团队保持系统平稳运行。</li>
</ul>
</li>
<li><p>简单性（Simplicity）</p>
<ul>
<li>从系统中消除尽可能多的复杂度（complexity），使新工程师也能轻松理解系统。（注意这和用户接口的简单性不一样。）</li>
</ul>
</li>
<li><p>可演化性（evolability）</p>
<ul>
<li>使工程师在未来能轻松地对系统进行更改，当需求变化时为新应用场景做适配。也称为可扩展性（extensibility），可修改性（modifiability）或可塑性（plasticity）。</li>
</ul>
</li>
</ol>
<h5 id="5-2-可操作性：人生苦短，关爱运维"><a href="#5-2-可操作性：人生苦短，关爱运维" class="headerlink" title="5.2 可操作性：人生苦短，关爱运维"></a>5.2 可操作性：人生苦短，关爱运维</h5><ol>
<li><p>一个优秀运维团队的典型职责如下（或者更多）</p>
<ul>
<li>监控系统的运行状况，并在服务状态不佳时快速恢复服务</li>
<li>跟踪问题的原因，例如系统故障或性能下降</li>
<li>及时更新软件和平台，比如安全补丁</li>
<li>了解系统间的相互作用，以便在异常变更造成损失前进行规避。</li>
<li>预测未来的问题，并在问题出现之前加以解决（例如，容量规划）</li>
<li>建立部署，配置、管理方面的良好实践，编写相应工具</li>
<li>执行复杂的维护任务，例如将应用程序从一个平台迁移到另一个平台</li>
<li>当配置变更时，维持系统的安全性</li>
<li>定义工作流程，使运维操作可预测，并保持生产环境稳定。</li>
<li>铁打的营盘流水的兵，维持组织对系统的了解。</li>
</ul>
</li>
<li><p>良好的可操作性意味着更轻松的日常工作，进而运维团队能专注于高价值的事情。数据系统可以通过各种方式使日常任务更轻松：</p>
<ul>
<li>通过良好的监控，提供对系统内部状态和运行时行为的可见性（visibility）</li>
<li>为自动化提供良好支持，将系统与标准化工具相集成</li>
<li>避免依赖单台机器（在整个系统继续不间断运行的情况下允许机器停机维护）</li>
<li>提供良好的文档和易于理解的操作模型（“如果做X，会发生Y”）</li>
<li>提供良好的默认行为，但需要时也允许管理员自由覆盖默认值</li>
<li>有条件时进行自我修复，但需要时也允许管理员手动控制系统状态</li>
<li>行为可预测，最大限度减少意外</li>
</ul>
</li>
</ol>
<h5 id="5-3-简单性：管理复杂度"><a href="#5-3-简单性：管理复杂度" class="headerlink" title="5.3 简单性：管理复杂度"></a>5.3 简单性：管理复杂度</h5><ol>
<li><p>复杂度（complexity） 有各种可能的症状</p>
<ul>
<li>状态空间激增</li>
<li>模块间紧密耦合</li>
<li>纠结的依赖关系</li>
<li>不一致的命名和术语</li>
<li>解决性能问题的Hack</li>
<li>需要绕开的特例等等</li>
</ul>
</li>
<li><p>用于消除额外复杂度的最好工具之一是抽象（abstraction）</p>
<ul>
<li>一个好的抽象可以将大量实现细节隐藏在一个干净，简单易懂的外观下面。</li>
<li>一个好的抽象也可以广泛用于各类不同应用。</li>
<li>比起重复造很多轮子，重用抽象不仅更有效率，而且有助于开发高质量的软件。</li>
<li>例如，高级编程语言是一种抽象，隐藏了机器码、CPU寄存器和系统调用。 SQL也是一种抽象，隐藏了复杂的磁盘/内存数据结构、来自其他客户端的并发请求、崩溃后的不一致性。</li>
<li>抽象可以帮助我们将系统的复杂度控制在可管理的水平，不过，找到好的抽象是非常困难的。在分布式系统领域虽然有许多好的算法，但我们并不清楚它们应该打包成什么样抽象。</li>
</ul>
</li>
</ol>
<h5 id="5-4-可演化性：拥抱变化"><a href="#5-4-可演化性：拥抱变化" class="headerlink" title="5.4 可演化性：拥抱变化"></a>5.4 可演化性：拥抱变化</h5><ol>
<li>敏捷<ul>
<li>在组织流程方面， 敏捷（agile） 工作模式为适应变化提供了一个框架。敏捷社区还开发了对在频繁变化的环境中开发软件很有帮助的技术工具和模式，如 测试驱动开发（TDD, test-driven development） 和 重构（refactoring） 。</li>
<li>这些敏捷技术的大部分讨论都集中在相当小的规模（同一个应用中的几个代码文件）。更大数据系统层面上提高敏捷性的方法，可能由几个不同的应用或服务组成。</li>
<li>数据系统层面的敏捷性： 可演化性（evolvability）</li>
</ul>
</li>
</ol>
<h1 id="第二章-数据模型与查询语言"><a href="#第二章-数据模型与查询语言" class="headerlink" title="第二章 数据模型与查询语言"></a>第二章 数据模型与查询语言</h1><p>几种查询语言需要再总结一下吗？数据模型就是当前数据库类型，对数据的存储模型，当前主流是关系型、图形数据库、文档数据库，对关系型了解，另两种都是什么？有什么具体的例子和应用场景。</p>
<h1 id="第三章存储与检索"><a href="#第三章存储与检索" class="headerlink" title="第三章存储与检索"></a>第三章存储与检索</h1><p>数据如何存储，如何新追加，各数据库引擎如何设计的。几种索引方式，什么是B树，LSM树，还有其他索引方式。</p>
<h1 id="第四章编码与演化"><a href="#第四章编码与演化" class="headerlink" title="第四章编码与演化"></a>第四章编码与演化</h1><p>讲了数据结构转换为网络中的字节或磁盘上的字节的几种方法。提到了protobuf和thrift、rest api和rpc。</p>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
  </entry>
  <entry>
    <title>一个简单的web聊天室</title>
    <url>/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84web%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li>一个简陋的web聊天室需要什么</li>
</ol>
<a id="more"></a>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol>
<li>用户</li>
<li>消息</li>
</ol>
<h3 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h3><ol>
<li>分发消息，创建并监听一个消息队列，如果有消息了就读出来，发送给所有Client.</li>
<li>内存存储client列表，发消息了就写入消息队列。</li>
<li>使用了websocket连接表示用户</li>
</ol>
<h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><ol>
<li>Vue</li>
<li>两个组件，一个显示消息，一个输入发送框</li>
</ol>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>服务端</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是RAII</title>
    <url>/%E4%BB%80%E4%B9%88%E6%98%AFRAII/</url>
    <content><![CDATA[<h1 id="什么是RAII"><a href="#什么是RAII" class="headerlink" title="什么是RAII"></a>什么是RAII</h1><ul>
<li>其他博客中很多写的是“RAII是Resource Acquisition Is Initialization的简称，是C++语言的一种管理资源、避免泄漏的惯用法。”，如果理解什么是RAII后再看这句话就很容易懂，但如果什么都不懂，直接看这一句应该是看不懂的。</li>
<li>我的直白的理解就是，一种编程规范，或者一种编程技巧，不是具体的语法之类的，就是和设计模式一样，是一种技巧。<a id="more"></a>

</li>
</ul>
<h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><ul>
<li>下面解释定义：一种资源管理、避免泄露的惯用法<ul>
<li>比如使用一个指针后，在不使用的时候要将它释放，但是有时候可能会忘记释放指针，就会造成内存泄露，如下面的例子，如果不调用delete s，就会造成s占用的资源一直不释放，直到程序死亡。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">	Studen* s&#x3D;new Student();</span><br><span class="line">	&#x2F;&#x2F;其他处理代码</span><br><span class="line">	delete s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用RAII机制，就是自定义管理，将要管理的东西疯转成对象，在对象的作用域结束的时候，调用对象的析构函数，自动释放资源，就不用程序员自己释放，简单来说就是这样。</li>
<li>为了方便，就直接使用C++11的share_prt做例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">	shared_ptr&lt;Studen&gt; s &#x3D;make_share&lt;Studen&gt; ();</span><br><span class="line">	&#x2F;&#x2F;其他处理代码</span><br><span class="line">	&#x2F;&#x2F; delete s; 不需要这一句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这只是简单的了解RAII，RAII还有一些坑，这些不想整理了，看看其他的博客吧。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>RAII</tag>
      </tags>
  </entry>
  <entry>
    <title>信号执行过程中又收到信号</title>
    <url>/%E4%BF%A1%E5%8F%B7%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%88%E6%94%B6%E5%88%B0%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>若signal安装了信号响应函数后，若连续发两次该信号，即第一个信号的函数还没执行完的时候，又收到了这个信号，会怎么处理？<br>答案：会等第一个函数执行完，再执行第二遍这个函数。</p>
<a id="more"></a>
<p>验证如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">void hander(int sig)&#123;</span><br><span class="line">    printf(&quot;收到了 %d 信号\n&quot;,sig);</span><br><span class="line">    sleep(5);</span><br><span class="line">    printf(&quot;hander继续执行了\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    if(signal(SIGUSR1,hander)&#x3D;&#x3D;SIG_ERR)&#123;</span><br><span class="line">        perror(&quot;error\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int i&#x3D;0;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,i);</span><br><span class="line">        pause();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/%E4%BF%A1%E5%8F%B7%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%88%E6%94%B6%E5%88%B0%E4%BF%A1%E5%8F%B7/%E5%8F%91%E9%80%81%E4%B8%A4%E6%AC%A1%E4%BF%A1%E5%8F%B7%E9%AA%8C%E8%AF%81.jpeg" class="" title="发送两次信号验证">]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>linux</tag>
        <tag>信号</tag>
      </tags>
  </entry>
  <entry>
    <title>关于网络劫持</title>
    <url>/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E5%8A%AB%E6%8C%81/</url>
    <content><![CDATA[<p>DNS与HTTP劫持：<a href="https://juejin.im/post/6844903817503309838">链接</a></p>
<p>Websocket劫持：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665515571&idx=1&sn=0d0b7dea7f77e8f1844b366f1af9667f&chksm=80d67270b7a1fb66d93bae6cb36eabb52671ca9c4fcfcbd4b99a0f97477ea3d7f7ef87f086f3&token=1745763505&lang=zh_CN#rd">链接</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>HTTP</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>几个系统衡量指标</title>
    <url>/%E5%87%A0%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ol>
<li><p>系统吞吐量</p>
<ul>
<li><p>一个系统的吞度量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。</p>
</li>
<li><p>单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。</p>
</li>
<li><p>系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间</p>
<a id="more"></a></li>
<li><p>一个系统吞吐量通常由QPS（TPS）、并发数两个因素决定，每套系统这两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统的吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换、内存等等其它消耗导致系统性能下降。</p>
</li>
<li><p>系统吞吐量评估</p>
<ul>
<li><p>通常境况下，我们面对需求，我们评估出来的出来QPS、并发数之外，还有另外一个维度：日PV。（通过访问日志计算pv）</p>
</li>
<li><p>找出系统的最高TPS和日PV，这两个要素有相对比较稳定的关系（除了放假、季节性因素影响之外）</p>
</li>
<li><p>通过压力测试或者经验预估，得出最高TPS，然后跟进1的关系，计算出系统最高的日吞吐量。</p>
<!-- ![image-20200913103048570](/Users/dxm/Documents/公司记录/学习笔记img/淘宝pv-qps图.png) -->
<img src="/%E5%87%A0%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87/%E6%B7%98%E5%AE%9Dpv-qps%E5%9B%BE.png" class="" title="淘宝pv-qps图.png"></li>
</ul>
</li>
<li><p>吞吐量的计算公式</p>
<ul>
<li>指单位时间内系统处理用户的请求数</li>
<li>从业务角度看，吞吐量可以用：请求数/秒、页面数/秒、人数/天或处理业务数/小时等单位来衡量</li>
<li>从网络角度看，吞吐量可以用：字节/秒来衡量</li>
<li>对于交互式应用来说，吞吐量指标反映的是服务器承受的压力，他能够说明系统的负载能力以不同方式表达的吞吐量可以说明不同层次的问题，例如，以字节数/秒方式可以表示数要受网络基础设施、服务器架构、应用服务器制约等方面的瓶颈；已请求数/秒的方式表示主要是受应用服务器和应用代码的制约体现出的瓶颈。</li>
<li>当没有遇到性能瓶颈的时候，吞吐量与虚拟用户数之间存在一定的联系，可以采用以下公式计算：F=VU * R 。其中F为吞吐量，VU表示虚拟用户个数，R表示每个虚拟用户发出的请求数，T表示性能测试所用的时间</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>QPS（TPS）</p>
<ul>
<li>每秒钟request/事务 数量</li>
<li>QPS（TPS）= 并发数/平均响应时间</li>
</ul>
</li>
<li><p>并发数</p>
</li>
</ol>
<ul>
<li>系统同时处理的request/事务数</li>
</ul>
<ol start="4">
<li><p>响应时间</p>
<ul>
<li>一般取平均响应时间</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>服务端</tag>
      </tags>
  </entry>
  <entry>
    <title>右值引用的一些理解</title>
    <url>/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<ol>
<li>右值引用之前看过不少次了,但过一段时间就忘了,,,这里简单整理一下我的理解</li>
<li>右值引用主要用来实现 移动语义 和 完美转发</li>
</ol>
<h4 id="1-移动语义"><a href="#1-移动语义" class="headerlink" title="1. 移动语义"></a>1. 移动语义</h4><ol>
<li>使用上可以用std::move() ,把参数强制转换成右值</li>
<li>我理解就是和浅拷贝很像,不过浅拷贝是多个指针指向堆上的空间,可能会重复释放从而出错,而移动语义是只有一个指针占有堆上的空间,移动后源指针就置空了.如果没有堆上的空间,那移动语义和浅拷贝就没什么区别</li>
</ol>
<h4 id="2-完美转发"><a href="#2-完美转发" class="headerlink" title="2. 完美转发"></a>2. 完美转发</h4><ol>
<li>这个是在模板中,结合折叠原则使用,实现”在函数模板中，完全按照模板参数的类型将参数传递给模板函数中调用的另一个函数，并且不产生额外开销。”</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>工程师文化瞎扯</title>
    <url>/%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E5%8C%96%E7%9E%8E%E6%89%AF/</url>
    <content><![CDATA[<h3 id="身为一个工程师如何快速在新团队落地"><a href="#身为一个工程师如何快速在新团队落地" class="headerlink" title="身为一个工程师如何快速在新团队落地"></a>身为一个工程师如何快速在新团队落地</h3><ol>
<li>熟悉业务<ul>
<li>了解产品流程</li>
</ul>
</li>
<li>熟悉技术<ul>
<li>了解系统架构，代码结构，使用的平台，技术栈</li>
</ul>
</li>
<li>熟悉人<ul>
<li>了解组织结构</li>
</ul>
</li>
</ol>
<a id="more"></a>

<h3 id="学会解决问题"><a href="#学会解决问题" class="headerlink" title="学会解决问题"></a>学会解决问题</h3><ol>
<li>提出问题、定义问题、分析问题、解决问题、展望未来</li>
</ol>
<h3 id="优秀工程师必备的一项技能"><a href="#优秀工程师必备的一项技能" class="headerlink" title="优秀工程师必备的一项技能"></a>优秀工程师必备的一项技能</h3><ol>
<li>思考力</li>
</ol>
<h3 id="如何在工作中快速成长："><a href="#如何在工作中快速成长：" class="headerlink" title="如何在工作中快速成长："></a>如何在工作中快速成长：</h3><ol>
<li>思考脑 vs 反射脑。通过大量的逻辑反复训练，形成直觉反射。</li>
<li>时间管理。找到不被打扰的时间用于投资自己的成长。</li>
<li>提升注意力。所谓提升注意力就是专注在目标事务上，直到产出预期的结果 一旦消费者占领了大脑，也就控制了我们日常的思考和行为。</li>
<li>执行力。执行力就是想明白，然后一步一步做下去。</li>
<li>贵人。贵人就是可以持续陪你输出高质量的人。</li>
<li>跳出舒适区。跳出舒适区就是进入学习区，平衡挑战和技能从而达到心流体验。当你不舒服时，难受或陷于困境时，应该停下来思考 困境是个人成长的最好机会，放弃、逃避、拒绝思考，就意味着放弃成长。如果 遇到困境不自知，不解决，则会出现昨日所不知不能者，今日仍是不知不能；去年所不知不能者，今年仍是不知不能</li>
<li>会议。参与会议讨论就是在模拟机器学习，通过正反馈来优化自己的逻辑和观点。</li>
<li>职业规划。所谓职业规划，就是工作能力提升。</li>
<li>时间换空间。所谓时间换空间，就是慢慢来，持之以恒，成长最快。</li>
</ol>
<h3 id="从计算机知识到落地能力，你欠缺了什么。"><a href="#从计算机知识到落地能力，你欠缺了什么。" class="headerlink" title="从计算机知识到落地能力，你欠缺了什么。"></a>从计算机知识到落地能力，你欠缺了什么。</h3><ol>
<li>夯实基础，越是几十年不变的基础，越是有值得深究的意义。</li>
</ol>
<h3 id="责任与使命"><a href="#责任与使命" class="headerlink" title="责任与使命"></a>责任与使命</h3><ol>
<li>要有团队使命，要为结果负责，为过程买单。一个喜欢推脱责任的领导，是阻碍团队发展的最大毒瘤。</li>
</ol>
<h3 id="及时自我总结"><a href="#及时自我总结" class="headerlink" title="及时自我总结"></a>及时自我总结</h3><ol>
<li>需求迭代的同时，兼顾问题的复盘，总结，归纳，团队内分享。避免下次出现相同类似问题。</li>
<li>是否由小到大，见微知著。从需求出发，是否理解某一块业务，理顺上下游关系。</li>
<li>通过一块业务，是否充分理解相关技术框架/基础组建的用法。</li>
<li>整个项目构建，设计上，有哪些做的不好的地方？能否提出合理的改进意见或者推动改进？</li>
<li>团队上：进度安排，沟通协调是否存在不足？</li>
</ol>
]]></content>
      <categories>
        <category>乱侃</category>
      </categories>
  </entry>
  <entry>
    <title>微服务架构演变</title>
    <url>/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/</url>
    <content><![CDATA[<h3 id="架构演变"><a href="#架构演变" class="headerlink" title="架构演变"></a>架构演变</h3><ol>
<li><p>单体架构</p>
<ul>
<li>单体架构：所有功能模块都放在一起。</li>
<li>优点：架构简单，适用于小型项目。</li>
<li>缺点：难以维护。系统故障时所有团队都要关注；无法做到故障隔离；不好扩容，因为扩容意味着所有模块都要部署一遍。<a id="more"></a>
</li>
</ul>
</li>
<li><p>垂直架构，模块化，负载均衡</p>
<ul>
<li>垂直架构：以项目/业务为单位，将单体架构中的大项目拆成多个小项目/业务。</li>
<li>优点：与单体架构相比，可以解决扩容等维护问题。</li>
<li>缺点：不同项目/业务中通用的功能无法复用。</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>SOA架构，服务管理，RPC技术</p>
<ul>
<li>SOA（带ESB总线的SOA实现）：将重复公用的功能抽取为组件，以服务的方式给各各系统提供服务。ESB 全称为 Enterprise Service Bus，即企业服务总线。所有的企业服务都挂接到该总线上对外公布。企业服务总线负责管理服务目录，解析服务请求者的请求方法、消息格式，并对服务提供者进行寻址，转发服务请求。</li>
<li>优点：功能可以复用。</li>
<li>缺点：粒度较粗，服务与ESB的耦合较紧密。</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>微服务架构，自治</p>
<ul>
<li>微服务是去 ESB 的 SOA。与带 ESB 总线的 SOA 实现相比，微服务粒度更细、去中心化更彻底。</li>
<li>微服务和SOA的区别：<a href="https://zhuanlan.zhihu.com/p/26713286">https://zhuanlan.zhihu.com/p/26713286</a></li>
</ul>
</li>
</ol>
<h3 id="SOA和微服务的区别"><a href="#SOA和微服务的区别" class="headerlink" title="SOA和微服务的区别"></a>SOA和微服务的区别</h3><ol>
<li>SOA本来就是为了解耦，去中心化，但是按照SOA的思路，这些系统总会在某个环节上走向集中，去中心化做的不彻底。</li>
<li>一开始大家都用ESB，这是通过一个总线来实现服务编排。但是这样的话系统在开发阶段就走向集中了，服务模块中没有业务，所有的业务逻辑都在ESB中通过BPEL来组装。组装好的流程再交给Struts等Server端MVC框架调用。</li>
<li>使用SOA ESB的时候，存在一个流程编排的Team来掌握所有业务行为，这群人需要具备架构设计、流程分析、系统分析的能力，所以他们很贵，人数也很少，但是所有业务变化都跟他们有关系，所以他们很容易变成最大的组织瓶颈。</li>
<li>后来不用ESB了，大家各自搞自己的，开发SCA服务就行了，业务行为往前推，放到Struts Controller里去。但是这样的系统还是会在打包环境走向集中，打出一个巨大的EAR包。</li>
<li>打成一个包部署也不方便，后来大家就想拆成多个WAR或者EAR，各搞各的，需要集成的时候我们就走SOAP吧。但是DB还是集中的。</li>
<li>把DB也拆开，就彻底去中心化了。但是要支撑这种做法，你需要做很多技术准备，这套东西做完了，也就搞出一套微服务了。</li>
</ol>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>服务端</tag>
      </tags>
  </entry>
  <entry>
    <title>惊群效应</title>
    <url>/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/</url>
    <content><![CDATA[<h3 id="惊群效应"><a href="#惊群效应" class="headerlink" title="惊群效应"></a>惊群效应</h3><pre><code>- 多个空闲线程监听一个fd，当连接到来的时候，多个线程同时调用，但只有一个获得fd，其他线程白忙活，白白浪费资源。</code></pre>
<a id="more"></a>

<ol>
<li><p>出现的场景</p>
<ul>
<li>Linux2.6内核版本之前系统API中的accept调用</li>
<li>epoll函数中的惊群问题</li>
<li>线程池中的惊群问题</li>
</ul>
</li>
<li><p>解决办法</p>
<ul>
<li>对于epll函数调用的惊群问题解决办法可以参考Nginx的解决办法，多个进程将listenfd加入到epoll之前，首先尝试获取一个全局的accept_mutex互斥锁，只有获得该锁的进程才可以把listenfd加入到epoll中，当网络连接事件到来时，只有epoll中含有listenfd的线程才会被唤醒并处理网络连接事件。从而解决了epoll调用中的惊群问题。</li>
<li>对于线程池中的惊群问题，我们需要分情况看待，有时候业务需求就是需要唤醒所有线程，那么这时候使用notify_all()唤醒所有线程就不能称为”惊群问题“，因为CPU并没有无谓消耗。而对于只需要唤醒一个线程的情况，我们需要使用notify_one()函数代替notify_all()只唤醒一个线程，从而避免惊群问题。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>服务端</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库锁与MVCC</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E4%B8%8EMVCC/</url>
    <content><![CDATA[<h3 id="数据库四个问题"><a href="#数据库四个问题" class="headerlink" title="数据库四个问题"></a>数据库四个问题</h3><ol>
<li>数据丢失<ul>
<li>不加锁<a id="more"></a></li>
</ul>
</li>
<li>脏读<ul>
<li>脏读/脏数据，读数据的时候不用加锁，但是读到数据后，另一个修改这个数据的进程回滚了，于是现在读到的数据就和真实数据不符合。</li>
<li>使用共享锁解决</li>
</ul>
</li>
<li>重复读<ul>
<li>在一个事务中要多次读取某个数据，但是如果期间释放了共享锁，这个数据被其他人修改了，第二次重复读的时候就会和第一次不一样。解决办法就是事务执行期间一直不释放共享锁，直到事务提交。</li>
</ul>
</li>
<li>幻读<ul>
<li>一个人修改了一批数据，比如把所有年龄18岁的都修改成19岁，修改完一看，还有一个18岁的，好像没有修改。实际是修改的同时，另一个人插入了一个18岁的记录。导致好像是这个18岁的没有修改。</li>
<li>串行化解决，就是我修改完，你才能插入。</li>
</ul>
</li>
</ol>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h5 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h5><ul>
<li>就普通的锁</li>
</ul>
<ol>
<li>记录锁，又叫行锁，对某行数据操作的时候上锁。</li>
<li>间隙锁，事务加锁后锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。<ul>
<li>间隙锁作用？防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生如下图的问题，在同一个事务里，A事务的两次查询出的结果会不一样。<img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E4%B8%8EMVCC/%E9%97%B4%E9%9A%99%E9%94%81%E4%BD%9C%E7%94%A8.png" class="" title="间隙锁作用.png"></li>
<li>间隙锁出现的条件：范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复读)的事务级别中。</li>
</ul>
</li>
</ol>
<h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><ul>
<li>旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区，线程尝试获取锁的过程不会阻塞；但不适应于单核场景。好处就是不用上下文切换，坏处是如果持有锁时间太长，其他线程一直自旋浪费CPU。适用于执行速度快，频繁切换的场景。</li>
</ul>
<h5 id="共享锁-读写锁"><a href="#共享锁-读写锁" class="headerlink" title="共享锁/读写锁"></a>共享锁/读写锁</h5><ul>
<li>读共享，写独占</li>
<li>当读数据的时候加一个共享锁，如果有读数据就+1，有共享锁就不能有排它锁，这样解决了脏读的问题。</li>
</ul>
<h5 id="Innodb引擎特有锁"><a href="#Innodb引擎特有锁" class="headerlink" title="Innodb引擎特有锁"></a>Innodb引擎特有锁</h5><ol>
<li><p>临键锁</p>
<ul>
<li>临键锁是INNODB的行锁默认算法，它是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。</li>
<li>临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插入。</li>
<li>间隙锁和临键锁的区别：<ul>
<li>间隙锁在根据索引范围查找失败的时候才锁，而且只锁一个区间。</li>
<li>临键锁是查找成功也锁，把找到的数据和他们的间隙都锁上。</li>
</ul>
</li>
</ul>
</li>
<li><p>行锁：当SQL命中索引的时候才加行锁。</p>
</li>
<li><p>表锁：其他时候都是加表锁。</p>
</li>
<li><p>意向锁：</p>
<ul>
<li>意向共享锁：当一个事务试图对整个表进行加共享锁之前，首先需要获得这个表的意向共享锁。</li>
<li>意向排它锁：当一个事务试图对整个表进行加排它锁之前，首先需要获得这个表的意向排它锁。</li>
</ul>
</li>
<li><p>为什么我们需要意向锁？</p>
<ul>
<li>innodb加锁的方式是基于索引，并且加锁粒度是行锁。</li>
<li>在事务A的操作过程中，后面的每个需要对表加持表锁的事务都需要遍历整个索引树才能知道自己是否能够进行加锁，太浪费时间和损耗数据库性能了</li>
<li>所以INNODB就加了意向锁的概念：如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁了，你们不能对整个表加共享锁或排它锁了，那么后面需要对整个表加锁的人只需要获取这个状态就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁.</li>
</ul>
</li>
</ol>
<h3 id="数据库多版本并发控制（MVCC）"><a href="#数据库多版本并发控制（MVCC）" class="headerlink" title="数据库多版本并发控制（MVCC）"></a>数据库多版本并发控制（MVCC）</h3><ol>
<li>使用锁进行串行化处理虽然解决了一系列问题，但是效率太低，而且无法避免死锁。</li>
<li>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读</li>
<li>MVCC给每个事务一个事务id，和回滚指针。有一个Read View数据结构，记录当前所有活跃事务和活跃事务中的最大事务id和最小事务id。</li>
<li>在读数据的时候，这个事务有个单独的id，重复读的时候再找这个事务id对应的 数据就行了。</li>
<li>写数据的时候是一个新的事务id。</li>
<li>这样在读写的时候就不用互相加锁了，提高读写效率。</li>
</ol>
<h3 id="乐观并发控制（OCC）"><a href="#乐观并发控制（OCC）" class="headerlink" title="乐观并发控制（OCC）"></a>乐观并发控制（OCC）</h3><ol>
<li>乐观并发控制（OCC）是一种用来解决写-写冲突的无锁并发控制，认为事务间争用没有那么多，所以先进行修改，在提交事务前，检查一下事务开始后，有没有新提交改变，如果没有就提交，如果有就放弃并重试。乐观并发控制类似自选锁。乐观并发控制适用于低数据争用，写冲突比较少的环境。</li>
</ol>
<h3 id="Undo日志："><a href="#Undo日志：" class="headerlink" title="Undo日志："></a>Undo日志：</h3><ol>
<li>记录事务执行前的数据，如果事务执行一半需要回滚，就直接回到最初的数据状态。</li>
<li>Undo日志的写入规则：有个缓冲区，隔一段时间写入硬盘，回滚的时候就看undo日志，如果事务提交了，就不用回滚，否则说明事务没执行完就中断了，直接回滚。</li>
<li>Undo日志的写入次序，一定要在相关的数据项写入之前。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>锁</tag>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>服务注册与发现consul笔记</title>
    <url>/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0consul%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><ol>
<li>微服务中使用的服务注册发现中心</li>
<li>同类有etcd、eureka等<a id="more"></a>

</li>
</ol>
<h3 id="2-简单使用"><a href="#2-简单使用" class="headerlink" title="2. 简单使用"></a>2. 简单使用</h3><ol>
<li>在docker中运行</li>
</ol>
<ul>
<li>在后台运行，要重新进入的话：docker exec -it fe693be00668 /bin/sh  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name&#x3D;consultest -p 8500:8500 consul:latest agent -server -bootstrap -ui -client 0.0.0.0</span><br></pre></td></tr></table></figure>
<ul>
<li>-server表示以服务端的方式启动</li>
<li>-bootstrap表示指定自己为leader，而不需要选举</li>
<li>-ui启动一个内置管理web页面</li>
<li>-client指定客户端可以访问的ip，默认只能本地访问，设置0.0.0.0可以任意访问。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>手动注册服务</li>
</ol>
<ul>
<li>consul services register -name=web 创建一个默认的没啥用的服务</li>
<li>使用json文件制定服务：consul services register web.json  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Service&quot;: &#123;</span><br><span class="line">      &quot;ID&quot;:&quot;userservice&quot;,</span><br><span class="line">      &quot;Name&quot;:&quot;userservice&quot;,</span><br><span class="line">      &quot;Tag&quot;:[</span><br><span class="line">              &quot;primary&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;Address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">      &quot;Port&quot;:8999,</span><br><span class="line">      &quot;Check&quot;:&#123;</span><br><span class="line">              &quot;HTTP&quot;:&quot;http:&#x2F;&#x2F;127.0.0.1:8999&#x2F;health&quot;,</span><br><span class="line">              &quot;Interval&quot;:&quot;5s&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>删除注册</li>
</ol>
<ul>
<li>consul services deregister -id=web 根据id</li>
<li>consul services deregister web.json 根据json配置文件</li>
</ul>
<h3 id="go操作consul"><a href="#go操作consul" class="headerlink" title="go操作consul"></a>go操作consul</h3><h5 id="1-注册服务与取消注册"><a href="#1-注册服务与取消注册" class="headerlink" title="1. 注册服务与取消注册"></a>1. 注册服务与取消注册</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import (</span><br><span class="line">  consulapi &quot;github.com&#x2F;hashicorp&#x2F;consul&#x2F;api&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">  ConsulClient *consulapi.Client</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init()  &#123;</span><br><span class="line">  config:&#x3D;consulapi.DefaultConfig()</span><br><span class="line">  config.Address&#x3D;&quot;172.30.20.16:8500&quot;</span><br><span class="line">  client,err:&#x3D;consulapi.NewClient(config)</span><br><span class="line">  if err!&#x3D;nil&#123;</span><br><span class="line">    panic(err)</span><br><span class="line">  &#125;</span><br><span class="line">  ConsulClient&#x3D;client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RegService()  &#123;</span><br><span class="line"></span><br><span class="line">  reg:&#x3D;consulapi.AgentServiceRegistration&#123;&#125;</span><br><span class="line">  reg.ID&#x3D;&quot;userservice&quot;</span><br><span class="line">  reg.Name&#x3D;&quot;userservice&quot;</span><br><span class="line">  reg.Address&#x3D;&quot;172.30.20.16&quot;</span><br><span class="line">  reg.Port&#x3D;8999</span><br><span class="line">  reg.Tags&#x3D;[]string&#123;&quot;primary&quot;&#125;</span><br><span class="line"></span><br><span class="line">  check:&#x3D;consulapi.AgentServiceCheck&#123;&#125;</span><br><span class="line">  check.Interval&#x3D;&quot;5s&quot;</span><br><span class="line">  check.HTTP&#x3D;&quot;http:&#x2F;&#x2F;172.30.20.16:8999&#x2F;health&quot;</span><br><span class="line"></span><br><span class="line">  reg.Check&#x3D;&amp;check</span><br><span class="line"></span><br><span class="line">  err:&#x3D;ConsulClient.Agent().ServiceRegister(&amp;reg)</span><br><span class="line">  if err!&#x3D;nil&#123;</span><br><span class="line">    panic(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Unregister(serviceID string)  &#123;</span><br><span class="line">  ConsulClient.Agent().ServiceDeregister(serviceID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-获得consul服务信息"><a href="#2-获得consul服务信息" class="headerlink" title="2. 获得consul服务信息"></a>2. 获得consul服务信息</h5><ol>
<li>使用consul客户端的api来操作</li>
</ol>
<h3 id="3-设置负载均衡"><a href="#3-设置负载均衡" class="headerlink" title="3. 设置负载均衡"></a>3. 设置负载均衡</h3><ol>
<li>轮询</li>
<li>随机<ul>
<li>通过修改lb包下random.go的源码</li>
</ul>
</li>
</ol>
<h3 id="4-api限流"><a href="#4-api限流" class="headerlink" title="4. api限流"></a>4. api限流</h3><h5 id="1-限流作用"><a href="#1-限流作用" class="headerlink" title="1. 限流作用"></a>1. 限流作用</h5><pre><code>- 对某一时间窗口内的请求数进行限制，保持系统的可用性和稳定性，防止因流量暴增而导致的系统运行缓慢或宕机。
- 功能性，比如限制用户访问次数，10s只能访问一次，冲会员可以多访问。</code></pre>
<h5 id="2-限流常用算法"><a href="#2-限流常用算法" class="headerlink" title="2. 限流常用算法"></a>2. 限流常用算法</h5><ol>
<li><p>漏桶</p>
<ul>
<li>漏桶生成令牌的速度恒定，出桶的速度也是恒定的，意味着如果瞬间有大量请求过来，则大部分会被丢弃。</li>
<li>令牌桶生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。</li>
</ul>
</li>
<li><p>令牌桶</p>
 <!-- ![img](/Users/dxm/Documents/公司记录/学习笔记img/令牌桶算法.png) -->
 <img src="/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0consul%E7%AC%94%E8%AE%B0/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95.png" class="" title="令牌桶算法.png">
<ul>
<li>以恒定的速度生成token</li>
<li>请求先拿token，拿到后才能进行业务处理，否则阻塞等待</li>
<li>token没有标识用户信息的意义，只是当做令牌</li>
</ul>
</li>
</ol>
<h5 id="3-令牌桶：go有个内置的限流包rate"><a href="#3-令牌桶：go有个内置的限流包rate" class="headerlink" title="3. 令牌桶：go有个内置的限流包rate"></a>3. 令牌桶：go有个内置的限流包rate</h5><ol start="0">
<li><p>rate.NewLimiter(1,5)创建一个容量为5，没1s生成一个token的桶</p>
</li>
<li><p>Wait/WaitN</p>
<ul>
<li>这个N指的是每次消耗几个token，令牌不够就阻塞等待</li>
</ul>
</li>
<li><p>Allow/AllowN</p>
<ul>
<li>不阻塞，令牌不够返回false，继续执行</li>
</ul>
</li>
<li><p>Reserve/ReserveN</p>
<ul>
<li>这个N指的是每次消耗几个token</li>
</ul>
</li>
<li><p>使用方式</p>
<ul>
<li>对请求处理前判断一下，如果拿到令牌就执行</li>
</ul>
</li>
</ol>
<h3 id="5-熔断"><a href="#5-熔断" class="headerlink" title="5. 熔断"></a>5. 熔断</h3><h5 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1. 介绍"></a>1. 介绍</h5><ol>
<li>本质是：隔离远程服务请求，防止级联故障。出现错误能让服务继续运行，防止崩溃。</li>
</ol>
<h5 id="2-处理库：hystrix-go"><a href="#2-处理库：hystrix-go" class="headerlink" title="2. 处理库：hystrix-go"></a>2. 处理库：hystrix-go</h5><ol>
<li>地址：<a href="https://github.com/afex/hystrix-go">https://github.com/afex/hystrix-go</a></li>
<li>可以对执行函数进行监控和错误处理，比如超时了怎么处理</li>
<li>可以同步处理错误，也可以异步处理（需要使用通道）</li>
<li>可以限制的参数：<ul>
<li>超时</li>
<li>并发数</li>
</ul>
</li>
</ol>
<h5 id="3-服务降级"><a href="#3-服务降级" class="headerlink" title="3. 服务降级"></a>3. 服务降级</h5><ol>
<li>如超时降级，就是利用hystrix-go检测到超时后，错误处理中进行其他默认处理。</li>
</ol>
<h5 id="4-熔断器"><a href="#4-熔断器" class="headerlink" title="4. 熔断器"></a>4. 熔断器</h5><ol>
<li><p>可以设置错误比例，比如超时超过10%，才打开熔断器进行出错服务降级等操作。</p>
 <!-- ![image-20200913113255085](/Users/dxm/Documents/公司记录/学习笔记img/熔断器部署位置.png) -->
 <img src="/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0consul%E7%AC%94%E8%AE%B0/%E7%86%94%E6%96%AD%E5%99%A8%E9%83%A8%E7%BD%B2%E4%BD%8D%E7%BD%AE.png" class="" title="熔断器部署位置.png">


</li>
</ol>
<h3 id="6-JWT"><a href="#6-JWT" class="headerlink" title="6. JWT"></a>6. JWT</h3><h5 id="0-go操作JWT"><a href="#0-go操作JWT" class="headerlink" title="0. go操作JWT"></a>0. go操作JWT</h5><ol>
<li>库地址：github.com/dgrijalva/jwt-go</li>
</ol>
<h5 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1. 介绍"></a>1. 介绍</h5><ol>
<li>JSON WEB TOKEN</li>
<li>是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</li>
</ol>
<h5 id="2-传统的session认证"><a href="#2-传统的session认证" class="headerlink" title="2. 传统的session认证"></a>2. 传统的session认证</h5><ol>
<li>在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。</li>
<li>但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来.</li>
<li>基于session认证所显露的问题<ul>
<li>Session: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</li>
<li>扩展性: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</li>
<li>CSRF: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</li>
</ul>
</li>
</ol>
<h5 id="3-基于token的鉴权机制"><a href="#3-基于token的鉴权机制" class="headerlink" title="3. 基于token的鉴权机制"></a>3. 基于token的鉴权机制</h5><ol>
<li><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
</li>
<li><p>流程</p>
<ul>
<li><p>用户使用用户名密码来请求服务器</p>
</li>
<li><p>服务器进行验证用户的信息</p>
</li>
<li><p>服务器通过验证发送给用户一个token</p>
</li>
<li><p>客户端存储token，并在每次请求时附送上这个token值</p>
</li>
<li><p>服务端验证token值，并返回数据</p>
  <!-- ![image-20200913233659997](/Users/dxm/Documents/公司记录/学习笔记img/JWT验证流程.png) -->
<img src="/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0consul%E7%AC%94%E8%AE%B0/JWT%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B.png" class="" title="JWT验证流程.png">


</li>
</ul>
</li>
</ol>
<ol start="3">
<li>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。</li>
</ol>
<h5 id="4-JWT的构成"><a href="#4-JWT的构成" class="headerlink" title="4. JWT的构成"></a>4. JWT的构成</h5><ol>
<li><p>JWT是由三段信息构成的，将这三段信息文本用.链接一起就构成了Jwt字符串。就像这样:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure>
</li>
<li><p>header</p>
<ul>
<li>jwt的头部承载两部分信息：<ul>
<li>声明类型，这里是jwt</li>
<li>声明加密的算法 通常直接使用 HMAC SHA256<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     &#39;typ&#39;: &#39;JWT&#39;,</span><br><span class="line">     &#39;alg&#39;: &#39;HS256&#39;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>playload</p>
<ul>
<li>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分:标准中注册的声明,公共的声明,私有的声明</li>
<li>定义一个payload:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">    &quot;admin&quot;: true</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>然后将其进行base64加密，得到Jwt的第二部分。</li>
</ul>
</li>
<li><p>signature</p>
<ul>
<li>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：<ul>
<li>header (base64后的)</li>
<li>payload (base64后的)</li>
<li>secret</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="5-如何应用JWT"><a href="#5-如何应用JWT" class="headerlink" title="5. 如何应用JWT"></a>5. 如何应用JWT</h5><ol>
<li>一般是在请求头里加入Authorization，并加上Bearer标注： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fetch(&#39;api&#x2F;user&#x2F;1&#39;, &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      &#39;Authorization&#39;: &#39;Bearer &#39; + token</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h5><ol>
<li><p>优点</p>
<ul>
<li>因为json的通用性，所以JWT是可以进行跨语言支持的，像            JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。</li>
<li>因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。</li>
<li>便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。</li>
<li>它不需要在服务端保存会话信息, 所以它易于应用的扩展</li>
</ul>
</li>
<li><p>安全相关</p>
<ul>
<li>不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。</li>
<li>保护好secret私钥，该私钥非常重要。</li>
<li>如果可以，请使用https协议</li>
</ul>
</li>
</ol>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ol>
<li><a href="https://www.consul.io/api-docs">https://www.consul.io/api-docs</a></li>
</ol>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>服务端</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫与反爬虫</title>
    <url>/%E7%88%AC%E8%99%AB%E4%B8%8E%E5%8F%8D%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><ul>
<li>爬虫主要要伪造User Agent 这个字段，这个是HTTP Header 中的一个字符串，让服务器端能识别客户端的操作系统及版本，浏览器及版本，浏览器引擎，语言等等信息。 这样可以针对性地做一些处理，例如发送桌面版或者手机版的网页。</li>
<li>比如： User-Agent:Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)</li>
</ul>
<a id="more"></a>

<h3 id="反爬虫识别爬虫做出反制。"><a href="#反爬虫识别爬虫做出反制。" class="headerlink" title="反爬虫识别爬虫做出反制。"></a>反爬虫识别爬虫做出反制。</h3><ol>
<li>User agent（修改）</li>
<li>单位时间内访问次数过于频繁（sleep一会儿再访问）</li>
<li>陷阱，放一个像素级连接，用户肉眼不可见，但爬虫程序可见，就会去访问这个链接，服务端就知道这是个爬虫，可以把Ip给封一段时间。</li>
<li>验证码，需要输入验证码才能访问。（如果是登录需要验证码，短暂爬取通过cookie。如果是爬取次数过多需要输验证码才能继续访问，可以分布式，多机器慢慢爬，爬一会儿休息一会，也可以用代理让ip不断变换。）</li>
<li>投毒，识别出是爬虫后，不封ip，故意返回一些假数据，坏得很。</li>
<li>前端通过js渲染，没法通过dom爬取数据了，不过通过ajax访问后端，返回的数据都是json，知道了这些API的输入输出后就能直接拿到数据了。<ul>
<li>爬虫可以使用一个内嵌的浏览器，这个浏览器不需要界面显示， 可以在程序中静悄悄地执行，叫做无界面浏览器，或者无头浏览器。例如selenium，phantomjs等。</li>
<li>有了全功能的内嵌浏览器，相当于一个真正的人类在请求网页了，把JavaScript下载下来，要在浏览器中做渲染，这个无头浏览器渲染完以后，就可以拿到HTML做后续的分析了。</li>
<li>不过缺点是处理的比较慢。可以采用分布式运行，多跑一些爬虫的实例，人多力量大。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>线程函数为类函数时</title>
    <url>/%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E4%B8%BA%E7%B1%BB%E5%87%BD%E6%95%B0%E6%97%B6/</url>
    <content><![CDATA[<h3 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h3><ul>
<li>linux编程，当线程执行的函数是类方法时，如何执行，有如下两种方法。</li>
</ul>
<a id="more"></a>
<h3 id="1-把函数定义为静态"><a href="#1-把函数定义为静态" class="headerlink" title="1. 把函数定义为静态"></a>1. 把函数定义为静态</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread t(bind(&amp;Object::func,a));</span><br></pre></td></tr></table></figure>

<h3 id="2-加this"><a href="#2-加this" class="headerlink" title="2. 加this"></a>2. 加this</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread t(bind(&amp;Object::func,this,a));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>网关服务器杂记</title>
    <url>/%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="网关服务器："><a href="#网关服务器：" class="headerlink" title="网关服务器："></a>网关服务器：</h3><ol>
<li>现在的路由器都是集成交换机+DHCP服务器+网关服务器一体的</li>
<li>NAT</li>
<li>NAT转换表</li>
<li>NAT穿透，只能内网访问外部，如果外部想访问自己，访问不到。解决办法：内网主动和网关服务器协商一个映射关系</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网关</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程协议设计与protobuf反射</title>
    <url>/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E4%B8%8Eprotobuf%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><ol>
<li>最近在想tcp连接传输信息中应用层协议如何设计, 普遍的有两种: 加结束符和加头部信息,能不能不加头部信息?…….貌似不行</li>
</ol>
<a id="more"></a>

<h3 id="2-协议头"><a href="#2-协议头" class="headerlink" title="2. 协议头"></a>2. 协议头</h3><ol>
<li>协议头必备的两个元素就是长度len, 类型type, 假设占8字节,在客户端和数据封装到一块,发送到服务端,服务端每次先接受8字节,获得类型和长度后,在读取len字节, 根据类型处理.</li>
</ol>
<h3 id="3-protobuf反射机制"><a href="#3-protobuf反射机制" class="headerlink" title="3. protobuf反射机制"></a>3. protobuf反射机制</h3><ol>
<li>protobuf能方便定义传输数据并序列化反序列化, 但还是需要自己加协议头,偶然看到muduo作者陈硕大佬对pootobuf反射机制的博客,本以为不需要协议头了,看完发现还是需要,博客地址: <a href="https://www.cnblogs.com/Solstice/archive/2011/04/03/2004458.html">protobuf反射机制</a>. 不过也了解了这个反射机制</li>
<li>就是能通过”类名”自动推导出类,比如一个User消息格式,可以通过如下方法获得反序列化User对象 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Message* mess&#x3D;get_by_name(&quot;User&quot;);	&#x2F;&#x2F; 这只是个举例,并不是调用这个函数,具体请看上面陈硕的博客</span><br></pre></td></tr></table></figure></li>
<li>陈硕大佬的处理方案是: 封装协议头,协议头里”类型”元素由”类名”取代, 这样的话解析协议头获得类名,然后根据类名获得对象,再进行处理</li>
<li>我个人认为这个解决了自己定义类型可能会重复的问题,自己定义类型可以用typeid或者string, 但不同人可能定义相同的typeid,用string的话可以避免重名,但每次添加新类型也要更新类型种类表,稍显麻烦,除此之外……这个反射机制好像没什么用……粗鄙之见,有什么更好的用处欢迎指教.</li>
</ol>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯教育分享-基于go语言生态打造的行业技术中台</title>
    <url>/%E8%85%BE%E8%AE%AF%E6%95%99%E8%82%B2%E5%88%86%E4%BA%AB-%E5%9F%BA%E4%BA%8Ego%E8%AF%AD%E8%A8%80%E7%94%9F%E6%80%81%E6%89%93%E9%80%A0%E7%9A%84%E8%A1%8C%E4%B8%9A%E6%8A%80%E6%9C%AF%E4%B8%AD%E5%8F%B0/</url>
    <content><![CDATA[<h3 id="1-中台是什么？把通用业务下沉到一个平台上，为业务提供服务，微服务化-amp-devops。"><a href="#1-中台是什么？把通用业务下沉到一个平台上，为业务提供服务，微服务化-amp-devops。" class="headerlink" title="1. 中台是什么？把通用业务下沉到一个平台上，为业务提供服务，微服务化&amp;devops。"></a>1. 中台是什么？把通用业务下沉到一个平台上，为业务提供服务，微服务化&amp;devops。</h3><ol>
<li>业务中台，沉淀业务模块开发组件，比如通用的评论模块</li>
<li>技术中台，提供技术基础能力</li>
<li>数据中台，聚焦在如何打通数据连接，沉淀核心数据，驱动业务发展，对数据提供统一出口，方便其他业务调用（要有一些鉴权操作等）<a id="more"></a>

</li>
</ol>
<h3 id="2-微服务"><a href="#2-微服务" class="headerlink" title="2. 微服务"></a>2. 微服务</h3><ol>
<li>是什么？一种软件架构方式，将复杂的应用按照业务划分成多个独立的，具有单一功能的，松耦合的，小型的服务。</li>
<li>为什么？解耦，自治（各自开发），规模小，敏捷性</li>
<li>怎么做？职责单一，解耦，无状态（一个请求来了后只看这个请求，而不看前后调用关系），接口实现</li>
<li>缺点：<ul>
<li>服务数量多，增加管理难度</li>
<li>异步调用，事务处理</li>
<li>配置复杂</li>
<li>业务链路长，增加分析问题难度</li>
<li>负载均衡问题</li>
</ul>
</li>
</ol>
<h3 id="3-开发流程"><a href="#3-开发流程" class="headerlink" title="3. 开发流程"></a>3. 开发流程</h3><ol>
<li>总体流程<ul>
<li>协议构建——protobuf、json</li>
<li>开发——grpc、zap</li>
<li>CI/CD——docker</li>
<li>运行——k8s</li>
</ul>
</li>
<li>现有API开发流程<ul>
<li>定义proto，生成pb文件</li>
<li>创建新项目</li>
<li>到doclever上录入接口定义，提供mock。（doclever是一个接口管理平台）</li>
<li>编写iapi.json，录入网关。（编写网关配置文件）</li>
<li>在postman添加接口，本地调试</li>
<li>编写接口文档(markdown)</li>
</ul>
</li>
<li>中心化的接口定义管理方案<ul>
<li>一处编写，按需生成</li>
<li>版本控制（proto是git管理的）</li>
<li>随时更新（proto必然是最新的），通过proto+注释的方式，写一个proto engine，自动化生成上一步的23456</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域问题CORS</title>
    <url>/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98CORS/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><ol>
<li>CORS全称 Cross-Origin Resource Sharing，跨源资源共享，是跨域的解决方案之一.</li>
<li>浏览器的同源策略是一个重要的安全机制，不同源的客户端在没有授权的情况下，不能够访问对方的资源。</li>
<li>同源的定义是访问链接的协议、域名和端口号均相同。在实际应用中，合理的跨域请求对于一些应用程序也很重要，</li>
<li> CORS 标准定义了在访问跨域资源时，浏览器与服务器应该如何沟通。CORS 的基本思想是使用 HTTP 头部让浏览器与服务器进行沟通，从而决定请求是否能够成功。需要服务器支持。</li>
<li> 在 CORS 成为标准之前，由于安全原因，没有办法跨域调用 API。也就是（一定程度上依旧是）被所谓同源策略（Same-Origin Policy）限制住了。同源策略是浏览器限制的。</li>
</ol>
<a id="more"></a>

<h1 id="2-同源策略"><a href="#2-同源策略" class="headerlink" title="2. 同源策略"></a>2. 同源策略</h1><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><ol>
<li>基于CSRF等安全隐患，浏览器会限制从脚本发出的跨域请求，虽然安全性更高，页面体验却差了。于是W3C推出了一种跨域的访问验证的机制，即CORS，这种机制支持跨域请求，且跨站数据传输更安全。</li>
<li>CORS验证机制需要客户端和服务的协同处理。</li>
</ol>
<h3 id="2-为什么要有同源策略"><a href="#2-为什么要有同源策略" class="headerlink" title="2. 为什么要有同源策略"></a>2. 为什么要有同源策略</h3><ol>
<li>防止CSRF攻击</li>
</ol>
<h3 id="3-CSRF是什么"><a href="#3-CSRF是什么" class="headerlink" title="3. CSRF是什么"></a>3. CSRF是什么</h3><ol>
<li><p>CSRF叫做跨站请求伪造攻击Cross-site request forgery，也有叫XSRF的。是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨網站指令碼（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
</li>
<li><p>简单点说，CSRF 就是利用用户的登录态发起恶意请求。</p>
 <!-- ![image-20200921102739746](/Users/dxm/Documents/公司记录/学习笔记img/CSRF原理.png) -->
 
</li>
<li><p>比如用户给服务器发送一个GET请求，获得个人数据，之前用户已经登录过了，浏览器保存有Cookie。现在有个第三方网站，弄一个图片链接，实际链接内容是这个GET请求，如果用户点了后，利用本地保存的Cookie，就返回了这个用户的个人数据。</p>
</li>
<li><p>这个第三方网站和服务器不同源（ip、端口、域名），为了防止CSRF，同源策略是个解决办法，比如，如果用户要删除自己的帖子，那么先要登录 <a href="http://www.c.com,然后找到对应的页面,发起删除帖子的请求.此时,referer/">www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer</a> 的值是 <a href="http://www.c.com;当请求是从/">http://www.c.com；当请求是从</a> <a href="http://www.a.com/">www.a.com</a> 发起时，Referer 的值是 <a href="http://www.a.com/">http://www.a.com</a> 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 <a href="http://www.c.com/">www.c.com</a> 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。</p>
</li>
<li><p>但是有些它就是要不同源访问，于是就有了CORS验证机制。</p>
</li>
</ol>
<h3 id="4-XSS是什么"><a href="#4-XSS是什么" class="headerlink" title="4. XSS是什么"></a>4. XSS是什么</h3><ol>
<li>xss本质是html注入,和sql注入差不多. </li>
<li>比如注册用户时,用户输入”张三”并提交,服务端会生成：<p>欢迎新用户,张三</p>。如果用户输入：<script>alert('逗你玩')</script>，服务端就会生成：<p>欢迎新用户,<script>alert('逗你玩')</script></p>。输入用户内容就会被浏览器识别为指令执行,这就是xss注入。</li>
</ol>
<h1 id="3-CORS验证机制"><a href="#3-CORS验证机制" class="headerlink" title="3. CORS验证机制"></a>3. CORS验证机制</h1><h3 id="1-客户端处理机制"><a href="#1-客户端处理机制" class="headerlink" title="1. 客户端处理机制"></a>1. 客户端处理机制</h3><ol>
<li>浏览器会对所有跨域请求进行验证，分为简单请求验证处理和预检请求验证处理。那么对应的就有简单请求和非简单请求之分。</li>
</ol>
<h5 id="1-简单请求"><a href="#1-简单请求" class="headerlink" title="1. 简单请求"></a>1. 简单请求</h5><ol>
<li><p>若一个请求同时满足以下两个条件，那么则为简单请求。</p>
<ul>
<li>请求方法为GET或HEAD或POST</li>
<li>请求头中的Content-Type值为application/x-www-form-urlencoded 或 multipart/form-data 或 text/plain</li>
</ul>
</li>
<li><p>对于简单请求，浏览器直接发送该请求，在同一个请求中作跨域验证。怎么验证呢？在请求头上附上Origin属性，表明这是一个跨域请求。服务器接到请求，根据设定的跨域规则来验证，验证通过，返回Access-Control-Allow-Origin等以Access-Control-开头的响应头以及请求的资源，否则返回403状态码，且不会返回请求的资源。</p>
</li>
</ol>
<h5 id="2-非简单请求"><a href="#2-非简单请求" class="headerlink" title="2. 非简单请求"></a>2. 非简单请求</h5><ol>
<li>不为简单请求的跨域请求均为非简单请求。非简单请求的跨域验证通过一个预检请求来验证，即在发送一个正式的跨域请求之前，发送一个预检请求，用来检查当前网页所在的域名是否在服务器的许可名单中以及可使用哪些请求方法，请求头字段。</li>
<li>预检请求<ul>
<li>请求方法为OPTIONS</li>
<li>请求头字段包括 Origin, Access-Control-Request-Method(表明正式的跨域请求可能用到的方法)，Access-Control-Request-Headers(表明正式的跨域请求可能用到的头字段)</li>
</ul>
</li>
<li>预检请求通过，发送正式的跨域请求，请求头带Origin字段。</li>
<li>携带证书信息的请求<ul>
<li>一般情况下，跨域请求不携带证书信息。但若请求的证书模式（credentials mode）被设为include，那么表明该请求需要携带证书信息。</li>
<li>在简单请求及正式的非简单请求中，请求头附带证书信息，响应头回应：Access-Control-Allow-Credentials：true，并返回请求资源。</li>
<li>在预检请求中，请求头并不会附带证书，响应头会回应：Access-Control-Allow-Credentials:true。</li>
<li>若服务器端同意请求携带信息，则Access-Control-Allow-Origin不能为*，只能为请求头中指定的Origin值。</li>
</ul>
</li>
</ol>
<h3 id="2-服务端处理机制"><a href="#2-服务端处理机制" class="headerlink" title="2. 服务端处理机制"></a>2. 服务端处理机制</h3><ol>
<li>检查http头部是否有Origin字段</li>
<li>没有或不允许，则当作普通请求处理，结束</li>
<li>若有且允许跨源，再看是否是预检请求（method为OPTIONS）</li>
<li>是预检请求，返回Access-Control-Allow-Origin，Access-Control-Allow-Methods等信息，内容为空</li>
<li>不是预检请求，返回Access-Control-Allow-Origin，Access-Control-Allow-Credentials等信息，内容为请求的资源。</li>
</ol>
<h1 id="4-CORS-规则"><a href="#4-CORS-规则" class="headerlink" title="4. CORS 规则"></a>4. CORS 规则</h1><h5 id="1-option"><a href="#1-option" class="headerlink" title="1. option"></a>1. option</h5><ol>
<li><p>CORS 标准中新增了一组 HTTP 首部字段，用于浏览器和服务器之间沟通。在跨域请求中，在一些情况下会有一个预检请求（preflight request），是用来检查是否允许这种类型的请求，这种请求使用 OPTIONS 方法。预检请求的使用，可以避免跨域请求对服务器的数据产生未预期的影响。</p>
</li>
<li><p>什么情况下回触发预检请求？</p>
<ol>
<li>使用 PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH 中任一方法。</li>
<li>人为设置了对 CORS 安全的首部字段集合之外的首部字段，该集合在正式标准中包含 Accept、Accept-Language、Content-Language、Content-Type（还有额外限制）。</li>
<li>Content-Type 的值不是 application/x-www-form-urlencoded、multipart/form-data、text/plain 其中之一。</li>
<li>请求中 XMLHttpRequestUpload 对象注册了事件监听器。</li>
<li>请求中使用了 ReadableStream 对象。</li>
</ol>
</li>
<li><p>不会触发预检请求的情况？</p>
<ol>
<li>使用 GET、HEAD、POST 方法之一。</li>
<li>不得人为设置对 CORS 安全的首部字段集合之外的首部字段，该集合在正式标准中包含 Accept、Accept-Language、Content-Language、Content-Type（还有额外限制）。</li>
<li>Content-Type 的值仅限 application/x-www-form-urlencoded、multipart/form-data、text/plain 其中之一。</li>
<li>请求中 XMLHttpRequestUpload 对象没有注册任何事件监听器。</li>
<li>请求中没有使用了 ReadableStream 对象。</li>
</ol>
</li>
</ol>
<h5 id="2-请求头"><a href="#2-请求头" class="headerlink" title="2. 请求头"></a>2. 请求头</h5><ol>
<li><p>Origin</p>
<ul>
<li>表示跨域请求或预请求来自哪里。</li>
</ul>
</li>
<li><p>Access-Control-Request-Method</p>
<ul>
<li>在使用 OPTION 方法时会用到，表示对同一资源的将来跨域请求可能使用的方法。</li>
</ul>
</li>
<li><p>Access-Control-Request-Headers</p>
<ul>
<li>在使用 OPTION 方法时会用到，表示对统一资源将来跨域请求可能使用的请求头部。</li>
</ul>
</li>
</ol>
<h5 id="3-响应头"><a href="#3-响应头" class="headerlink" title="3. 响应头"></a>3. 响应头</h5><ol>
<li><p>Access-Control-Allow-Origin</p>
<ul>
<li>表示是否能够共享响应。如果服务器认为请求可以接受，就设置该头部为请求头的 Origin 信息或者 * ；如果没有这个头部，或者这个头部的信息跟请求的 Origin 信息不匹配，浏览器就会驳回请求。</li>
</ul>
</li>
<li><p>Access-Control-Allow-Credentials</p>
<ul>
<li>表示跨域请求是否提供凭据。默认情况下，跨域请求不提供凭据，设置该头部为 true 时，表示对应的请求应该发送凭据。如果服务器的响应中没有设置该头部，但发送的请求中带了凭据，浏览器会调用到 onerror 事件处理程序。如果是 fetch 请求，该值设置为 include 。</li>
</ul>
</li>
<li><p>Access-Control-Allow-Methods</p>
<ul>
<li>表示跨域请求支持的方法。</li>
</ul>
</li>
<li><p>Access-Control-Allow-Headers</p>
<ul>
<li>表示跨域请求支持的头部。</li>
</ul>
</li>
<li><p>Access-Control-Max-Age</p>
<ul>
<li>表示预请求可以缓存多长时间，以秒为单位。</li>
</ul>
</li>
<li><p>Access-Control-Expose-Headers</p>
<ul>
<li>通过列出其名称，指示哪些头部可以作为响应的一部分公开。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>服务端</tag>
        <tag>cors</tag>
      </tags>
  </entry>
  <entry>
    <title>运维学习路线</title>
    <url>/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h3 id="Linux发行版本与区别"><a href="#Linux发行版本与区别" class="headerlink" title="Linux发行版本与区别"></a>Linux发行版本与区别</h3><h3 id="Linux-红帽系统认证体系"><a href="#Linux-红帽系统认证体系" class="headerlink" title="Linux 红帽系统认证体系"></a>Linux 红帽系统认证体系</h3><a id="more"></a>
<h3 id="CentOS-RHEL-7-x-系统部署-与-基本调试"><a href="#CentOS-RHEL-7-x-系统部署-与-基本调试" class="headerlink" title="CentOS/RHEL 7.x 系统部署 与 基本调试"></a>CentOS/RHEL 7.x 系统部署 与 基本调试</h3><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h3 id="用户与组的概念与能力"><a href="#用户与组的概念与能力" class="headerlink" title="用户与组的概念与能力"></a>用户与组的概念与能力</h3><h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><h1 id="Linux-操作系统"><a href="#Linux-操作系统" class="headerlink" title="Linux 操作系统"></a>Linux 操作系统</h1><h3 id="操作系统的启动概念和流程"><a href="#操作系统的启动概念和流程" class="headerlink" title="操作系统的启动概念和流程"></a>操作系统的启动概念和流程</h3><h3 id="Linux启动流程"><a href="#Linux启动流程" class="headerlink" title="Linux启动流程"></a>Linux启动流程</h3><h3 id="CentOS-6-与-CentOS-7-的区别"><a href="#CentOS-6-与-CentOS-7-的区别" class="headerlink" title="CentOS 6 与 CentOS 7 的区别"></a>CentOS 6 与 CentOS 7 的区别</h3><h3 id="Linux系统的基础配置"><a href="#Linux系统的基础配置" class="headerlink" title="Linux系统的基础配置"></a>Linux系统的基础配置</h3><h3 id="重置root密码"><a href="#重置root密码" class="headerlink" title="重置root密码"></a>重置root密码</h3><h1 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h1><h3 id="系统工作命令"><a href="#系统工作命令" class="headerlink" title="系统工作命令"></a>系统工作命令</h3><p>echo<br>date<br>kill</p>
<h3 id="状态监测命令"><a href="#状态监测命令" class="headerlink" title="状态监测命令"></a>状态监测命令</h3><p>ifconfig<br>uname<br>uptime<br>history</p>
<h3 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h3><p>pwd<br>cd<br>ls</p>
<h3 id="文件编辑命令"><a href="#文件编辑命令" class="headerlink" title="文件编辑命令"></a>文件编辑命令</h3><p>cat<br>more<br>less<br>tail<br>head</p>
<h3 id="目录管理命令"><a href="#目录管理命令" class="headerlink" title="目录管理命令"></a>目录管理命令</h3><p>touch<br>mkdir<br>rm</p>
<h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><p>useradd<br>userdel<br>groupadd<br>su<br>sudo</p>
<h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>curl是一个命令行访问URL的工具，作用是发出网络请求，然后得到和提取数据，显示在”标准输出”（stdout）上面。可以用它构造http request报文，且可以解析服务器返回的http response，额外还支持cookie特性，可以用curl完成web浏览器的基本功能，curl还支持HTTPS/FTP/FTPS/TELNET/LDAP等协议。</p>
<h5 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h5><ul>
<li>-v 详细输出，包含请求和响应的首部</li>
<li>-o test 将指定curl返回保存为test文件，内容从html/jpg到各种MIME类型文件</li>
<li>-O  把输出写到该文件中，保留远程文件的文件名</li>
<li>-C 在保存文件时进行续传</li>
<li>-x  ip:port 指定使用的http代理</li>
<li>-c &lt;file&gt; 保存服务器的cookie文件</li>
<li>-H &lt;header:value&gt;  为HTTP请求设置任意header及值</li>
<li>-L 跟随重定向</li>
<li>-S 显示错误信息</li>
<li>-s 静默模式，不输出任何信息</li>
<li>-G 以get的方式发送数据</li>
<li>-f  连接失败是不显示http错误</li>
<li>-d 以post方式传送数据</li>
<li>-I 仅显示HTTP头信息</li>
<li>-i 显示头和body，默认只显示body</li>
<li>-w %{http_code} 控制额外输出<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5></li>
</ul>
<ol>
<li>只返回状态码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -I -m 15 -o &#x2F;dev&#x2F;null -s -w %&#123;http_code&#125; www.baidu.com</span><br><span class="line"></span><br><span class="line">-I 仅测试HTTP头信息</span><br><span class="line">-m 15 最多查询15s</span><br><span class="line">-o &#x2F;dev&#x2F;null 屏蔽原有输出信息</span><br><span class="line">-s  静默模式，不输出任何东西</span><br><span class="line">-w %&#123;http_code&#125; 控制额外输出</span><br></pre></td></tr></table></figure></li>
<li>自定义显示文字和返回状态码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -I -m 15 -o &#x2F;dev&#x2F;null -s -w &quot;我爱你：%&#123;http_code&#125;&quot; www.baidu.com</span><br></pre></td></tr></table></figure></li>
<li>抓取页面内容到一个文件中（test文件不需要创建）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o test.html www.baidu.com</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>/etc<br>/var<br>/usr<br>绝对路径 与 相对路径</p>
<h3 id="文件类型与权限管理"><a href="#文件类型与权限管理" class="headerlink" title="文件类型与权限管理"></a>文件类型与权限管理</h3><p>文件类型与普通权限<br>文件特殊与隐藏权限<br>文件访问控制列表ACL</p>
<h3 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h3><p>RPM软件包管理<br>tar<br>zip<br>源码包软件安装<br>YUM软件安装与管理</p>
<h3 id="系统进程管理"><a href="#系统进程管理" class="headerlink" title="系统进程管理"></a>系统进程管理</h3><p>ps<br>top<br>kill<br>进程优先级</p>
<h3 id="磁盘管理-1"><a href="#磁盘管理-1" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><p>文件系统概念与常见文件系统类别<br>硬盘结构<br>IDE/SATA/SAS/SCSI/SSD等硬盘类型<br>fdisk磁盘分区</p>
<h3 id="RAID磁盘冗余阵列与LVM逻辑卷管理"><a href="#RAID磁盘冗余阵列与LVM逻辑卷管理" class="headerlink" title="RAID磁盘冗余阵列与LVM逻辑卷管理"></a>RAID磁盘冗余阵列与LVM逻辑卷管理</h3><p>RAID 0/1/5/01/10概念<br>LVM - PV/VG/LV概念与应用</p>
<h3 id="管道、重定向、环境变量"><a href="#管道、重定向、环境变量" class="headerlink" title="管道、重定向、环境变量"></a>管道、重定向、环境变量</h3><p>输入输出重定向<br>管道符的概念 与 基本应用<br>常见系统环境变量</p>
<h3 id="内核优化相关"><a href="#内核优化相关" class="headerlink" title="内核优化相关"></a>内核优化相关</h3><h1 id="基础网络"><a href="#基础网络" class="headerlink" title="基础网络"></a>基础网络</h1><h3 id="网络知识（TCP、UDP、HTTP、HTTPS）、网络抓包"><a href="#网络知识（TCP、UDP、HTTP、HTTPS）、网络抓包" class="headerlink" title="网络知识（TCP、UDP、HTTP、HTTPS）、网络抓包"></a>网络知识（TCP、UDP、HTTP、HTTPS）、网络抓包</h3><h3 id="OSI-TCP网络模型"><a href="#OSI-TCP网络模型" class="headerlink" title="OSI/TCP网络模型"></a>OSI/TCP网络模型</h3><h3 id="IP地址、网关、子网掩码"><a href="#IP地址、网关、子网掩码" class="headerlink" title="IP地址、网关、子网掩码"></a>IP地址、网关、子网掩码</h3><h3 id="路由交换基本概念"><a href="#路由交换基本概念" class="headerlink" title="路由交换基本概念"></a>路由交换基本概念</h3><h3 id="HTTP协议详解"><a href="#HTTP协议详解" class="headerlink" title="HTTP协议详解"></a>HTTP协议详解</h3><h5 id="HTTP-Request-amp-Respoinse-详解"><a href="#HTTP-Request-amp-Respoinse-详解" class="headerlink" title="HTTP Request &amp; Respoinse 详解"></a>HTTP Request &amp; Respoinse 详解</h5><h5 id="HTTP-1-0-1-1协议去呗"><a href="#HTTP-1-0-1-1协议去呗" class="headerlink" title="HTTP 1.0/1.1协议去呗"></a>HTTP 1.0/1.1协议去呗</h5><h5 id="HTTP状态码详解"><a href="#HTTP状态码详解" class="headerlink" title="HTTP状态码详解"></a>HTTP状态码详解</h5><h1 id="shell基础"><a href="#shell基础" class="headerlink" title="shell基础"></a>shell基础</h1><h3 id="vi-vim"><a href="#vi-vim" class="headerlink" title="vi/vim"></a>vi/vim</h3><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p>at<br>crond</p>
<h3 id="自定义变量与函数"><a href="#自定义变量与函数" class="headerlink" title="自定义变量与函数"></a>自定义变量与函数</h3><h3 id="if-语句与判断括号"><a href="#if-语句与判断括号" class="headerlink" title="if 语句与判断括号"></a>if 语句与判断括号</h3><h3 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h3><h3 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h3><h3 id="case-选择语句"><a href="#case-选择语句" class="headerlink" title="case 选择语句"></a>case 选择语句</h3><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><h3 id="shell四剑客-find-sed-grep-awk"><a href="#shell四剑客-find-sed-grep-awk" class="headerlink" title="shell四剑客 find sed grep awk"></a>shell四剑客 find sed grep awk</h3><h3 id="编写运维工具-Shell脚本企业实战"><a href="#编写运维工具-Shell脚本企业实战" class="headerlink" title="编写运维工具/Shell脚本企业实战"></a>编写运维工具/Shell脚本企业实战</h3><h5 id="系统备份脚本"><a href="#系统备份脚本" class="headerlink" title="系统备份脚本"></a>系统备份脚本</h5><h5 id="收集服务器信息脚本"><a href="#收集服务器信息脚本" class="headerlink" title="收集服务器信息脚本"></a>收集服务器信息脚本</h5><h5 id="拒绝恶意IP登录"><a href="#拒绝恶意IP登录" class="headerlink" title="拒绝恶意IP登录"></a>拒绝恶意IP登录</h5><h1 id="Linux服务"><a href="#Linux服务" class="headerlink" title="Linux服务"></a>Linux服务</h1><h3 id="SSHD服务"><a href="#SSHD服务" class="headerlink" title="SSHD服务"></a>SSHD服务</h3><h5 id="常用ssh连接工具"><a href="#常用ssh连接工具" class="headerlink" title="常用ssh连接工具"></a>常用ssh连接工具</h5><h5 id="SSHD服务简介与基本配置"><a href="#SSHD服务简介与基本配置" class="headerlink" title="SSHD服务简介与基本配置"></a>SSHD服务简介与基本配置</h5><h5 id="SSHD实现公钥认证"><a href="#SSHD实现公钥认证" class="headerlink" title="SSHD实现公钥认证"></a>SSHD实现公钥认证</h5><h5 id="SCP进程传输与SSH隧道"><a href="#SCP进程传输与SSH隧道" class="headerlink" title="SCP进程传输与SSH隧道"></a>SCP进程传输与SSH隧道</h5><h3 id="Rsync服务"><a href="#Rsync服务" class="headerlink" title="Rsync服务"></a>Rsync服务</h3><h5 id="Rsync服务简介与搭建"><a href="#Rsync服务简介与搭建" class="headerlink" title="Rsync服务简介与搭建"></a>Rsync服务简介与搭建</h5><h5 id="Rsync客户端远程备份数据"><a href="#Rsync客户端远程备份数据" class="headerlink" title="Rsync客户端远程备份数据"></a>Rsync客户端远程备份数据</h5><h3 id="DHCP服务-NTP服务"><a href="#DHCP服务-NTP服务" class="headerlink" title="DHCP服务-NTP服务"></a>DHCP服务-NTP服务</h3><h5 id="DHCP服务简介与搭建"><a href="#DHCP服务简介与搭建" class="headerlink" title="DHCP服务简介与搭建"></a>DHCP服务简介与搭建</h5><h5 id="实现动态分配IP地址"><a href="#实现动态分配IP地址" class="headerlink" title="实现动态分配IP地址"></a>实现动态分配IP地址</h5><h5 id="NTP时间同步服务"><a href="#NTP时间同步服务" class="headerlink" title="NTP时间同步服务"></a>NTP时间同步服务</h5><h3 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h3><h5 id="DNS协议简介与服务搭建"><a href="#DNS协议简介与服务搭建" class="headerlink" title="DNS协议简介与服务搭建"></a>DNS协议简介与服务搭建</h5><h5 id="DNS正向-反向解析"><a href="#DNS正向-反向解析" class="headerlink" title="DNS正向/反向解析"></a>DNS正向/反向解析</h5><h5 id="DNS主从服务器搭建"><a href="#DNS主从服务器搭建" class="headerlink" title="DNS主从服务器搭建"></a>DNS主从服务器搭建</h5><h3 id="vsFTPd服务-NFS服务"><a href="#vsFTPd服务-NFS服务" class="headerlink" title="vsFTPd服务-NFS服务"></a>vsFTPd服务-NFS服务</h3><h5 id="FTP协议简介与服务搭建"><a href="#FTP协议简介与服务搭建" class="headerlink" title="FTP协议简介与服务搭建"></a>FTP协议简介与服务搭建</h5><h5 id="匿名用户、本地用户与虚拟用户"><a href="#匿名用户、本地用户与虚拟用户" class="headerlink" title="匿名用户、本地用户与虚拟用户"></a>匿名用户、本地用户与虚拟用户</h5><h5 id="NFS网络文件系统"><a href="#NFS网络文件系统" class="headerlink" title="NFS网络文件系统"></a>NFS网络文件系统</h5><h3 id="httpd服务"><a href="#httpd服务" class="headerlink" title="httpd服务"></a>httpd服务</h3><h5 id="web服务器简介"><a href="#web服务器简介" class="headerlink" title="web服务器简介"></a>web服务器简介</h5><h5 id="Apache源码安装编译配置"><a href="#Apache源码安装编译配置" class="headerlink" title="Apache源码安装编译配置"></a>Apache源码安装编译配置</h5><h3 id="实战：PXE-KickStart无人值守系统"><a href="#实战：PXE-KickStart无人值守系统" class="headerlink" title="实战：PXE+KickStart无人值守系统"></a>实战：PXE+KickStart无人值守系统</h3><h3 id="防火墙管理工具：iptables"><a href="#防火墙管理工具：iptables" class="headerlink" title="防火墙管理工具：iptables"></a>防火墙管理工具：iptables</h3><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><h5 id="iptables内核原理"><a href="#iptables内核原理" class="headerlink" title="iptables内核原理"></a>iptables内核原理</h5><h5 id="三表五链"><a href="#三表五链" class="headerlink" title="三表五链"></a>三表五链</h5><h5 id="规则策略"><a href="#规则策略" class="headerlink" title="规则策略"></a>规则策略</h5><h3 id="防火墙管理工具：firewalld"><a href="#防火墙管理工具：firewalld" class="headerlink" title="防火墙管理工具：firewalld"></a>防火墙管理工具：firewalld</h3><h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5><h5 id="区域Zone详解"><a href="#区域Zone详解" class="headerlink" title="区域Zone详解"></a>区域Zone详解</h5><h5 id="服务详解"><a href="#服务详解" class="headerlink" title="服务详解"></a>服务详解</h5><h5 id="区域规则详解"><a href="#区域规则详解" class="headerlink" title="区域规则详解"></a>区域规则详解</h5><h5 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h5><h1 id="运维基础知识"><a href="#运维基础知识" class="headerlink" title="运维基础知识"></a>运维基础知识</h1><h3 id="批量部署工具-ansible"><a href="#批量部署工具-ansible" class="headerlink" title="批量部署工具 ansible"></a>批量部署工具 ansible</h3><h5 id="概述与运行机制"><a href="#概述与运行机制" class="headerlink" title="概述与运行机制"></a>概述与运行机制</h5><h3 id="批量部署工具-puppet"><a href="#批量部署工具-puppet" class="headerlink" title="批量部署工具 puppet"></a>批量部署工具 puppet</h3><h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><h3 id="salt"><a href="#salt" class="headerlink" title="salt"></a>salt</h3><h3 id="ansible-playbook"><a href="#ansible-playbook" class="headerlink" title="ansible-playbook"></a>ansible-playbook</h3><h3 id="nginx、lvs、hapoxy-负载均衡模式-原理及算法-、架构优化、软件优化相关、安全防护（nginx-lua-WAF）"><a href="#nginx、lvs、hapoxy-负载均衡模式-原理及算法-、架构优化、软件优化相关、安全防护（nginx-lua-WAF）" class="headerlink" title="nginx、lvs、hapoxy 负载均衡模式(原理及算法)、架构优化、软件优化相关、安全防护（nginx+lua WAF）"></a>nginx、lvs、hapoxy 负载均衡模式(原理及算法)、架构优化、软件优化相关、安全防护（nginx+lua WAF）</h3><h3 id="mysql-基础集群-主从、双主、MHA等、SQL语句的优化"><a href="#mysql-基础集群-主从、双主、MHA等、SQL语句的优化" class="headerlink" title="mysql (基础集群)主从、双主、MHA等、SQL语句的优化"></a>mysql (基础集群)主从、双主、MHA等、SQL语句的优化</h3><h3 id="nosql-redis集群、MongoDB、memcached-、redis分片集群、mongodb-sharding"><a href="#nosql-redis集群、MongoDB、memcached-、redis分片集群、mongodb-sharding" class="headerlink" title="nosql (redis集群、MongoDB、memcached)、redis分片集群、mongodb(sharding)"></a>nosql (redis集群、MongoDB、memcached)、redis分片集群、mongodb(sharding)</h3><h3 id="zabbix基础"><a href="#zabbix基础" class="headerlink" title="zabbix基础"></a>zabbix基础</h3><h3 id="jenkins基础"><a href="#jenkins基础" class="headerlink" title="jenkins基础"></a>jenkins基础</h3><h3 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h3><h1 id="DBA"><a href="#DBA" class="headerlink" title="DBA"></a>DBA</h1><p>略</p>
<h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><h3 id="zabbix分布式"><a href="#zabbix分布式" class="headerlink" title="zabbix分布式"></a>zabbix分布式</h3><h5 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h5><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><h5 id="报警"><a href="#报警" class="headerlink" title="报警"></a>报警</h5><h3 id="prometheus"><a href="#prometheus" class="headerlink" title="prometheus"></a>prometheus</h3><h3 id="open-falcon"><a href="#open-falcon" class="headerlink" title="open-falcon"></a>open-falcon</h3><h1 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h1><h3 id="CI-CD概述及运行流程"><a href="#CI-CD概述及运行流程" class="headerlink" title="CI/CD概述及运行流程"></a>CI/CD概述及运行流程</h3><h3 id="搭建gitlab平台及使用"><a href="#搭建gitlab平台及使用" class="headerlink" title="搭建gitlab平台及使用"></a>搭建gitlab平台及使用</h3><h3 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h3><h5 id="触发构建"><a href="#触发构建" class="headerlink" title="触发构建"></a>触发构建</h5><h5 id="参数化构建"><a href="#参数化构建" class="headerlink" title="参数化构建"></a>参数化构建</h5><h3 id="gitlab"><a href="#gitlab" class="headerlink" title="gitlab"></a>gitlab</h3><h3 id="ansible"><a href="#ansible" class="headerlink" title="ansible"></a>ansible</h3><h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><h1 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h1><h3 id="HA"><a href="#HA" class="headerlink" title="HA"></a>HA</h3><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><h4 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h4><h4 id="VMware"><a href="#VMware" class="headerlink" title="VMware"></a>VMware</h4><h4 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h4><h5 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h5><h5 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h5><h5 id="docker-swarm"><a href="#docker-swarm" class="headerlink" title="docker swarm"></a>docker swarm</h5><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h3 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h3><h3 id="Glusterfs"><a href="#Glusterfs" class="headerlink" title="Glusterfs"></a>Glusterfs</h3><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><h3 id="硬件存储、刀片"><a href="#硬件存储、刀片" class="headerlink" title="硬件存储、刀片"></a>硬件存储、刀片</h3><h1 id="ELK-日志分析平台"><a href="#ELK-日志分析平台" class="headerlink" title="ELK 日志分析平台"></a>ELK 日志分析平台</h1><h3 id="ELK基本原理"><a href="#ELK基本原理" class="headerlink" title="ELK基本原理"></a>ELK基本原理</h3><h3 id="ELK安装和基础实战"><a href="#ELK安装和基础实战" class="headerlink" title="ELK安装和基础实战"></a>ELK安装和基础实战</h3><h3 id="ELK基础监控"><a href="#ELK基础监控" class="headerlink" title="ELK基础监控"></a>ELK基础监控</h3><h3 id="ELK场景实战"><a href="#ELK场景实战" class="headerlink" title="ELK场景实战"></a>ELK场景实战</h3><h3 id="ELK监控方案"><a href="#ELK监控方案" class="headerlink" title="ELK监控方案"></a>ELK监控方案</h3><h3 id="ELK性能优化"><a href="#ELK性能优化" class="headerlink" title="ELK性能优化"></a>ELK性能优化</h3><h3 id="elasticSearch"><a href="#elasticSearch" class="headerlink" title="elasticSearch"></a>elasticSearch</h3><h3 id="Filebeat"><a href="#Filebeat" class="headerlink" title="Filebeat"></a>Filebeat</h3><h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><h3 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h3><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h3 id="rabbitMQ"><a href="#rabbitMQ" class="headerlink" title="rabbitMQ"></a>rabbitMQ</h3><h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><h1 id="私有云OpenStack"><a href="#私有云OpenStack" class="headerlink" title="私有云OpenStack"></a>私有云OpenStack</h1>]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>GO命令行工具的使用</title>
    <url>/GO%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="0-go交叉编译"><a href="#0-go交叉编译" class="headerlink" title="0. go交叉编译"></a>0. go交叉编译</h3><h5 id="1-mac下编译linux程序"><a href="#1-mac下编译linux程序" class="headerlink" title="1. mac下编译linux程序"></a>1. mac下编译linux程序</h5><ul>
<li>GOOS=linux GOARCH=amd64 go build hello.go<a id="more"></a>

</li>
</ul>
<h3 id="1-go-version"><a href="#1-go-version" class="headerlink" title="1. go version"></a>1. go version</h3><ol>
<li><p>看go语言版本</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go version</span><br><span class="line">  go version go1.14.4 darwin&#x2F;amd64</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看go文件的构建版本信息</p>
<ul>
<li>文件路径可以要加绝对路径</li>
<li>可以看多个文件，也可以直接指定目录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go version &#x2F;Users&#x2F;dxm&#x2F;go&#x2F;src&#x2F;beeserver&#x2F;beeserver</span><br><span class="line">   &#x2F;Users&#x2F;dxm&#x2F;go&#x2F;src&#x2F;beeserver&#x2F;beeserver: go1.14.4</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 目录</span><br><span class="line">  $ go version &#x2F;Users&#x2F;dxm&#x2F;go&#x2F;src&#x2F;beeserver</span><br><span class="line">   &#x2F;Users&#x2F;dxm&#x2F;go&#x2F;src&#x2F;beeserver&#x2F;beeserver: go1.14.4</span><br><span class="line">   &#x2F;Users&#x2F;dxm&#x2F;go&#x2F;src&#x2F;beeserver&#x2F;go_build_main_go: go1.14.4</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查看go可执行文件的包依赖信息(查看go mod信息)</p>
<ul>
<li><p>加个-m参数就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go version -m &#x2F;Users&#x2F;dxm&#x2F;go&#x2F;src&#x2F;beeserver&#x2F;beeserver</span><br><span class="line">  &#x2F;Users&#x2F;dxm&#x2F;go&#x2F;src&#x2F;beeserver&#x2F;beeserver: go1.14.4</span><br><span class="line">   path	beeserver</span><br><span class="line">   mod	beeserver	(devel)</span><br><span class="line">   dep	github.com&#x2F;astaxie&#x2F;beego	v1.12.2	h1:CajUexhSX5ONWDiSCpeQBNVfTzOtPb9e9d+3vuU5FuU&#x3D;</span><br><span class="line">   dep	github.com&#x2F;beorn7&#x2F;perks	v1.0.1	h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM&#x3D;</span><br><span class="line">   dep	github.com&#x2F;cespare&#x2F;xxhash&#x2F;v2	v2.1.1	h1:6MnRN8NT7+YBpUIWxHtefFZOKTAPgGjpQSxqLNn0+qY&#x3D;</span><br><span class="line">   dep	github.com&#x2F;go-sql-driver&#x2F;mysql	v1.5.0	h1:ozyZYNQW3x3HtqT1jira07DN2PArx2v7&#x2F;mN66gGcHOs&#x3D;</span><br><span class="line">   dep	github.com&#x2F;golang&#x2F;protobuf	v1.4.2	h1:+Z5KGCizgyZCbGh1KZqA0fcLLkwbsjIzS4aV2v7wJX0&#x3D;</span><br><span class="line">   dep	github.com&#x2F;hashicorp&#x2F;golang-lru	v0.5.4	h1:YDjusn29QI&#x2F;Das2iO9M0BHnIbxPeyuCHsjMW+lJfyTc&#x3D;</span><br><span class="line">   dep	github.com&#x2F;matttproud&#x2F;golang_protobuf_extensions	v1.0.1	h1:4hp9jkHxhMHkqkrB3Ix0jegS5sx&#x2F;RkqARlsWZ6pIwiU&#x3D;</span><br><span class="line">   dep	github.com&#x2F;prometheus&#x2F;client_golang	v1.7.0	h1:wCi7urQOGBsYcQROHqpUUX4ct84xp40t9R9JX0FuA&#x2F;U&#x3D;</span><br><span class="line">   dep	github.com&#x2F;prometheus&#x2F;client_model	v0.2.0	h1:uq5h0d+GuxiXLJLNABMgp2qUWDPiLvgCzz2dUR+&#x2F;W&#x2F;M&#x3D;</span><br><span class="line">   dep	github.com&#x2F;prometheus&#x2F;common	v0.10.0	h1:RyRA7RzGXQZiW+tGMr7sxa85G1z0yOpM1qq5c8lNawc&#x3D;</span><br><span class="line">   dep	github.com&#x2F;prometheus&#x2F;procfs	v0.1.3	h1:F0+tqvhOksq22sc6iCHF5WGlWjdwj92p0udFh1VFBS8&#x3D;</span><br><span class="line">   dep	github.com&#x2F;shiena&#x2F;ansicolor	v0.0.0-20151119151921-a422bbe96644	h1:X+yvsM2yrEktyI+b2qND5gpH8YhURn0k8OCaeRnkINo&#x3D;</span><br><span class="line">   dep	golang.org&#x2F;x&#x2F;crypto	v0.0.0-20191011191535-87dc89f01550	h1:ObdrDkeb4kJdCP557AjRjq69pTHfNouLtWZG7j9rPN8&#x3D;</span><br><span class="line">   dep	golang.org&#x2F;x&#x2F;net	v0.0.0-20190620200207-3b0461eec859	h1:R&#x2F;3boaszxrf1GEUWTVDzSKVwLmSJpwZ1yqXm8j0v2QI&#x3D;</span><br><span class="line">   dep	golang.org&#x2F;x&#x2F;sys	v0.0.0-20200615200032-f1bc736245b1	h1:ogLJMz+qpzav7lGMh10LMvAkM&#x2F;fAoGlaiiHYiFYdm80&#x3D;</span><br><span class="line">   dep	golang.org&#x2F;x&#x2F;text	v0.3.0	h1:g61tztE5qeGQ89tm6NTjjM9VPIm088od1l6aSorWRWg&#x3D;</span><br><span class="line">   dep	google.golang.org&#x2F;protobuf	v1.23.0	h1:4MY060fB1DLGMB&#x2F;7MBTLnwQUY6+F09GEiz6SsrNqyzM&#x3D;</span><br><span class="line">   dep	gopkg.in&#x2F;yaml.v2	v2.2.8	h1:obN1ZagJSUGI0Ek&#x2F;LBmuj4SNLPfIny3KsKFopxRdj10&#x3D;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>注意只能查看Go语言编译生成的可执行文件</p>
</li>
</ol>
<h3 id="2-go-run"><a href="#2-go-run" class="headerlink" title="2. go run"></a>2. go run</h3><ol>
<li><p>go run命令包含了两个动作：编译命令源码文件和运行对应的可执行文件。</p>
</li>
<li><p>go run命令只接受Go源码文件作为参数，而不接受代码包。与go build命令和go install命令一样，go run命令也不允许多个命令源码文件作为参数，即使它们在同一个代码包中也是如此。而原因也是一致的，多个命令源码文件都有相同的main函数声明。</p>
</li>
<li><p>go run -n test.go 只打印相关命令而不执行</p>
</li>
<li><p>go run -x -work test.go 既打印相关命令又执行</p>
<ul>
<li>-work 是打印临时工作目录的名称，并在退出时不删除它（少用）。</li>
</ul>
</li>
</ol>
<h3 id="3-go-build"><a href="#3-go-build" class="headerlink" title="3. go build"></a>3. go build</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go build [-o 输出名] [-i] [编译标记] [包名]</span><br></pre></td></tr></table></figure></code></pre>
<ol>
<li><p>编译规则</p>
<ul>
<li>如果参数为***.go文件或文件列表，则编译为一个个单独的包。</li>
<li>当编译单个main包（文件），则生成可执行文件。</li>
<li>当编译单个或多个包非主包时，只构建编译包，但丢弃生成的对象（.a），仅用作检查包可以构建。即最后不会生成可执行文件。</li>
<li>当编译包时，会自动忽略’_test.go’的测试文件。</li>
</ul>
</li>
<li><p>主要作用</p>
<ul>
<li>用于测试编译包，在项目目录下生成可执行文件（有main包）。</li>
</ul>
</li>
<li><p>go build指令会调用所有引用包的源码，重新编译，而不是直接使用pkg里的编译后文件，如果在【$GOROOT】与【$GOPATH】下没有找到import引入包的项目源码，就会报错。</p>
</li>
</ol>
<h3 id="4-go-install"><a href="#4-go-install" class="headerlink" title="4. go install"></a>4. go install</h3><ol>
<li><p>主要作用</p>
<ul>
<li>主要用来生成库和工具。一是编译包文件（无main包），将编译后的包文件放到 pkg 目录下（$GOPATH/pkg）。二是编译生成可执行文件（有main包），将可执行文件放到 bin 目录（$GOPATH/bin）。</li>
</ul>
</li>
<li><p>和go build的不同点</p>
<ul>
<li>go build 不能生成包文件, go install 可以生成包文件</li>
<li>go build 生成可执行文件在当前目录下， go install 生成可执行文件在bin目录下（$GOPATH/bin），这样就可以使项目可执行文件能被方便的全局调用。</li>
<li>go install 输出目录始终为 GOPATH 下的 bin 目录，无法使用-o附加参数进行自定义。</li>
</ul>
</li>
<li><p>GOPATH 下的 pkg 目录放置的是编译期间的中间文件。（.a）</p>
<ul>
<li>每个package都会生成对应的.a文件，Go在install的时候先判断package是否有改动，如果没有就不再编译.a文件，加快编译速度。</li>
<li>build的话强制全部编译</li>
<li>只把.a文件给别人，别人是用不了的，必须得要源码。</li>
</ul>
</li>
</ol>
<h3 id="5-go-get"><a href="#5-go-get" class="headerlink" title="5. go get"></a>5. go get</h3><ol>
<li><p>go get 可以暂时理解为git clone 到 $GOPATH/src  + go install</p>
</li>
<li><p>用法：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get [-d] [-f] [-t] [-u] [-fix] [-insecure] [build flags] [packages]</span><br></pre></td></tr></table></figure>
</li>
<li><p>标记名称 描述</p>
</li>
</ol>
<p>-d 让命令程序只执行下载动作，而不执行安装动作。<br>-f 仅在使用-u标记时才有效。该标记会让命令程序忽略掉对已下载代码包的导入路径的检查。如果下载并安装的代码包所属的项目是你从别人那里Fork过来的，那么这样做就尤为重要了。<br>-fix 让命令程序在下载代码包后先执行修正动作，而后再进行编译和安装。<br>-insecure 允许命令程序使用非安全的scheme（如HTTP）去下载指定的代码包。如果你用的代码仓库（如公司内部的Gitlab）没有HTTPS支持，可以添加此标记。请在确定安全的情况下使用它。<br>-t 让命令程序同时下载并安装指定的代码包中的测试源码文件中依赖的代码包。<br>-u 让命令利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包。<br>-v 打印出被构建的代码包的名字<br>-x 打印出用到的命令</p>
<h3 id="6-go-mod"><a href="#6-go-mod" class="headerlink" title="6. go mod"></a>6. go mod</h3><ol>
<li>自从 Go 官方从去年推出 1.11 之后，增加新的依赖管理模块并且更加易于管理项目中所需要的模块。模块是存储在文件树中的 Go 包的集合，其根目录中包含 go.mod 文件。 go.mod 文件定义了模块的模块路径，它也是用于根目录的导入路径，以及它的依赖性要求。每个依赖性要求都被写为模块路径和特定语义版本。</li>
</ol>
<h5 id="1-使用module的前置工作"><a href="#1-使用module的前置工作" class="headerlink" title="1. 使用module的前置工作"></a>1. 使用module的前置工作</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	export GO111MODULE&#x3D;on</span><br><span class="line">export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.io &#x2F;&#x2F; 设置代理</span><br></pre></td></tr></table></figure></code></pre>
<h5 id="2-常见操作"><a href="#2-常见操作" class="headerlink" title="2. 常见操作"></a>2. 常见操作</h5><ol>
<li><p>创建一个新模块</p>
<ul>
<li>go mod init hello 初始化一个module名字为 hello 的模块，生成一个go.mod文件。</li>
</ul>
</li>
<li><p>添加依赖</p>
<ul>
<li>在代码中直接import，go build后会自动添加</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>升级依赖项</p>
<ul>
<li>查看使用的依赖列表：go list -m all</li>
<li>go tidy 下载更新依赖</li>
</ul>
</li>
<li><p>删除未使用的依赖项</p>
<ul>
<li>go mod tidy</li>
</ul>
</li>
</ol>
<h5 id="3-go-mod参数"><a href="#3-go-mod参数" class="headerlink" title="3. go mod参数"></a>3. go mod参数</h5><pre><code>        download    download modules to local cache
    edit        edit go.mod from tools or scripts
    graph       print module requirement graph
    init        initialize new module in current directory
    tidy        add missing and remove unused modules
    vendor      make vendored copy of dependencies
    verify      verify dependencies have expected content
    why         explain why packages or modules are needed</code></pre>
<h3 id="7-go-test"><a href="#7-go-test" class="headerlink" title="7. go test"></a>7. go test</h3><h5 id="1-测试文件"><a href="#1-测试文件" class="headerlink" title="1. 测试文件"></a>1. 测试文件</h5><h6 id="1-测试目录所有文件"><a href="#1-测试目录所有文件" class="headerlink" title="1. 测试目录所有文件"></a>1. 测试目录所有文件</h6><ul>
<li>go的test一般以xxx_test.go为文件名，xxx并没有特别要求是要实测的文件名</li>
<li>在当前目录下使用 go test 会运行当前目录下所有的 test 文件。</li>
</ul>
<h6 id="2-测试单个文件"><a href="#2-测试单个文件" class="headerlink" title="2. 测试单个文件"></a>2. 测试单个文件</h6><ul>
<li>测试单个文件，一定要带上被测试的原文件</li>
<li>go test -v  wechat_test.go wechat.go </li>
</ul>
<h6 id="3-测试单个函数"><a href="#3-测试单个函数" class="headerlink" title="3. 测试单个函数"></a>3. 测试单个函数</h6><ul>
<li>go test -v -test.run TestRefreshAccessToken</li>
</ul>
<h5 id="2-四种测试用例"><a href="#2-四种测试用例" class="headerlink" title="2. 四种测试用例"></a>2. 四种测试用例</h5><ol>
<li><p>TestXxxx(t *testing.T) // 基本测试用例</p>
<ul>
<li>go test 不会按照顺序执行多个 test case。若想要顺序执行，需要用到 subtests 。用 t.Run 来执行 subtests 可以做到控制顺序的作用。</li>
</ul>
</li>
<li><p>BenchmarkXxxx(b *testing.B) // 压力测试的测试用例</p>
<ul>
<li>执行命令 go test -bench=.  输入该命令后，go test 只会测试 Benchmark 开头的函数</li>
<li>benchmark 的 case 一般会跑 b.N 次，而且每次执行都会如此</li>
<li>在执行过程中会根据实际 case 的执行时间是否稳定会增加 b.N 的次数以达到稳态</li>
</ul>
</li>
</ol>
<ol start="3">
<li>Example_Xxx() // 测试控制台输出的例子</li>
</ol>
<ol start="4">
<li>TestMain(m *testing.M) // 测试Main函数<ul>
<li>TestMain 作为初始化 test。作为入口 test。可以在 m.Run() 之前初始化一些东西，比如数据库连接、文件打开。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func TestMain(m *testing.M) &#123;</span><br><span class="line">    fmt.Println(&quot;test main first&quot;)</span><br><span class="line">    m.Run()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<h5 id="3-test两种运行模式"><a href="#3-test两种运行模式" class="headerlink" title="3. test两种运行模式"></a>3. test两种运行模式</h5><ol>
<li>本地目录模式，在没有包参数（例如 go test 或 go test -v ）调用时发生。在此模式下， go test 编译当前目录中找到的包和测试，然后运行测试二进制文件。在这种模式下，caching 是禁用的。在包测试完成后，go test 打印一个概要行，显示测试状态、包名和运行时间。</li>
<li>包列表模式，在使用显示包参数调用 go test 时发生（例如 go test math ， go test ./… 甚至是 go test . ）。在此模式下，go 测试编译并测试在命令上列出的每个包。如果一个包测试通过， go test 只打印最终的 ok 总结行。如果一个包测试失败， go test 将输出完整的测试输出。如果使用 -bench 或 -v 标志，则 go test 会输出完整的输出，甚至是通过包测试，以显示所请求的基准测试结果或详细日志记录。</li>
</ol>
<h3 id="8-go-env"><a href="#8-go-env" class="headerlink" title="8. go env"></a>8. go env</h3><ol>
<li>命令go env用于打印Go语言的环境信息。</li>
</ol>
<h3 id="9-go-fix"><a href="#9-go-fix" class="headerlink" title="9. go fix"></a>9. go fix</h3><ol>
<li><p>命令go fix会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。这里所说的版本即Go语言的版本。代码包的所有Go语言源码文件不包括其子代码包（如果有的话）中的文件。修正操作包括把对旧程序调用的代码更换为对新程序调用的代码、把旧的语法更换为新的语法，等等。</p>
</li>
<li><p>命令go fix其实是命令go tool fix的简单封装。这甚至比go fmt命令对gofmt命令的封装更简单。像其它的Go命令一样，go fix命令会先对作为参数的代码包导入路径进行验证，以确保它是正确有效的。像在本小节开始处描述的那样，go fix命令会把有效代码包中的所有Go语言源码文件作为多个参数传递给go tool fix命令。实际上，go fix命令本身不接受任何标记，它会把加入的所有标记都原样传递给go tool fix命令。</p>
</li>
<li><p>go tool fix命令可接受的标记如下表</p>
<p> 标记名称    标记描述<br> -diff    不将修正后的内容写入文件，而只打印修正前后的内容的对比信息到标准输出。<br> -r    只对目标源码文件做有限的修正操作。该标记的值即为允许的修正操作的名称。多个名称之间用英文半角逗号分隔。<br> -force    使用此标记后，即使源码文件中的代码已经与Go语言的最新版本相匹配了，也会强行执行指定的修正操作。该标记的值就是需要强行执行的修正操作的名称，多个名称之间用英文半角逗号分隔。</p>
</li>
</ol>
<h3 id="10-go-fmt"><a href="#10-go-fmt" class="headerlink" title="10. go fmt"></a>10. go fmt</h3><ol>
<li><p>go fmt命令会按照Go语言代码规范格式化指定代码包中的所有Go语言源码文件的代码，所有Go语言源码文件即包括命令源码文件、库源码文件和测试源码文件。注意，当代码包还有子代码包时，子代码包中的Go语言源码文件是不包含在内的。也就是说，go fmt命令只会格式化被直接保存在指定代码包对应目录下的Go语言源码文件。</p>
</li>
<li><p>与go doc命令和godoc命令的关系类似，go fmt命令是gofmt命令的简单封装。go fmt命令本身可以接受两个标记。标记-n可以让命令程序仅打印出内部使用的gofmt命令及其标记和参数而不真正执行它。标记-x则会使命令程序既打印又执行这个命令。在go fmt命令程序内部，会在其调用的gofmt命令后面加上标记-l和-w，并以指定代码包中的所有Go语言源码文件的路径作为参数，就像这样：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go fmt -n pkgtool</span><br><span class="line">  gofmt -l -w golang&#x2F;goc2p&#x2F;src&#x2F;pkgtool&#x2F;envir.go golang&#x2F;goc2p&#x2F;src pkgtoolenvir_test.go golang&#x2F;goc2p&#x2F;src&#x2F;pkgtool&#x2F;fpath.go golang&#x2F;goc2p&#x2F;src&#x2F;pkgtool ipath.go golang&#x2F;goc2p&#x2F;src&#x2F;pkgtool&#x2F;pnode.go golang&#x2F;goc2p&#x2F;src&#x2F;pkgtool&#x2F;util.go golang&#x2F;goc2p&#x2F;src&#x2F;pkgtool&#x2F;util_test.go</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="11-go-doc"><a href="#11-go-doc" class="headerlink" title="11. go doc"></a>11. go doc</h3><ol>
<li><p>go doc fmt</p>
<ul>
<li>用于展示指定代码包fmt的文档</li>
</ul>
</li>
<li><p>godoc -http=localhost:6060 -index </p>
<ul>
<li>在本地指定web服务，网页查看文档</li>
<li>-index是指定搜索功能</li>
</ul>
</li>
</ol>
<h3 id="12-go-clean"><a href="#12-go-clean" class="headerlink" title="12. go clean"></a>12. go clean</h3><ol>
<li><p>执行go clean命令会删除掉执行其它命令时产生的一些文件和目录，包括:</p>
<ul>
<li>在使用go build命令时在当前代码包下生成的与包名同名或者与Go源码文件同名的可执行文件。在Windows下，则是与包名同名或者Go源码文件同名且带有“.exe”后缀的文件。</li>
<li>在执行go test命令并加入-c标记时在当前代码包下生成的以包名加“.test”后缀为名的文件。在Windows下，则是以包名加“.test.exe”后缀为名的文件。</li>
<li>如果执行go clean命令时带有标记-i，则会同时删除安装（执行go install命令）当前代码包时所产生的结果文件。如果当前代码包中只包含库源码文件，则结果文件指的就是在工作区的pkg目录的相应目录下的归档文件。如果当前代码包中只包含一个命令源码文件，则结果文件指的就是在工作区的bin目录下的可执行文件。</li>
<li>还有一些目录和文件是在编译Go或C源码文件时留在相应目录中的。包括：“_obj”和“_test”目录，名称为“_testmain.go”、“test.out”、“build.out”或“a.out”的文件，名称以“.5”、“.6”、“.8”、“.a”、“.o”或“.so”为后缀的文件。这些目录和文件是在执行go build命令时生成在临时目录中的。</li>
<li>如果执行go clean命令时带有标记-r，则还包括当前代码包的所有依赖包的上述目录和文件。</li>
</ul>
</li>
</ol>
<h3 id="13-go-list"><a href="#13-go-list" class="headerlink" title="13. go list"></a>13. go list</h3><ol>
<li>go list -e -json fmt 查看fmt包的信息</li>
</ol>
<h3 id="14-go-vet"><a href="#14-go-vet" class="headerlink" title="14. go vet"></a>14. go vet</h3><ol>
<li>命令go vet是一个用于检查Go语言源码中静态错误的简单工具。与大多数Go命令一样，go vet命令可以接受-n标记和-x标记。-n标记用于只打印流程中执行的命令而不真正执行它们。-n标记也用于打印流程中执行的命令，但不会取消这些命令的执行。</li>
<li>go vet命令是go tool vet命令的简单封装。它会首先载入和分析指定的代码包，并把指定代码包中的所有Go语言源码文件和以“.s”结尾的文件的相对路径作为参数传递给go tool vet命令。其中，以“.s”结尾的文件是汇编语言的源码文件。如果go vet命令的参数是Go语言源码文件的路径，则会直接将这些参数传递给go tool vet命令。</li>
<li>go tool vet命令的作用是检查Go语言源代码并且报告可疑的代码编写问题。比如，在调用Printf函数时没有传入格式化字符串，以及某些不标准的方法签名，等等。该命令使用试探性的手法检查错误，因此并不能保证报告的问题确实需要解决。但是，它确实能够找到一些编译器没有捕捉到的错误。</li>
</ol>
<h3 id="15-go-generate"><a href="#15-go-generate" class="headerlink" title="15. go generate"></a>15. go generate</h3><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><ol>
<li>go generate命令是go 1.4版本里面新添加的一个命令，当运行go generate时，它将扫描与当前包相关的源代码文件，找出所有包含”//go:generate”的特殊注释，提取并执行该特殊注释后面的命令，命令为可执行程序，形同shell下面执行。</li>
</ol>
<h5 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h5><ol>
<li>protobufs：从 protocol buffer 定义文件（.proto）生成 .pb.go 文件。</li>
<li>Unicode：从 UnicodeData.txt 生成 Unicode 表.</li>
</ol>
<h5 id="3-例子"><a href="#3-例子" class="headerlink" title="3. 例子"></a>3. 例子</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"> import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;go:generate echo hello</span><br><span class="line"> &#x2F;&#x2F;go:generate go run main.go</span><br><span class="line"> &#x2F;&#x2F;go:generate  echo file&#x3D;$GOFILE pkg&#x3D;$GOPACKAGE</span><br><span class="line"> func main() &#123;</span><br><span class="line">     fmt.Println(&quot;Hello world!&quot;)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 输出</span><br><span class="line"> $ go generate</span><br><span class="line"> hello</span><br><span class="line"> Hello world!</span><br><span class="line"> file&#x3D;main.go pkg&#x3D;main</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO特性</title>
    <url>/GO%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h3><h5 id="1-闭包基本使用"><a href="#1-闭包基本使用" class="headerlink" title="1. 闭包基本使用"></a>1. 闭包基本使用</h5><a id="more"></a>
<pre><code><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(f())  <span class="comment">// 别忘记括号，不加括号相当于地址</span></span><br><span class="line">    fmt.Println(f())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></code></pre>
<h5 id="2-闭包作为函数返回值"><a href="#2-闭包作为函数返回值" class="headerlink" title="2. 闭包作为函数返回值"></a>2. 闭包作为函数返回值</h5><pre><code><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Increase</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        n++</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    in := Increase()</span><br><span class="line">    fmt.Println(in())</span><br><span class="line">    fmt.Println(in())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></code></pre>
<h5 id="3-并发中的闭包"><a href="#3-并发中的闭包" class="headerlink" title="3. 并发中的闭包"></a>3. 并发中的闭包</h5><pre><code>- Go语言的并发时，一定要处理好循环中的闭包引用的外部变量。

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
- 这种现象的原因在于闭包共享外部的变量i，注意到，每次调用go就会启动一个goroutine，这需要一定时间；但是，启动的goroutine与循环变量递增不是在同一个goroutine，可以把i认为处于主goroutine中。启动一个goroutine的速度远小于循环执行的速度，所以即使是第一个goroutine刚起启动时，外层的循环也执行到了最后一步了。由于所有的goroutine共享i，而且这个i会在最后一个使用它的goroutine结束后被销毁，所以最后的输出结果都是最后一步的i==5。</code></pre>
<h5 id="14-并发闭包问题的两种解决方式"><a href="#14-并发闭包问题的两种解决方式" class="headerlink" title="14. 并发闭包问题的两种解决方式"></a>14. 并发闭包问题的两种解决方式</h5><pre><code>- 共享的环境变量作为函数参数传递

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
- 使用同名的变量保留当前的状态

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line"></span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    for i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        i :&#x3D; i       &#x2F;&#x2F; 注意这里的同名变量覆盖</span><br><span class="line">        go func() &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">输出结果：</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">结果顺序原因同1</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
- 输出结果不一定按照顺序，这取决于每个goroutine的实际情况，但是最后的结果是不变的。可以理解为，函数参数的传递是瞬时的，而且是在一个goroutine执行之前就完成，所以此时执行的闭包存储了当前i的状态。    </code></pre>
<h3 id="二、接口"><a href="#二、接口" class="headerlink" title="二、接口"></a>二、接口</h3><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><ol>
<li>和其他语言不同的是，在Go语言中接口的实现是隐式的。即我们不用去明确的指出某一个类型实现了某一个接口.只要某一类型的方法中实现了接口中的全部方法签名，就意味着此类型实现了这一接口。</li>
</ol>
<h5 id="2-接口的组合"><a href="#2-接口的组合" class="headerlink" title="2. 接口的组合"></a>2. 接口的组合</h5><ol>
<li>直接embbedding。</li>
</ol>
<h5 id="3-类型断言"><a href="#3-类型断言" class="headerlink" title="3. 类型断言"></a>3. 类型断言</h5><ol>
<li>为什么Go语言在运行时还需要再判断一次呢，这是由于在类型断言方法m = i.(Type)中,如果Type实现了接口i,但是此时接口内部并没有任何动态类型(此时为nil),这时在运行时会直接panic。如果不想panic，就加个ok判断一下，如下。ok为bool类型。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := i.(Type)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="4-空接口"><a href="#4-空接口" class="headerlink" title="4. 空接口"></a>4. 空接口</h5><ol>
<li><p>空接口可以存储结构体、字段串、整数等任何的类型。</p>
</li>
<li><p>在Println源码中,使用switch语句嵌套这一语法获取空接口中的动态类型。并根据动态类型的不同,进行不同的格式化输出。</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> f := arg.(<span class="keyword">type</span>) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">       p.fmtBool(f, verb)</span><br><span class="line">   <span class="keyword">case</span> <span class="keyword">float32</span>:</span><br><span class="line">       p.fmtFloat(<span class="keyword">float64</span>(f), <span class="number">32</span>, verb)</span><br><span class="line">   <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">       p.fmtFloat(f, <span class="number">64</span>, verb)</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func MyPrintln(arg interface&#123;&#125;)&#123;</span><br><span class="line">    switch arg.(type) &#123;</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Println(&quot;string:&quot;,strings.ToUpper(arg.(string)))</span><br><span class="line">    case bool:</span><br><span class="line">        fmt.Println(&quot;this is bool&quot;)</span><br><span class="line">    case float32,float64:</span><br><span class="line">        fmt.Println(&quot;this is float&quot;)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="5-接口的比较性"><a href="#5-接口的比较性" class="headerlink" title="5. 接口的比较性"></a>5. 接口的比较性</h5><ol>
<li>两个接口之间可以通过==或!=进行比较。</li>
<li>如果两个接口不为nil,如果他们具有相同的动态类型与动态类型值，则两个接口是相同的。</li>
<li>如果都为nil，比较结果相等，如果只有1个接口为nil,那么比较结果总是false。</li>
<li>如果接口存储的动态类型值是不可比较的,在运行时会报错。</li>
</ol>
<h3 id="三、Go标准库-锁、信号量、POOL"><a href="#三、Go标准库-锁、信号量、POOL" class="headerlink" title="三、Go标准库-锁、信号量、POOL"></a>三、Go标准库-锁、信号量、POOL</h3><h5 id="1-Mutex-互斥锁"><a href="#1-Mutex-互斥锁" class="headerlink" title="1. Mutex 互斥锁"></a>1. Mutex 互斥锁</h5><ol>
<li><p>互斥锁是用来保证在任一时刻， 只能有一个例程访问某个对象。 Mutex的初始值为解锁的状态。 通常作为其他结构体的匿名字段使用， 并且可以安全的在多个例程中并行使用</p>
</li>
<li><p>成员方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Lock 用于锁住 m，如果 m 已经被加锁，则 Lock 将被阻塞，直到 m 被解锁。</span><br><span class="line">   func (m *Mutex) Lock()</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Unlock 用于解锁 m，如果 m 未加锁，则该操作会引发 panic。</span><br><span class="line">   func (m *Mutex) Unlock()</span><br></pre></td></tr></table></figure></li>
<li><p>示例代码</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">   import (</span><br><span class="line">       &quot;fmt&quot;</span><br><span class="line">       &quot;sync&quot;</span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line">   type safeInt struct &#123;</span><br><span class="line">       sync.Mutex</span><br><span class="line">       Num int</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   func main() &#123;</span><br><span class="line">       waitNum :&#x3D; 10</span><br><span class="line">       count :&#x3D; safeInt&#123;&#125;</span><br><span class="line">       done :&#x3D; make(chan bool)</span><br><span class="line"></span><br><span class="line">       for i :&#x3D; 0; i &lt; waitNum; i++ &#123;</span><br><span class="line">           go func(i int) &#123;</span><br><span class="line">               count.Lock()</span><br><span class="line">               count.Num &#x3D; count.Num + i</span><br><span class="line">               fmt.Print(count.Num, &quot; &quot;)</span><br><span class="line">               count.Unlock()</span><br><span class="line">               done &lt;- true</span><br><span class="line">           &#125;(i)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for i :&#x3D; 0; i &lt; waitNum; i++ &#123;</span><br><span class="line">           &lt;-done</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-RWMutex-读写互斥锁"><a href="#2-RWMutex-读写互斥锁" class="headerlink" title="2. RWMutex 读写互斥锁"></a>2. RWMutex 读写互斥锁</h5><ol>
<li><p>RWMutex是读写互斥锁。该锁可以被同时多个读取者持有或唯一个写入者持有。RWMutex可以创建为其他结构体的字段；零值为解锁状态。RWMutex类型的锁也和线程无关，可以由不同的线程加读取锁/写入和解读取锁/写入锁。Mutex 可以安全的在多个例程中并行使用。</p>
<ul>
<li>可以读时， 多个goroutine可以同时读。</li>
<li>写的时候， 其他goroutine不可读也不可写。</li>
</ul>
</li>
<li><p>成员方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Lock 将 rw 设置为写锁定状态，禁止其他例程读取或写入。</span><br><span class="line">   func (rw *RWMutex) Lock()</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Unlock 解除 rw 的写锁定状态，如果 rw 未被写锁定，则该操作会引发 panic。</span><br><span class="line">   func (rw *RWMutex) Unlock()</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; RLock 将 rw 设置为读锁定状态，禁止其他例程写入，但可以读取。</span><br><span class="line">   func (rw *RWMutex) RLock()</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Runlock 解除 rw 的读锁定状态，如果 rw 未被读锁顶，则该操作会引发 panic。</span><br><span class="line">   func (rw *RWMutex) RUnlock()</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; RLocker 返回一个互斥锁，将 rw.RLock 和 rw.RUnlock 封装成了一个 Locker 接口。</span><br><span class="line">   func (rw *RWMutex) RLocker() Locker</span><br></pre></td></tr></table></figure></li>
<li><p>示例代码</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">   import (</span><br><span class="line">       &quot;fmt&quot;</span><br><span class="line">       &quot;sync&quot;</span><br><span class="line">       &quot;time&quot;</span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line">   var m *sync.RWMutex</span><br><span class="line">   var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">   func main() &#123;</span><br><span class="line">       m &#x3D; new(sync.RWMutex)</span><br><span class="line">       wg.Add(2)</span><br><span class="line">       go write(1)</span><br><span class="line">       time.Sleep(1 * time.Second)</span><br><span class="line">       go read(2)</span><br><span class="line">       wg.Wait()</span><br><span class="line">   &#125;</span><br><span class="line">   func write(i int) &#123;</span><br><span class="line">       fmt.Println(i, &quot;写开始.&quot;)</span><br><span class="line">       m.Lock()</span><br><span class="line">       fmt.Println(i, &quot;正在写入中......&quot;)</span><br><span class="line">       time.Sleep(3 * time.Second)</span><br><span class="line">       m.Unlock()</span><br><span class="line">       fmt.Println(i, &quot;写入结束.&quot;)</span><br><span class="line">       wg.Done()</span><br><span class="line">   &#125;</span><br><span class="line">   func read(i int) &#123;</span><br><span class="line">       fmt.Println(i, &quot;读开始.&quot;)</span><br><span class="line">       m.RLock()</span><br><span class="line">       fmt.Println(i, &quot;正在读取中......&quot;)</span><br><span class="line">       time.Sleep(1 * time.Second)</span><br><span class="line">       m.RUnlock()</span><br><span class="line">       fmt.Println(i, &quot;读取结束.&quot;)</span><br><span class="line">       wg.Done()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="3-WaitGroup-组等待"><a href="#3-WaitGroup-组等待" class="headerlink" title="3. WaitGroup 组等待"></a>3. WaitGroup 组等待</h5><ol>
<li><p>WaitGroup用于等待一组线程的结束。父线程调用Add方法来设定应等待的线程的数量。每个被等待的线程在结束时应调用Done方法。同时，主线程里可以调用Wait方法阻塞至所有线程结束（计数器归零）。</p>
</li>
<li><p>成员方法    </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 计数器增加 delta，delta 可以是负数。</span><br><span class="line">   func (wg *WaitGroup) Add(delta int)</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 计数器减少 1</span><br><span class="line">   func (wg *WaitGroup) Done()</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 等待直到计数器归零。如果计数器小于 0，则该操作会引发 panic。</span><br><span class="line">   func (wg *WaitGroup) Wait()</span><br></pre></td></tr></table></figure></li>
<li><p>示例代码</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    wg :&#x3D; sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(10)</span><br><span class="line">    for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">        go func(i int) &#123;</span><br><span class="line">            defer wg.Done()</span><br><span class="line">            fmt.Print(i, &quot; &quot;)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="4-Cond-条件等待"><a href="#4-Cond-条件等待" class="headerlink" title="4. Cond 条件等待"></a>4. Cond 条件等待</h5><ol>
<li><p>Cond结构</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Cond struct &#123;</span><br><span class="line">       &#x2F;&#x2F; L is held while observing or changing the condition</span><br><span class="line">       L Locker</span><br><span class="line">       &#x2F;&#x2F; contains filtered or unexported fields</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Cond实现了一个条件变量，一个线程集合地，供线程等待或者宣布某事件的发生。</p>
</li>
<li><p>每个Cond实例都有一个相关的锁（一般是<em>Mutex或</em>RWMutex类型的值），它必须在改变条件时或者调用Wait方法时保持锁定。</p>
</li>
<li><p>Cond可以创建为其他结构体的字段，Cond在开始使用后不能被拷贝。</p>
</li>
<li><p>条件等待通过Wait让例程等待，通过Signal让一个等待的例程继续，通过Broadcase让所有等待的继续。在Wait之前需要手动为c.L上锁， Wait结束了手动解锁。为避免虚假唤醒， 需要将Wait放到一个条件判断的循环中，官方要求写法:</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c.L.Lock()</span><br><span class="line">   <span class="keyword">for</span> !condition() &#123;</span><br><span class="line">       c.Wait()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 执行条件满足之后的动作...</span></span><br><span class="line">   c.L.Unlock()</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员方法</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">       L Locker <span class="comment">// 在&quot;检查条件&quot;或&quot;更改条件&quot;时 L 应该锁定。</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建一个条件等待</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Broadcast 唤醒所有等待的 Wait，建议在&quot;更改条件&quot;时锁定 c.L，更改完毕再解锁。</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Signal 唤醒一个等待的 Wait，建议在&quot;更改条件&quot;时锁定 c.L，更改完毕再解锁。</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Wait 会解锁 c.L 并进入等待状态，在被唤醒时，会重新锁定 c.L</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例代码</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">   <span class="keyword">import</span> (</span><br><span class="line">       <span class="string">&quot;fmt&quot;</span></span><br><span class="line">       <span class="string">&quot;sync&quot;</span></span><br><span class="line">       <span class="string">&quot;time&quot;</span></span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">       condition := <span class="literal">false</span> <span class="comment">// 条件不满足</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">       cond := sync.NewCond(&amp;mu) <span class="comment">// 创建一个Cond</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//让协程去创造条件</span></span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">           mu.Lock()</span><br><span class="line">           condition = <span class="literal">true</span> <span class="comment">// 改写条件</span></span><br><span class="line">           time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">           cond.Signal() <span class="comment">// 发送通知：条件ok</span></span><br><span class="line">           mu.Unlock()</span><br><span class="line">       &#125;()</span><br><span class="line"></span><br><span class="line">       mu.Lock()</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检查条件是否满足，避免虚假通知，同时避免 Signal 提前于 Wait 执行。</span></span><br><span class="line">       <span class="keyword">for</span> !condition &#123; <span class="comment">// 如果Signal提前执行了，那么此处就是false了</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 等待条件满足的通知，如果虚假通知，则继续循环等待</span></span><br><span class="line">           cond.Wait() <span class="comment">// 等待时 mu 处于解锁状态，唤醒时重新锁定。 (阻塞当前线程)</span></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       fmt.Println(<span class="string">&quot;条件满足，开始后续动作...&quot;</span>)</span><br><span class="line">       mu.Unlock()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="5-Locker"><a href="#5-Locker" class="headerlink" title="5. Locker"></a>5. Locker</h5><ol>
<li><p>Locker接口代表一个可以加锁和解锁的对象。 是一个接口。</p>
</li>
<li><p>结构</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Locker interface &#123;</span><br><span class="line">       Lock()</span><br><span class="line">       Unlock()</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-Pool-临时对象池"><a href="#6-Pool-临时对象池" class="headerlink" title="6. Pool 临时对象池"></a>6. Pool 临时对象池</h5></li>
<li><p>我们通常用golang来构建高并发场景下的应用，但是由于golang内建的GC机制会影响应用的性能，为了减少GC，golang提供了对象重用的机制，也就是sync.Pool对象池。</p>
</li>
<li><p>sync.Pool是可伸缩的，并发安全的。其大小仅受限于内存的大小，可以被看作是一个存放可重用对象的值的容器。 设计的目的是存放已经分配的但是暂时不用的对象，在需要用到的时候直接从pool中取。</p>
</li>
<li><p>暂不了解。</p>
</li>
</ol>
<h3 id="四、Go的异常处理"><a href="#四、Go的异常处理" class="headerlink" title="四、Go的异常处理"></a>四、Go的异常处理</h3><h5 id="1-异常与错误的概念"><a href="#1-异常与错误的概念" class="headerlink" title="1. 异常与错误的概念"></a>1. 异常与错误的概念</h5><ol>
<li>异常和错误不是一个概念，但二者经常被弄混。错误指的是可能出现问题的地方出现了问题，比如打开一个文件时失败，这种情况在人们的意料之中 ；而异常指的是不应该出现问题的地方出现了问题，比如引用了空指针，这种情况在人们的意料之外。可见，错误是业务过程的一部分，而异常不是 。</li>
<li>go使用error来处理错误，使用panic和recover来触发和终止异常流程。同时引入关键字defer来延迟执行defer后面的函数（异常后也执行）。</li>
</ol>
<h5 id="2-异常的处理"><a href="#2-异常的处理" class="headerlink" title="2. 异常的处理"></a>2. 异常的处理</h5><ol>
<li>如越界，引用空指针等触发panic，就调用defer函数。</li>
<li>然后向上传递panic，一直到遇到recover接收处理。</li>
<li>如果没有recover，会一直传到协程的起点，然后终止包括主协程在内的所有协程。</li>
</ol>
<h5 id="3-go异常和错误互相转化"><a href="#3-go异常和错误互相转化" class="headerlink" title="3. go异常和错误互相转化"></a>3. go异常和错误互相转化</h5><ol>
<li>错误转异常，如当错误次数过多的时候就抛出异常。</li>
<li>异常转错误，如用recover接收后当做错误处理，程序继续执行。</li>
</ol>
<h5 id="4-异常与错误的使用场景"><a href="#4-异常与错误的使用场景" class="headerlink" title="4. 异常与错误的使用场景"></a>4. 异常与错误的使用场景</h5><ol>
<li>异常使用的场景<ul>
<li>空指针引用</li>
<li>下标越界</li>
<li>除数为0</li>
<li>不应该出现的分支，比如default</li>
<li>输入不应该引起函数错误</li>
</ul>
</li>
<li>对于异常，我们可以选择在一个合适的上游去recover，并打印堆栈信息，使得部署后的程序不会终止。</li>
<li>其他使用错误</li>
</ol>
<h5 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5. 错误处理"></a>5. 错误处理</h5><ol>
<li><p>不要滥用错误，比如有些返回场景是需要bool类型的，也返回一个errors.New(“假的”)，就很不合理。很多没有必要的地方，不用非得返回一个nil。</p>
</li>
<li><p>如果有error返回，应该放在返回列表的最后一位。</p>
</li>
<li><p>错误值要统一定义，不要每个函数想起来什么返回什么。最好每个包里有个专门的错误对象定义文件。如下：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ERR_EOF = errors.New(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line">   <span class="keyword">var</span> ERR_CLOSED_PIPE = errors.New(<span class="string">&quot;io: read/write on closed pipe&quot;</span>)</span><br><span class="line">   <span class="keyword">var</span> ERR_NO_PROGRESS = errors.New(<span class="string">&quot;multiple Read calls return no data or error&quot;</span>)</span><br><span class="line">   <span class="keyword">var</span> ERR_SHORT_BUFFER = errors.New(<span class="string">&quot;short buffer&quot;</span>)</span><br><span class="line">   <span class="keyword">var</span> ERR_SHORT_WRITE = errors.New(<span class="string">&quot;short write&quot;</span>)</span><br><span class="line">   <span class="keyword">var</span> ERR_UNEXPECTED_EOF = errors.New(<span class="string">&quot;unexpected EOF&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>错误逐层传递时，层层都加日志，方便定位。</p>
</li>
<li><p>错误处理使用defer</p>
<ul>
<li><p>当出现错误的时候，需要把之前申请的资源都释放掉，一般如下这样写：</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferDemo</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">          err := createResource1()</span><br><span class="line">          <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> ERR_CREATE_RESOURCE1_FAILED</span><br><span class="line">          &#125;</span><br><span class="line">          err = createResource2()</span><br><span class="line">          <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">              destroyResource1()</span><br><span class="line">              <span class="keyword">return</span> ERR_CREATE_RESOURCE2_FAILED</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          err = createResource3()</span><br><span class="line">          <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">              destroyResource1()</span><br><span class="line">              destroyResource2()</span><br><span class="line">              <span class="keyword">return</span> ERR_CREATE_RESOURCE3_FAILED</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          err = createResource4()</span><br><span class="line">          <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">              destroyResource1()</span><br><span class="line">              destroyResource2()</span><br><span class="line">              destroyResource3()</span><br><span class="line">              <span class="keyword">return</span> ERR_CREATE_RESOURCE4_FAILED</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用defer来释放资源</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func deferDemo() error &#123;</span><br><span class="line">    err :&#x3D; createResource1()</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return ERR_CREATE_RESOURCE1_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            destroyResource1()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    err &#x3D; createResource2()</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return ERR_CREATE_RESOURCE2_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            destroyResource2()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err &#x3D; createResource3()</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return ERR_CREATE_RESOURCE3_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            destroyResource3()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err &#x3D; createResource4()</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return ERR_CREATE_RESOURCE4_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>当尝试几次可以避免失败时，不要立即返回错误，如尝试请求某个URL，有时第一次没有响应可以再试一次。</p>
</li>
<li><p>当上层函数不关心错误时，建议不返回error，只打印日志就行。</p>
</li>
</ol>
<h5 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6. 异常处理"></a>6. 异常处理</h5><ol>
<li><p>在程序开发阶段，坚持速错。在早期开发以及任何发布阶段之前，最简单的同时也可能是最好的方法是调用panic函数来中断程序的执行以强制发生错误，使得该错误不会被忽略，因而能够被尽快修复。</p>
</li>
<li><p>在程序部署后，应恢复异常避免程序终止。在上层函数应该用recover接收异常。可以通过配置文件或环境变量的方式，来区分开发环境和部署环境是否进行recover。</p>
</li>
<li><p>recover一般的处理方法</p>
<ul>
<li>打印堆栈的异常调用信息和关键的业务信息，以便这些问题保留可见；</li>
<li>将异常转换为错误，以便调用者让程序恢复到健康状态并继续安全运行。错误需要自己转换。  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">          <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">              <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">                  fmt.Println(<span class="string">&quot;panic recover! p:&quot;</span>, p)</span><br><span class="line">                  str, ok := p.(<span class="keyword">string</span>)</span><br><span class="line">                  <span class="keyword">if</span> ok &#123;</span><br><span class="line">                      err = errors.New(str)</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      err = errors.New(<span class="string">&quot;panic&quot;</span>)</span><br><span class="line">                  &#125;</span><br><span class="line">                  debug.PrintStack()</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;()</span><br><span class="line">          <span class="keyword">return</span> funcB()</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">          <span class="comment">// simulation</span></span><br><span class="line">          <span class="built_in">panic</span>(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span> errors.New(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">          err := funcA()</span><br><span class="line">          <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">              fmt.Printf(<span class="string">&quot;err is nil\\n&quot;</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              fmt.Printf(<span class="string">&quot;err is %v\\n&quot;</span>, err)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>对于不应该出现的分支，使用异常处理。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch s :&#x3D; suit(drawCard()); s &#123;</span><br><span class="line">       case &quot;Spades&quot;:</span><br><span class="line">       &#x2F;&#x2F; ...</span><br><span class="line">       case &quot;Hearts&quot;:</span><br><span class="line">       &#x2F;&#x2F; ...</span><br><span class="line">       case &quot;Diamonds&quot;:</span><br><span class="line">       &#x2F;&#x2F; ... </span><br><span class="line">       case &quot;Clubs&quot;:</span><br><span class="line">       &#x2F;&#x2F; ...</span><br><span class="line">       default:</span><br><span class="line">           panic(fmt.Sprintf(&quot;invalid suit %v&quot;, s))</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数由用户保证不会出错，一出错立刻panic，减少繁琐的错误处理。比如我确定就是字符串，非得传一个Int，那就直接panic，也不进行错误检查。</p>
</li>
</ol>
<h3 id="五、Go语言中反射包的实现原理"><a href="#五、Go语言中反射包的实现原理" class="headerlink" title="五、Go语言中反射包的实现原理"></a>五、Go语言中反射包的实现原理</h3><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h5><ol>
<li><p>反射是建立在类型系统（the type system）上的。Go是静态类型化的。每个变量都有一个静态类型，也就是说，在编译的时候变量的类型就被很精确地确定下来了。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type MyInt int</span><br><span class="line">var i int</span><br><span class="line">var j MyInt</span><br></pre></td></tr></table></figure>
<ul>
<li>如上，i的类型就是int，而j的类型就是MyInt。这里的变量i和j具有不同的静态类型，虽然它们有相同的底层类型（underlying type），如果不显示的进行强制类型转换它们是不能互相赋值的。</li>
</ul>
</li>
</ol>
<h5 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h5><ul>
<li>应用场景还不知道，看着好像理解是什么，就是能获得对象的类型，但是也不知道这样有什么用。TODO</li>
</ul>
<h3 id="六、Go语言并发的设计模式和应用场景"><a href="#六、Go语言并发的设计模式和应用场景" class="headerlink" title="六、Go语言并发的设计模式和应用场景"></a>六、Go语言并发的设计模式和应用场景</h3><h5 id="1-利用阻塞通道自动生成数据。"><a href="#1-利用阻塞通道自动生成数据。" class="headerlink" title="1. 利用阻塞通道自动生成数据。"></a>1. 利用阻塞通道自动生成数据。</h5><ol>
<li><p>创建一个阻塞通道，每次想要数据了就从中提取。比如可以生成随机数。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func xrange() chan int&#123; &#x2F;&#x2F; xrange用来生成自增的整数</span><br><span class="line">       var ch chan int &#x3D; make(chan int)</span><br><span class="line"></span><br><span class="line">       go func() &#123; &#x2F;&#x2F; 开出一个goroutine</span><br><span class="line">           for i :&#x3D; 0; ; i++ &#123;</span><br><span class="line">               ch &lt;- i  &#x2F;&#x2F; 直到信道索要数据，才把i添加进信道</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;()</span><br><span class="line"></span><br><span class="line">       return ch</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   func main() &#123;</span><br><span class="line"></span><br><span class="line">       generator :&#x3D; xrange()</span><br><span class="line"></span><br><span class="line">       for i:&#x3D;0; i &lt; 1000; i++ &#123;  &#x2F;&#x2F; 我们生成1000个自增的整数！</span><br><span class="line">           fmt.Println(&lt;-generator)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-主程序阻塞通道等待，等到协程执行完发送信号，主程序再推出。"><a href="#2-主程序阻塞通道等待，等到协程执行完发送信号，主程序再推出。" class="headerlink" title="2. 主程序阻塞通道等待，等到协程执行完发送信号，主程序再推出。"></a>2. 主程序阻塞通道等待，等到协程执行完发送信号，主程序再推出。</h5><h5 id="3-指定数据生成器"><a href="#3-指定数据生成器" class="headerlink" title="3. 指定数据生成器"></a>3. 指定数据生成器</h5><ol>
<li>比如指定0和1随机数生成器</li>
<li>如下，其中select是随机执行case语句的，在go的select设计中，每次select，会随机打乱case顺序。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func rand01() chan int &#123;</span><br><span class="line">       ch :&#x3D; make(chan int)</span><br><span class="line"></span><br><span class="line">       go func () &#123;</span><br><span class="line">           for &#123;</span><br><span class="line">               select &#123; &#x2F;&#x2F;select会尝试执行各个case, 如果都可以执行，那么随机选一个执行</span><br><span class="line">               case ch &lt;- 0:</span><br><span class="line">               case ch &lt;- 1:</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;()</span><br><span class="line"></span><br><span class="line">       return ch</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   func main() &#123;</span><br><span class="line">       generator :&#x3D; rand01() &#x2F;&#x2F;初始化一个01随机生成器</span><br><span class="line">   </span><br><span class="line">       &#x2F;&#x2F;测试，打印10个随机01</span><br><span class="line">       for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">           fmt.Println(&lt;-generator)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-定时器"><a href="#4-定时器" class="headerlink" title="4. 定时器"></a>4. 定时器</h5></li>
<li>time.After</li>
<li>定时给通道发消息</li>
</ol>
<h5 id="5-当成先进先出的队列使用"><a href="#5-当成先进先出的队列使用" class="headerlink" title="5. 当成先进先出的队列使用"></a>5. 当成先进先出的队列使用</h5><h5 id="6-菊花链（过滤器）"><a href="#6-菊花链（过滤器）" class="headerlink" title="6. 菊花链（过滤器）"></a>6. 菊花链（过滤器）</h5><ol>
<li><p>这个真的妙不可言</p>
</li>
<li><p>如这个生成素数的例子，这段程序来慢慢分析。</p>
<ul>
<li><p>xrange()可以忽略，直接指定2也行</p>
</li>
<li><p>先看main()函数。</p>
<ul>
<li>筛子中最小的数肯定是素数，然后这个素数的倍数肯定不是素数，每次循环就是做这个事，把这个素数的倍数剔除了。</li>
<li>filter(nums, number)就是剔除操作，number为当前的素数，nums为要剔除的列表，然后会返回一个新的列表。</li>
<li>把新列表中的第一个数取出来，作为下一次循环的筛子，这个数肯定是素数。</li>
<li>当筛子大于100的时候，就是获得的第一个大于100的素数，循环结束。</li>
</ul>
</li>
<li><p>filter()函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    * 利用信道菊花链筛法求某一个整数范围的素数</span><br><span class="line">    * 筛法求素数的基本思想是：把从1开始的、某一范围内的正整数从小到大顺序排列，</span><br><span class="line">    * 1不是素数，首先把它筛掉。剩下的数中选择最小的数是素数，然后去掉它的倍数。</span><br><span class="line">    * 依次类推，直到筛子为空时结束</span><br><span class="line">    *&#x2F;</span><br><span class="line">   package main</span><br><span class="line"></span><br><span class="line">   import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">   func xrange() chan int&#123; &#x2F;&#x2F; 从2开始自增的整数生成器</span><br><span class="line">       var ch chan int &#x3D; make(chan int)</span><br><span class="line"></span><br><span class="line">       go func() &#123; &#x2F;&#x2F; 开出一个goroutine</span><br><span class="line">           for i :&#x3D; 2; ; i++ &#123;</span><br><span class="line">               ch &lt;- i  &#x2F;&#x2F; 直到信道索要数据，才把i添加进信道</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;()</span><br><span class="line"></span><br><span class="line">       return ch</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   func filter(in chan int, number int) chan int &#123;</span><br><span class="line">       &#x2F;&#x2F; 输入一个整数队列，筛出是number倍数的, 不是number的倍数的放入输出队列</span><br><span class="line">       &#x2F;&#x2F; in: 输入队列</span><br><span class="line">       out :&#x3D; make(chan int)</span><br><span class="line">   </span><br><span class="line">       go func() &#123;</span><br><span class="line">           for &#123;</span><br><span class="line">               i :&#x3D; &lt;- in &#x2F;&#x2F; 从输入中取一个</span><br><span class="line">   </span><br><span class="line">               if i % number !&#x3D; 0 &#123;</span><br><span class="line">                   out &lt;- i &#x2F;&#x2F; 放入输出信道</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;()</span><br><span class="line">   </span><br><span class="line">       return out</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   func main() &#123;</span><br><span class="line">       const max &#x3D; 100 &#x2F;&#x2F; 找出100以内的所有素数</span><br><span class="line">       nums :&#x3D; xrange() &#x2F;&#x2F; 初始化一个整数生成器</span><br><span class="line">       number :&#x3D; &lt;-nums  &#x2F;&#x2F; 从生成器中抓一个整数(2), 作为初始化整数</span><br><span class="line">   </span><br><span class="line">       for number &lt;&#x3D; max &#123; &#x2F;&#x2F; number作为筛子，当筛子超过max的时候结束筛选</span><br><span class="line">           fmt.Println(number) &#x2F;&#x2F; 打印素数, 筛子即一个素数</span><br><span class="line">           nums &#x3D; filter(nums, number) &#x2F;&#x2F;筛掉number的倍数</span><br><span class="line">           number &#x3D; &lt;- nums  &#x2F;&#x2F; 更新筛子</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="七、关于golang锁的正确使用方式"><a href="#七、关于golang锁的正确使用方式" class="headerlink" title="七、关于golang锁的正确使用方式"></a>七、关于golang锁的正确使用方式</h3><h5 id="1-尽量减少锁的持有时间"><a href="#1-尽量减少锁的持有时间" class="headerlink" title="1. 尽量减少锁的持有时间"></a>1. 尽量减少锁的持有时间</h5><ol>
<li><p>细化锁的粒度。通过细化锁的粒度来减少锁的持有时间以及避免在持有锁操作的时候做各种耗时的操作。</p>
</li>
<li><p>不要在持有锁的时候做 IO 操作。尽量只通过持有锁来保护 IO 操作需要的资源而不是 IO 操作本身。如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func doSomething() &#123;</span><br><span class="line">      m.Lock()</span><br><span class="line">      item :&#x3D; ...</span><br><span class="line">      http.Get()  &#x2F;&#x2F; 各种耗时的 IO 操作</span><br><span class="line">      m.Unlock()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 改为</span><br><span class="line">  func doSomething() &#123;</span><br><span class="line">      m.Lock()</span><br><span class="line">      item :&#x3D; ...</span><br><span class="line">      m.Unlock()</span><br><span class="line"></span><br><span class="line">      http.Get()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-善用-defer-来确保在函数内正确释放了锁"><a href="#2-善用-defer-来确保在函数内正确释放了锁" class="headerlink" title="2. 善用 defer 来确保在函数内正确释放了锁"></a>2. 善用 defer 来确保在函数内正确释放了锁</h5><ol>
<li>但是注意defer就代表整个函数期间都持有锁，可以用匿名函数。</li>
</ol>
<h5 id="3-在适当时候使用-RWMutex"><a href="#3-在适当时候使用-RWMutex" class="headerlink" title="3. 在适当时候使用 RWMutex"></a>3. 在适当时候使用 RWMutex</h5><ol>
<li>当确定操作不会修改保护的资源时，可以使用 RWMutex 来减少锁等待时间（不同的 goroutine 可以同时持有 RLock, 但是 Lock 限制了只能有一个 goroutine 持有 Lock）</li>
</ol>
<h5 id="4-copy-结构体操作可能导致非预期的死锁"><a href="#4-copy-结构体操作可能导致非预期的死锁" class="headerlink" title="4. copy 结构体操作可能导致非预期的死锁"></a>4. copy 结构体操作可能导致非预期的死锁</h5><ol>
<li>copy 结构体时，如果结构体中有锁的话，记得重新初始化一个锁对象，否则会出现非预期的死锁。</li>
</ol>
<h5 id="5-build-test-时使用-race-参数以便运行时检测数据竞争问题"><a href="#5-build-test-时使用-race-参数以便运行时检测数据竞争问题" class="headerlink" title="5. build/test 时使用 -race 参数以便运行时检测数据竞争问题"></a>5. build/test 时使用 -race 参数以便运行时检测数据竞争问题</h5><h5 id="6-使用-go-deadlock-检测死锁或锁等待问题"><a href="#6-使用-go-deadlock-检测死锁或锁等待问题" class="headerlink" title="6. 使用 go-deadlock 检测死锁或锁等待问题"></a>6. 使用 go-deadlock 检测死锁或锁等待问题</h5><ol>
<li><p>go-deadlock是一个库</p>
</li>
<li><p>示例代码：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">   <span class="keyword">import</span> (</span><br><span class="line">       <span class="string">&quot;net/http&quot;</span></span><br><span class="line">       <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">       sync <span class="string">&quot;github.com/sasha-s/go-deadlock&quot;</span></span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">   <span class="keyword">var</span> url = <span class="string">&quot;http://xxx.com:80&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> &#123;</span><br><span class="line">       mu.Lock()</span><br><span class="line">       <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">       u := url</span><br><span class="line">       http.Get(u)  <span class="comment">// 非预期的在持有锁期间做 IO 操作，导致锁等待时间变长</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="comment">// 检测超过 100 ms 的锁等待</span></span><br><span class="line">       sync.Opts.DeadlockTimeout = time.Millisecond * <span class="number">100</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">       <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">           wg.Add(<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">               <span class="keyword">defer</span> wg.Done()</span><br><span class="line">               do()</span><br><span class="line">           &#125;()</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       wg.Wait()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="7-实现-tryLock-功能"><a href="#7-实现-tryLock-功能" class="headerlink" title="7. 实现 tryLock 功能"></a>7. 实现 tryLock 功能</h5><ol>
<li>一般 Lock() 如果拿不到锁的话，会一直阻塞在那里，在某些场景下这个功能不是我们所期望的结果，我们可能希望程序在一定时间内无法获取到锁的话就做其他操作或者直接返回失败：比如在一个 http server 中，处理请求时因为锁等待时间太长导致客户端大量超时，引发客户端重连以及服务端 goroutine 数量持续增长（虽然客户端超时了，但是处理请求的 goroutine 还在继续处理已超时的请求并且阻塞在了获取锁的地方，然后客户端重连又加重了这个问题，表现就是处理请求的 goroutine 数量直线上升）。这个时候我们就需要有一个类似 tryLock 的功能，在发现短时间内无法获取到锁的时候直接返回失败的响应，防止问题进一步加重（Fail Fast）。</li>
<li>go语言实现tryLock:<a href="https://colobu.com/2017/03/09/implement-TryLock-in-Go/">https://colobu.com/2017/03/09/implement-TryLock-in-Go/</a></li>
</ol>
<h5 id="8-改为使用-channel"><a href="#8-改为使用-channel" class="headerlink" title="8. 改为使用 channel"></a>8. 改为使用 channel</h5><h3 id="八、其他"><a href="#八、其他" class="headerlink" title="八、其他"></a>八、其他</h3><h5 id="1-runtime-GOMAXPROCS"><a href="#1-runtime-GOMAXPROCS" class="headerlink" title="1. runtime.GOMAXPROCS()"></a>1. runtime.GOMAXPROCS()</h5><ol>
<li>&lt;1：不修改任何数值。=1：单核心执行。&gt;1：多核并发执行。</li>
<li>指定的是使用的CPU核数，go1.5以后不指定的话默认使用最大核数。</li>
</ol>
<h5 id="2-go-defer的一些注意事项"><a href="#2-go-defer的一些注意事项" class="headerlink" title="2. go defer的一些注意事项"></a>2. go defer的一些注意事项</h5><ol>
<li>异常后defer函数也会执行，常用来解锁</li>
<li>返回值和defer的执行顺序问题，一般是先把返回值写入，然后开始执行defer。如果defer修改了返回值，分两种情况。<ul>
<li>如果返回值是声明过的，就会修改。func name()(i int)</li>
<li>如果返回值没有声明，在函数中声明并返回的，就不会修改。func name()(int)</li>
</ul>
</li>
</ol>
<h5 id="3-信道死锁-阻塞"><a href="#3-信道死锁-阻塞" class="headerlink" title="3. 信道死锁/阻塞"></a>3. 信道死锁/阻塞</h5><ol>
<li>不指定容量，写入数据就会一直阻塞，直到数据读出。（注意不指定容量和指定容量大小为1，是不一样的，为1说明容量为1，只写入一个数据的时候不阻塞，写入第二个数据的时候如果第一个数据没被读出才阻塞。）</li>
<li>指定容量，当容量满的时候才会阻塞。</li>
</ol>
<h3 id="九、语言相关"><a href="#九、语言相关" class="headerlink" title="九、语言相关"></a>九、语言相关</h3><h5 id="1-map"><a href="#1-map" class="headerlink" title="1. map"></a>1. map</h5><ul>
<li>支持多键索引</li>
<li>delete(map,key)删除元素</li>
<li>sync.Map ，并发map，效率降低，安全性提高，但不支持len()操作，不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。</li>
</ul>
<h5 id="2-goto"><a href="#2-goto" class="headerlink" title="2. goto"></a>2. goto</h5><ul>
<li>使用goto统一处理错误  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    err :&#x3D; firstCheckError()</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        goto onExit</span><br><span class="line">    &#125;</span><br><span class="line">    err &#x3D; secondCheckError()</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        goto onExit</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(&quot;done&quot;)</span><br><span class="line">    return</span><br><span class="line">onExit:</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>python进阶</title>
    <url>/python%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="一、第三方模块"><a href="#一、第三方模块" class="headerlink" title="一、第三方模块"></a>一、第三方模块</h1><h3 id="1-virtualenv"><a href="#1-virtualenv" class="headerlink" title="1. virtualenv"></a>1. virtualenv</h3><ul>
<li>virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。</li>
<li>用pip安装的包都被安装到新建的环境下，系统Python环境不受任何影响<a id="more"></a></li>
<li>使用<ul>
<li>安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install virtualenv</span><br></pre></td></tr></table></figure></li>
<li>创建环境<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtualenv --no-site-packages venv</span><br><span class="line">&#x2F;&#x2F;no-site-packages指的是系统pip的不复制过去，建立一个纯净的python环境</span><br><span class="line">&#x2F;&#x2F;例如Anocanda一个环境，Django单独安装一个环境</span><br><span class="line">&#x2F;&#x2F;有些想用python2，有些用python3，都可以用虚拟环境解决</span><br></pre></td></tr></table></figure></li>
<li>使用环境<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source venv&#x2F;bin&#x2F;activate</span><br></pre></td></tr></table></figure>
<h3 id="2-Tkinter图形库"><a href="#2-Tkinter图形库" class="headerlink" title="2. Tkinter图形库"></a>2. Tkinter图形库</h3></li>
</ul>
</li>
<li>Python提供了多个图形界面的库，如：<ul>
<li>Tkinter： Python标准内置库，能在大多数Unix平台下使用</li>
<li>wxPython： 开源软件    </li>
<li>Jython： 和java有关的一种</li>
<li>PyQT：  和QT有关的一种</li>
</ul>
</li>
</ul>
<h1 id="二、文件操作"><a href="#二、文件操作" class="headerlink" title="二、文件操作"></a>二、文件操作</h1><h3 id="1-读文件"><a href="#1-读文件" class="headerlink" title="1. 读文件"></a>1. 读文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. open file</span><br><span class="line">    open(path,flag[,encoding][,errors])</span><br><span class="line">        path:路径</span><br><span class="line">        flag:打开方式</span><br><span class="line">#常用       r   只读，文件描述符放在文件开头</span><br><span class="line">#常用       rb  只读，文件描述符放在文件开头，以二进制格式打开</span><br><span class="line">            r+  读写，文件描述符放在文件开头</span><br><span class="line">#常用       w   只写，若文件已存在会覆盖，不存在则创建</span><br><span class="line">#常用       wb  打开一个文件只用于写入二进制</span><br><span class="line">            w+  打开一个文件用于读写</span><br><span class="line">            a   追加，若文件存在，文件描述符放在末尾</span><br><span class="line">            a+</span><br><span class="line">            encoding:编码方式</span><br><span class="line">            errors:错误处理</span><br><span class="line">2. operate file</span><br><span class="line">3. close file</span><br><span class="line"></span><br><span class="line">4. 注意</span><br><span class="line">    打开文件后，要注意文件描述符的位置</span><br></pre></td></tr></table></figure>

<ul>
<li>打开文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path&#x3D;r&quot;C:\Users\test.txt&quot;   #文件并不存在</span><br><span class="line">f&#x3D;open(path,&quot;r&quot;)</span><br><span class="line">#f&#x3D;open(path,&quot;r&quot;,encoding&#x3D;&quot;utf-8&quot;,error&#x3D;&quot;ignole&quot;)   ignole指忽略错误</span><br></pre></td></tr></table></figure></li>
<li>读文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##1. 读全部</span><br><span class="line">str1&#x3D;f.read()   #常用</span><br><span class="line"></span><br><span class="line">##2. 读10字节</span><br><span class="line">str2&#x3D;f.read(10)</span><br><span class="line"></span><br><span class="line">##3. 读整行</span><br><span class="line">str3&#x3D;f.readline()   #常用</span><br><span class="line">str4&#x3D;f.readline(10)     #读取10字节，注意不是读取10行，若行字节小于10，读整行</span><br><span class="line"></span><br><span class="line">##4. 读取所有行并返回列表</span><br><span class="line">str5&#x3D;f.readlines()</span><br><span class="line">str6&#x3D;f.readlines(20)    #若一行不足20字节，读一行，若小于20，读取最多不超过20字节的行数</span><br><span class="line"></span><br><span class="line">##5. 修改描述符的位置</span><br><span class="line">f.seek(0)</span><br><span class="line"></span><br><span class="line">##########################################关闭文件</span><br><span class="line"></span><br><span class="line">#1. try···finally</span><br><span class="line">try:</span><br><span class="line">    f1&#x3D;open(path,&#39;r&#39;)</span><br><span class="line">    print(f1.read())</span><br><span class="line">finally:</span><br><span class="line">    if f1:</span><br><span class="line">        f1.close()</span><br><span class="line"></span><br><span class="line">#2. with···as··: 自动关闭</span><br><span class="line"></span><br><span class="line">with open(path,&#39;r&#39;) as f2:</span><br><span class="line">    print(f2.read())</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-写文件"><a href="#2-写文件" class="headerlink" title="2. 写文件"></a>2. 写文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path&#x3D;r&quot;C:\users\test.txt&quot;</span><br><span class="line"></span><br><span class="line">f&#x3D;open(path,&quot;w&quot;)</span><br><span class="line"></span><br><span class="line">#1. 将信息写入缓冲区</span><br><span class="line">f.write(&quot;Gao Lingyu&quot;)   #此时还没写入文件</span><br><span class="line"></span><br><span class="line">#2. 刷新缓冲区</span><br><span class="line">f.flush()   #直接把内部缓冲区的数据立刻写入文件</span><br><span class="line">            #或者等缓冲区满自动刷新</span><br><span class="line">            #关闭文件自动刷新</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">time.sleep(0.01)</span><br><span class="line"></span><br><span class="line">#3. 自动关闭</span><br><span class="line"></span><br><span class="line">with open(path,&quot;a&quot;) as f1:</span><br><span class="line">    f1.write(&quot;Gao Lingyu&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="3-编码与解码"><a href="#3-编码与解码" class="headerlink" title="3. 编码与解码"></a>3. 编码与解码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写爬虫时常用编解码：</span><br><span class="line">    gzip 表示打包格式，要想用uft-8，就不能打包</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#如果wb,rb二进制读写，要进行编解码</span><br><span class="line"></span><br><span class="line">#编码</span><br><span class="line">path&#x3D;r&quot;C:\test.txt&quot;</span><br><span class="line">with open(path,&quot;wb&quot;,encoding&#x3D;&quot;utf-8&quot;) as f1:</span><br><span class="line">    str&#x3D;&quot;gaolingyu&quot;</span><br><span class="line">    f1.write(str.encode(&quot;utf-8&quot;))</span><br><span class="line"></span><br><span class="line">#解码</span><br><span class="line">with open(path,&quot;rb&quot;) as fr:</span><br><span class="line">    data&#x3D;fr.read()</span><br><span class="line">    print(type(data))</span><br><span class="line">    newData&#x3D;data.decode(&quot;utf-8&quot;)</span><br><span class="line">    print(newData)</span><br><span class="line"></span><br><span class="line">#编码和解码要一致才行，要想强行读，可以设置errors&#x3D;&quot;ignore&quot;</span><br></pre></td></tr></table></figure>

<h3 id="4-对特殊数据结构的存储，pickle模块"><a href="#4-对特殊数据结构的存储，pickle模块" class="headerlink" title="4. 对特殊数据结构的存储，pickle模块"></a>4. 对特殊数据结构的存储，pickle模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">就是对特殊数据结构的存储</span><br><span class="line">可以直接在文件中存储这四种结构</span><br><span class="line">存储完后直接查看文件会出现乱码</span><br><span class="line">要用代码读</span><br><span class="line"></span><br><span class="line">数据持久性就是指把数据长期存储，比如存到本地文件</span><br><span class="line"></span><br><span class="line">写：dump</span><br><span class="line">读：load</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pickle   #数据持久性模块</span><br><span class="line"></span><br><span class="line">#list存储</span><br><span class="line">myList&#x3D;[1,2,3,&quot;gaolingyu&quot;]</span><br><span class="line">path&#x3D;r&quot;C:\text.txt&quot;</span><br><span class="line">f&#x3D;open(path,&quot;wb&quot;)</span><br><span class="line">pickle.dump(myList,f)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">#读取</span><br><span class="line">f&#x3D;open(path,&quot;rb&quot;)</span><br><span class="line">tempList&#x3D;pickle.load(f)</span><br><span class="line">print(tempList)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">#其他结构类似，主要是dump,load</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="三、时间系统模块"><a href="#三、时间系统模块" class="headerlink" title="三、时间系统模块"></a>三、时间系统模块</h1><h3 id="1-calendar模块"><a href="#1-calendar模块" class="headerlink" title="1. calendar模块"></a>1. calendar模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#日历模块</span><br><span class="line"></span><br><span class="line">import calendar</span><br><span class="line"></span><br><span class="line">#返回指定月份的日历</span><br><span class="line">print(calendar.month(2018,12))</span><br><span class="line"></span><br><span class="line">#返回指定年份的日历</span><br><span class="line">print(calendar.calendar(2018))</span><br></pre></td></tr></table></figure>

<h3 id="2-datetime模块"><a href="#2-datetime模块" class="headerlink" title="2. datetime模块"></a>2. datetime模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># datetime可以理解为对time的封装，接口更易用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">d1&#x3D;datetime.datetime.now()</span><br><span class="line">print(d1)</span><br><span class="line"></span><br><span class="line">d2&#x3D;datetime.datetime(2000,12,2)</span><br><span class="line">print(d2,type(d2))</span><br><span class="line"></span><br><span class="line">#将时间转为字符串</span><br><span class="line">d3&#x3D;d1.strftime(&quot;%y-%m-%d %X&quot;)</span><br><span class="line">print(d3)</span><br><span class="line"></span><br><span class="line">#算时间差距</span><br><span class="line">d4&#x3D;d1-d2</span><br><span class="line">print(d4,type(d4))</span><br><span class="line">print(d4.days)  #只有这个类才有days属性</span><br></pre></td></tr></table></figure>

<h3 id="3-time模块"><a href="#3-time模块" class="headerlink" title="3. time模块"></a>3. time模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UTC(世界协调时间)</span><br><span class="line">DST(夏令时)</span><br><span class="line"></span><br><span class="line">时间的表示形式：</span><br><span class="line">1. 时间戳：以整形或浮点型表示，以秒为单位，从1970.1.1号开始的计数值</span><br><span class="line">2. 元组：一种Python的数据结构，这个元组有9个整型内容</span><br><span class="line">        year,month,day</span><br><span class="line">        hours,minute,second</span><br><span class="line">        weekday,yearday,flag(0,1,-1)</span><br><span class="line">3. 格式化字符串</span><br><span class="line">    %Y 年份 %m 月份 %d天数 %H 小时</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">#时间戳</span><br><span class="line">t&#x3D;time.time()</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">#UTC时间元组</span><br><span class="line">t&#x3D;time.gmtime()</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">#本地时间元组</span><br><span class="line">t&#x3D;time.localtime()</span><br><span class="line">print(t)</span><br><span class="line">print(type(t))</span><br><span class="line">#将本地时间转换成时间戳</span><br><span class="line">m&#x3D;time.mktime(t)</span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line">q&#x3D;time.strftime(&quot;%Y.%m.%d %H:%M:%S&quot;)</span><br><span class="line">print(q)</span><br><span class="line"></span><br><span class="line">q&#x3D;time.strftime(&quot;%Y.%m.%d %H:%M:%S&quot;,t)</span><br><span class="line">print(q)</span><br><span class="line"></span><br><span class="line">#time.clock() can be used to count time</span><br><span class="line">y1&#x3D;time.clock()</span><br><span class="line">print(y1)</span><br><span class="line">time.sleep(1)</span><br><span class="line">y2&#x3D;time.clock()</span><br><span class="line">print(y2)</span><br><span class="line">print(int(y2-y1))</span><br></pre></td></tr></table></figure>

<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><h1 id="四、OS模块"><a href="#四、OS模块" class="headerlink" title="四、OS模块"></a>四、OS模块</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#OS:包含了普遍的操作系统的功能</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">#获得系统名字</span><br><span class="line">#nt windows</span><br><span class="line">#posix  Linux&#x2F;Unix&#x2F;Mac OS X</span><br><span class="line">print(os.name)</span><br><span class="line"></span><br><span class="line">#获得操作系统详细信息，仅linux下可用</span><br><span class="line">try:</span><br><span class="line">    os.uname()</span><br><span class="line">except:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">#获取系统环境变量</span><br><span class="line">#print(os.environ)</span><br><span class="line">print(os.environ.get(&quot;APPDATA&quot;))</span><br><span class="line"></span><br><span class="line">print(os.curdir)    #当前目录</span><br><span class="line"></span><br><span class="line">print(os.getcwd())  #当前工作目录，即Python脚本所在目录</span><br><span class="line"></span><br><span class="line">print(os.listdir(r&quot;E:\code20G&quot;))    #获得该目录下所有文件，返回一个列表</span><br><span class="line"></span><br><span class="line">os.mkdir(&quot;Python创建的目录&quot;)    #在当前目录下创建文件夹，也可以用绝对路径</span><br><span class="line">os.rmdir(&quot;Python创建的目录&quot;)</span><br><span class="line"></span><br><span class="line">print(os.stat(&quot;filename&quot;))  #获得文件属性</span><br><span class="line"></span><br><span class="line">os.rename(&quot;srcfile&quot;,&quot;newName&quot;)  #改名</span><br><span class="line"></span><br><span class="line">os.remove(&quot;filename&quot;)   #删除文件</span><br><span class="line"></span><br><span class="line">os.system(&quot;notepad&quot;)  #直接执行命令</span><br><span class="line">os.system(&quot;mspaint&quot;)    #画板</span><br><span class="line"></span><br><span class="line">#shutdown -s -t 500 500秒后关机</span><br><span class="line">#shutdown -a    取消关机</span><br><span class="line">os.system(&quot;taskkill &#x2F;f &#x2F;im notepad.exe&quot;)    #关闭指定程序</span><br><span class="line"></span><br><span class="line">os.path.abspath(&quot;.&#x2F;&quot;)   #查看当前路径的绝对路径</span><br><span class="line"></span><br><span class="line">p1&#x3D;&quot;&#x2F;root&quot;</span><br><span class="line">p2&#x3D;&quot;mydir&quot;</span><br><span class="line">os.path.join(p1,p2) #拼接路径，得到 &#x2F;root&#x2F;mydir</span><br><span class="line"></span><br><span class="line">p1&#x3D;&quot;&#x2F;root&#x2F;mydir&#x2F;aaa.txt&quot;</span><br><span class="line">os.path.split(p1)   #得到一个列表，两个元素，[&#39;&#x2F;root&#x2F;mydir&#39;,&#39;aaa.txt&#39;]</span><br><span class="line">os.path.splitext(p1)   #得到一个列表，两个元素，[&#39;&#x2F;root&#x2F;mydir&#x2F;aaa&#39;,&#39;.txt&#39;]</span><br><span class="line">                        #只获取扩展名，没有扩展名的话为空</span><br><span class="line"></span><br><span class="line">os.path.isdir(p1)</span><br><span class="line">os.path.isfile(p1)  #判断文件是否存在</span><br><span class="line">os.path.exists(p1)  #目录是否存在</span><br><span class="line">os.path.getsize(p1) #获得文件大小</span><br></pre></td></tr></table></figure>

<h1 id="五、类"><a href="#五、类" class="headerlink" title="五、类"></a>五、类</h1><h3 id="0-类的定义"><a href="#0-类的定义" class="headerlink" title="0. 类的定义"></a>0. 类的定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 类名(父类列表):</span><br><span class="line">    属性    属性也可以定义在__init__(self)中</span><br><span class="line">    私有属性 在名字前加两个下划线__</span><br><span class="line">    行为</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    __name&#x3D;&quot;&quot;   #私有属性</span><br><span class="line">    age&#x3D;0       #公有属性</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def setName(self,name):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line"></span><br><span class="line">    def getName(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">p&#x3D;Person()</span><br><span class="line">p.setName(&quot;lingyu&quot;)</span><br><span class="line">name&#x3D;p.getName()</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure>

<h3 id="1-单继承"><a href="#1-单继承" class="headerlink" title="1. 单继承"></a>1. 单继承</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class Person(object):</span><br><span class="line">    name&#x3D;&quot;lingyu&quot;</span><br><span class="line">    age&#x3D;0</span><br><span class="line"></span><br><span class="line">    # def __init__(self):</span><br><span class="line">    #     print(&quot;构造函数&quot;)</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">        self.age&#x3D;age</span><br><span class="line">        print(&quot;带参数的构造函数&quot;,self.name,self.age)</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def setName(self,name):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line"></span><br><span class="line">    def getName(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">class Student(Person):</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        super(Student,self).__init__(name,age)</span><br><span class="line">        self.id&#x3D;1000</span><br><span class="line"></span><br><span class="line"># s&#x3D;Student()</span><br><span class="line"></span><br><span class="line">s2&#x3D;Student(&quot;hhh&quot;,10)</span><br><span class="line">print(s2.getName())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-多继承"><a href="#2-多继承" class="headerlink" title="2. 多继承"></a>2. 多继承</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;&#39;&#39;</span><br><span class="line">    若父类中有方法名相同，默认调用继承时排前面的父类的方法名</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">class Father(object):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,money):</span><br><span class="line">        self.money&#x3D;money</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Mather(object):</span><br><span class="line">    def __init__(self,butiful):</span><br><span class="line">        self.butiful&#x3D;butiful</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Child(Father,Mather):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,my_name,money,butiful):</span><br><span class="line">        Father.__init__(self,money)</span><br><span class="line">        Mather.__init__(self,butiful)</span><br><span class="line">        self.name&#x3D;my_name</span><br><span class="line"></span><br><span class="line">c&#x3D;Child(&quot;吕口&quot;,1000,100)</span><br><span class="line">print(c.money)</span><br><span class="line">print(c.name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-对象属性与类属性"><a href="#3-对象属性与类属性" class="headerlink" title="3. 对象属性与类属性"></a>3. 对象属性与类属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对象属性：</span><br><span class="line">    通过对象名调用</span><br><span class="line"></span><br><span class="line">    对象可在实例后，自己临时添加属性</span><br><span class="line"></span><br><span class="line">    临时添加方法：from type import MethodType</span><br><span class="line">                MethodType(要添加的函数名，实例对象名)</span><br><span class="line"></span><br><span class="line">类属性：</span><br><span class="line">    通过类名调用，和C++类中的static类似，但有区别</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    str&#x3D;&quot;这是一个人&quot;    #可通过Person.str访问</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name&#x3D;&quot;这是对象属性&quot;    #不能通过Person.str访问</span><br><span class="line">        </span><br><span class="line">#对象属性的优先级大于类属性</span><br><span class="line">p&#x3D;Person()</span><br><span class="line">print(p.str)</span><br><span class="line">print(Person.str)</span><br><span class="line">p.str&#x3D;&quot;改变了类属性&quot;</span><br><span class="line">p.age&#x3D;18</span><br><span class="line">print(p.age)    #可临时给对象添加属性，类中没添加</span><br><span class="line"></span><br><span class="line">print(Person.str)</span><br><span class="line">print(p.str)</span><br></pre></td></tr></table></figure>

<h3 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4. 构造函数"></a>4. 构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__init__(self)  </span><br><span class="line">在类的对象创建时自动调用</span><br><span class="line">可以不写，但会自动生成一个</span><br><span class="line">构造函数不能有多个，要实现多态可以传多个参数</span><br><span class="line">属性也可以定义在__init__(self)中</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    name&#x3D;&quot;&quot;</span><br><span class="line">    age&#x3D;0</span><br><span class="line"></span><br><span class="line">    # def __init__(self):</span><br><span class="line">    #     print(&quot;构造函数&quot;)</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">        self.age&#x3D;age</span><br><span class="line">        print(&quot;带参数的构造函数&quot;,self.name,self.age)</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def setName(self,name):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line"></span><br><span class="line">    def getName(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">p&#x3D;Person(&quot;lingyu&quot;,18)</span><br></pre></td></tr></table></figure>

<h3 id="5-析构函数"><a href="#5-析构函数" class="headerlink" title="5. 析构函数"></a>5. 析构函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__del__(self)   释放对象时调用 </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    name&#x3D;&quot;&quot;</span><br><span class="line">    age&#x3D;0</span><br><span class="line"></span><br><span class="line">    # def __init__(self):</span><br><span class="line">    #     print(&quot;构造函数&quot;)</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">        self.age&#x3D;age</span><br><span class="line">        print(&quot;带参数的构造函数&quot;,self.name,self.age)</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def setName(self,name):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line"></span><br><span class="line">    def getName(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;析构函数执行了&quot;)</span><br><span class="line"></span><br><span class="line">p&#x3D;Person(&quot;lingyu&quot;,18)</span><br><span class="line"></span><br><span class="line">del p</span><br><span class="line">while 1:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<h3 id="6-重写str"><a href="#6-重写str" class="headerlink" title="6. 重写str()"></a>6. 重写<strong>str</strong>()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    name&#x3D;&quot;&quot;</span><br><span class="line">    age&#x3D;0</span><br><span class="line"></span><br><span class="line">    # def __init__(self):</span><br><span class="line">    #     print(&quot;构造函数&quot;)</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">        self.age&#x3D;age</span><br><span class="line">        print(&quot;带参数的构造函数&quot;,self.name,self.age)</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def setName(self,name):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line"></span><br><span class="line">    def getName(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;这是一个人的类&quot;</span><br><span class="line"></span><br><span class="line">p&#x3D;Person(&quot;lingyu&quot;,18)</span><br><span class="line"></span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure>

<h3 id="7-运算符重载"><a href="#7-运算符重载" class="headerlink" title="7. 运算符重载"></a>7. 运算符重载</h3><ul>
<li>就是重写特殊函数<ul>
<li>例如：__str__(self)等</li>
</ul>
</li>
</ul>
<h1 id="六、模块"><a href="#六、模块" class="headerlink" title="六、模块"></a>六、模块</h1><h3 id="1-包"><a href="#1-包" class="headerlink" title="1.包"></a>1.包</h3><ul>
<li><p>为什么用包：</p>
<ul>
<li>若不同的人写的模块名字相同，引用会发生冲突</li>
</ul>
</li>
<li><p>怎么用：</p>
<ul>
<li>相当于建立一个文件夹，该文件夹下必须有<strong>init</strong>.py文件，有这个文件才能被认为是一个包</li>
</ul>
</li>
</ul>
<h3 id="2-系统模块"><a href="#2-系统模块" class="headerlink" title="2. 系统模块"></a>2. 系统模块</h3><ul>
<li>sys主要用argv属性，获得命令行参数</li>
<li>相当于main(argv,args[])中的args<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">for i in sys.argv:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-自定义模块"><a href="#3-自定义模块" class="headerlink" title="3. 自定义模块"></a>3. 自定义模块</h3><ul>
<li>一个.py文件就是一个模块</li>
<li>__name__==”__main__”的作用  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def hello():</span><br><span class="line">    pass</span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">    print(&quot;只有当这个py文件直接运行时这一段代码\</span><br><span class="line">    才会运行，否则不运行&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;这个py文件被引入其他文件时会执行这句&quot;)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<pre><code>#常用格式：


def main():
    pass


if __name__==&quot;__main__&quot;:
    main()
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 七、高级函数</span><br><span class="line"></span><br><span class="line">### 1. 过滤器</span><br></pre></td></tr></table></figure></code></pre>
<p>filter(fn,lsd)<br>fn: func name<br>lsd: 序列<br>function: 过滤序列<br>        把传入的函数依次作用于序列中的每一个元素，<br>        返回True就保留，False不保留</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">def is_oushu(num):</span><br><span class="line">    if num%2&#x3D;&#x3D;0:</span><br><span class="line">        return True</span><br><span class="line">    return False</span><br><span class="line">list1&#x3D;[1,2,3,4,5,6,7,8,9]</span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line">res&#x3D;filter(is_oushu,list1)</span><br><span class="line">print(list(res))</span><br></pre></td></tr></table></figure>

<h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先进先出</span><br><span class="line">使用collections模块</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line"></span><br><span class="line">#创建一个空队列</span><br><span class="line">queue &#x3D; collections.deque()</span><br><span class="line">print(queue)</span><br><span class="line"></span><br><span class="line">#进队</span><br><span class="line">queue.append(&quot;a&quot;)</span><br><span class="line">queue.append(&quot;b&quot;)</span><br><span class="line">queue.append(&quot;c&quot;)</span><br><span class="line">print(queue)</span><br><span class="line">res1&#x3D;queue.pop()</span><br><span class="line">res2&#x3D;queue.popleft()    #这个才是先进先出</span><br><span class="line">print(res1)</span><br><span class="line">print(res2)</span><br><span class="line">print(queue)</span><br></pre></td></tr></table></figure>

<h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">后进先出</span><br><span class="line">用列表来模拟找</span><br><span class="line">append()入栈</span><br><span class="line">pop()出栈</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stack&#x3D;[]</span><br><span class="line"></span><br><span class="line">stack.append(&quot;a&quot;)</span><br><span class="line">stack.append(&quot;b&quot;)</span><br><span class="line">stack.append(&quot;c&quot;)</span><br><span class="line">print(stack)</span><br><span class="line"></span><br><span class="line">res&#x3D;stack.pop()</span><br><span class="line">print(res)</span><br><span class="line">print(stack)</span><br></pre></td></tr></table></figure>

<h3 id="4-排序"><a href="#4-排序" class="headerlink" title="4. 排序"></a>4. 排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll&#x3D;[4,2,-7,1,5]</span><br><span class="line">ll2&#x3D;sorted(ll)  #默认升序排序</span><br><span class="line"></span><br><span class="line">ll3&#x3D;sorted(ll,key&#x3D;abs)  #按绝对值大小排序</span><br><span class="line">                        #还可以根据key实现自定义排序规则</span><br><span class="line">print(ll)</span><br><span class="line">print(ll2)</span><br><span class="line">print(ll3)</span><br><span class="line"></span><br><span class="line">自己写排序函数</span><br><span class="line">def up_to_len(str):</span><br><span class="line">    return len(str)</span><br><span class="line">ll&#x3D;[&quot;asd&quot;,&quot;as&quot;,&quot;qwded&quot;,&quot;adwwe&quot;]</span><br><span class="line">ll4&#x3D;sorted(ll,key&#x3D;up_to_len)</span><br><span class="line">print(ll4)</span><br></pre></td></tr></table></figure>

<h3 id="5-map-reduce"><a href="#5-map-reduce" class="headerlink" title="5. map,reduce"></a>5. map,reduce</h3><ul>
<li>map就是对列表的每一个元素应用某个函数</li>
<li>reduce是计算<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分布式计算</span><br><span class="line">    map把数据分给不同的主机</span><br><span class="line">    reduce把各主机的结果整合起来</span><br><span class="line"></span><br><span class="line">map(fn,lsd)</span><br><span class="line">fn: 函数</span><br><span class="line">lsd: 序列</span><br><span class="line">功能：将传入的函数依次作用于序列中的每一个元素，</span><br><span class="line">    并把结果作为新的Iterator返回</span><br><span class="line"></span><br><span class="line">reduce(fn,lsd)</span><br><span class="line">fn: 函数</span><br><span class="line">lsd: 列表</span><br><span class="line">功能：一个函数作用在序列上，这个函数必须接受两个参数，</span><br><span class="line">    reduce把结果继续和序列的下一个元素累计运算</span><br><span class="line">例子：reduce(f,[a,b,c])</span><br><span class="line">    等价于：f(f(f(a),b),c)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    map例子</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">def char2int(ch):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">        将character装换成int</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    chs&#x3D;&#123;&quot;0&quot;:0,&quot;1&quot;:1,&quot;2&quot;:2&#125;</span><br><span class="line">    return chs[ch]</span><br><span class="line"></span><br><span class="line">list1&#x3D;[&quot;1&quot;,&quot;2&quot;,&quot;0&quot;]</span><br><span class="line"></span><br><span class="line">result&#x3D;map(char2int,list1)</span><br><span class="line">print(result)</span><br><span class="line">print(list(result))</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">    将other换成string</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">list2&#x3D;[0,1,2,True,4,5,6,7.5,8,9999]</span><br><span class="line">res2&#x3D;map(str,list2)</span><br><span class="line">print(list(res2))</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">    reduce例子</span><br><span class="line">    map不用额外库，reduce需要</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">from functools import reduce</span><br><span class="line"></span><br><span class="line">def count_sum(a,b):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">        计算a+b</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    return a+b</span><br><span class="line"></span><br><span class="line">list3&#x3D;[1,2,3,4]</span><br><span class="line">res&#x3D;reduce(count_sum,list3)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>

<h3 id="6-偏函数"><a href="#6-偏函数" class="headerlink" title="6. 偏函数"></a>6. 偏函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;----------------自己定义的偏函数---------------&quot;)</span><br><span class="line">#自己定义偏函数</span><br><span class="line"></span><br><span class="line">print(int(&quot;1000&quot;))  #默认基数为10</span><br><span class="line"></span><br><span class="line">print(int(&quot;1000&quot;,base&#x3D;2))   #设置基数为2</span><br><span class="line"></span><br><span class="line">#自己定义的偏函数</span><br><span class="line">def int2(str,base&#x3D;2):</span><br><span class="line">    return int(str,base)</span><br><span class="line">print(int2(&quot;1000&quot;))</span><br><span class="line"></span><br><span class="line">print(&quot;----------------调用模块---------------&quot;)</span><br><span class="line"></span><br><span class="line">import functools</span><br><span class="line"></span><br><span class="line">#作用：把一个参数固定住，形成一个新的函数</span><br><span class="line">#把int函数的base参数固定为2</span><br><span class="line">int3&#x3D;functools.partial(int,base&#x3D;2)</span><br><span class="line"></span><br><span class="line">print(int3(&quot;1000&quot;))</span><br></pre></td></tr></table></figure>

<h3 id="7-装饰器"><a href="#7-装饰器" class="headerlink" title="7. 装饰器"></a>7. 装饰器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">概念：是一个闭包，把一个函数当做参数，返回一个替代版的函数</span><br><span class="line">        就是一个返回函数的函数</span><br><span class="line">用途：不能更改原来的函数，又想增加一些功能</span><br></pre></td></tr></table></figure>


<ul>
<li><p>最简单的装饰器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;-------------最简单装饰器----------&quot;)</span><br><span class="line"></span><br><span class="line">def ppp():</span><br><span class="line">    print(&quot;Hello&quot;)</span><br><span class="line"></span><br><span class="line">def outer1(func):</span><br><span class="line">    def inner():</span><br><span class="line">        print(&quot;***&quot;)</span><br><span class="line">        func()</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">f &#x3D; outer1(ppp)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
</li>
<li><p>改进的装饰器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;-------------改进装饰器----------&quot;)</span><br><span class="line"></span><br><span class="line">def outer(func):</span><br><span class="line">    def inner(age):</span><br><span class="line">        if(age&lt;0):</span><br><span class="line">            print(&quot;年龄有误，更改为0&quot;)</span><br><span class="line">            age&#x3D;0</span><br><span class="line">        func(age)</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@outer</span><br><span class="line">def say(age):</span><br><span class="line">    print(&quot;I am %d years old&quot;%(age))</span><br><span class="line"></span><br><span class="line">#上面加 @outer 代替了下面这句</span><br><span class="line">#say&#x3D;outer(say)</span><br><span class="line"></span><br><span class="line">say(-1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>通用的装饰器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;----------------通用装饰器---------------&quot;)</span><br><span class="line"></span><br><span class="line">def outer2(func):</span><br><span class="line">    def inner(*args,**kwargs):</span><br><span class="line">        #添加修改的功能</span><br><span class="line">        print(&quot;装饰器修饰了&quot;)</span><br><span class="line">        return func(*args,**kwargs)</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@outer2</span><br><span class="line">def say2(name,age):</span><br><span class="line">    print(&quot;I am %s, %d years old&quot;%(name,age))</span><br><span class="line"></span><br><span class="line">say2(&quot;吕口&quot;,18)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="8-广度遍历"><a href="#8-广度遍历" class="headerlink" title="8. 广度遍历"></a>8. 广度遍历</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">队列模拟广度优先遍历</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import collections</span><br><span class="line">def getAllDirQueue(path):</span><br><span class="line">    queue&#x3D;collections.deque()</span><br><span class="line">    queue.append(path)</span><br><span class="line">    while len(queue)!&#x3D;0:</span><br><span class="line">        dirPath&#x3D;queue.popleft()</span><br><span class="line">        file_list&#x3D;os.listdir(dirPath)</span><br><span class="line">        for file_name in file_list:</span><br><span class="line">            absPath&#x3D;os.path.join(dirPath,file_name)</span><br><span class="line">            if os.path.isdir(absPath):</span><br><span class="line">                print(&quot;目录：&quot;,file_name)</span><br><span class="line">                queue.append(absPath)</span><br><span class="line">            else:</span><br><span class="line">                print(&quot;文件：&quot;,file_name)</span><br><span class="line"></span><br><span class="line">path  &#x3D;r&quot;E:\Task\3_上_专业英语&quot;</span><br><span class="line">getAllDirQueue(path)</span><br></pre></td></tr></table></figure>

<h3 id="9-深度遍历"><a href="#9-深度遍历" class="headerlink" title="9. 深度遍历"></a>9. 深度遍历</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用栈遍历模拟递归遍历（深度遍历）</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def getAllDirDeep(path,sp):</span><br><span class="line">    stack&#x3D;[]</span><br><span class="line">    stack.append(path)</span><br><span class="line">    sp +&#x3D;&quot;   &quot;</span><br><span class="line">    #当栈为空时结束循环</span><br><span class="line">    while len(stack)!&#x3D;0:</span><br><span class="line">        dirPath&#x3D;stack.pop()</span><br><span class="line">        file_list&#x3D;os.listdir(dirPath)</span><br><span class="line">        for file_name in file_list:</span><br><span class="line">            absPath&#x3D;os.path.join(dirPath,file_name)</span><br><span class="line">            if os.path.isdir(absPath):</span><br><span class="line">                print(sp,&quot;目录：&quot;,file_name)</span><br><span class="line">                stack.append(absPath)</span><br><span class="line">            else:</span><br><span class="line">                print(sp,&quot;文件：&quot;,file_name)</span><br><span class="line"></span><br><span class="line">path&#x3D;r&quot;E:\Task\3_上_专业英语&quot;</span><br><span class="line">sp&#x3D;&quot;&quot;</span><br><span class="line">getAllDirDeep(path,sp)</span><br></pre></td></tr></table></figure>

<h3 id="10-递归遍历目录"><a href="#10-递归遍历目录" class="headerlink" title="10. 递归遍历目录"></a>10. 递归遍历目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">def getAllDir(path,sp):</span><br><span class="line">    #获得当前目录下所有文件</span><br><span class="line">    file_list&#x3D;os.listdir(path)</span><br><span class="line">    sp +&#x3D;&quot;   &quot;</span><br><span class="line">    #判断每一个文件是否是目录，是的话递归遍历，不是的话</span><br><span class="line">    for file_name in file_list:</span><br><span class="line">        abs_path&#x3D;os.path.join(path,file_name)</span><br><span class="line">        if os.path.isdir(abs_path):</span><br><span class="line">            print(sp,&quot;目录：&quot;,file_name)</span><br><span class="line">        #递归</span><br><span class="line">            getAllDir(abs_path,sp)</span><br><span class="line">        else:</span><br><span class="line">            print(sp,&quot;文件：&quot;,file_name)</span><br><span class="line"></span><br><span class="line">sp&#x3D;&quot;&quot;</span><br><span class="line">getAllDir(r&quot;E:\Task\3_上_专业英语&quot;,sp)</span><br></pre></td></tr></table></figure>

<h1 id="八、多任务"><a href="#八、多任务" class="headerlink" title="八、多任务"></a>八、多任务</h1><h3 id="1-用途"><a href="#1-用途" class="headerlink" title="1. 用途"></a>1. 用途</h3><ul>
<li>计算密集型 or IO密集型<ul>
<li>计算密集型就是用CPU比较多，此时进程数等于CPU核数效率最高，例如对视频高清解码</li>
<li>IO密集型就是多IO，此时进程越多越好，但也不能无限多，例如Web应用</li>
</ul>
</li>
</ul>
<h5 id="多任务实现原理"><a href="#多任务实现原理" class="headerlink" title="多任务实现原理"></a>多任务实现原理</h5><pre><code>设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，
通常是一个Master，多个Worker</code></pre>
<h5 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h5><pre><code>主进程是Master，其他进程是Worker
1. 优点
    稳定性高，一个进程崩溃了，不会影响主进程和其他进程
2. 缺点
    创建进程的开销大，Linux下的fork还好，Windows下开销巨大
    操作系统能同时运行的进程数也是有限的</code></pre>
<h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><pre><code>主线程是Master，others is Worker
1. 优点
    在windows下，多线程效率比多进程高
2. 缺点
    任何一个线程挂掉都可能造成整个进程崩溃</code></pre>
<h3 id="2-进程"><a href="#2-进程" class="headerlink" title="2. 进程"></a>2. 进程</h3><h5 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h5><ul>
<li>multiprocessing是一个跨平台的多进程库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def process2():</span><br><span class="line">    while True:</span><br><span class="line">        print(&quot;进程2-------&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;主进程启动&quot;)</span><br><span class="line"></span><br><span class="line">    p&#x3D;Process(target&#x3D;process2)</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        print(&quot;主进程------&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="父子进程的先后顺序"><a href="#父子进程的先后顺序" class="headerlink" title="父子进程的先后顺序"></a>父子进程的先后顺序</h5><ul>
<li>一般子进程启动后，不受父进程的结束影响,可用.join()，让父进程等子进程运行完后再运行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def process2():</span><br><span class="line">    while True:</span><br><span class="line">        print(&quot;进程2----开始---&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        print(&quot;进程2----结束---&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;主进程启动&quot;)</span><br><span class="line"></span><br><span class="line">    p&#x3D;Process(target&#x3D;process2)</span><br><span class="line">    p.start()</span><br><span class="line">    #父进程等子进程结束后再继续向下运行</span><br><span class="line">    p.join()    #此时代码不往下执行</span><br><span class="line">    while True:</span><br><span class="line">        print(&quot;主进程------&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="进程间通信：通过队列实现"><a href="#进程间通信：通过队列实现" class="headerlink" title="进程间通信：通过队列实现"></a>进程间通信：通过队列实现</h5><ul>
<li>有点类似管道<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">from multiprocessing import Process,Queue</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def write(q):</span><br><span class="line">    print(&quot;启动了进程%s&quot; % (os.getpid()))</span><br><span class="line">    for chr in [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;]:</span><br><span class="line">        q.put(chr)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">    print(&quot;子进程%s结束&quot;%(os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def read(q):</span><br><span class="line">    print(&quot;启动了读进程%s&quot; % (os.getpid()))</span><br><span class="line">    while True:</span><br><span class="line">        value&#x3D;q.get(True)</span><br><span class="line">        print(&quot;value&#x3D;&quot;,value)</span><br><span class="line">    print(&quot;结束了读进程%s&quot; % (os.getpid()))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    q&#x3D;Queue()</span><br><span class="line">    pw&#x3D;Process(target&#x3D;write,args&#x3D;(q,))</span><br><span class="line">    pr&#x3D;Process(target&#x3D;read,args&#x3D;(q,))</span><br><span class="line"></span><br><span class="line">    pw.start()</span><br><span class="line">    pr.start()</span><br><span class="line"></span><br><span class="line">    pw.join()</span><br><span class="line">    #pr is a infinite loop and can only be forced to end </span><br><span class="line">    pr.terminate()</span><br><span class="line"></span><br><span class="line">    print(&quot;The parent process ends&quot;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h5><ul>
<li>用于处理大量子进程<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">from multiprocessing import Pool</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def run(name):</span><br><span class="line">    print(&quot;子进程%d启动---%s&quot; % (name,os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(&quot;父进程启动&quot;)    </span><br><span class="line">    #create multiple process</span><br><span class="line">    #use process pool</span><br><span class="line">    #the pool&#39;s default size is the number of core</span><br><span class="line">    pool&#x3D;Pool()</span><br><span class="line">    for i in range(10):</span><br><span class="line">        #create process and manage by pool</span><br><span class="line">        pool.apply_async(run,args&#x3D;(i,))</span><br><span class="line"></span><br><span class="line">    #call close() before call join(), after close(),can&#39;t create new process</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    print(&quot;父进程结束&quot;)   </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="全局变量在多个进程中互不影响"><a href="#全局变量在多个进程中互不影响" class="headerlink" title="全局变量在多个进程中互不影响"></a>全局变量在多个进程中互不影响</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line">num&#x3D;100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    global num</span><br><span class="line">    num +&#x3D; 1</span><br><span class="line">    print(&quot;子进程&quot;,num)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    p&#x3D;Process(target&#x3D;run)</span><br><span class="line">    p2&#x3D;Process(target&#x3D;run)</span><br><span class="line"></span><br><span class="line">    p.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    print(&quot;父进程&quot;,num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h5 id="自己封装进程"><a href="#自己封装进程" class="headerlink" title="自己封装进程"></a>自己封装进程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class lvkouProcess(Process):</span><br><span class="line"></span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        Process.__init__(self)</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;子进程%s启动&quot; % (self.name))</span><br><span class="line">        print(&quot;子进程%s结束&quot; % (self.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(&quot;主进程启动&quot;)</span><br><span class="line">    p&#x3D;lvkouProcess(&quot;LingYu&quot;)</span><br><span class="line">    p.start()   #Automatically call run()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&quot;主进程结束&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="3-线程"><a href="#3-线程" class="headerlink" title="3. 线程"></a>3. 线程</h3><h5 id="入门-1"><a href="#入门-1" class="headerlink" title="入门"></a>入门</h5><ul>
<li>线程用的是进程的空间<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">a&#x3D;10</span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    print(&quot;子线程%s启动&quot; % (threading.current_thread().name))</span><br><span class="line">    print(a)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;子线程%s结束&quot; % (threading.current_thread().name))</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(&quot;主线程%s启动&quot; % (threading.current_thread().name))</span><br><span class="line">    t&#x3D;threading.Thread(target&#x3D;run,name&#x3D;&quot;son&quot;)</span><br><span class="line">    t.start()</span><br><span class="line">    print(&quot;主线程%s结束&quot; % (threading.current_thread().name))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="多线程共享变量"><a href="#多线程共享变量" class="headerlink" title="多线程共享变量"></a>多线程共享变量</h5><ul>
<li>多进程，会对使用内存进行拷贝，各进程互不影响</li>
<li>多线程，各线程共享相同变量，若多个线程同时改一个变量，容易把内存搞乱<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">num&#x3D;0</span><br><span class="line"></span><br><span class="line">def run(n):</span><br><span class="line">    global num</span><br><span class="line">    for i in range(10000000):</span><br><span class="line">        num  +&#x3D; n</span><br><span class="line">        num  -&#x3D; n</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    t&#x3D;threading.Thread(target&#x3D;run,args&#x3D;(9,))</span><br><span class="line">    t2&#x3D;threading.Thread(target&#x3D;run,args&#x3D;(6,))</span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line">    t.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    print(num)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">num&#x3D;0</span><br><span class="line">#锁对象</span><br><span class="line">lock&#x3D;threading.Lock()</span><br><span class="line"></span><br><span class="line">def run(n):</span><br><span class="line">    global num</span><br><span class="line">    for i in range(10000000):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        try:</span><br><span class="line">            num &#x3D;num + n</span><br><span class="line">            num &#x3D;num - n</span><br><span class="line">        finally:#一定要释放锁</span><br><span class="line">            lock.release()</span><br><span class="line">        #下三行与上面功能一样，with能自动释放</span><br><span class="line">        with lock:</span><br><span class="line">            num +&#x3D; n</span><br><span class="line">            num -&#x3D; n</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    t&#x3D;threading.Thread(target&#x3D;run,args&#x3D;(9,))</span><br><span class="line">    t2&#x3D;threading.Thread(target&#x3D;run,args&#x3D;(6,))</span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line">    t.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    print(num)</span><br></pre></td></tr></table></figure>

<h5 id="定时线程"><a href="#定时线程" class="headerlink" title="定时线程"></a>定时线程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    print(&quot;the child thread&quot;)</span><br><span class="line"></span><br><span class="line">#延时5s</span><br><span class="line">t&#x3D;threading.Timer(5,run)</span><br><span class="line"></span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line">t.join()</span><br><span class="line">print(&quot;The parent ends&quot;)</span><br></pre></td></tr></table></figure>

<h5 id="条件变量调度"><a href="#条件变量调度" class="headerlink" title="条件变量调度"></a>条件变量调度</h5><ul>
<li>若不加cond,线程执行是没有顺序的,加了后从0到9依次执行</li>
<li>这只是两个进程，多个进程用到再学吧<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"></span><br><span class="line">cond&#x3D;threading.Condition()</span><br><span class="line"></span><br><span class="line">def run1():</span><br><span class="line">    with cond:</span><br><span class="line">        for i in range(0,10,2):</span><br><span class="line">            print(threading.current_thread().name,i)</span><br><span class="line">            time.sleep(0.2)</span><br><span class="line">            cond.wait() #等待</span><br><span class="line">            cond.notify()   #通知不用等待了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def run2():</span><br><span class="line">    with cond:</span><br><span class="line">        for i in range(1,10,2):</span><br><span class="line">            print(threading.current_thread().name,i)</span><br><span class="line">            time.sleep(0.2)</span><br><span class="line">            cond.notify()</span><br><span class="line">            cond.wait()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    t1&#x3D;threading.Thread(target&#x3D;run1)</span><br><span class="line">    t2&#x3D;threading.Thread(target&#x3D;run2)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    print(&quot;主线程结束&quot;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading,queue,time,random</span><br><span class="line"></span><br><span class="line">#生产者</span><br><span class="line">def product(id,q):</span><br><span class="line">    while True:</span><br><span class="line">        num&#x3D;random.randint(0,10000)</span><br><span class="line">        q.put(num)</span><br><span class="line">        print(&quot;%d product a %d&quot; % (id,num))</span><br><span class="line">        time.sleep(3)</span><br><span class="line">    q.task_done()</span><br><span class="line"></span><br><span class="line">#消费者</span><br><span class="line">def customer(id,q):</span><br><span class="line">    while True:</span><br><span class="line">        item&#x3D;q.get()</span><br><span class="line">        # print(type(item))</span><br><span class="line">        if item is None:</span><br><span class="line">            break</span><br><span class="line">        print(&quot;%d customed %d&quot; % (id,item))</span><br><span class="line">        time.sleep(2)</span><br><span class="line">    q.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    #消息队列</span><br><span class="line">    q&#x3D;queue.Queue()</span><br><span class="line"></span><br><span class="line">    #启动生产者</span><br><span class="line">    for i in range(4):</span><br><span class="line">        threading.Thread(target&#x3D;product,args&#x3D;(i,q)).start()</span><br><span class="line">    #启动消费者</span><br><span class="line">    for i in range(3):</span><br><span class="line">        threading.Thread(target&#x3D;customer,args&#x3D;(i,q)).start()</span><br></pre></td></tr></table></figure>

<h3 id="4-协成"><a href="#4-协成" class="headerlink" title="4. 协成"></a>4. 协成</h3><h5 id="入门-2"><a href="#入门-2" class="headerlink" title="入门"></a>入门</h5><ul>
<li><p>Python协程是通过generator实现的,这就是一个简单的协程</p>
</li>
<li><p>子程序/函数：层级调用，A调用B,B调用C,通过栈实现，调用的顺序明确</p>
</li>
<li><p>协程：看上去也是子程序，但在执行过程中，在子程序内部中可中断，然后转而执行别的子程序</p>
</li>
<li><p>协程实现功能像线程，但是一个线程执行，而不是多个线程调度执行，</p>
</li>
<li><p>协程效率极高，不存在同时写变量的冲突</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def run2():</span><br><span class="line">    data&#x3D;&quot;&quot;</span><br><span class="line">    r&#x3D;yield data</span><br><span class="line">    #第一次send,r&#x3D;None</span><br><span class="line">    print(1,r,data)</span><br><span class="line">    r&#x3D;yield data</span><br><span class="line">    #第二次send,r&#x3D;&quot;hello&quot;</span><br><span class="line">    print(2,r,data)</span><br><span class="line">    r&#x3D;yield data</span><br><span class="line">    #第三次send,r&#x3D;&quot;lingyu&quot;</span><br><span class="line">    print(3,r,data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    print(1)</span><br><span class="line">    yield 10</span><br><span class="line">    print(2)</span><br><span class="line">    yield 20</span><br><span class="line">    print(3)</span><br><span class="line">    yield 30</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    m&#x3D;run()</span><br><span class="line">    print(type(m))</span><br><span class="line">    print(next(m))</span><br><span class="line">    print(next(m))</span><br><span class="line">    print(next(m))</span><br><span class="line">    #数据传输，run2()实现</span><br><span class="line">    m&#x3D;run2()</span><br><span class="line">    print(m.send(None)) #启动</span><br><span class="line">    print(m.send(&quot;hello&quot;))</span><br><span class="line">    print(m.send(&quot;lingyu&quot;))</span><br></pre></td></tr></table></figure>

<h5 id="协程实现消费者生产者"><a href="#协程实现消费者生产者" class="headerlink" title="协程实现消费者生产者"></a>协程实现消费者生产者</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def product(m):</span><br><span class="line">    m.send(None)</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&quot;product %d&quot; % (i))</span><br><span class="line">        recive&#x3D;m.send(i)</span><br><span class="line">        print(&quot;recive %s from cunstom&quot; % (recive))</span><br><span class="line">    m.close()</span><br><span class="line"></span><br><span class="line">def customer():</span><br><span class="line">    data&#x3D;&quot;&quot;</span><br><span class="line">    while True:</span><br><span class="line">        n&#x3D; yield data</span><br><span class="line">        if n&#x3D;&#x3D;None:</span><br><span class="line">            return</span><br><span class="line">        print(&quot;custome %d&quot; % (n))</span><br><span class="line">        data&#x3D;&quot;200&quot;</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    m&#x3D;customer()</span><br><span class="line">    product(m)</span><br></pre></td></tr></table></figure>

<h1 id="九、正则表达式"><a href="#九、正则表达式" class="headerlink" title="九、正则表达式"></a>九、正则表达式</h1><h3 id="1-re模块"><a href="#1-re模块" class="headerlink" title="1. re模块"></a>1. re模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">re.match(pattern,string,flags&#x3D;0)</span><br><span class="line">patter: 匹配的正则表达式</span><br><span class="line">string: 要匹配的字符串，</span><br><span class="line">flags: 标志位，用于控制正则表达式的匹配方式，例如可以忽略大小写</span><br><span class="line">        值如下：re.I    忽略大小写</span><br><span class="line">               re.M     多行匹配,正则表达式中的^操作符能够将给定字符串的每行当做匹配开始</span><br><span class="line">               re.S     .能匹配所有字符，默认匹配除换行符以外的所有字符</span><br><span class="line">               re.U     根据Unicode字符集解析字符 影响\b等</span><br><span class="line">function: 只从头匹配</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">#www.baidu.com</span><br><span class="line">str1&#x3D;&quot;www.baidu.com&quot;</span><br><span class="line">str2&#x3D;&quot;Www.baidu.com&quot;</span><br><span class="line">str3&#x3D;&quot;baidu.com.www&quot;</span><br><span class="line">print(re.match(&quot;www&quot;,str1))</span><br><span class="line">print(re.match(&quot;www&quot;,str2))</span><br><span class="line">print(re.match(&quot;www&quot;,str3))</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">re.search(pattern,string,flags&#x3D;0)</span><br><span class="line"></span><br><span class="line">function: 扫描整个字符串，返回第一个成功的匹配</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">print(&quot;---------------------------------&quot;)</span><br><span class="line">print(re.search(&quot;www&quot;,str1))</span><br><span class="line">print(re.search(&quot;www&quot;,str2))</span><br><span class="line">print(re.search(&quot;www&quot;,str3))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">re.findall(pattern,string,flags&#x3D;0)</span><br><span class="line"></span><br><span class="line">function: 扫描整个字符串，返回所有成功匹配的列表</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">str4&#x3D;&quot;www.baidu.www.com&quot;</span><br><span class="line">print(re.findall(&quot;www&quot;,str4))</span><br></pre></td></tr></table></figure>

<h1 id="十、数据库"><a href="#十、数据库" class="headerlink" title="十、数据库"></a>十、数据库</h1><h3 id="1-mysql"><a href="#1-mysql" class="headerlink" title="1. mysql"></a>1. mysql</h3><ul>
<li>连接中出现的问题：<ul>
<li>一开始这个文件的名字不叫“连接测试.py”，而是”pymysql.py”,和包名重名了就会出问题<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#连接数据库</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">参数1：mysql服务所在主机的IP</span><br><span class="line">参数2: 用户名</span><br><span class="line">参数3：密码</span><br><span class="line">参数4：要连接的数据库名</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">db&#x3D;pymysql.connect(&quot;localhost&quot;,&quot;root&quot;, &quot;123456&quot;,&quot;news&quot;)</span><br><span class="line"></span><br><span class="line">title&#x3D;&#39;贵州大学喜报：我馆“书心旅图”项目获“2018年全民阅读优秀案例奖项”&#39;</span><br><span class="line">publicTime&#x3D;&#39;2018-12-03&#39;</span><br><span class="line">publicContent&#x3D;&#39;2018年11月23日&#39;</span><br><span class="line">visitCount&#x3D;&#39;13&#39;</span><br><span class="line">id&#x3D;1</span><br><span class="line">#创建一个cursor对象</span><br><span class="line">cursor&#x3D;db.cursor()</span><br><span class="line">sql&#x3D;&quot;select version()&quot;</span><br><span class="line"></span><br><span class="line">insert&#x3D;&quot;insert into newsapp_newsitem \</span><br><span class="line">        values(&#39;&quot;+str(id)+&quot;&#39;,&#39;&quot;+title+&quot;&#39;,&#39;&quot;+publicTime+&quot;&#39;,&#39;&quot;+publicContent+&quot;&#39;,&#39;&quot;+visitCount+&quot;&#39;);&quot;</span><br><span class="line">cursor.execute(insert)</span><br><span class="line">db.commit()</span><br><span class="line">#执行sql语句</span><br><span class="line">data&#x3D;cursor.execute(sql)</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line">#断开</span><br><span class="line">cursor.close()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="十一、网络编程"><a href="#十一、网络编程" class="headerlink" title="十一、网络编程"></a>十一、网络编程</h1><h3 id="1-TCP"><a href="#1-TCP" class="headerlink" title="1. TCP"></a>1. TCP</h3><h5 id="clent"><a href="#clent" class="headerlink" title="clent"></a>clent</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">client&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">client.connect((&quot;192.168.1.107&quot;,8081))</span><br><span class="line"></span><br><span class="line">count&#x3D;0</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    count +&#x3D; 1</span><br><span class="line">    data &#x3D; input(&quot;请输入给服务器发送的数据：&quot;)</span><br><span class="line">    client.send(data.encode(&quot;utf-8&quot;))</span><br><span class="line">    info &#x3D; client.recv(1024)</span><br><span class="line">    print(&quot;服务器说：&quot;,info.decode(&quot;utf-8&quot;))</span><br></pre></td></tr></table></figure>

<h5 id="server"><a href="#server" class="headerlink" title="server"></a>server</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">server&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">#绑定IP端口</span><br><span class="line">server.bind((&#39;192.168.1.107&#39;,8081))</span><br><span class="line"></span><br><span class="line">#监听</span><br><span class="line">server.listen(5)</span><br><span class="line">print(&quot;服务器启动成功&quot;)</span><br><span class="line"></span><br><span class="line">#等待连接</span><br><span class="line">client_socket,client_address&#x3D;server.accept()</span><br><span class="line">print(client_socket,&quot;连接成功&quot;,client_address)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    data&#x3D;client_socket.recv(1024)</span><br><span class="line">    if len(data)&gt;0:</span><br><span class="line">        print(&quot;收到：&quot;,client_address,&quot;的数据：&quot;,data.decode(&quot;utf-8&quot;))</span><br><span class="line">        client_socket.send(&quot;已收到，你好&quot;.encode(&quot;utf-8&quot;))</span><br></pre></td></tr></table></figure>

<h5 id="多个client"><a href="#多个client" class="headerlink" title="多个client"></a>多个client</h5><ul>
<li>之前的只能接受一个client连接,这个可以接受多个client的连接<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">server&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">server.bind((&quot;192.168.1.107&quot;,8081))</span><br><span class="line"></span><br><span class="line">server.listen()</span><br><span class="line"></span><br><span class="line">print(&quot;server start sucessfully!&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def deal(sk,address):</span><br><span class="line">    while True:</span><br><span class="line">        data&#x3D;sk.recv(1024).decode(&quot;utf-8&quot;)</span><br><span class="line">        print(&quot;收到&quot;,address,&quot;的消息：&quot;,data)</span><br><span class="line">        sk.send(&quot;已收到&quot;.encode(&quot;utf-8&quot;))</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    client_socket,client_address&#x3D;server.accept()</span><br><span class="line">    t&#x3D;threading.Thread(target&#x3D;deal,args&#x3D;(client_socket,client_address))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-UDP"><a href="#2-UDP" class="headerlink" title="2. UDP"></a>2. UDP</h3><h5 id="client"><a href="#client" class="headerlink" title="client"></a>client</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">client&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    data&#x3D;input(&quot;请输入：&quot;)</span><br><span class="line">    client.sendto(data.encode(&quot;utf-8&quot;),(&quot;192.168.1.107&quot;,8081))</span><br><span class="line">    data&#x3D;client.recv(1024).decode(&quot;utf-8&quot;)</span><br><span class="line">    print(data)</span><br></pre></td></tr></table></figure>

<h5 id="server-1"><a href="#server-1" class="headerlink" title="server"></a>server</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">server&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">server.bind((&quot;192.168.1.107&quot;,8081))</span><br><span class="line"></span><br><span class="line">print(&quot;服务器启动成功&quot;)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    data,address&#x3D;server.recvfrom(1024)</span><br><span class="line">    print(&quot;收到消息：&quot;,data.decode(&quot;utf-8&quot;))</span><br><span class="line">    server.sendto(&quot;已收到&quot;.encode(&quot;utf-8&quot;),address)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>《Cpp Primer Plus》</title>
    <url>/%E3%80%8ACpp-Primer-Plus%E3%80%8B/</url>
    <content><![CDATA[<h1 id="一、杂项"><a href="#一、杂项" class="headerlink" title="一、杂项"></a>一、杂项</h1><h3 id="1-progma-once和ifndef"><a href="#1-progma-once和ifndef" class="headerlink" title="1. progma once和ifndef"></a>1. progma once和ifndef</h3><ol>
<li>ifndef是C++标准，针对代码，若是ifndef后面的名字有重复会出问题</li>
<li>pragma once是非标准，编译器自己实现，针对文件，若是有重复文件，还是会有重复包含问题</li>
</ol>
<a id="more"></a>
<h3 id="2-虚函数"><a href="#2-虚函数" class="headerlink" title="2. 虚函数"></a>2. 虚函数</h3><ol>
<li>子类中重写基类的虚函数时，不要改变参数类型和数量，否则会覆盖。最好不要用默认参数</li>
</ol>
<h1 id="第三章：处理数据"><a href="#第三章：处理数据" class="headerlink" title="第三章：处理数据"></a>第三章：处理数据</h1><ol>
<li>C++新增整型：unsigned long long, long long 至少64位</li>
<li>using std::cout</li>
<li>char类型<ul>
<li>wchar_t: 处理超过8位的字符集，如日文汉子系统。cin/cout处理char流，不适合wchar_t,<br>可以用wcin/wcout。用L表示<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wchar_t a &#x3D; L&#39;c&#39;;</span><br></pre></td></tr></table></figure></li>
<li>char16_t/char32_t: C++11新增类型，wchar_t的长度和特征随着实现而改变，不适合unicode编码，因此新增这两种类型<br>两种都是无符号的，分别用u/U表示<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char16_t c16&#x3D;u&#39;a&#39;;</span><br><span class="line">char32_t c16&#x3D;U&#39;\U0000222B&#39;;</span><br><span class="line">U&quot;hello&quot;;   &#x2F;&#x2F;字符串常量</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>C++11的auto<ul>
<li>和C中的auto不同，作用是编译器根据初始值自动推断数据类型</li>
<li>处理简单类型不必要，用处一般是较复杂的类型，比如STL中的迭代器自动推断。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; test;</span><br><span class="line">auto p&#x3D;test.begin();</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h1 id="第四章：复合类型"><a href="#第四章：复合类型" class="headerlink" title="第四章：复合类型"></a>第四章：复合类型</h1><ol>
<li>数组，char[]字符串，注意若要处理输入，注意\n是否在缓冲区内等等问题，看输入是否符合预期</li>
<li>string(C++98标准)</li>
<li>结构struct,枚举enum,共同体union</li>
<li>指针数组，new int[10] 用delete[]释放，new int用delete释放</li>
<li>自动存储，静态存储，动态存储。实际上就是局部变量存在栈区，static存在数据区，new的存在堆区</li>
<li>数组的替代——vector,vector效率比[]低，但更安全，若想效率高点，可以用array&lt;int,5&gt; a;表示5个int类型的数组</li>
</ol>
<h1 id="第五章：循环和关系表达式"><a href="#第五章：循环和关系表达式" class="headerlink" title="第五章：循环和关系表达式"></a>第五章：循环和关系表达式</h1><ol>
<li>基于范围的for循环(C++11)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double prices[5]&#x3D;&#123;1,2,3,4,5&#125;;</span><br><span class="line">for(double x:prices)&#123;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">for(double &amp;x:prices)&#123;</span><br><span class="line">    x&#x3D;1;&#x2F;&#x2F;这是要修改prices里面的值的话，要加&amp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>其他的for(x;x;x){}, while(x){}, do{}while(x);， 没什么说的</li>
</ol>
<h1 id="第六章：分支语句与逻辑运算符"><a href="#第六章：分支语句与逻辑运算符" class="headerlink" title="第六章：分支语句与逻辑运算符"></a>第六章：分支语句与逻辑运算符</h1><ol>
<li><p><cctype>库<br> 从C继承的（ctype.h）与字符相关的库</p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>作用与返回值</th>
</tr>
</thead>
<tbody><tr>
<td>isalnum(c)</td>
<td>若c是字母或数字，返回true</td>
</tr>
<tr>
<td>其他的</td>
<td>需要时自己搜吧，知道有这个库就ok了</td>
</tr>
<tr>
<td>toupper(c)</td>
<td>返回c的大写，不改变c</td>
</tr>
<tr>
<td>tolower(c)</td>
<td>返回c的小写，不改变c</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="第七、八章：函数"><a href="#第七、八章：函数" class="headerlink" title="第七、八章：函数"></a>第七、八章：函数</h1><ol>
<li>函数指针，回调函数。可以用typedef简化函数声明</li>
<li>内联函数inline，可以替代#define</li>
<li>引用传值，默认参数</li>
<li>函数重载，参数可以数量和类型不同。只有返回值类型不同不算重载</li>
<li>函数模板,可以进行模板函数的重载，只要参数不一样就行 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T,class T2&gt;</span><br><span class="line">T test(T a,T b)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>函数模板具体化<br> 为了解决某些特殊类型的问题，比如结构体不能加减，可以单独写一个针对此结构体的类型函数，如下所示 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;&gt; void test&lt;Student&gt;(Student,Student);</span><br></pre></td></tr></table></figure></li>
<li>函数模板实例化<ul>
<li>实例化和具体化不一样，实例化分为隐士和显示实例化，显示实例化如下，两者的书写格式主要是少个&lt;&gt;  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template void test&lt;int&gt;(int,int);</span><br></pre></td></tr></table></figure></li>
<li>实例化我理解是指定生成这种类型的函数，如上，生成一个参数为int的函数。不然的话得根据参数自己去生成</li>
<li>具体化是在声明的时候用的，实例化实在代码执行中用的<br>(第二次看，，讲真没看懂这条笔记是啥意思，，然后又看了看书就又懂了。。。)</li>
</ul>
</li>
<li>通过使用auto和decltype关键字，可以在模板函数中推导不确定的类型，这个需要的时候再查 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">auto gt(T1 x,T2 y) -&gt; decltype(x+y)&#123;</span><br><span class="line">    ...</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-&gt; decltype(x+y) 是后置返回类型声明，表示返回类型是x+y的类型</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="第九章：内存模型和名称空间"><a href="#第九章：内存模型和名称空间" class="headerlink" title="第九章：内存模型和名称空间"></a>第九章：内存模型和名称空间</h1><ol>
<li><p>存储持续性</p>
<ul>
<li>自动</li>
<li>静态</li>
<li>动态</li>
<li>线程存储持续性(C++11)，上三个和C一样，这个是和线程声明周期一样长的，用thread_local声明</li>
</ul>
</li>
<li><p>作用域和链接性都和C差不多，已经做过笔记不再赘述</p>
</li>
<li><p>mutable 关键字声明的变量，即使加const也可以修改，用在结构体中</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Student&#123;</span><br><span class="line">    int id;</span><br><span class="line">    mutable string name;</span><br><span class="line">&#125;;</span><br><span class="line">const Student s;</span><br><span class="line">&#x2F;&#x2F;s的id不能改，但是名字能改</span><br></pre></td></tr></table></figure></li>
<li><p>函数链接性<br> 默认是外部链接<br> 加上static后就变为内部链接</p>
</li>
<li><p>名称空间</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace lvkou&#123;</span><br><span class="line">    int id;</span><br><span class="line">    bool sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>using使用</p>
<ul>
<li>using声明 lvkou::id=1;</li>
<li>using编译 using namespace lvkou;</li>
<li>using替代typedef using xx=vector<int>;</li>
</ul>
</li>
<li><p>匿名名称空间</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace&#123;</span><br><span class="line">    int aa;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;等价于,即将作用域限制与本文件</span><br><span class="line">static int aa;</span><br></pre></td></tr></table></figure>
<h1 id="第十章：对象和类"><a href="#第十章：对象和类" class="headerlink" title="第十章：对象和类"></a>第十章：对象和类</h1></li>
<li><p>默认构造</p>
<ul>
<li>不写构造函数的话自动生成默认构造</li>
<li>使用：Student s=new Student;  //不加小括号代表使用默认构造——加小括号：Student()</li>
<li>只有一个参数的构造函数，接受参数类型到类类型的隐式转换</li>
<li>用explicit声明的构造函数，不能用于隐式转换</li>
</ul>
</li>
<li><p>析构函数</p>
<ul>
<li>若有堆空间，需要自己写析构函数释放，否则使用默认的析构函数就行</li>
<li>若是虚基类，一定要把析构函数声明为virtual</li>
</ul>
</li>
<li><p>构造函数</p>
<ul>
<li>写在函数里的是赋值，不是初始化，写在函数列表后面的是初始化，初始化顺序和声明顺序一样，和写的顺序无关</li>
<li>初始化列表不能用this指针</li>
</ul>
</li>
<li><p>private,protect,public的用法区别得会</p>
</li>
<li><p>const成员函数<br> 声明为const的函数，只能读取类成员，不能改变类成员，若在类使用过程中定义了一个const的对象，则不能调用非const的成员函数</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void show() const&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>this的使用</p>
<ul>
<li>一般在返回的时候使用，return *this，例如操作符重载</li>
</ul>
</li>
<li><p>const成员变量</p>
<ul>
<li>在类内声明const, 同时要加上static</li>
</ul>
</li>
</ol>
<h1 id="第十一、十二章：使用类"><a href="#第十一、十二章：使用类" class="headerlink" title="第十一、十二章：使用类"></a>第十一、十二章：使用类</h1><ol>
<li>运算符重载<ul>
<li>++的两个重载注意一下，参数加int的是 ++i, 不加int的是i++</li>
<li>仿函数：重载()运算符</li>
<li>除了()、[]、-&gt;、=这四种不能重载为非成员函数外，其他函数都能写为非成员函数。</li>
<li>根据类设计，如果不是必须，把操作符重载写为非成员函数更好一些，尤其是为类定义类型转换时<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student operator&#x3D;(const Student&amp;)&#123;</span><br><span class="line"></span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>友元<ul>
<li>友元函数</li>
<li>友元类</li>
<li>友元成员函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Time的hours是private的, 令该函数为Time类的友元就能访问了</span><br><span class="line">void operator&lt;&lt;(ostream&amp; os,const Time&amp; t)&#123;</span><br><span class="line">    os&lt;&lt;t.hours&lt;&lt;&quot;:&quot;&lt;&lt;&quot;t.minutes&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;但上面这种情况不能处理 cout&lt;&lt;a&lt;&lt;b; 这种连续输出的情况</span><br><span class="line">&#x2F;&#x2F;因为上面相当于(cout&lt;&lt;a)&lt;&lt;b;   而(cout&lt;&lt;a)返回的不是ostream类型，修改如下：</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; os,const Time&amp; t)&#123;</span><br><span class="line">    os&lt;&lt;t.hours&lt;&lt;&quot;:&quot;&lt;&lt;&quot;t.minutes&quot;;</span><br><span class="line">    return os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>拷贝构造/赋值构造<ul>
<li>若有成员变量在堆区，要自己写拷贝构造函数进行深拷贝，否则只是浅拷贝</li>
<li>赋值构造是重写=操作符，和拷贝构造类似，不过应该返回引用类型<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student::Student(Student&amp; s)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Student&amp; operator&#x3D;(const Student&amp; s)&#123;</span><br><span class="line">    ...</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>调用拷贝构造的三种情况<ul>
<li>使用</li>
<li>对象参数</li>
<li>返回对象</li>
</ul>
</li>
<li>析构函数的调用情况<ul>
<li>局部，区域结束调用</li>
<li>static，程序结束调用</li>
<li>new, 手动delete，否则等到程序结束，由操作系统释放</li>
</ul>
</li>
<li>定位new<br> 我去还有这种操作，，，第一次学<br> 就是指定new 后对象放置的空间 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* buf&#x3D;new char[100];</span><br><span class="line">Student* s1,*s2;</span><br><span class="line">s1&#x3D;new(buf) Student;</span><br><span class="line">s2&#x3D;new(buf) Student;</span><br><span class="line">&#x2F;&#x2F;s2把s1覆盖了</span><br></pre></td></tr></table></figure></li>
<li>C++11允许类内初始化，相当于默认值</li>
</ol>
<h1 id="第十三章：类继承"><a href="#第十三章：类继承" class="headerlink" title="第十三章：类继承"></a>第十三章：类继承</h1><ol>
<li><p>继承is-a, 包含has-a</p>
</li>
<li><p>三种继承, 只有public能被对象调用</p>
<table>
<thead>
<tr>
<th>基类访问特性</th>
<th>继承方法</th>
<th>子类访问特性</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>public</td>
<td>public</td>
</tr>
<tr>
<td>protect</td>
<td>-</td>
<td>protect</td>
</tr>
<tr>
<td>private</td>
<td>-</td>
<td>no acess</td>
</tr>
<tr>
<td>public</td>
<td>protect</td>
<td>protect</td>
</tr>
<tr>
<td>protect</td>
<td>-</td>
<td>protect</td>
</tr>
<tr>
<td>private</td>
<td>-</td>
<td>no acess</td>
</tr>
<tr>
<td>public</td>
<td>private</td>
<td>no acess</td>
</tr>
<tr>
<td>protect</td>
<td>-</td>
<td>no acess</td>
</tr>
<tr>
<td>private</td>
<td>-</td>
<td>no acess</td>
</tr>
</tbody></table>
<ul>
<li>无语，Markdown不支持单元格合并，写html又觉得太麻烦了</li>
</ul>
</li>
<li><p>构造</p>
<ul>
<li>派生类先调用基类构造函数，再调用自己的构造函数</li>
<li>若基类构造函数需要参数，在构造函数的初始化列表处传过去</li>
</ul>
</li>
<li><p>多态</p>
<ul>
<li>静态多态：重写基类方法，注意重写和重载的区别</li>
<li>动态多态：基类使用虚方法，注意若有虚方法，基类的析构函数最好也声明为virtual<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 为什么声明为虚析构？</span><br><span class="line">    因为若不声明，则派生类对象结束后会调用基类的析构方法，而不会调用自己的，可能造成内存泄露</span><br><span class="line">- 为什么叫动态？</span><br><span class="line">    若基类存在虚方法，则会对其对象添加一个隐藏成员，保存一个指向函数地址数组的指针，这种数组叫虚函数表，表项为函数地址。在创建对象时，也继承虚表，若是派生类对象，则修改对应函数的地址，这样会额外占些空间，且程序速度降低</span><br><span class="line">- 虚方法在派生类中不一定非要重写，虚函数表项保留基类函数地址，但不重写的话也没必要定义为派生类</span><br><span class="line">- 构造函数不能是虚函数</span><br><span class="line">- 如果重定义时和基类的参数不符合，可能会有警告。会覆盖基类的这个函数，不是重载</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>静态联编和动态联编</p>
<ul>
<li>动态联编，还是有虚继承的时候，用指针运行时才确定对象类型</li>
<li>静态联编，不用指针，直接使用对象，编译期间确定对象类型<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Base *b&#x3D; new Son;&#x2F;&#x2F;动态</span><br><span class="line">Base b; &#x2F;&#x2F;确定为Base基类类型了</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>抽象基类</p>
<ul>
<li>纯虚方法，也叫接口，只定义，在子类中必须重写</li>
<li>顶基类一般全部定义为接口<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtual void eat3()&#x3D;0;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h1 id="第十四章：C-中的代码重用"><a href="#第十四章：C-中的代码重用" class="headerlink" title="第十四章：C++中的代码重用"></a>第十四章：C++中的代码重用</h1><ol>
<li>通常，包含，私有继承，公有继承用于实现has-a的关系</li>
<li>最好使用包含，除非要重新定义虚函数，或者要用到基类的protect成员，否则用包含，容易理解</li>
<li>多重继承，典型的菱形继承问题，可以用虚基类，xxx:virtual public name{};</li>
<li>类模板 template<class T></li>
<li>模板的具体化：隐式实例化，显式实例化，显式具体化。上面说过，不再赘述</li>
<li>模板别名 using aaa=std::vector<int></li>
<li>模板友元，非模板 友元，约束模板友元，非约束模板友元。这个需要的时候再细看。</li>
</ol>
<h1 id="第十五章：友元，异常和其他"><a href="#第十五章：友元，异常和其他" class="headerlink" title="第十五章：友元，异常和其他"></a>第十五章：友元，异常和其他</h1><ol>
<li>友元类的使用</li>
<li>嵌套类的使用</li>
<li>异常处理<ul>
<li>abord(),stdlib.h库，直接退出程序，需要程序员自己判断什么时候调用</li>
<li>返回错误码，在函数参数用用一个参数传指针或引用来存错误码，还是需要程序员自己判断<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool test(int a,int* ERR_CODE)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>异常机制<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;捕获异常</span><br><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">&#125;catch(char* s)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;抛出异常</span><br><span class="line">if(a&#x3D;&#x3D;0)&#123;</span><br><span class="line">    throw &quot;a is 0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>return 和 throw的不同处理方式<ul>
<li>return返回上一个调用此函数的函数</li>
<li>throw一直往上找到catch的语句，没有就abort()</li>
</ul>
</li>
<li>基类引用可以执行派生类对象，这个在多重继承中有用，throw()参数若是对象的话，不能先捕获基类引用</li>
<li>exception类，所有异常类的基类 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;catch(exception&amp; e)&#123;</span><br><span class="line">    cout&lt;&lt;e.what()&lt;&lt;endl;   &#x2F;&#x2F;输入错误信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>new 的异常处理 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F;new 失败时返回null</span><br><span class="line">int* a&#x3D;new(std::nothrow) int;    </span><br></pre></td></tr></table></figure></li>
<li>RTTI 运行阶段类型识别(Runtime Type Identification)<ul>
<li>注意:RTTI只适用于包含虚函数的类</li>
<li>三个支持RTTI的元素<ul>
<li>dynamic_cast 运算符使用一个指向基类的指针来生成一个指向派生类的指针</li>
<li>typeid，返回一个指出对象类型的值</li>
<li>type_info，结构存储有关特定类型的值</li>
</ul>
</li>
<li>dynamic_cast<ul>
<li>它主要是确保类型转换的安全性<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Base *b&#x3D;new Base;</span><br><span class="line">Person *p&#x3D;new Person;</span><br><span class="line">Student *s&#x3D;new Student; &#x2F;&#x2F;注意这三者是依次继承的</span><br><span class="line">Student *p1&#x3D;(Student*)s;    &#x2F;&#x2F;安全的</span><br><span class="line">Student *p2&#x3D;(Student*)b;    &#x2F;&#x2F;不安全</span><br><span class="line">Person* p3&#x3D;(Student*)s;     &#x2F;&#x2F;安全</span><br><span class="line">&#x2F;&#x2F;用dynamic_cast转换后，不安全的就会返回null</span><br><span class="line">Person* s&#x3D;dynamic_cast&lt;Person*&gt;(b)</span><br><span class="line">&#x2F;&#x2F;指针b指向的类型是否可以转换为Person*类型，若果可以转换成功，不行的话返回null</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>typeid(obj)==typeid(obj2),通过这种方式判断是不是同一个类，typeid返回一个type_info类型，能获得对象信息</li>
</ul>
</li>
<li>更严格的类型转换<ul>
<li>dynamic_cast</li>
<li>const_cast    把const改为非const</li>
<li>static_cast   </li>
<li>reinterpret_cast</li>
</ul>
</li>
</ol>
<h1 id="第十六章：string类和标准模板库"><a href="#第十六章：string类和标准模板库" class="headerlink" title="第十六章：string类和标准模板库"></a>第十六章：string类和标准模板库</h1><ol>
<li>string的几种构造函数<ul>
<li>字符串</li>
<li>迭代器</li>
<li>n个字符</li>
<li>初始化列表(C++11)</li>
<li>截取字符串</li>
</ul>
</li>
<li>find的几种用法</li>
<li>size(),capacity(),reserve()的区别<ul>
<li>reserve()是请求最小内存大小</li>
<li>capacity()是返回总内存大小</li>
<li>size()是使用的元素个数</li>
</ul>
</li>
<li>智能指针<ul>
<li>auto_ptr  已弃用，因为可能会有问题，例如把指针赋值给另一个指针后，上一个指针就失效了，但还存在  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;例</span><br><span class="line">unique&lt;Student&gt; p&#x3D;new Student;</span><br><span class="line">unique&lt;Student&gt; q;</span><br><span class="line">q&#x3D;p;    &#x2F;&#x2F;这个赋值会让p失效，万一以后使用p的话就会出错</span><br><span class="line">    &#x2F;&#x2F;为什么让p失效？为了防止以后对同一对象调用两次析构函数</span><br><span class="line">        &#x2F;&#x2F;用unique_ptr的话这里编译不通过，若想赋值的话得用move()</span><br><span class="line">q&#x3D;move(p);</span><br></pre></td></tr></table></figure></li>
<li>unique_ptr    auto_ptr的替代品</li>
<li>share_ptr     能多个指针指向同一对象  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unique&lt;Student&gt; p&#x3D;new Student;</span><br></pre></td></tr></table></figure></li>
<li>注意，auto_ptr和share_ptr只适用于new分配的内存，不适用于new[]。unique两种都适用</li>
</ul>
</li>
<li>vector的使用<ul>
<li>增删改查</li>
<li>for_each(v.begin(),v.end(),dosomething);   对每个元素执行dosomething操作</li>
<li>random_shuffle(v.begin(),v.end());    对v中元素打乱排序</li>
<li>sort(v.begin(),v.end(),compare);  快排，默认从小到大</li>
<li>基于范围的for循环  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(auto &amp;x:v)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意迭代器的本质是指针，某些地方可以用指针代替迭代器，注意是某些地方</li>
<li>cbegin()获得const迭代器，不能修改指向的值</li>
<li>rbegin()等于end()，但二者类型不同</li>
</ul>
</li>
<li>迭代器类型<ul>
<li>输入迭代器</li>
<li>输出迭代器  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这个可以用于输出vector中的元素,等价于把</span><br><span class="line">copy(v.begin(),v.end(),ostream_iterator&lt;int&gt;(cout,&quot; &quot;))</span><br><span class="line">&#x2F;&#x2F;把v中的元素拷贝到输出迭代器，等价于对每个元素执行 cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;</span><br></pre></td></tr></table></figure></li>
<li>正向迭代器</li>
<li>双向迭代器</li>
<li>随即访问迭代器</li>
</ul>
</li>
<li>容器类型<ul>
<li>序列容器<ul>
<li>vector</li>
<li>deque</li>
<li>list 双向链表，容器插入或删除后，迭代器指向元素不变</li>
<li>forward_list(C++11)   单链表，功能没有list强，但简单紧凑</li>
<li>queue</li>
<li>priority_queue    默认底层类是vector，总把最大元素放到队首，也可以自定义首部元素规则</li>
<li>stack</li>
<li>array(C++11)</li>
</ul>
</li>
<li>关联容器<ul>
<li>set</li>
<li>multiset</li>
<li>map</li>
<li>multimap</li>
</ul>
</li>
<li>无序关联容器<br>  关联容器底层实现是红黑树，无序关联容器底层实现是哈希表<ul>
<li>unodered_set</li>
<li>unordered_multiset</li>
<li>unorder_map</li>
<li>unordered_multimap</li>
</ul>
</li>
</ul>
</li>
<li>函数对象（仿函数）<ul>
<li>transform(v.begin(),v.end(),v2.begin(),out,plus&lt;&gt;()) , 更多transform学STL时再细写</li>
<li>看了一些例子，觉得transform用熟练了，无敌啊</li>
</ul>
</li>
<li>算法组<ul>
<li>非修改式序列操作  如find,for_each等</li>
<li>修改式序列操作    如transform,random_shuffle,copy等</li>
<li>排序和相关操作    如sort等</li>
<li>通用数字运算  前三个在<algorithm>,这个在<numeric></li>
</ul>
</li>
<li>其他库<ul>
<li>valarray库<ul>
<li>能方便的对数组内的数值进行计算，指出sum(),max(),min()等的计算。</li>
<li>没有.begin() .end()函数，想用可以 sort(begin(obj),end(obj));</li>
<li>用vectoc存数据，复制到valarray里面进行计算 </li>
</ul>
</li>
</ul>
</li>
<li>模板initializer_list(C++11)</li>
</ol>
<h1 id="第十七章：输入输出和文件"><a href="#第十七章：输入输出和文件" class="headerlink" title="第十七章：输入输出和文件"></a>第十七章：输入输出和文件</h1><ol>
<li><p>输出格式控制：cout.width(5)等，但感觉不如printf方便好记</p>
</li>
<li><p>iomanip，专门控制输出格式的头文件，常用的有setw(),setprecision(),setfill()</p>
</li>
<li><p>文件io,要包含&lt;ifsteam&gt;</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ofstream fout;</span><br><span class="line">fout.open(&quot;xxx.txt&quot;); </span><br><span class="line">fout&lt;&lt;&quot;hello word!&quot;;</span><br><span class="line">fout.close();</span><br><span class="line">string rel;</span><br><span class="line">ifstream fin;</span><br><span class="line">fin.open(&quot;xxx.txt&quot;);</span><br><span class="line">fin&gt;&gt;rel;</span><br><span class="line">fin.close();</span><br></pre></td></tr></table></figure></li>
<li><p>流状态检查</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(!fin.is_open())&#123;</span><br><span class="line">    ......&#x2F;&#x2F;打开失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>文件模式</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ios_base::in</td>
<td>读文件</td>
</tr>
<tr>
<td>ios_base::out</td>
<td>写文件</td>
</tr>
<tr>
<td>ios_base::ate</td>
<td>打开文件并移到文件尾</td>
</tr>
<tr>
<td>ios_base::app</td>
<td>追加到文件尾</td>
</tr>
<tr>
<td>ios_base::trunc</td>
<td>如果文件存在，则截断文件</td>
</tr>
<tr>
<td>ios_base::binary</td>
<td>二进制文件</td>
</tr>
</tbody></table>
<pre><code> 输入流的默认为ios_base::in;
 输出流的默认为ios_base::out|ios_base::trunc</code></pre>
</li>
<li><p>讲真C++文件操作看着真费劲，不如fread,fwrite或者read,write</p>
</li>
</ol>
<h1 id="第十八章：C-新标准"><a href="#第十八章：C-新标准" class="headerlink" title="第十八章：C++新标准"></a>第十八章：C++新标准</h1><ol>
<li>复习前面介绍过的C++11<ul>
<li>新类型 long long ,unsigned long long</li>
<li>统一的初始化，可以用{1,2,3}列表初始化，<ul>
<li>窄缩，禁止将数值赋给无法存储它的数据类型</li>
<li>std::initializer_list</li>
</ul>
</li>
<li>声明<ul>
<li>auto</li>
<li>decltype(x) y,将y声明为和x一个类型，在定义模板时很有用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T,class U&gt;</span><br><span class="line">auto test(T t,U u) -&gt; decltype(T*U)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>返回类型后置，如上代码例子，专门用于模板这种</li>
<li>模板别名 using xx=xxxx; 代替typedef</li>
<li>nullptr,C++11的空指针</li>
</ul>
</li>
<li>智能指针 unique_ptr,shared_ptr,weak_ptr</li>
<li>异常规范的修改<ul>
<li>不能再指明函数可能引发的异常  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test() throw(bad_exp)&#123;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;错误</span><br></pre></td></tr></table></figure></li>
<li>可以声明不会产生异常  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test() noexcept&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>作用域内枚举  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum&#123;a,b,c&#125;     &#x2F;&#x2F;traditional form</span><br><span class="line">enum class a_new&#123;a,b,c&#125; &#x2F;&#x2F;new</span><br><span class="line">enum struce b_new&#123;a,b,c&#125;    &#x2F;&#x2F;new</span><br><span class="line">&#x2F;&#x2F;可以根据类名来选择枚举名，以前不能用重名，现在可以了</span><br></pre></td></tr></table></figure></li>
<li>对类的修改<ul>
<li>explicit  //对构造函数声明，禁止隐式转换</li>
<li>类内成员初始化，可以在创建类的时候初始化成员，当做默认值</li>
</ul>
</li>
<li>模板和STL方面的修改<ul>
<li>基于范围的for循环 for(auto x:v){……}</li>
<li>新增的STL容器 forward_list,unordered_系列，array</li>
<li>新的STL方法   cbegin(),cend(),const迭代器</li>
<li>valarray升级，新加了begin(),end(),使得STL算法可以应用在上面</li>
<li>摒弃export</li>
<li>尖括号<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::vector&lt;&lt;vector&lt;int&gt; &gt; &#x2F;&#x2F;以前为了怕识别成&gt;&gt;,后面要用空格隔开，C++11不用了</span><br><span class="line">std::vector&lt;&lt;vector&lt;int&gt;&gt; &#x2F;&#x2F;C++11这样写也行</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>右值引用<br>  &amp;&amp; 声明，引用等号右边的值  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int &amp;&amp;a&#x3D;x+y;</span><br><span class="line">&#x2F;&#x2F;a为x+y的结果，以后x+y改变，a也不会变</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>移动构造和右值引用<ul>
<li>主要是利用右值引用写构造函数和赋值函数</li>
<li>对程序员来说重要的不是写右值引用的代码，而是使用利用右值引用实现移动语义库的代码</li>
</ul>
</li>
<li>新的类功能</li>
</ol>
<ul>
<li><p>特殊的成员函数，在原有的四个默认情况下新增了两个</p>
<ul>
<li>移动构造函数</li>
<li>移动赋值函数<br>原来的四个是：</li>
<li>默认构造</li>
<li>默认拷贝构造</li>
<li>默认赋值</li>
<li>默认析构</li>
</ul>
</li>
<li><p>默认的方法和禁用的方法</p>
<ul>
<li>Student() =default;   //声明默认构造</li>
<li>Student(const Student&amp;) =delete   //禁止拷贝构造，也可以设置成私有，但不如这个易理解</li>
<li>委托构造，构造中用构造</li>
<li>继承构造函数，就是如果自己没写，就调用基类的相应构造方法，不过派生类的成员变量要通过初始化列表自己初始化<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student(int id,string name,bool boy):b(boy),Base(id,name)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>管理虚方法：override,final</p>
<ul>
<li>要解决的问题：如果派生类重写了基类的虚方法，但是参数不同，这样不会重载，是直接覆盖，基类的那个就不能用了，为了解决这个问题，引入override。</li>
<li>而final是禁止派生类重写这个虚方法</li>
</ul>
</li>
<li><p>override是在派生类中使用的</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在派生类中</span><br><span class="line">virtual void test() override&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>final是在基类中使用的</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtual void test() final&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Lambda函数</p>
<ul>
<li>格式  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[]() -&gt;double&#123;...&#125;</span><br><span class="line">&#x2F;&#x2F;返回double的lambda,也可以不声明返回类型，由decltype自动推断</span><br></pre></td></tr></table></figure></li>
<li>用于函数对象，函数指针的地方，如STL算法</li>
<li>为什么用lambda  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STL中常用为比较表达式替代函数对象</span><br><span class="line">[&#x3D;],[&amp;] 分别传值和传引用访问所有自动变量</span><br><span class="line">[xx]传值使用xx变量，加&amp;传引用</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>包装器/适配器</p>
</li>
<li><p>可变参数模板</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T,class... Args&gt;</span><br><span class="line">void show_list(const T&amp; value,Args&amp;... args)&#123;</span><br><span class="line">    &#x2F;&#x2F;每次只取args里的一个值</span><br><span class="line">    cout&lt;&lt;value&lt;&lt;&quot;, &quot;;</span><br><span class="line">    show_list(args...);&#x2F;&#x2F;这样递归盗用</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void show_list(const T&amp; value)&#123;</span><br><span class="line">    &#x2F;&#x2F;参数只有一个值的情况下，结束递归</span><br><span class="line">    cout&lt;&lt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>并行编程</p>
<ul>
<li>thread_local把变量声明为和线程生命周期一样长</li>
<li>线程支持库：thread,mutex,condition_variable,future</li>
</ul>
</li>
<li><p>新增的库</p>
<ul>
<li>tuple:扩展的pair，可以存储多个类型不同的值</li>
<li>regex:正则表达式库</li>
<li>chrono:处理时间间隔</li>
<li>ratio:有理算数库，对有理数的算术运算</li>
</ul>
</li>
<li><p>低级编程</p>
<ul>
<li>不是质量低级，而是更底层。</li>
<li>constexpr 机制让编译器能够在编译阶段计算结果为常量的表达式</li>
</ul>
</li>
<li><p>杂项</p>
<ul>
<li>assert,static_assert</li>
<li>元编程加强</li>
</ul>
</li>
<li><p>语言变化</p>
<ul>
<li>boost,tr1,标准库的实验场</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《Effective C++》</title>
    <url>/%E3%80%8AEffective-C-%E3%80%8B/</url>
    <content><![CDATA[<h1 id="1-视C-为一个语言联邦"><a href="#1-视C-为一个语言联邦" class="headerlink" title="1.视C++为一个语言联邦"></a>1.视C++为一个语言联邦</h1><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><p>C++是一个多重泛型编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式，具有强大的能力和弹性。</p>
<a id="more"></a>
<h5 id="四个次语言"><a href="#四个次语言" class="headerlink" title="四个次语言"></a>四个次语言</h5><p>将C++视为语言联邦，有多个次语言</p>
<ol>
<li>C: 没有模板，异常，重载，类的C。</li>
<li>Object-Oriented C++: C with class, 封装，继承，多态，虚函数。</li>
<li>Template C++: C++泛型编程。拓展出元编程能力。</li>
<li>STL: 容器，迭代器，算法</li>
</ol>
<h5 id="什么是元编程"><a href="#什么是元编程" class="headerlink" title="什么是元编程"></a>什么是元编程</h5><p>可以扩展程序自身，这样的能力，为元编程。<br>扣定义的话，动态生成html的程序也可以叫元编程。<br>Lisp 以元编程为基本。而 Ruby 因为元编程易用又强大。</p>
<h1 id="2-尽量以const-enum-inline替换-define"><a href="#2-尽量以const-enum-inline替换-define" class="headerlink" title="2.尽量以const,enum,inline替换#define"></a>2.尽量以const,enum,inline替换#define</h1><h5 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define &#x2F;&#x2F;处于预处理阶段 </span><br><span class="line">#define MAX 1.6</span><br><span class="line">#define CALL_MAX(a,b) f((a)&gt;(b)?(a):(b)) </span><br></pre></td></tr></table></figure>

<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ol>
<li><p>#define MAX 1.6</p>
<ul>
<li>预处理阶段就会把MAX全换成1.6，当运用此常量得到编译错误信息后，可能不知所云，因为错误信息也许会提到1.6而不是MAX</li>
<li>可能会导致生成多个常量1.6，码量可能会大一点。</li>
</ul>
</li>
<li><p>#define CALL_MAX(a,b) f((a)&gt;(b)?(a):(b)) </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;5;</span><br><span class="line">b&#x3D;0;</span><br><span class="line">CALL_MAX(++a,b);  &#x2F;&#x2F;a被加两次</span><br><span class="line">CALL_MAX(++a,b+10);  &#x2F;&#x2F;a被加一次</span><br><span class="line">    &#x2F;&#x2F;a的递增次数要看代码执行了几次。</span><br></pre></td></tr></table></figure>
<p> 可以改为</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline int test(const int&amp; a,const int&amp; b)&#123;</span><br><span class="line">    return a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在类中使用一个不变的值，可以定义为const,最好再定义为static，只保留一份</p>
</li>
</ol>
<h5 id="谨记"><a href="#谨记" class="headerlink" title="谨记"></a>谨记</h5><ol>
<li>对于单纯常量，最好用const或enum替换#define.</li>
<li>对于形似函数的宏，最好用inline函数替换#define.</li>
<li>#define在控制编译上还是有用的，#ifdef,#ifndef</li>
</ol>
<h1 id="3-尽可能使用const"><a href="#3-尽可能使用const" class="headerlink" title="3.尽可能使用const"></a>3.尽可能使用const</h1><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char val&#x3D;&quot;hello&quot;;</span><br><span class="line">char* p &#x3D; val;</span><br><span class="line">const char* p &#x3D; val;    &#x2F;&#x2F;p指向的数据不能变</span><br><span class="line">char* const p &#x3D; val;    &#x2F;&#x2F;p不能变</span><br><span class="line">const char* const p &#x3D; val;  &#x2F;&#x2F;都不能变</span><br></pre></td></tr></table></figure>

<p>这一条除了上面的懂了，下面的，讲真的，complex。</p>
<h1 id="4-确定对象被使用前已被初始化"><a href="#4-确定对象被使用前已被初始化" class="headerlink" title="4.确定对象被使用前已被初始化"></a>4.确定对象被使用前已被初始化</h1><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ol>
<li>为内置对象进行手工初始化；</li>
<li>对于对象，构造函数最好用初始化列表，在构造函数中写的是赋值，不是初始化。初始化次序和它们在类中声明的顺序一样。</li>
<li>单实例模式。</li>
</ol>
<h1 id="5-了解C-默默编写并调用哪些函数"><a href="#5-了解C-默默编写并调用哪些函数" class="headerlink" title="5.了解C++默默编写并调用哪些函数"></a>5.了解C++默默编写并调用哪些函数</h1><h5 id="一个空类默认生成的几个函数"><a href="#一个空类默认生成的几个函数" class="headerlink" title="一个空类默认生成的几个函数"></a>一个空类默认生成的几个函数</h5><ol>
<li>默认构造     default<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student s;</span><br></pre></td></tr></table></figure></li>
<li>拷贝构造     copy<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student s(s2);</span><br></pre></td></tr></table></figure></li>
<li>=重载    copy assinment<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student s;</span><br><span class="line">s&#x3D;s2;</span><br></pre></td></tr></table></figure></li>
<li>析构函数</li>
</ol>
<h1 id="6-若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#6-若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="6.若不想使用编译器自动生成的函数，就该明确拒绝"></a>6.若不想使用编译器自动生成的函数，就该明确拒绝</h1><ol>
<li>将copy构造和copy assignment声明为private而不实现</li>
<li>写一个uncopyable,将copy构造和copy assignment声明为private而不实现，然后继承此类的类就都不能copy和=了。</li>
</ol>
<h1 id="7-为多态基类生明virtual析构函数"><a href="#7-为多态基类生明virtual析构函数" class="headerlink" title="7.为多态基类生明virtual析构函数"></a>7.为多态基类生明virtual析构函数</h1><h5 id="virtual析构函数"><a href="#virtual析构函数" class="headerlink" title="virtual析构函数"></a>virtual析构函数</h5><ol>
<li>抽象类最好声明一个virtual的析构函数。如果类中带有任何virtual，都最好声明一个virtual的析构函数。</li>
<li>非基类最好不要声明virtual析构函数</li>
</ol>
<h1 id="8-别让异常逃离析构函数"><a href="#8-别让异常逃离析构函数" class="headerlink" title="8.别让异常逃离析构函数"></a>8.别让异常逃离析构函数</h1><h5 id="析构函数的异常"><a href="#析构函数的异常" class="headerlink" title="析构函数的异常"></a>析构函数的异常</h5><ol>
<li><p>析构函数最好不要抛出任何异常，不然会导致不可预料的结果。如果可能有异常，就在异常发生时强制结束程序或者记录异常，不处理继续执行。</p>
</li>
<li><p>析构函数中的异常处理，程序猿最好在外面自己另外定义一个函数处理。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">有一个数据库管理类，在析构函数中要调用db.close()。可能会有异常。</span><br><span class="line">这是应该自己写个close函数，将关闭数据库的函数写到自己的函数中，并自己调用，而不应该交给析构函数。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="9-绝不在构造和析构过程中调用virtual函数"><a href="#9-绝不在构造和析构过程中调用virtual函数" class="headerlink" title="9.绝不在构造和析构过程中调用virtual函数"></a>9.绝不在构造和析构过程中调用virtual函数</h1><ol>
<li>因为基类在构造和析构过程中调用的虚函数不能传到派生类</li>
<li>派生类实例化时，先基类调用构造函数，但此时虚函数还是一个未知的函数。</li>
</ol>
<h1 id="10-令operator-返回一个reference-to-this"><a href="#10-令operator-返回一个reference-to-this" class="headerlink" title="10.令operator=返回一个reference to *this"></a>10.令operator=返回一个reference to *this</h1><h5 id="为了实现连锁赋值"><a href="#为了实现连锁赋值" class="headerlink" title="为了实现连锁赋值"></a>为了实现连锁赋值</h5><ol>
<li><p>x=y=z=5 等价于 x=(y=(z=5))</p>
</li>
<li><p>为了实现“连锁赋值”，必须返回一个reference to *this.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int&amp; operator&#x3D;(const int&amp; rhs)&#123;</span><br><span class="line">    ---</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="11-在operator-中处理”自我赋值”"><a href="#11-在operator-中处理”自我赋值”" class="headerlink" title="11.在operator=中处理”自我赋值”"></a>11.在operator=中处理”自我赋值”</h1></li>
<li><p>必须判断自我赋值，不然可能出问题，例如返回本身的引用，却在赋值前先把自己delete了（书上的例子），总之实现自我赋值就是了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(this&#x3D;&#x3D;&amp;rhs)&#123;</span><br><span class="line">    &#x2F;&#x2F;如果是本身就不做操作</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line">else 做其他的赋值操作</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="12-复制对象时勿忘其每一个成分"><a href="#12-复制对象时勿忘其每一个成分" class="headerlink" title="12.复制对象时勿忘其每一个成分"></a>12.复制对象时勿忘其每一个成分</h1><h5 id="copy构造和copy-assignment要写完全"><a href="#copy构造和copy-assignment要写完全" class="headerlink" title="copy构造和copy assignment要写完全"></a>copy构造和copy assignment要写完全</h5><ol>
<li>即该复制的都要复制</li>
<li>派生类复制对象的时候也必须调用基类的拷贝函数</li>
<li>一般自己写copy构造是需要深拷贝的情况，即有指针的情况下，不然的话默认拷贝构造可能比自己写的好用。</li>
<li>不要让赋值函数调用拷贝构造函数，建立独立的成员函数来做这件事。一般是private函数并命名为Init。所有copying函数共同调用此函数</li>
</ol>
<h1 id="13-以对象管理资源"><a href="#13-以对象管理资源" class="headerlink" title="13.以对象管理资源"></a>13.以对象管理资源</h1><h5 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h5><ol>
<li>动态分配内存</li>
<li>文件描述符</li>
<li>互斥锁</li>
<li>图形界面中的笔刷</li>
<li>数据库连接</li>
<li>socket</li>
<li>……</li>
</ol>
<h5 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h5><ol>
<li><p>获得资源后立即放进管理对象，如智能指针auto_ptr，定义为智能指针，自己不用释放，指针结束后会自己调用析构函数释放资源。</p>
</li>
<li><p>管理对象运用析构函数确保资源被释放</p>
</li>
<li><p>两个RAII(罐装容器)：tr1::shared_ptr 和 auto_ptr. RAII设计还是比较精巧的，而且很有用，不过比较难用。</p>
</li>
<li><p>tr1::shared_ptr 的复制会增加引用计数，析构会减少引用计数。当引用计数变成0才真正释放资源。</p>
</li>
<li><p>auto_ptr 复制的时候，原来的指针变为NULL,只保留一份资源</p>
</li>
</ol>
<h1 id="14-在资源管理类中小心coping行为"><a href="#14-在资源管理类中小心coping行为" class="headerlink" title="14.在资源管理类中小心coping行为"></a>14.在资源管理类中小心coping行为</h1><ol>
<li>复制RAII对象必须一起复制他所管理的资源，资源的copying行为决定了RAII（罐装容器）对象的copying行为</li>
<li>RAII即对对象资源处理的封装，要控制释放资源。</li>
<li>RAII class copying行为一般有两种：禁止copy，对资源引用计数。</li>
</ol>
<h1 id="15-在资源管理类中提供对原始资源的访问"><a href="#15-在资源管理类中提供对原始资源的访问" class="headerlink" title="15.在资源管理类中提供对原始资源的访问"></a>15.在资源管理类中提供对原始资源的访问</h1><ol>
<li>每一个RAII class应该提供一个”取得资源” 的办法</li>
<li>比如tr1::shared_ptr 提供了get函数</li>
</ol>
<h1 id="16-成对使用new和delete时要采取相同形式"><a href="#16-成对使用new和delete时要采取相同形式" class="headerlink" title="16.成对使用new和delete时要采取相同形式"></a>16.成对使用new和delete时要采取相同形式</h1><ol>
<li>new[] –&gt; delete[]，即new中不用[]，delete也不要用[]，要不就都用。</li>
</ol>
<h1 id="17-以独立语句将newed对象置入智能指针"><a href="#17-以独立语句将newed对象置入智能指针" class="headerlink" title="17.以独立语句将newed对象置入智能指针"></a>17.以独立语句将newed对象置入智能指针</h1><ol>
<li>总结就是 new 一个对象和把它放入一个只能指针中间不能再执行其他代码，不然抛异常的话，对象没有被智能指针管理，就会造成内存泄露。书上的例子比较有意思。</li>
</ol>
<h1 id="18-让接口容易被正确使用，不易被误用"><a href="#18-让接口容易被正确使用，不易被误用" class="headerlink" title="18.让接口容易被正确使用，不易被误用"></a>18.让接口容易被正确使用，不易被误用</h1><ol>
<li><p>不一致性造成的开发人员心理和肉体上的摩擦与争执，没任何一个IDE可以完全消除</p>
</li>
<li><p>“促进正确使用”的办法包括接口的一致性以及与内置类型的行为兼容</p>
</li>
<li><p>“阻止误用”的办法包括建立新类型、限制类型上的操作、束缚对象值、消除客户的资源管理责任</p>
</li>
<li><p>tr1::shared_ptr 支持定制型删除器。可被用来自动解除互斥锁</p>
</li>
</ol>
<h1 id="19-设计class犹如设计type"><a href="#19-设计class犹如设计type" class="headerlink" title="19.设计class犹如设计type"></a>19.设计class犹如设计type</h1><ol>
<li>就是设计class时要考虑全面</li>
</ol>
<h1 id="20-宁以pass-by-reference-to-const替换pass-by-value"><a href="#20-宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="20.宁以pass-by-reference-to-const替换pass-by-value"></a>20.宁以pass-by-reference-to-const替换pass-by-value</h1><ol>
<li>自己定义的对向尽量引用传递，而不是值传递。</li>
<li>引用传递可以避免切割问题。什么是切割问题呢？就是传一个带有自己特性的子类对象，若直接值传递，就会复制，可能就传的是个基类对向了。如传Windows窗口，具体看书吧。</li>
</ol>
<h1 id="21-必须返回对象时，别妄想返回其reference"><a href="#21-必须返回对象时，别妄想返回其reference" class="headerlink" title="21.必须返回对象时，别妄想返回其reference"></a>21.必须返回对象时，别妄想返回其reference</h1><ol>
<li>不要返回一个reference指向local stack对象或者heap-allcated对象</li>
</ol>
<h1 id="22-将成员变量声明为private"><a href="#22-将成员变量声明为private" class="headerlink" title="22.将成员变量声明为private"></a>22.将成员变量声明为private</h1><ol>
<li><p>这可赋予用户数据访问的一致性。</p>
</li>
<li><p>protected不比public更具封装性</p>
</li>
<li><p>封装性与 “当其内容改变时可能造成的代码破坏量” 成反比。（封装的越好，内容改变造成的破坏越小）</p>
</li>
</ol>
<h1 id="23-宁以non-member、non-friend替换member函数"><a href="#23-宁以non-member、non-friend替换member函数" class="headerlink" title="23.宁以non-member、non-friend替换member函数"></a>23.宁以non-member、non-friend替换member函数</h1><ol>
<li>即如果可以的话，尽量非成员函数实现某些功能，可以传入对向的引用对对象进行操作。</li>
</ol>
<h1 id="24-若所有参数皆需类型转换，请为此采用non-member函数"><a href="#24-若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="24.若所有参数皆需类型转换，请为此采用non-member函数"></a>24.若所有参数皆需类型转换，请为此采用non-member函数</h1><ol>
<li><p>令classes支持隐式类型转换是个糟糕的主意，即最好加上explicit声明禁止隐式转换。</p>
</li>
<li><p>如果需要为某个函数的所有参数进行类型转换，那么这个函数必须是一个non-member</p>
</li>
</ol>
<h1 id="25-考虑写出一个不抛异常的swap函数"><a href="#25-考虑写出一个不抛异常的swap函数" class="headerlink" title="25.考虑写出一个不抛异常的swap函数"></a>25.考虑写出一个不抛异常的swap函数</h1><ol>
<li><p>标准库的swap(T &amp;a,T &amp;b);仅支持T类型有copy构造或copy assignment的情况。</p>
</li>
<li><p>需要自己写swap的时候要注意，，，一般也不需要自己写吧。</p>
</li>
</ol>
<h1 id="26-尽可能延后变量定义式的出现时间"><a href="#26-尽可能延后变量定义式的出现时间" class="headerlink" title="26.尽可能延后变量定义式的出现时间"></a>26.尽可能延后变量定义式的出现时间</h1><ol>
<li><p>对象的构造和析构都会造成开销。尽量在使用的时候再定义。</p>
</li>
<li><p>最好在定义的时候初始化，可以省去默认构造的开销。</p>
</li>
</ol>
<h1 id="27-尽量少做转型动作"><a href="#27-尽量少做转型动作" class="headerlink" title="27.尽量少做转型动作"></a>27.尽量少做转型动作</h1><h4 id="转型"><a href="#转型" class="headerlink" title="转型"></a>转型</h4><h6 id="1-旧式转型"><a href="#1-旧式转型" class="headerlink" title="(1)旧式转型"></a>(1)旧式转型</h6><pre><code>(int)a;
int(a);//都是将a转换成int类型</code></pre>
<h5 id="2-C-新式转型"><a href="#2-C-新式转型" class="headerlink" title="(2)C++新式转型"></a>(2)C++新式转型</h5><pre><code>const_case&lt;T&gt;( expression )     //移除对象的常量性
dynamic_case&lt;T&gt;( expression )   //安全向下转型
reinterpret_case&lt;T&gt;( expression )   //低级转型
static_case&lt;T&gt;( expression )    //强迫隐士转换，和(int)a类似</code></pre>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>尽量避免转型</li>
<li>如果必须转型，应将转型动作隐藏在函数里，客户直接调用函数。</li>
<li>尽量使用C++新式转型</li>
</ol>
<h1 id="28-避免返回handles指向对象内部成分"><a href="#28-避免返回handles指向对象内部成分" class="headerlink" title="28.避免返回handles指向对象内部成分"></a>28.避免返回handles指向对象内部成分</h1><ol>
<li><p>不要返回内部handle，也不要返回指向访问级别较低的成员函数。降低dangling handle的可能性</p>
</li>
<li><p>即public函数不要返回private成员的引用，必须返回的话，要加上const，即返回const XXX&amp; 类型。</p>
</li>
</ol>
<h1 id="29-为“异常安全”而努力是值得的"><a href="#29-为“异常安全”而努力是值得的" class="headerlink" title="29.为“异常安全”而努力是值得的"></a>29.为“异常安全”而努力是值得的</h1><h5 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h5><ol>
<li>不泄露任何资源</li>
<li>不允许数据败坏</li>
</ol>
<h5 id="异常安全函数的三个保证"><a href="#异常安全函数的三个保证" class="headerlink" title="异常安全函数的三个保证"></a>异常安全函数的三个保证</h5><ol>
<li>基本承诺：如果异常抛出，程序的其他数据仍然保持有效状态，不会被破坏，例如改变屏幕背景，若失败，背景应该为改变前的样子或默认背景。</li>
<li>强烈保证：如果函数失败，会回到程序调用函数前的状态。能通过copy-and-swap实现，但并非对所有函数都可实现且有意义。</li>
<li>不抛掷保证：承诺不抛出异常，函数总能完成它该有的功能。</li>
</ol>
<h1 id="30-透彻了解inlining的里里外外"><a href="#30-透彻了解inlining的里里外外" class="headerlink" title="30.透彻了解inlining的里里外外"></a>30.透彻了解inlining的里里外外</h1><ol>
<li>inline应该用在小型的、频繁的函数，主要是省去函数调用的开销。</li>
<li>若过多用inline，代码量就会增大，代码膨胀可能会导致额外的换页行为，降低指令告诉缓存的命中率，随而降低效率。</li>
</ol>
<h1 id="31-将文件间的编译依存关系降至最低"><a href="#31-将文件间的编译依存关系降至最低" class="headerlink" title="31.将文件间的编译依存关系降至最低"></a>31.将文件间的编译依存关系降至最低</h1><ol>
<li>能使用reference 和pointer的，就不要用object，就是尽量用引用和指针。</li>
<li>类中用对象的话，编译阶段就会确定类的大小，用指针的话计算的是指针的大小。</li>
<li>类中尽量用指针，不过用指针的话要注意深度拷贝和析构的问题，默认析构函数不会delete指针成员</li>
<li>程序库头文件应该仅有声明式</li>
</ol>
<h1 id="32-确定你的public继承塑模出is-a关系"><a href="#32-确定你的public继承塑模出is-a关系" class="headerlink" title="32.确定你的public继承塑模出is-a关系"></a>32.确定你的public继承塑模出is-a关系</h1><ol>
<li>如果要继承的话，一定要是is-a关系，即基类的每个函数都适用于派生类</li>
</ol>
<h1 id="33-避免遮掩继承而来的名称"><a href="#33-避免遮掩继承而来的名称" class="headerlink" title="33.避免遮掩继承而来的名称"></a>33.避免遮掩继承而来的名称</h1><ol>
<li><p>在子类中的同名成员会遮掩基类中的成员</p>
</li>
<li><p>适用using:Base::函数名()，就可以让基类中使用基类中的函数</p>
<ul>
<li>若基类有多个重载，子类中有重名函数就会覆盖所有重载，而使用using就可以重新用那些重载</li>
<li>若基类中是私有变量，使用using就能在子类中使用</li>
</ul>
</li>
</ol>
<h1 id="34-区分接口继承和实现继承"><a href="#34-区分接口继承和实现继承" class="headerlink" title="34.区分接口继承和实现继承"></a>34.区分接口继承和实现继承</h1><ol>
<li><p>pure virtual —— 接口继承，在子类中必须实现</p>
</li>
<li><p>non-pure virtual —— 接口 + 缺省实现继承，子类中可以再实现，也可以用默认的，不过有时候不想用默认的却会忘了实现，可以看书中飞机例子的解决办法。</p>
</li>
<li><p>non virtual —— 接口+强制实现继承，子类中不能更改它的行为</p>
</li>
</ol>
<h1 id="35-考虑virtual函数以外的其他选择"><a href="#35-考虑virtual函数以外的其他选择" class="headerlink" title="35.考虑virtual函数以外的其他选择"></a>35.考虑virtual函数以外的其他选择</h1><ol>
<li>不一定非得用virtual函数，替代方案有很多，比如：函数指针成员变量，NVI手法，Strategy设计模式等</li>
</ol>
<h1 id="36-绝不重新定义继承而来的non-virtual函数"><a href="#36-绝不重新定义继承而来的non-virtual函数" class="headerlink" title="36.绝不重新定义继承而来的non-virtual函数"></a>36.绝不重新定义继承而来的non-virtual函数</h1><ol>
<li>对应34条，不要在子类中重新定义non-virtual，若需要重写，就把基类中的定义为virtual（怎么感觉又和35矛盾了。。。）</li>
</ol>
<h1 id="37-绝不重新定义继承而来的缺省参数值"><a href="#37-绝不重新定义继承而来的缺省参数值" class="headerlink" title="37.绝不重新定义继承而来的缺省参数值"></a>37.绝不重新定义继承而来的缺省参数值</h1><ol>
<li>主要是对virtual的子类实现来说，若基类中virtual函数有缺省值，子类中不应该改变。</li>
<li>缺省值是静态绑定的，而virtual是动态绑定的。</li>
</ol>
<h1 id="38-通过复合塑模出has-a或“根据某物实现出”"><a href="#38-通过复合塑模出has-a或“根据某物实现出”" class="headerlink" title="38.通过复合塑模出has-a或“根据某物实现出”"></a>38.通过复合塑模出has-a或“根据某物实现出”</h1><ol>
<li>“复合(composition)”的近义词：组合，分层(layering)，内含(containment)，聚合(aggregation)，内嵌(embedding)</li>
<li>要有 has-a 的关系</li>
</ol>
<h1 id="39-明智而审慎地使用private继承"><a href="#39-明智而审慎地使用private继承" class="headerlink" title="39.明智而审慎地使用private继承"></a>39.明智而审慎地使用private继承</h1><ol>
<li><p>一般而言，不需要用private继承。复合基本可以完全包含private继承的能力</p>
</li>
<li><p>一般必须要用virtual函数的时候可以用私有继承，否则复合基本可以完全包含private继承的能力</p>
</li>
<li><p>2可能说的不对0.0</p>
</li>
</ol>
<h1 id="40-明智而审慎地使用多重继承"><a href="#40-明智而审慎地使用多重继承" class="headerlink" title="40.明智而审慎地使用多重继承"></a>40.明智而审慎地使用多重继承</h1><ol>
<li><p>多重继承可能导致成员歧义，即基类中有相同的成员名字</p>
</li>
<li><p>菱形/钻石继承，所有继承的类都变为虚继承，但是，虚继承的那些class产生的对象往往比使用non-virtual继承的体积大，访问这些成员变量也相对较慢。</p>
</li>
</ol>
<h1 id="41-了解隐式接口和编译期多态"><a href="#41-了解隐式接口和编译期多态" class="headerlink" title="41.了解隐式接口和编译期多态"></a>41.了解隐式接口和编译期多态</h1><ol>
<li><p>在构造函数前声明 explicit 关键字，禁止隐式转换，从而变成显式接口</p>
</li>
<li><p>类中某些成员函数是virtual的，当调用这些函数的时候就表现出运行期多态。</p>
</li>
<li><p>编译期多态主要是对templates模板来说，类型的多态</p>
</li>
</ol>
<h1 id="42-了解typename的双重意义"><a href="#42-了解typename的双重意义" class="headerlink" title="42.了解typename的双重意义"></a>42.了解typename的双重意义</h1><ol>
<li>声明template时，可以用class或typename，二者等价<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">template&lt;typename T&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="43-学习处理模块化基类内的名称"><a href="#43-学习处理模块化基类内的名称" class="headerlink" title="43.学习处理模块化基类内的名称"></a>43.学习处理模块化基类内的名称</h1><ol>
<li>不太懂，等需要模板编程的时候再细看吧。</li>
</ol>
<h1 id="44-将与参数无关的代码抽离templates"><a href="#44-将与参数无关的代码抽离templates" class="headerlink" title="44.将与参数无关的代码抽离templates"></a>44.将与参数无关的代码抽离templates</h1><ol>
<li><p>若两个函数实现过程中有很多重复代码，应该将重复代码单独写成一个函数，调用之。</p>
</li>
<li><p>对模板同理，至于怎么操作。。。</p>
</li>
</ol>
<h1 id="45-运用成员函数模板接受所有兼容类型"><a href="#45-运用成员函数模板接受所有兼容类型" class="headerlink" title="45.运用成员函数模板接受所有兼容类型"></a>45.运用成员函数模板接受所有兼容类型</h1><ol>
<li>模板这块先略过吧，没有什么编程需求，所以没有直观感受。</li>
</ol>
<h1 id="46-需要类型转换时请为模板定义非成员函数"><a href="#46-需要类型转换时请为模板定义非成员函数" class="headerlink" title="46.需要类型转换时请为模板定义非成员函数"></a>46.需要类型转换时请为模板定义非成员函数</h1><ol>
<li>模板这块先略过吧，没有什么编程需求，所以没有直观感受。</li>
</ol>
<h1 id="47-请使用traits-classes表现类型信息"><a href="#47-请使用traits-classes表现类型信息" class="headerlink" title="47.请使用traits classes表现类型信息"></a>47.请使用traits classes表现类型信息</h1><ol>
<li>模板这块先略过吧，没有什么编程需求，所以没有直观感受。</li>
</ol>
<h1 id="48-认识template元编程"><a href="#48-认识template元编程" class="headerlink" title="48.认识template元编程"></a>48.认识template元编程</h1><ol>
<li><p>元编程执行于编译期，可以把工作转移一部分到编译期，而且一些在运行期才能检查出来的错误也能转到在编译期检查出来。</p>
</li>
<li><p>通过template&lt;当做参数&gt;实现</p>
</li>
</ol>
<h1 id="49-了解new-handler的行为"><a href="#49-了解new-handler的行为" class="headerlink" title="49.了解new-handler的行为"></a>49.了解new-handler的行为</h1><ol>
<li>new_handler声明与std</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace std&#123;</span><br><span class="line">    typedef void (*new_handler);</span><br><span class="line">    new_handler set_new_handler(new_handler p) throw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>new_handler 是一个函数指针，它有什么用呢？<br> 当new一块空间不足时，它就会抛出异常，但在异常之前会先调用一个客户指定 的错误处理函数，就是new_handler，通过ser_new_handler(函数名)来设置。</p>
</li>
<li><p>卸载new_handler<br> set_new_handler(NULL)</p>
</li>
<li><p>作用局限，只适用于内存分配，后续的构造函数调用可能还是会抛出异常。</p>
</li>
</ol>
<h1 id="50-了解new和delete的合理替换时机"><a href="#50-了解new和delete的合理替换时机" class="headerlink" title="50.了解new和delete的合理替换时机"></a>50.了解new和delete的合理替换时机</h1><ol>
<li><p>一般替换掉默认的new和delete一般是为了： 提高性能（比如tcmalloc），收集数据、检测错误等。比如valgrind之类（Valgrind是一款用于内存调试、内存泄漏检测以及性能分析的软件开发工具。）</p>
</li>
<li><p>替换方法：简单来说就是封装malloc和free,relloc等，做出自己想要的效果。。。。简单来说。</p>
</li>
</ol>
<h1 id="51-编写new和delete时需固守常规"><a href="#51-编写new和delete时需固守常规" class="headerlink" title="51.编写new和delete时需固守常规"></a>51.编写new和delete时需固守常规</h1><ol>
<li><p>无限循环尝试分配内存，若无法满足内存需求，就该调用new_handler</p>
</li>
<li><p>也要有能力处理0bytes申请。还应该能处理比正确大小更大的申请</p>
</li>
<li><p>delete 应该在收到NULL指针时不做任何事</p>
</li>
</ol>
<h1 id="52-写了placement-new也要写placement-delete"><a href="#52-写了placement-new也要写placement-delete" class="headerlink" title="52.写了placement new也要写placement delete"></a>52.写了placement new也要写placement delete</h1><ol>
<li><p>主要讨论一个在构造函数中抛出异常会不会内存泄露的问题。placement new/delete 就是在类中自己重载new和delete操作符。</p>
</li>
<li><p>一个对象在构造函数中抛出异常，对象本身的内存会被成功释放，但是其析构函数不会被调用。其内部局部成员对象清栈时是会被释放掉的，故其析构函数被调用，但是用户在构造函数中动态生成的对象没有被delete掉（new出来的是一个指针，清栈时是不会delete掉栈里的指针）。</p>
</li>
<li><p>如果一个对象在构造函数中打开很多系统资源，但是构造函数中后续代码抛出了异常，则这些资源将不会被释放，建议在构造函数中加入try catch语句，对先前申请的资源进行释放后（也就是做析构函数该做的事情）再次抛出异常，确保内存和其他资源被成功回收。</p>
</li>
</ol>
<h1 id="53-不要轻忽编译器的警告"><a href="#53-不要轻忽编译器的警告" class="headerlink" title="53.不要轻忽编译器的警告"></a>53.不要轻忽编译器的警告</h1><ol>
<li>额总之就是在不过度依赖编译器的情况下达到0警告</li>
</ol>
<h1 id="54-让自己熟悉包括TR1在内的标准程序库"><a href="#54-让自己熟悉包括TR1在内的标准程序库" class="headerlink" title="54.让自己熟悉包括TR1在内的标准程序库"></a>54.让自己熟悉包括TR1在内的标准程序库</h1><h5 id="C-98加入的新特性"><a href="#C-98加入的新特性" class="headerlink" title="C++98加入的新特性"></a>C++98加入的新特性</h5><ol>
<li>STL</li>
<li>iostreams</li>
<li>国际化支持，如：wchar_t等</li>
<li>数值处理：如复数模板complex</li>
<li>异常阶层体系</li>
<li>C89标准程序库</li>
</ol>
<h5 id="TR1"><a href="#TR1" class="headerlink" title="TR1"></a>TR1</h5><p>14个新组件，std::tr1::shared_ptr</p>
<ol>
<li>智能指针</li>
<li>tr1::function，传递函数指针，详情再看教程吧。</li>
<li>tr1::bind，比bind1st,bind2nd更好用的STL绑定器，绑定的函数有点像传递仿函数的功能。</li>
<li>Hash tables，STL的map和se是用红黑树实现的，这实现的Hash结构的。</li>
<li>正则表达式</li>
<li>Tuples(变量组)</li>
<li>tr1::array</li>
<li>tr1::mem_fun</li>
<li>tr1::reference_wrapper</li>
<li>随机数，超越rand,rand是C库的</li>
<li>数学特殊函数，拉格朗日等</li>
<li>C99 兼容扩充</li>
</ol>
<h5 id="tr2"><a href="#tr2" class="headerlink" title="tr2"></a>tr2</h5><ol start="13">
<li>type traits </li>
<li>tr1::result_of</li>
</ol>
<h5 id=""><a href="#" class="headerlink" title="???"></a>???</h5><p>看到最后，来一句：TR1只是规范，还没有实物？？？但是智能指针什么的《C++ primer》都说了。。。好吧，05年的书太早了，看了上面这么多，瞬间觉得自己根本不懂C++，都快C++20了，complex，学的好累0.0，还是python简单些。。。</p>
<h1 id="55-让自己熟悉Boost"><a href="#55-让自己熟悉Boost" class="headerlink" title="55.让自己熟悉Boost"></a>55.让自己熟悉Boost</h1><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul>
<li>Boost是一个C++开发者的社群，也是一个免费的C++程序库群。它的网址是<a href="http://www.boost.org/">www.boost.org</a>  </li>
</ul>
<h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><ul>
<li>作为一个“可被加入标准C++库的测试场”，以TR1提案进入标准C++的14个新程序序库中，超过三分之二是基于Boost的成果</li>
</ul>
<h5 id="网上言论"><a href="#网上言论" class="headerlink" title="网上言论"></a>网上言论</h5><ol>
<li>说尽量用STL不要用boost什么的，现在很多boost都成标准了什么的。。。崩溃，STL还了解一些，不过理解也就是一些容器迭代器仿函数什么的。看了boost那么大，及其崩溃，不知从何学起。唉慢慢来吧。</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《Linux 编程实践教程》</title>
    <url>/%E3%80%8ALinux-%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B%E3%80%8B/</url>
    <content><![CDATA[<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ol>
<li>这个笔记是本人在有一定基础的情况下做的，所以有很多基础的就不记了，比如fork和vfork的区别，子进程怎么判断等……————打脸，对这些基础概念都有点儿模糊了。</li>
</ol>
<a id="more"></a>
<h1 id="第一章：Unix系统编程概述"><a href="#第一章：Unix系统编程概述" class="headerlink" title="第一章：Unix系统编程概述"></a>第一章：Unix系统编程概述</h1><h3 id="零-相关命令和操作"><a href="#零-相关命令和操作" class="headerlink" title="零. 相关命令和操作"></a>零. 相关命令和操作</h3><ul>
<li>bc</li>
<li>more<h3 id="一-理解系统编程"><a href="#一-理解系统编程" class="headerlink" title="一. 理解系统编程"></a>一. 理解系统编程</h3></li>
</ul>
<ol>
<li>处理器 Processor</li>
<li>输入输出 IO</li>
<li>进程管理 Process Management</li>
<li>内存 Memory</li>
<li>设备 Device</li>
<li>计时器 Timers</li>
<li>进程间通信 Interprocess Communication</li>
<li>网络 Networking</li>
</ol>
<h3 id="二、学习方法"><a href="#二、学习方法" class="headerlink" title="二、学习方法"></a>二、学习方法</h3><ol>
<li>分析程序–它是做什么的<br> 分析现有程序，了解其功能和实现原理</li>
<li>学习系统调用–它是如何实现的</li>
<li>编程实现–自己能不能编写一个</li>
</ol>
<h1 id="第二章：用户、文件操作与联机帮助-编写who"><a href="#第二章：用户、文件操作与联机帮助-编写who" class="headerlink" title="第二章：用户、文件操作与联机帮助:编写who"></a>第二章：用户、文件操作与联机帮助:编写who</h1><h3 id="零-相关命令和操作-1"><a href="#零-相关命令和操作-1" class="headerlink" title="零. 相关命令和操作"></a>零. 相关命令和操作</h3><ul>
<li>man,who,cp,login</li>
<li>open(),read(),write(),creat(),lseek(),close()</li>
<li>perror<h3 id="1-编写who指令"><a href="#1-编写who指令" class="headerlink" title="1. 编写who指令"></a>1. 编写who指令</h3></li>
</ul>
<ol>
<li><p>知识准备：</p>
<ul>
<li><p>用户登录信息存放在文件 /var/run/utmp 文件中</p>
</li>
<li><p>/usr/include/utmp.h头文件有 utmp结构体，专门用来存储用户信息</p>
</li>
</ul>
</li>
<li><p>编写步骤：</p>
<ul>
<li><ol>
<li>读取/var/run/utmp文件，把数据读到utmp结构体中<br> 不过我查看这个文件加密了，，，这个怎么读。。。估计是书比较老，低版本的Linux能读？</li>
</ol>
</li>
<li><ol start="2">
<li>再按照自己想要的格式打印出来</li>
</ol>
</li>
<li><ol start="3">
<li>循环直到读完文件数据</li>
</ol>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>注意man的使用</li>
</ul>
</li>
</ol>
<h3 id="2-编写cp"><a href="#2-编写cp" class="headerlink" title="2. 编写cp"></a>2. 编写cp</h3><ol>
<li>cp f1 f2<br> 把f1的内容复制给f2，f2存在的话覆盖，不存在的话建立（用create就能满足这个要求了）</li>
<li>就是文件的读写一顿操作</li>
</ol>
<h3 id="3-缓冲的使用"><a href="#3-缓冲的使用" class="headerlink" title="3. 缓冲的使用"></a>3. 缓冲的使用</h3><ol>
<li>每次read/write，都要进行内核态用户态切换，为了提高读写速度，可以一次多读点，存缓冲区里（buf）</li>
<li>内核缓冲区<ul>
<li>数据并不是调用write后就立刻写到磁盘上，而是先存进内核缓冲区，积累到一定数量再写。</li>
<li>读数据也是先从磁盘读到缓冲区</li>
<li>这样能提高磁盘IO效率，但是若突然断电，内核还来不及把内核缓冲区的数据写到磁盘上，就会导致更新的数据丢失</li>
</ul>
</li>
</ol>
<h3 id="4-终端注销"><a href="#4-终端注销" class="headerlink" title="4. 终端注销"></a>4. 终端注销</h3><ol>
<li>还是读utmp文件，修改相应记录的状态，这个加密文件，，，貌似改不了啊</li>
</ol>
<h3 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5. 错误处理"></a>5. 错误处理</h3><ol>
<li>&lt;errno.h&gt;中有指定错误类型的宏，可以根据这个获得错误信息 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern int error;</span><br><span class="line">&#x2F;&#x2F;根据error的值判断错误类型</span><br></pre></td></tr></table></figure></li>
<li>但是perror更方便，直接自动判断错误信息。</li>
</ol>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><ol>
<li>系统调用总结<ul>
<li>open(filename,how)</li>
<li>create(filename,model)</li>
<li>read(fd,buf,size)</li>
<li>write(fd,buf,size)</li>
<li>lseek(fd,distance,base)</li>
<li>close(fd)</li>
</ul>
</li>
<li>文件描述符，一个整形类型</li>
<li>缓存</li>
<li>error错误标示</li>
</ol>
<h3 id="7-课后思考"><a href="#7-课后思考" class="headerlink" title="7. 课后思考"></a>7. 课后思考</h3><ol>
<li>lseek如果设置偏移量大于文件长度<ul>
<li>会自动填充中间的空洞，但是空洞那部分不一定占用磁盘，要看操作系统的实现</li>
</ul>
</li>
<li>sync(),fsync(fd),fdatasync(fd)显式把数据从缓冲区写到磁盘</li>
</ol>
<h1 id="第三章：目录与文件属性：编写ls"><a href="#第三章：目录与文件属性：编写ls" class="headerlink" title="第三章：目录与文件属性：编写ls"></a>第三章：目录与文件属性：编写ls</h1><h3 id="零-相关命令和操作-2"><a href="#零-相关命令和操作-2" class="headerlink" title="零. 相关命令和操作"></a>零. 相关命令和操作</h3><ul>
<li>ls</li>
<li>opendir(),readdir(),closedir(),seekdir()</li>
<li>stat()</li>
<li>chmod(),chown(),utime()</li>
<li>rename()<h3 id="一、ls实现"><a href="#一、ls实现" class="headerlink" title="一、ls实现"></a>一、ls实现</h3></li>
</ul>
<ol>
<li>简单的ls<ul>
<li>就是读取目录并显示出来</li>
</ul>
</li>
<li>ls -l<ul>
<li>这个需要文件信息，用stat函数获取。</li>
<li>用getgrgid根据gid获得组的信息，从而获得组名，用户名也是这样获取<h3 id="二、三个特殊的位"><a href="#二、三个特殊的位" class="headerlink" title="二、三个特殊的位"></a>二、三个特殊的位</h3></li>
</ul>
</li>
<li>SUID<ul>
<li>给程序额外的权限，例如修改密码会修改/etc/passwd,而这个文件有权限限制，就可以给程序一个特殊的权限，也就是SUID，使得这个程序的所有者变为root，这样就可以通过passwd程序修改密码了</li>
</ul>
</li>
<li>SGID<ul>
<li>设置程序运行时所属组，获得组用户的权限</li>
</ul>
</li>
<li>sticky位<ul>
<li>对于文件来说，指把程序放到交换空间，加快装载速度，不过现在不重要，用虚拟存储技术取代，用页交换</li>
<li>对目录而言，sticky使得目录里的文件只能被创建者删除，这对于临时文件夹是很有用的，比如/tmp</li>
</ul>
</li>
</ol>
<h3 id="三、设置和修改文件属性"><a href="#三、设置和修改文件属性" class="headerlink" title="三、设置和修改文件属性"></a>三、设置和修改文件属性</h3><ol>
<li>创建时可以指定model,create(filename,model),如0777,0代表八进制</li>
<li>umask(022)设置掩码，创建只是请求，掩码是关闭某些权限</li>
<li>改变权限chmod(filename,model)</li>
<li>改变所有者和组 chown(filename,uid,gid)</li>
<li>修改时间 utime(filename,tt)</li>
<li>修改文件名 rename(old,new)</li>
<li>不同文件类型的文件创建方式不一样</li>
</ol>
<h1 id="第四章：文件系统-编写pwd"><a href="#第四章：文件系统-编写pwd" class="headerlink" title="第四章：文件系统:编写pwd"></a>第四章：文件系统:编写pwd</h1><h3 id="零-相关命令和操作-3"><a href="#零-相关命令和操作-3" class="headerlink" title="零. 相关命令和操作"></a>零. 相关命令和操作</h3><ul>
<li>pwd</li>
<li>mkdir(),rmdir(),chdir()</li>
<li>link(),unlink(),rename(),symlink()<h3 id="一、几种常用文件操作"><a href="#一、几种常用文件操作" class="headerlink" title="一、几种常用文件操作"></a>一、几种常用文件操作</h3></li>
<li><ol>
<li>mkdir/rmdir</li>
</ol>
</li>
<li><ol start="2">
<li>link/unlink</li>
</ol>
</li>
<li><ol start="3">
<li>rename</li>
</ol>
</li>
<li><ol start="4">
<li>chdir</li>
</ol>
</li>
</ul>
<h3 id="二、实现pwd"><a href="#二、实现pwd" class="headerlink" title="二、实现pwd"></a>二、实现pwd</h3><ul>
<li><ol>
<li>根据”.”读取当前目录名 </li>
</ol>
</li>
<li><ol start="2">
<li>根据”..”跳到上一级目录，读取上一级目录名</li>
</ol>
</li>
<li><ol start="3">
<li>直到根目录，根目录的”.”和”..”都指向自己</li>
</ol>
</li>
<li>注意：自己实现的pwd不能到 /目录，只能到”家”目录，因为这个家目录是分区后的文件系统的根，分区后，每个区有一个自己的文件系统树</li>
</ul>
<h3 id="三、装载点"><a href="#三、装载点" class="headerlink" title="三、装载点"></a>三、装载点</h3><ul>
<li><ol>
<li>如上所说，每个磁盘或分区有自己的文件系统树，但对用户来说感受不到，感觉像一个大树，就是把一个文件系统挂载到另一个文件系统的某个目录上，这个目录作为指针指向另一个目录的根</li>
</ol>
</li>
<li><ol start="2">
<li>Unix允许不同类别的文件系统挂载</li>
</ol>
</li>
</ul>
<h1 id="第五章：连接控制：学习stty"><a href="#第五章：连接控制：学习stty" class="headerlink" title="第五章：连接控制：学习stty"></a>第五章：连接控制：学习stty</h1><h3 id="零-相关命令和操作-4"><a href="#零-相关命令和操作-4" class="headerlink" title="零. 相关命令和操作"></a>零. 相关命令和操作</h3><ul>
<li>stty,write</li>
<li>fcntl,ioctl</li>
<li>tcsetattr,tcgetattr<h3 id="一、一切皆文件"><a href="#一、一切皆文件" class="headerlink" title="一、一切皆文件"></a>一、一切皆文件</h3></li>
<li>设备也是文件，对文件的操作能用在设备文件上</li>
<li>终端也是文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tty     &#x2F;&#x2F;查看当前终端名字</span><br><span class="line">who &gt; &#x2F;dev&#x2F;pts&#x2F;1    &#x2F;&#x2F;把信息输入到这个终端</span><br></pre></td></tr></table></figure></li>
<li>设备文件的i-节点存储的是指向内核子程序的指针，而不是文件的大小和存储列表，内核中传输设备数据的子程序被称为设备驱动程序</li>
<li>在/dev/pts/1这个例子中，在终端进行数据传输的代码是在 设备-进程表 中编号为136的子程序，该子程序接受一个参数，参数为1。<br>  136 和 1 被成为设备的主设备号和从设备号，主设备号确认处理该设备的子程序，从设备号作为参数传到子程序</li>
</ul>
<h3 id="二、磁盘链接的属性"><a href="#二、磁盘链接的属性" class="headerlink" title="二、磁盘链接的属性"></a>二、磁盘链接的属性</h3><ul>
<li><ol>
<li>实际上就是对磁盘文件的属性控制 </li>
</ol>
<ul>
<li>获取设置</li>
<li>修改设置</li>
<li>存储设置</li>
<li>fcntl(fd,cmd)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一个设置文件为自动添加模式的例子</span><br><span class="line">s&#x3D;fcntl(fd,F_GETFL);    &#x2F;&#x2F;get flags</span><br><span class="line">s|&#x3D;O_APPEND;            &#x2F;&#x2F;set APPEND bit</span><br><span class="line">result&#x3D;fcntl(fd,F_SETFL,s)  &#x2F;&#x2F;set flags</span><br><span class="line">if(result&#x3D;&#x3D;-1)&#123;</span><br><span class="line">    perror(&quot;...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">write(fd,buf,1);    &#x2F;&#x2F;在结尾写入</span><br><span class="line">&#x2F;&#x2F;为什么不用lseek定位到结尾，再写入？</span><br><span class="line">答：因为若有两个程序同时要写入，两个都调用了lseek时定位到同一位置，那么后写入的就会覆盖前一个写入的。</span><br><span class="line">而设置标志位后这个动作就会变为原子操作。</span><br></pre></td></tr></table></figure></li>
<li>也可以在open的时候指定文件操作</li>
</ul>
</li>
<li><ol start="2">
<li>磁盘链接文件通过open,fcntl控制链接属性</li>
</ol>
</li>
</ul>
<h3 id="三、终端链接的属性"><a href="#三、终端链接的属性" class="headerlink" title="三、终端链接的属性"></a>三、终端链接的属性</h3><ul>
<li><ol>
<li>处理进程和外部设备数据流的内核子程序被称为终端驱动程序或tty驱动程序。驱动程序包含很多控制设备操作的设置。进程可以读、修改和重置这些驱动控制标志。</li>
</ol>
</li>
<li><ol start="2">
<li>stty命令，读取和修改终端驱动程序的设置</li>
</ol>
</li>
</ul>
<h3 id="四、编写终端驱动程序"><a href="#四、编写终端驱动程序" class="headerlink" title="四、编写终端驱动程序"></a>四、编写终端驱动程序</h3><ul>
<li><ol>
<li>驱动程序的操作</li>
</ol>
<ul>
<li>输入</li>
<li>输出</li>
<li>控制</li>
<li>本地</li>
</ul>
</li>
<li><ol start="2">
<li>编写步骤</li>
</ol>
<ul>
<li>从驱动程序获得属性</li>
<li>修改索要修改的属性</li>
<li>将修改过的属性送回驱动程序</li>
<li>使用tcgetattr/tcsetattr</li>
</ul>
</li>
<li><ol start="3">
<li>其他设备编程</li>
</ol>
<ul>
<li>ioctl()   每个设备文件都支持系统调用ioctl</li>
</ul>
</li>
<li><ol start="4">
<li>获取鼠标信息，cat /etc/input/mouse1 显示鼠标的操作信息，但是全是乱码。。。</li>
</ol>
</li>
</ul>
<h1 id="第六章：为用户编程：终端控制和信号"><a href="#第六章：为用户编程：终端控制和信号" class="headerlink" title="第六章：为用户编程：终端控制和信号"></a>第六章：为用户编程：终端控制和信号</h1><h3 id="零-相关命令和操作-5"><a href="#零-相关命令和操作-5" class="headerlink" title="零. 相关命令和操作"></a>零. 相关命令和操作</h3><ul>
<li>fcntl,signal</li>
</ul>
<h3 id="一、终端模式"><a href="#一、终端模式" class="headerlink" title="一、终端模式"></a>一、终端模式</h3><ul>
<li><ol>
<li>规范模式<br> 也成为cooked模式，驱动程序输入的字符保存在缓冲区，可以进行退格等操作。</li>
</ol>
</li>
<li><ol start="2">
<li>非规范模式<br> 缓冲和编辑功能关闭，退格作为一个输入符号，不能再编辑已经输入过的内容</li>
</ol>
</li>
<li><ol start="3">
<li>规范模式要按下回车键程序才读取输入的内容，而非规范输入实时读取，在写需要输入 y/n的程序时很有用</li>
</ol>
</li>
</ul>
<h3 id="二、信号"><a href="#二、信号" class="headerlink" title="二、信号"></a>二、信号</h3><ul>
<li><ol>
<li>信号的三个来源：用户，内核，进程</li>
</ol>
</li>
<li><ol start="2">
<li>自己的程序最好写个进程杀死信号的处理函数，把修改的设置恢复为默认的</li>
</ol>
</li>
<li><ol start="3">
<li>SIGSTOP和SIGKILL不能被捕捉和忽略，Ctrl-C是SIGINT信号</li>
</ol>
</li>
</ul>
<h1 id="第七章：事件驱动编程：编写一个视频游戏"><a href="#第七章：事件驱动编程：编写一个视频游戏" class="headerlink" title="第七章：事件驱动编程：编写一个视频游戏"></a>第七章：事件驱动编程：编写一个视频游戏</h1><h3 id="零-相关命令和操作-6"><a href="#零-相关命令和操作-6" class="headerlink" title="零. 相关命令和操作"></a>零. 相关命令和操作</h3><ul>
<li>alarm,setitimer,getitimer</li>
<li>kill,pause</li>
<li>sigaction,sigprocmask</li>
<li>fcntl,aio_read</li>
</ul>
<h3 id="一、curses入门"><a href="#一、curses入门" class="headerlink" title="一、curses入门"></a>一、curses入门</h3><ul>
<li><ol>
<li>curses是一个基于字符的图形界面库</li>
</ol>
</li>
<li><ol start="2">
<li>reflesh() 刷新界面<br> curses内部有虚拟和实际屏幕，虚拟屏幕来对内容进行改动。<br> refresh()比较真实屏幕和虚拟屏幕的差异，然后只改动不一样的地方。</li>
</ol>
</li>
<li><ol start="3">
<li>这种只传输改变的内容而不是影响本身的技术被用在视频流中。</li>
</ol>
</li>
</ul>
<h3 id="二、时钟编程"><a href="#二、时钟编程" class="headerlink" title="二、时钟编程"></a>二、时钟编程</h3><ul>
<li><ol>
<li>计时器 </li>
</ol>
<ul>
<li>sleep()</li>
<li>alarm()</li>
</ul>
</li>
<li><ol start="2">
<li>间隔计时器</li>
</ol>
<ul>
<li>getitimer/setitimer   函数</li>
<li>itimerval/timeval 结构</li>
</ul>
</li>
</ul>
<h3 id="三、信号处理"><a href="#三、信号处理" class="headerlink" title="三、信号处理"></a>三、信号处理</h3><ul>
<li><ol>
<li>早期的信号处理机制–捕鼠器模型</li>
</ol>
<ul>
<li>默认：signal(SIGALRM,SIG_DEF);</li>
<li>忽略：signal(SIGALRM,SIG_IGN);</li>
<li>调用函数：signal(SIGALRM,handler);</li>
</ul>
</li>
<li><ol start="2">
<li>处理多个信号</li>
</ol>
<ul>
<li>signal会有问题，只能捕捉一次，使用完就失效了，还得在handler中再设置一次signal，像一个捕鼠器。但是若还没设置的时候就又出现了这个信号呢？早期的信号处理有这个Bug</li>
<li>总之signsl有很多问题，然后就有了sigaction<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct siaaction&#123;</span><br><span class="line">    void (*sa_handler)();</span><br><span class="line">    void (*sa_sigaction)(int,siginfo_t*,void*);</span><br><span class="line">    sigset_t sa_mask;</span><br><span class="line">    int sa_flags;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;sa_handler是用老信号处理，如SIG_IGN等</span><br><span class="line">&#x2F;&#x2F;通过sa_mask设置是使用老的还是新的</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="四、防止数据损毁"><a href="#四、防止数据损毁" class="headerlink" title="四、防止数据损毁"></a>四、防止数据损毁</h3><ul>
<li><ol>
<li>临界区：若修改某个数据结构的代码在运行期间被打断将导致数据的不完整或摧毁，则称这段代码为临界区。要设法保护这段代码。</li>
</ol>
</li>
<li><ol start="2">
<li>阻塞信号</li>
</ol>
<ul>
<li>在信号处理者那里阻塞信号：在处理一个信号的时候阻塞另一个信号，要设置sa_mask位，注意是阻塞而不是忽略</li>
<li>一个进程的阻塞信号：在任何时候一个进程都有一些信号被阻塞，这个信号集就被称为信号挡板(signal mask),通过sigprocmask可以修改这个阻塞信号集。</li>
<li>用sigsetops构造信号集<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sigemptyset(sigset_t* setp);&#x2F;&#x2F;清空setp</span><br><span class="line">sigfillset(sigset_t* setp);&#x2F;&#x2F;将所有信号加到setp</span><br><span class="line">sigaddset(sigset_t* setp,int signum);&#x2F;&#x2F;将signum信号加到setp</span><br><span class="line">sigdelset(sigset_t* setp,int signum);&#x2F;&#x2F;将signum信号从setp删除</span><br></pre></td></tr></table></figure></li>
<li>例子：暂时的阻塞用户信号<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sigset_t sigs,prevsigs;</span><br><span class="line">sigemptyset(&amp;sigs);</span><br><span class="line">sigaddset($sigs,SIGINT);</span><br><span class="line">sigaddset($sigs,SIGQUIT);</span><br><span class="line">sigprocmask(SIG_BLOCK,&amp;sigs,&amp;prevsigs);</span><br><span class="line">&#x2F;&#x2F;dosomething</span><br><span class="line">sigprocmask(SIG_BLOCK,&amp;prevsigs,NULL);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ol start="3">
<li>向另一个进程发送信号 kill</li>
</ol>
</li>
</ul>
<h3 id="五、异步IO"><a href="#五、异步IO" class="headerlink" title="五、异步IO"></a>五、异步IO</h3><ul>
<li><ol>
<li>使用O_ASYNC</li>
</ol>
<ul>
<li>用fcntl 对文件操作符设置O_ASYNC属性</li>
<li>当有键盘输入时，内核向进程发送SIGIO信号</li>
</ul>
</li>
<li><ol start="2">
<li>使用aio_read</li>
</ol>
<ul>
<li>aiocb //an aio control buf 结构体</li>
<li>aio_read(&amp;kbcbuf);</li>
</ul>
</li>
</ul>
<h1 id="第八章：进程和程序：编写命令解释器sh"><a href="#第八章：进程和程序：编写命令解释器sh" class="headerlink" title="第八章：进程和程序：编写命令解释器sh"></a>第八章：进程和程序：编写命令解释器sh</h1><h3 id="零-相关命令和操作-7"><a href="#零-相关命令和操作-7" class="headerlink" title="零. 相关命令和操作"></a>零. 相关命令和操作</h3><ul>
<li>fork,exec,wait,exit</li>
<li>sh,ps<h3 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h3></li>
<li><ol>
<li>查看进程<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -la  &#x2F;&#x2F;list all</span><br><span class="line">ps aux  &#x2F;&#x2F;查看所有进程，进程所属用户</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>shell主循环<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(! end_of_input)&#123;</span><br><span class="line">    get command;</span><br><span class="line">    execute command;</span><br><span class="line">    wait for command finish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="3">
<li>exec**命令 一个进程调用另一个进程</li>
</ol>
</li>
<li><ol start="4">
<li>fork(),vfork()创建进程</li>
</ol>
</li>
<li><ol start="5">
<li>wait(pid) 等待子进程结束</li>
</ol>
</li>
<li><ol start="6">
<li>退出exit(),atexit(),向父进程发送SIGCHLD</li>
</ol>
</li>
</ul>
<h1 id="第九章：可编程的Shell-shell编程和环境：编写自己的shell"><a href="#第九章：可编程的Shell-shell编程和环境：编写自己的shell" class="headerlink" title="第九章：可编程的Shell,shell编程和环境：编写自己的shell"></a>第九章：可编程的Shell,shell编程和环境：编写自己的shell</h1><h3 id="零-相关命令和操作-8"><a href="#零-相关命令和操作-8" class="headerlink" title="零. 相关命令和操作"></a>零. 相关命令和操作</h3><ul>
<li>exit,getenv</li>
<li>env</li>
</ul>
<h3 id="一、shell脚本"><a href="#一、shell脚本" class="headerlink" title="一、shell脚本"></a>一、shell脚本</h3><ul>
<li><ol>
<li>元素：变量，IO,控制语句，环境</li>
</ol>
</li>
<li><ol start="2">
<li>讲真的，这个自写shell解释器是有点东西的</li>
</ol>
</li>
<li><ol start="3">
<li>环境变量，全局/etc/profile,个人.bashrc</li>
</ol>
</li>
</ul>
<h1 id="第十章：IO重定向和管道"><a href="#第十章：IO重定向和管道" class="headerlink" title="第十章：IO重定向和管道"></a>第十章：IO重定向和管道</h1><h3 id="零-相关命令和操作-9"><a href="#零-相关命令和操作-9" class="headerlink" title="零. 相关命令和操作"></a>零. 相关命令和操作</h3><ul>
<li>dup,dup2</li>
<li>pipe<h3 id="一、标准文件描述符"><a href="#一、标准文件描述符" class="headerlink" title="一、标准文件描述符"></a>一、标准文件描述符</h3></li>
<li><ol>
<li>标准输入：stdin    0</li>
</ol>
</li>
<li><ol start="2">
<li>标准输出：stdout   1</li>
</ol>
</li>
<li><ol start="3">
<li>标准错误输出：stderr   2</li>
</ol>
</li>
<li><ol start="4">
<li>命令行里面的重定向，是把标准输出文件描述符1 重定向到自己指定的文件<h3 id="二、重定向"><a href="#二、重定向" class="headerlink" title="二、重定向"></a>二、重定向</h3></li>
</ol>
</li>
<li><ol>
<li>close-open</li>
</ol>
</li>
<li><ol start="2">
<li>open-close-dup-close</li>
</ol>
</li>
<li><ol start="3">
<li>open-dup2-close    //dup2会自己关闭老的文件描述符</li>
</ol>
</li>
</ul>
<h3 id="三、管道"><a href="#三、管道" class="headerlink" title="三、管道"></a>三、管道</h3><ul>
<li><ol>
<li>pipe(array),父子进程传送，匿名管道</li>
</ol>
</li>
<li><ol start="2">
<li>管道非文件，类似文件却不同<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 从管道读数据</span><br><span class="line">    （1）管道无数据时阻塞</span><br><span class="line">    （2）当所有写者关闭写端，读管道的调用返回0</span><br><span class="line">    （3）多个读者会出问题，因为数据读一次就没了，不像文件一直存在</span><br><span class="line">2. 向管道写数据</span><br><span class="line">    （1）若管道空间不够，写入阻塞</span><br><span class="line">    （2）写入必须保证一个最小块的大小，如512字节</span><br><span class="line">    （3）若无读者存在，则写失败，返回-1</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h1 id="第十一章：连接到近端或远端的进程：服务器与Socket"><a href="#第十一章：连接到近端或远端的进程：服务器与Socket" class="headerlink" title="第十一章：连接到近端或远端的进程：服务器与Socket"></a>第十一章：连接到近端或远端的进程：服务器与Socket</h1><h3 id="零-相关命令和操作-10"><a href="#零-相关命令和操作-10" class="headerlink" title="零. 相关命令和操作"></a>零. 相关命令和操作</h3><ul>
<li>fdopen,popen,socket,bind,listen,accept,connect</li>
</ul>
<h3 id="一、三种传输数据的方式"><a href="#一、三种传输数据的方式" class="headerlink" title="一、三种传输数据的方式"></a>一、三种传输数据的方式</h3><ul>
<li><ol>
<li>文件 open-write-read</li>
</ol>
</li>
<li><ol start="2">
<li>管道 pipe-fork-read-write </li>
</ol>
</li>
<li><ol start="3">
<li>socket socket-bind-listen-accept<pre><code>   socket-connect</code></pre>
</li>
</ol>
</li>
</ul>
<h3 id="二、bc：Unix中使用的计算器"><a href="#二、bc：Unix中使用的计算器" class="headerlink" title="二、bc：Unix中使用的计算器"></a>二、bc：Unix中使用的计算器</h3><ul>
<li><ol>
<li>bc只处理输入，计算是由另一个dc程序实现的，他俩要进行通信</li>
</ol>
</li>
<li><ol start="2">
<li>bc的思想</li>
</ol>
<ul>
<li>客户/服务器模型</li>
<li>双向通信</li>
<li>永久性服务，dc只有一个，bc可以有很多个<br>bc/dc成为协程，当一个程序完成自己的工作后把控制权交给另一个程序</li>
</ul>
</li>
<li><ol start="3">
<li>编写bc</li>
</ol>
<ul>
<li>pipe</li>
<li>fork</li>
<li>dup</li>
<li>exec</li>
</ul>
</li>
</ul>
<h3 id="三、看似文件"><a href="#三、看似文件" class="headerlink" title="三、看似文件"></a>三、看似文件</h3><ul>
<li><ol>
<li>fdopen 让文件描述符像文件一样使用<br> 以文件描述符作为参数而不是文件名，返回FILE*类型</li>
</ol>
</li>
<li><ol start="2">
<li>popen 让进程看似文件</li>
</ol>
<ul>
<li>参数为程序，返回FILE*</li>
<li>要用pclose()关闭，其中调用了wait()等待进程关闭</li>
</ul>
</li>
<li><ol start="3">
<li>popen 函数实现</li>
</ol>
<ul>
<li>用管道</li>
<li>用fdopen返回读管道文件</li>
</ul>
</li>
</ul>
<h3 id="四、访问数据"><a href="#四、访问数据" class="headerlink" title="四、访问数据"></a>四、访问数据</h3><ul>
<li><ol>
<li>文件读写</li>
</ol>
</li>
<li><ol start="2">
<li>函数：应用程序API</li>
</ol>
</li>
<li><ol start="3">
<li>从进程获取数据，可以用不同的语言编写</li>
</ol>
</li>
</ul>
<h3 id="五、telnet"><a href="#五、telnet" class="headerlink" title="五、telnet"></a>五、telnet</h3><ul>
<li>telnet ip port</li>
<li>我自己的经验……可以用于测试端口是否可用，或者自己写程序的测试</li>
</ul>
<h3 id="六、时间服务器"><a href="#六、时间服务器" class="headerlink" title="六、时间服务器"></a>六、时间服务器</h3><ul>
<li><ol>
<li>处理连接，把时间信息发送过去</li>
</ol>
</li>
<li><ol start="2">
<li>socket-bind-listen-accept-传数据-close</li>
</ol>
</li>
<li><ol start="3">
<li>可以用 telnet ip port 获得结果，也可以自己写客户端</li>
</ol>
</li>
<li><ol start="4">
<li>客户端：socket-connect-read/write-close</li>
</ol>
</li>
</ul>
<h3 id="七、远程的ls命令"><a href="#七、远程的ls命令" class="headerlink" title="七、远程的ls命令"></a>七、远程的ls命令</h3><ul>
<li><ol>
<li>登录远程服务器用ls命令</li>
</ol>
</li>
<li><ol start="2">
<li>本地用远程的ls命令，需要写服务器</li>
</ol>
</li>
<li><ol start="3">
<li>可在远程写个接受shell命令的服务器，调用popen从进程中读取数据返回到客户端，但是注意rm等命令不能随意用</li>
</ol>
</li>
</ul>
<h3 id="八、软件精灵-守护进程"><a href="#八、软件精灵-守护进程" class="headerlink" title="八、软件精灵/守护进程"></a>八、软件精灵/守护进程</h3><ul>
<li><ol>
<li>如httpd,syslogd等，这里的d是精灵(daemon)的意思，也叫守护进程</li>
</ol>
</li>
</ul>
<h1 id="第十二章：连接和协议：编写Web服务器"><a href="#第十二章：连接和协议：编写Web服务器" class="headerlink" title="第十二章：连接和协议：编写Web服务器"></a>第十二章：连接和协议：编写Web服务器</h1><h3 id="一、服务器的三个核心步骤"><a href="#一、服务器的三个核心步骤" class="headerlink" title="一、服务器的三个核心步骤"></a>一、服务器的三个核心步骤</h3><ul>
<li><ol>
<li>服务器设立服务</li>
</ol>
</li>
<li><ol start="2">
<li>客户端连接到服务器</li>
</ol>
</li>
<li><ol start="3">
<li>服务器和客户处理事物</li>
</ol>
</li>
</ul>
<h3 id="二、服务端和客户端的构造"><a href="#二、服务端和客户端的构造" class="headerlink" title="二、服务端和客户端的构造"></a>二、服务端和客户端的构造</h3><ul>
<li><ol>
<li>make_server_socket(port)</li>
</ol>
<ul>
<li>封装socket，bind,listen</li>
</ul>
</li>
<li><ol start="2">
<li>connect_to_server(hostname,port)</li>
</ol>
<ul>
<li>封装socket,connect</li>
</ul>
</li>
<li><ol start="3">
<li>子进程结束发送，SIGCHLD信号，可以自己捕捉处理，避免僵尸进程的产生，也可以用wait，但是wait有问题，比如有多个子进程同时结束，wait来不及同时处理从而产生僵尸进程，可以用waitpid代替</li>
</ol>
</li>
</ul>
<h3 id="三、Web的三种基本用户操作"><a href="#三、Web的三种基本用户操作" class="headerlink" title="三、Web的三种基本用户操作"></a>三、Web的三种基本用户操作</h3><ul>
<li><ol>
<li>请求目录，列举目录信息</li>
</ol>
</li>
<li><ol start="2">
<li>文件请求，返回文件内容</li>
</ol>
</li>
<li><ol start="3">
<li>cgi文件，运行程序</li>
</ol>
</li>
<li><ol start="4">
<li>返回错误消息</li>
</ol>
</li>
</ul>
<h3 id="四、设计Web服务器"><a href="#四、设计Web服务器" class="headerlink" title="四、设计Web服务器"></a>四、设计Web服务器</h3><ul>
<li><ol>
<li>建立服务器</li>
</ol>
</li>
<li><ol start="2">
<li>接收请求</li>
</ol>
</li>
<li><ol start="3">
<li>读取请求</li>
</ol>
</li>
<li><ol start="4">
<li>处理请求</li>
</ol>
</li>
<li><ol start="5">
<li>发送应答</li>
</ol>
</li>
</ul>
<h3 id="五、HTTP协议"><a href="#五、HTTP协议" class="headerlink" title="五、HTTP协议"></a>五、HTTP协议</h3><ul>
<li><ol>
<li>客户发送请求<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET filename HTTP&#x2F;version</span><br><span class="line">可选参数</span><br><span class="line">空行</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>服务器发送应答<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;version status-code status-msg</span><br><span class="line">附加信息</span><br><span class="line">空行</span><br><span class="line">内容</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h1 id="第十三章：基于数据报的编程：编写许可证服务器"><a href="#第十三章：基于数据报的编程：编写许可证服务器" class="headerlink" title="第十三章：基于数据报的编程：编写许可证服务器"></a>第十三章：基于数据报的编程：编写许可证服务器</h1><h3 id="零、相关命令和操作"><a href="#零、相关命令和操作" class="headerlink" title="零、相关命令和操作"></a>零、相关命令和操作</h3><ul>
<li>socket</li>
<li>sendto,recvfrom<h3 id="一、许可证服务系统"><a href="#一、许可证服务系统" class="headerlink" title="一、许可证服务系统"></a>一、许可证服务系统</h3></li>
<li><ol>
<li>用户想使用程序</li>
</ol>
</li>
<li><ol start="2">
<li>程序向许可证服务器请求是否可用</li>
</ol>
</li>
<li><ol start="3">
<li>若可用，获得许可证，从而使用</li>
</ol>
</li>
<li><ol start="4">
<li>不可用，提示</li>
</ol>
</li>
<li><ol start="5">
<li>若是本地服务器，票据格式可以是进程pid+信息<h3 id="二、数据报，UDP"><a href="#二、数据报，UDP" class="headerlink" title="二、数据报，UDP"></a>二、数据报，UDP</h3>TCP|UDP</li>
</ol>
</li>
<li>–|—<br>流|数据报<br>分片/重组|否<br>排序|否<br>可靠地|可能未到达<br>连接的|多个发送者<br>有连接操作，较慢|无握手，较快</li>
</ul>
<h3 id="三、许可证服务器改进"><a href="#三、许可证服务器改进" class="headerlink" title="三、许可证服务器改进"></a>三、许可证服务器改进</h3><ul>
<li><ol>
<li>客户端崩溃怎么办</li>
</ol>
<ul>
<li>造成的问题：没有释放票据，一直占用着，其他客户也不能用</li>
<li>解决办法：服务器端调度收回票据，隔一段时间问客户还用不用，不用的话就收回</li>
<li>注意：在处理请求的时候最好关闭调度，也就是忽略alarm信号，防止破坏数据的一致性</li>
</ul>
</li>
<li><ol start="2">
<li>服务器崩溃</li>
</ol>
<ul>
<li>造成的问题：签出列表丢失，失去进程持有票据的记录</li>
<li>解决办法：1. 票据验证，客户周期性的向服务器发送票据副本<pre><code>      2. 协议中增加验证</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="四、分布式许可证服务器"><a href="#四、分布式许可证服务器" class="headerlink" title="四、分布式许可证服务器"></a>四、分布式许可证服务器</h3><p>会出现的问题</p>
<ul>
<li><ol>
<li>因为票据标示是进程pid，在不同的主机上可能有相同的pid，发生矛盾，可以扩展票据表项的格式，增加主机标识</li>
</ol>
</li>
<li><ol start="2">
<li>回收票据，是通过kill(pid,0)回收的，而不同主机服务器不能给客户端发送信号，可以每个客户端都运行服务器实例。但是又会有新问题。kill(pid,0)是退出信号</li>
</ol>
</li>
<li><ol start="3">
<li>主机崩溃，若其中一台崩溃，会发生什么？主服务器还在运行的话，如何回收票据？客户端如何验证票据呢？如果主服务器崩溃，谁来分发票据？有如下解决办法：</li>
</ol>
<ul>
<li>客户端服务器和中央服务器通信</li>
<li>每个客户都和中央服务器通信</li>
<li>客户服务器和客户服务器通信，没有中央服务器</li>
</ul>
</li>
</ul>
<h3 id="五、Unix域socket"><a href="#五、Unix域socket" class="headerlink" title="五、Unix域socket"></a>五、Unix域socket</h3><ul>
<li><ol>
<li>文件名作为socket地址</li>
</ol>
</li>
<li><ol start="2">
<li>就是本地socket通信</li>
</ol>
</li>
</ul>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><table>
<thead>
<tr>
<th>socket</th>
<th>PF_INET</th>
<th>PF_UNIX</th>
</tr>
</thead>
<tbody><tr>
<td>SOCK_STREAM</td>
<td>连接的，跨机器</td>
<td>连接的，本地</td>
</tr>
<tr>
<td>SOCK_DGRAM</td>
<td>数据报，跨机器</td>
<td>数据报，本地</td>
</tr>
</tbody></table>
<h1 id="第十四章：线程机制：并发函数的使用"><a href="#第十四章：线程机制：并发函数的使用" class="headerlink" title="第十四章：线程机制：并发函数的使用"></a>第十四章：线程机制：并发函数的使用</h1><h3 id="零、相关命令和操作-1"><a href="#零、相关命令和操作-1" class="headerlink" title="零、相关命令和操作"></a>零、相关命令和操作</h3><ul>
<li>pthread_create,pthread_join</li>
<li>pthread_mutex_lock,pthread_mutex_unlock</li>
<li>pthread_cond_wait,pthread_cond_signal</li>
</ul>
<h3 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h3><ul>
<li><ol>
<li>pthread_create 绑定线程函数</li>
</ol>
</li>
<li><ol start="2">
<li>pthread_join 等待线程结束</li>
</ol>
</li>
<li><ol start="3">
<li>pthread_mutex_lock/unlock 互斥量访问资源，比如多个线程需要修改一个变量，就在修改前后加解锁，不过加锁后速度降低，也可以线程单独开一个变量，处理完返回，看情况。</li>
</ol>
</li>
</ul>
<h3 id="二、线程和进程"><a href="#二、线程和进程" class="headerlink" title="二、线程和进程"></a>二、线程和进程</h3><ul>
<li><ol>
<li>线程是共享进程的内存，所以要考虑很多问题。如下几个问题</li>
</ol>
</li>
<li><ol start="2">
<li>共享的数据空间</li>
</ol>
<ul>
<li>一个线程中malloc，而另一个线程free</li>
</ul>
</li>
<li><ol start="3">
<li>共享的文件描述符</li>
</ol>
<ul>
<li>若一个文件关闭了某个文件描述符，则对于其他的线程来说也不能用这个文件描述符了</li>
</ul>
</li>
<li><ol start="4">
<li>fork,exec,exit,signals</li>
</ol>
<ul>
<li>某线程fork，则只有该线程在新进程中运行，其他线程不会</li>
<li>某线程exit，则其他线程全部退出</li>
<li>某线程exec，则其他线程全部退出,新的程序取代当前程序</li>
<li>对于signal,进程可以接受任意信号，对于线程呢？这个可以看其他书学习<h3 id="三、线程间互通消息"><a href="#三、线程间互通消息" class="headerlink" title="三、线程间互通消息"></a>三、线程间互通消息</h3></li>
</ul>
</li>
<li><ol>
<li>使用条件变量</li>
</ol>
<ul>
<li>pthread_cond_signal(cond),通过条件变量发送消息，若没有wait，什么都不发生，若有多个wait，只响应一个</li>
<li>pthread_cond_wait(cond,mutex),等待其他线程发出signal条件变量消息，此函数总是和互斥锁一起使用，改函数解开锁，并挂起等待，若没有被锁，则执行结果不确定</li>
</ul>
</li>
</ul>
<h3 id="四、多线程Web服务器"><a href="#四、多线程Web服务器" class="headerlink" title="四、多线程Web服务器"></a>四、多线程Web服务器</h3><ul>
<li><ol>
<li>把fork换成pthread_create</li>
</ol>
</li>
<li><ol start="2">
<li>独立线程</li>
</ol>
<ul>
<li>一般线程需要pthread_join来等待线程结束回收资源，然而有些线程不用等待返回，但还得释放资源，可以在create时声明，称之为独立线程</li>
</ul>
</li>
<li>3.Web服务器不需要等待处理请求的线程返回，所以可以设置为独立线程</li>
</ul>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><ul>
<li><ol>
<li>可以通过线程可以实现复杂的动画</li>
</ol>
</li>
<li><ol start="2">
<li>通信方式</li>
</ol>
<ul>
<li>进程通信通过：管道，文件，socket，信号</li>
<li>线程：锁，信号量，文件，信号</li>
</ul>
</li>
</ul>
<h1 id="第十五章：进程间通信（IPC）"><a href="#第十五章：进程间通信（IPC）" class="headerlink" title="第十五章：进程间通信（IPC）"></a>第十五章：进程间通信（IPC）</h1><h3 id="零、相关命令和操作-2"><a href="#零、相关命令和操作-2" class="headerlink" title="零、相关命令和操作"></a>零、相关命令和操作</h3><ul>
<li>select,poll</li>
<li>mkfifo</li>
<li>shmget,shmat,shmctl,shmdt</li>
<li>semget,semctl,semop</li>
<li>talk,lpr</li>
</ul>
<h3 id="一、从多个数据源读取数据"><a href="#一、从多个数据源读取数据" class="headerlink" title="一、从多个数据源读取数据"></a>一、从多个数据源读取数据</h3><ul>
<li><ol>
<li>talk,直接read/write,设置read非阻塞，但是这样极其占用资源，因为调用read要进行内核切换。</li>
</ol>
</li>
<li><ol start="2">
<li>select系统调用</li>
</ol>
<ul>
<li>获得算需要的文件描述符列表</li>
<li>将此列表传给select</li>
<li>select挂起直到任何一个文件文件描述符有数据到达</li>
<li>select设置一个变量中的若干位，用来通知你哪一个文件描述符已经有输入的数据</li>
</ul>
</li>
<li><ol start="3">
<li>poll和select类似</li>
</ol>
</li>
</ul>
<h3 id="二、通信的选择"><a href="#二、通信的选择" class="headerlink" title="二、通信的选择"></a>二、通信的选择</h3><ul>
<li><ol>
<li>进程间通信的三种方式</li>
</ol>
<ul>
<li>文件</li>
<li>命名管道 mkfifo/unlink/open/write/read,和文件不同的是，从管道读取数据后，数据就没了。</li>
<li>共享内存<ul>
<li>共享内存段不依赖进程的存在而存在</li>
<li>共享内存段有自己的名字，称为关键字(key)，是个整型</li>
<li>共享内存段有自己的拥有者和权限位</li>
<li>进程可以连接到某共享内存段，并且获得指向此段的指针</li>
<li>操作<ul>
<li><ol>
<li>得到共享内存段，shmget(…)</li>
</ol>
</li>
<li><ol start="2">
<li>进程连接共享内存，shmat(…)</li>
</ol>
</li>
<li><ol start="3">
<li>读写交互，通用的对指针的读写</li>
</ol>
</li>
</ul>
</li>
<li>特点<ul>
<li><ol>
<li>多个客户，可以多个客户读取共享内存段</li>
</ol>
</li>
<li><ol start="2">
<li>避免竞态条件，使用信号量</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ol start="2">
<li>各通信方式的比较</li>
</ol>
<ul>
<li>速度<ul>
<li>通过文件或命名管道需要更多的操作。</li>
<li>但是共享内存机制同样也包括了对磁盘的读写，因为虚拟内存系统允许用户空间(内存)中的段交换到磁盘上</li>
</ul>
</li>
<li>连接和无连接<ul>
<li>无连接：共享内存，文件，数据报socket</li>
<li>连接：fifo,流socket</li>
</ul>
</li>
<li>范围<ul>
<li>父子进程通信：无名管道</li>
<li>本机进程通信：共享内存，命名管道，本地socket</li>
<li>远程主机通信：文件，ip socket</li>
</ul>
</li>
<li>访问限制<ul>
<li>ip socket没有访问权限限制</li>
<li>其他基本都有文件系统权限限制</li>
</ul>
</li>
<li>竞态条件<ul>
<li>问题：一个读，另一个写，会有问题</li>
<li>解决：锁和信号量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三、进程间的分工合作"><a href="#三、进程间的分工合作" class="headerlink" title="三、进程间的分工合作"></a>三、进程间的分工合作</h3><ul>
<li><ol>
<li>文件锁</li>
</ol>
<ul>
<li>读数据锁：其他人可以读，不能写</li>
<li>写数据锁：其他人不能操作</li>
<li>通过fcntl设置</li>
</ul>
</li>
<li>2.信号量<ul>
<li>创建信号量集：semget</li>
<li>将所有信号量置0:semctl</li>
<li>执行操作：semop</li>
<li>删除信号量：semctl</li>
</ul>
</li>
</ul>
<h3 id="四、打印池"><a href="#四、打印池" class="headerlink" title="四、打印池"></a>四、打印池</h3><ul>
<li><ol>
<li>多个写者，一个读者，例如打印机</li>
</ol>
</li>
<li><ol start="2">
<li>客户/服务器模型</li>
</ol>
<ul>
<li>客户只把要打印的数据发送到服务器</li>
<li>服务器对要打印的数据进行处理，然后放到打印队列中</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>《Vuejs实战》</title>
    <url>/%E3%80%8AVuejs%E5%AE%9E%E6%88%98%E3%80%8B/</url>
    <content><![CDATA[<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ul>
<li>感觉和微信小程序语法很类似<a id="more"></a></li>
<li>解决vue和Django一起用时的语法冲突  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决办法1:</span><br><span class="line">    在django1.5以后,加入了标签:</span><br><span class="line">    &#123;% verbatim myblock %&#125; &#123;% endverbatim myblock %&#125;</span><br><span class="line">    被此标签包裹的代码将不会被Django的模板引擎渲染。</span><br><span class="line">    因此,我们可以把带有&#123;&#123; &#125;&#125; 的Vue代码放在 &#123;% verbatim myblock %&#125;标签中间,例如:</span><br><span class="line"></span><br><span class="line">    &lt;div id&#x3D;&quot;app1&quot;&gt;</span><br><span class="line">    &#123;% verbatim myblock %&#125;</span><br><span class="line">    &#123;&#123; message1 &#125;&#125;</span><br><span class="line">    &#123;% endverbatim myblock %&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">解决办法2:</span><br><span class="line">    修改Vue的&#123;&#123; &#125;&#125; 为&#123;[ ]&#125;</span><br><span class="line"></span><br><span class="line">    var app &#x3D;new Vue(&#123;</span><br><span class="line">        delimiters:[&#39;[[&#39;,&#39;]]&#39;],</span><br><span class="line">        el :&#39;#lv-form&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            info:&#39;asd&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            infochange:function()&#123;</span><br><span class="line">                info&#x3D;&#39;aaa&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<h1 id="第一篇：基础篇"><a href="#第一篇：基础篇" class="headerlink" title="第一篇：基础篇"></a>第一篇：基础篇</h1></li>
<li>基础篇将循序渐进地介绍 Vue.js 的核心功能,包括数据的双向绑定、计算属性、基本指令、自定义指令及组件等。通过对基础篇的学习,可以快速构建出 Vue.js 应用井直接用于生产环境。<h1 id="第一章：初识Vue-js"><a href="#第一章：初识Vue-js" class="headerlink" title="第一章：初识Vue.js"></a>第一章：初识Vue.js</h1></li>
</ul>
<h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h3><ul>
<li>简单小巧<ul>
<li>Vue.js 压缩后大小仅有17KB</li>
</ul>
</li>
<li>渐进式( Progressive )<ul>
<li>就是你可以 一步一步、有阶段性地来使用 Vue.js ,不必一开始就使用所有的东西</li>
</ul>
</li>
<li>它提供了现代 Web开发中常见的高级功能,比如 :<ul>
<li>解辑视图与数据。</li>
<li>可复用的组件 .</li>
<li>前端路由.</li>
<li>状态管理 .</li>
<li>虚拟 DOM ( Virtual DOM)</li>
</ul>
</li>
</ul>
<h3 id="2-MVVM模式"><a href="#2-MVVM模式" class="headerlink" title="2. MVVM模式"></a>2. MVVM模式</h3><ul>
<li>由MVC衍生而来</li>
<li>View&lt;——&gt;ViewModel&lt;—–&gt;Model</li>
</ul>
<h3 id="3-Vue-js与jQuery的不同"><a href="#3-Vue-js与jQuery的不同" class="headerlink" title="3. Vue.js与jQuery的不同"></a>3. Vue.js与jQuery的不同</h3><ul>
<li>jQuery视图代码和业务逻辑紧藕合在一起,随着功能不断增加,直接操作 DOM 会使得代码越来越难以维护。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(showBtn) &#123;</span><br><span class="line">var btn &#x3D; $(&#39;&lt; button&gt;Click me&lt;&#x2F;button &gt;&#39;);</span><br><span class="line">btn.on(&#39;click&#39;, function ()&#123;</span><br><span class="line">    console.log (&#39;Clicked!&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">$(&#39;#app&#39;).appeηd(btn);</span><br></pre></td></tr></table></figure></li>
<li>Vue.js 通过 MVVM 的模式拆分为视图与数据两部分,并将其分离。因此,你只需要关心你的数据即可, DOM 的事情 Vue 会帮你自动搞定,比如上面的示例用 Vue.js 可以改写为 :  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id &#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;button v-if &#x3D;&quot;showBtn&quot; v-on:click &#x3D;&quot;handleClick&quot;&gt; Click me&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            showBtn: true</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            handleClick: function()&#123;</span><br><span class="line">                console.log (&#39;Clicked !&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-传统前端开发和Vue"><a href="#4-传统前端开发和Vue" class="headerlink" title="4. 传统前端开发和Vue"></a>4. 传统前端开发和Vue</h3><h5 id="传统前端开发"><a href="#传统前端开发" class="headerlink" title="传统前端开发"></a>传统前端开发</h5><ul>
<li>“万金油”的技术技<ul>
<li>jQuery + RequireJS ( SeaJS ) + artTemplate ( doT ) +Gulp ( Grunt)</li>
<li>这套技术战以 jQuery 为核心,能兼容绝大部分浏览器</li>
<li>使用 RequireJS 或 SeaJS 进行模块化开发可以解决代码依赖混乱的问题 , 同时便于维护及团队协作</li>
<li>使用轻量级的前端模板(如 doT )可以将数据与 HTML模板分离</li>
<li>用自动化构建工具(如 Gulp )可以合并压缩代码</li>
</ul>
</li>
</ul>
<h5 id="Vue-的开发模式"><a href="#Vue-的开发模式" class="headerlink" title="Vue 的开发模式"></a>Vue 的开发模式</h5><ul>
<li>Vue.js是一个渐进式的 JavaScript 框架,根据项目需求,你可以选择从不同的维度来使用它。</li>
<li>如果你只是想体验 Vue带来的快感,或者开发几个简单的 HTML 5 页面或小应用,你可以直接通过 script 加 载 CDN 文件，例如 :  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">〈!一自动识别最新稳定版本的 Vue . j s 一〉</span><br><span class="line">&lt;script src &#x3D; &quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue&#x2F;dist&#x2F;vue.min.js&quot; &gt;&lt;&#x2F;script&gt;</span><br><span class="line">〈! 一指定某个具体版本的 Vue . j s 一〉</span><br><span class="line">&lt;script src &#x3D; &quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue@2.1.6&#x2F;dist&#x2F;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li>对于一些业务逻辑复杂,对前端工程有要求的项目,可以使用Vue单文件的形式配合webpack使用,必要时还会用到vuex来管理状态, vue-router来管理路由。</li>
</ul>
<h1 id="第二章：数据绑定和第一个-Vue-应用"><a href="#第二章：数据绑定和第一个-Vue-应用" class="headerlink" title="第二章：数据绑定和第一个 Vue 应用"></a>第二章：数据绑定和第一个 Vue 应用</h1><h3 id="1-第一个例子"><a href="#1-第一个例子" class="headerlink" title="1. 第一个例子"></a>1. 第一个例子</h3><ul>
<li>实时显示输入框中的内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; !DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Vue 实例&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;input type &#x3D;&quot;text&quot; v-model &#x3D;&quot;name&quot; placeholder&#x3D;&quot;你的名字&quot;〉</span><br><span class="line">        &lt;hl &gt;你好,&#123;&#123; name &#125;&#125;&lt;&#x2F;hl&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue&#x2F;dist&#x2F;vue.min.js&quot;&gt;&lt;&#x2F; script &gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var app &#x3D;new Vue(&#123;</span><br><span class="line">            el :’#app’,</span><br><span class="line">            data: &#123;</span><br><span class="line">                name : &#39;&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-Vue实例与数据绑定"><a href="#2-Vue实例与数据绑定" class="headerlink" title="2. Vue实例与数据绑定"></a>2. Vue实例与数据绑定</h3><ul>
<li>通过构造函数 Vue 就可以创建一个 Vue 的根实例  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">var app&#x3D;new Vue(&#123;</span><br><span class="line">    el:document.getElementById(&#39;app&#39;)   &#x2F;&#x2F;或者是&#39;#app&#39;</span><br><span class="line">    data: &#123;</span><br><span class="line">        name : &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>必不可少的 一个选项就是 el 。 el 用于指定一个页面中己存在的 DOM 元素来挂载 Vue实例,它可以是 HTMLElement ,也可以是 css 选择器,</li>
<li>通过 Vue 实例的 data 选项,可以声明应用内需要双向绑定的数据。</li>
<li>上例中在 input 标签上,有一个 v-model 的指令,它的值对应于我们创建的 Vue 实例的 data 选项 中的 name 字段 , 这就是 Vue 的 数据绑定。</li>
<li>建议所有会用到的数据都预先在 data 内声明,这样不至于将数据散落在业务逻辑中,难以维护。</li>
<li>Vue 实例本身也代理了 data 对象里的所有属性,所以可以这样访问:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(app.name);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3. 生命周期"></a>3. 生命周期</h3><ul>
<li>created<ul>
<li>实例创建完成后调用,此阶段完成了数据的观测等,但尚未挂载, $el 还不可用。需要初始化处理一些数据时会比较有用,后面章节将有介绍.</li>
</ul>
</li>
<li>mounted<ul>
<li>el 挂载到实例上后调用,一般我们的第一个业务逻辑会在这里开始 。</li>
</ul>
</li>
<li>beforeDestroy<ul>
<li>实例销毁之前调用。主要解绑一些使用 addEventListener 监听的事件等。</li>
</ul>
</li>
</ul>
<h3 id="4-插值与表达式"><a href="#4-插值与表达式" class="headerlink" title="4. 插值与表达式"></a>4. 插值与表达式</h3><ul>
<li><p>就是的使用</p>
</li>
<li><p>var_name是个变量或表达式</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D; &quot;app&quot; 〉</span><br><span class="line">    &#123;&#123;number&#x2F;10 ))</span><br><span class="line">    &#123;&#123; isOK ? ’ 确定 ’:’ 取消 ’ &#125;&#125;</span><br><span class="line">    &#123;&#123; text.split (&#39;,&#39;).reverse().join(&#39;,&#39;) &#125;&#125;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>如果有的时候就是想输出 HTML ,而不是将数据解释后的纯文本,可以使用 v-html:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span v-html &#x3D;&quot;link&quot;&gt;&lt;&#x2F; span&gt;</span><br><span class="line">......</span><br><span class="line">var app&#x3D;new Vue(&#123;</span><br><span class="line">    el:document.getElementById(&#39;app&#39;)   &#x2F;&#x2F;或者是&#39;#app&#39;</span><br><span class="line">    data: &#123;</span><br><span class="line">        link : &#39;&lt;a href &#x3D;”#”&gt;这是一个连接&lt;&#x2F;a&gt;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>如果想显示<code>&#123;&#123;&#125;&#125;`标签,而不进行替换 , 使用 v-pre
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span v-pre &gt;&#123;&#123; 这里的内容是不会被编译的 &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

### 5. 过滤器
- Vue.js支持在`&#123;&#123;&#125;&#125;</code>插值的尾部添加 一小管道符”|”对数据进行过滤</p>
</li>
<li><p>经常用于格式化文本 ,比如字母全部大写、货币千位使用逗号分隔等。</p>
</li>
<li><p>过滤 的规则 是自定义的, 通过给 Vue 实例添加选项 filters 来设置</p>
</li>
<li><p>一个时间过滤器的例子</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; date | formatDate &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app &#x3D;new Vue(&#123;</span><br><span class="line">        el :’#app’,</span><br><span class="line">        data: &#123;</span><br><span class="line">            date : new Date()</span><br><span class="line">        &#125;,</span><br><span class="line">        filters:&#123;</span><br><span class="line">            formatDate:function(value)&#123;&#x2F;&#x2F;value是传入的要过滤的数据</span><br><span class="line">                var date &#x3D; new Date(value);</span><br><span class="line">                var year &#x3D; date.getFullYear();</span><br><span class="line">                var month &#x3D; date.getMonth()+1;</span><br><span class="line">                &#x2F;&#x2F;将新格式的数据返回</span><br><span class="line">                return year+&#39;-&#39;+month;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted:function()&#123;</span><br><span class="line">            var _this&#x3D;this;</span><br><span class="line">            this.timer&#x3D;setInterval(function()&#123;</span><br><span class="line">                _this.date&#x3D;new Date();</span><br><span class="line">            &#125;,1000);&#x2F;&#x2F;设置定时器修改时间</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeDestroy:function()&#123;</span><br><span class="line">            if(this.thimer)&#123;</span><br><span class="line">                clearInterval(this.timer);&#x2F;&#x2F;实例销毁前清除定时器</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>过滤器也可以串联</p>
<ul>
<li><code>&#123;&#123; message|filter1|filter2 &#125;&#125;</code></li>
</ul>
</li>
<li><p>过滤器接收参数</p>
<ul>
<li><code>&#123;&#123; message|filterA('arg1','arg2') &#125;&#125;</code></li>
<li>arg1和arg2分别是第二、三个参数，第一个参数是message</li>
</ul>
</li>
<li><p>过滤器应当用于处理简单的文本转换,如果要实现更为复杂的数据变换,应该使用计算属性</p>
</li>
</ul>
<h3 id="6-指令和事件-v-if-v-bind-v-on"><a href="#6-指令和事件-v-if-v-bind-v-on" class="headerlink" title="6. 指令和事件,v-if,v-bind,v-on"></a>6. 指令和事件,v-if,v-bind,v-on</h3><ul>
<li>指令( Directives )是 Vue 模板中最常用的一项功能,它带有前缀 v-</li>
<li>指令的主要职责就是当其表达式的值改变时,相应地将某些行为应用到 DOM 上</li>
<li>以 v-if 为例 :  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-if &#x3D;&quot;show&quot;〉显示这段文本 &lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app &#x3D;new Vue(&#123;</span><br><span class="line">        el :’#app’,</span><br><span class="line">        data: &#123;</span><br><span class="line">            show : true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F;当数据 show 的值为 true 时, p 元素会被插入,为 false 时则会被移除 。</span><br><span class="line">&#x2F;&#x2F;数据驱动 DOM 是 Vue.js的核心理念,所以不到万不得已时不要主动操作 DOM ,</span><br><span class="line">&#x2F;&#x2F;你只需要维护好数据, DOM 的事 Vue 会帮你优雅的处理。</span><br></pre></td></tr></table></figure></li>
<li>v-bind 的基本用途是动态更新 HTML 元素上的属性,比如 id、 class 等,例如下面几个示例:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;当通过各种方式改变数据时,链接和图片都会自动更新。</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;a v-bind:href &#x3D;”url”&gt;链接&lt;&#x2F; a&gt;</span><br><span class="line">    &lt;img v-bind:src&#x3D;”imgUrl”&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app &#x3D;new Vue(&#123;</span><br><span class="line">        el :’#app’,</span><br><span class="line">        data: &#123;</span><br><span class="line">            url :&#39;https:&#x2F;&#x2F;www.github.com&#39;,</span><br><span class="line">            imgUrl :&#39;http:&#x2F;&#x2F;xxx.xxx.xx&#x2F;img.png&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li>v-on ,它用来绑定事件监听器,这样我们就可以做一些交互  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-if &#x3D;&quot;show&quot;〉显示这段文本 &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;” handleClose ”〉点击隐藏&lt;&#x2F; button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app &#x3D;new Vue(&#123;</span><br><span class="line">        el :’#app’,</span><br><span class="line">        data: &#123;</span><br><span class="line">            show:true</span><br><span class="line">        &#125;</span><br><span class="line">        methods:&#123;</span><br><span class="line">            handleClose:function()&#123;</span><br><span class="line">                this.show&#x3D;false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F;在普通元素上, v-on 可以监昕原生的 DOM 事件,除了 click 外,还有 dblclick、 keyup, mousemove 等</span><br><span class="line">&#x2F;&#x2F;表达式可以是一个方法名,这些方法都写在 Vue 实例的 methods 属性内,并且是函数的形式</span><br><span class="line">&#x2F;&#x2F;表达式除了方法名, 也可以直接是一个内联语旬,上例也可以改写为:</span><br><span class="line">&lt;button v-on:click&#x3D;&quot;show&#x3D;false&quot;〉点击隐藏&lt;&#x2F; button&gt;</span><br></pre></td></tr></table></figure>
<h3 id="7-语法糖"><a href="#7-语法糖" class="headerlink" title="7. 语法糖"></a>7. 语法糖</h3></li>
<li>语法糖是指在不影响功能的情况下 , 添加某种方法实现同样的效果 , 从而方便程序开发。</li>
<li>v-bind , 可以省略 v-bind,直接写一个冒号  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a v-bind:href &#x3D;”url”&gt;链接&lt;&#x2F; a&gt;</span><br><span class="line">&#x2F;&#x2F;缩写为</span><br><span class="line">&lt;a :href &#x3D;”url”&gt;链接&lt;&#x2F; a&gt;</span><br></pre></td></tr></table></figure></li>
<li>v-on 可以直接用 “ @ ” 来缩写  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button v-on:click&#x3D;” handleClose ”〉点击隐藏&lt;&#x2F; button&gt;</span><br><span class="line">&#x2F;&#x2F;缩写为</span><br><span class="line">&lt;button @click&#x3D;” handleClose ”〉点击隐藏&lt;&#x2F; button&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第三章：计算属性"><a href="#第三章：计算属性" class="headerlink" title="第三章：计算属性"></a>第三章：计算属性</h1><h3 id="1-什么是计算属性"><a href="#1-什么是计算属性" class="headerlink" title="1. 什么是计算属性"></a>1. 什么是计算属性</h3><ul>
<li><p>我理解就是对 <code>&#123;&#123; &#125;&#125;</code> 里的变量进行动态计算显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; text.split (’,’).reverse().join(’,’) &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>如上对变量的计算还容易理解，但若是复杂的计算，应该使用计算属性，如下所示</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; reversedText &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app &#x3D;new Vue(&#123;</span><br><span class="line">        el :’#app’,</span><br><span class="line">        data: &#123;</span><br><span class="line">            text : &#39;123456&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed:&#123;</span><br><span class="line">            reversedText:function()&#123;</span><br><span class="line">                &#x2F;&#x2F;this指当前Vue实例</span><br><span class="line">                return this.text.split (’,’).reverse().join(’,’);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-计算属性用法"><a href="#2-计算属性用法" class="headerlink" title="2. 计算属性用法"></a>2. 计算属性用法</h3></li>
<li><p>除了上例简单的用法,计算属性还可以依赖多个 Vue 实例的数据,只要其中任一数据变化,计算属性就会重新执行,视图也会更新</p>
<ul>
<li>例如购物车里面有许多物品，计算总价</li>
</ul>
</li>
<li><p>每一个计算属性都包含-个 getter 和 一个 setter ,我们上面 的两个示例都是计算属性的默认用法 , 只是利用了 getter 来读取。在你需要时,也可以提供一个 setter 函数</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    reversedText:&#123;</span><br><span class="line">        &#x2F;&#x2F;getter</span><br><span class="line">        get:function()&#123;</span><br><span class="line">            return this.text.split (’,’).reverse().join(’,’);</span><br><span class="line">        &#125;,</span><br><span class="line">        set:function(newText)&#123;</span><br><span class="line">            this.text&#x3D;newText;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-计算属性缓存"><a href="#3-计算属性缓存" class="headerlink" title="3. 计算属性缓存"></a>3. 计算属性缓存</h3><ul>
<li>调用 methods 里的方法也可以与计算属性起到同样的作用 ,比如本章第一个示例可以用 methods 改写为:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; reversedText() &#125;&#125;&#x2F;&#x2F;注意这里调用了函数</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app &#x3D;new Vue(&#123;</span><br><span class="line">        el :’#app’,</span><br><span class="line">        data: &#123;</span><br><span class="line">            text : &#39;123456&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            reversedText:function()&#123;</span><br><span class="line">                &#x2F;&#x2F;this指当前Vue实例</span><br><span class="line">                return this.text.split (’,’).reverse().join(’,’);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li>既然使用 methods 就可以实现,那么为什么还需要计算属性呢?原因就是计算属性是基于它的依赖缓存的。<ul>
<li>一个计算属性所依赖的数据发生变化时,它才会重新取值,所以text 只要不改变,计算属性也就不更新,如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    now:function()&#123;</span><br><span class="line">        return Date.now();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;这里的 Date.now()不是响应式依赖,所以计算属性 now 不会更新。</span><br><span class="line">&#x2F;&#x2F;但是 methods 则不同,只要重新渲染 ,它就会被调用,因此函数也会被执行 。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>使用计算属性还是 methods 取决于你是否需要缓存,当遍历大数组和做大量计算时,应当使用计算属性,除非你不希望得到缓存。</li>
</ul>
<h1 id="第四章：v-bind-及-class-与-style-绑定"><a href="#第四章：v-bind-及-class-与-style-绑定" class="headerlink" title="第四章：v-bind 及 class 与 style 绑定"></a>第四章：v-bind 及 class 与 style 绑定</h1><h3 id="1-v-bind"><a href="#1-v-bind" class="headerlink" title="1. v-bind"></a>1. v-bind</h3><ul>
<li>动态更新 HTML 元素上的属性</li>
<li>在数据绑定中,最常见的两个需求就是元素的样式名称 class 和内联样式 ~tyle 的动态绑定</li>
<li>我们只需要用 v-bind 计算出表达式最终的字符串就可以,不过有时候表达式的逻辑较复杂,使用字符串拼接方法较难阅读和维护,所以 Vue.js 增强了对 class 和 style 的绑定。</li>
</ul>
<h3 id="2-绑定-class-的几种方式"><a href="#2-绑定-class-的几种方式" class="headerlink" title="2. 绑定 class 的几种方式"></a>2. 绑定 class 的几种方式</h3><h5 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div :class &#x3D;”&#123;’active’: isActive &#125;”&gt;&lt;&#x2F; div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app &#x3D;new Vue(&#123;</span><br><span class="line">        el :’#app’,</span><br><span class="line">        data: &#123;</span><br><span class="line">            isActive : true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="数组用法"><a href="#数组用法" class="headerlink" title="数组用法"></a>数组用法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div :class &#x3D;&quot;[activeCls,errorCls]&quot;&gt;&lt;&#x2F; div&gt;</span><br><span class="line">    &lt;div : class &#x3D;&quot;[isActive?activeCls:&#39;&#39;,errorCls]&quot;&gt;&lt;&#x2F; div&gt;&#x2F;&#x2F;也可以三元表达式</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app &#x3D;new Vue(&#123;</span><br><span class="line">        el :’#app’,</span><br><span class="line">        data: &#123;</span><br><span class="line">            isActive：true,</span><br><span class="line">            activeCls:&#39;active&#39;,</span><br><span class="line">            errorCls:&#39;error&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F;渲染后的结果为 :</span><br><span class="line">&lt;div :class &#x3D;&quot;active error&quot;&gt;&lt;&#x2F; div&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以写成计算属性<h5 id="在组件上使用"><a href="#在组件上使用" class="headerlink" title="在组件上使用"></a>在组件上使用</h5></li>
<li>第七章讲组件</li>
</ul>
<h3 id="3-绑定内联样式"><a href="#3-绑定内联样式" class="headerlink" title="3. 绑定内联样式"></a>3. 绑定内联样式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div :style &#x3D;”styles”&gt;文本&lt;&#x2F; div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app &#x3D;new Vue(&#123;</span><br><span class="line">        el :’#app’,</span><br><span class="line">        data: &#123;</span><br><span class="line">            styles:&#123;</span><br><span class="line">                color : &#39;red&#39;,</span><br><span class="line">                fontSize:14</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F;应用 多 个样式对象时 , 可 以 使用数组语法 :</span><br><span class="line">&lt;div :style &#x3D;&quot;[styleA , styleB]&quot;&gt;文本&lt;&#x2F;div&gt;&#x2F;&#x2F;不常用</span><br></pre></td></tr></table></figure>

<h1 id="第五章：内置指令"><a href="#第五章：内置指令" class="headerlink" title="第五章：内置指令"></a>第五章：内置指令</h1><h3 id="1-基本指令"><a href="#1-基本指令" class="headerlink" title="1. 基本指令"></a>1. 基本指令</h3><h5 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot; v-cloak&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app &#x3D;new Vue(&#123;</span><br><span class="line">        el :’#app’,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message : &#39;一段文本&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>这时虽然己经加了指令 v-cloak ,但其实并没有起到任何作用,当网速较慢时，在页面上会显示{ { message } }的字样，直到 Vue 创建实例、编译模板时, DOM 才会被替换,所以这个过程屏幕是有闪动的。</li>
<li>只要加 一句 css 就可以解决这个问题了 :  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[v-cloak]&#123;</span><br><span class="line">    display:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>v-cloak 是一个解决初始化慢导致页面闪动的最佳实践</li>
<li>对于简单的项目很实用,但是在具有工程化的项目里,比如后面进阶篇将介绍 webpack 和 vue-router 时,项目的 HTML结构只有一个空的 div 元素,剩余的内容都是由路由去挂载不同组件完成的,所以不再需要 v-cloak</li>
</ul>
<h5 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h5><ul>
<li>v-once 也是一个不需要表达式的指令,作用是定义它的元素或组件只渲染一 次,包括元素或<br>组件的所有子节点。首次渲染后,不再随数据的变化重新渲染,将被视为静态内容,</li>
<li>就是 <code>&#123;&#123; &#125;&#125;</code> 内的变量改变也不重新渲染</li>
<li>v-once 在业务中也很少使用,当你需要进一步优化性能时,可能会用到。</li>
</ul>
<h3 id="2-条件渲染指令"><a href="#2-条件渲染指令" class="headerlink" title="2. 条件渲染指令"></a>2. 条件渲染指令</h3><h5 id="v-if-v-else-if-v-else"><a href="#v-if-v-else-if-v-else" class="headerlink" title="v-if,v-else-if,v-else"></a>v-if,v-else-if,v-else</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-if &#x3D;&quot;status &#x3D;&#x3D;&#x3D; 1&quot;&gt;当 status 为 1 时显示该行&lt;&#x2F; p&gt;</span><br><span class="line">    &lt;p v-else-if &#x3D;&quot;status &#x3D;&#x3D;&#x3D; 2&quot;〉当 status 为 2 时显示该行&lt;&#x2F; p&gt;</span><br><span class="line">    &lt;p v-else &gt;否则显示该行&lt;&#x2F; p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app &#x3D;new Vue(&#123;</span><br><span class="line">        el :’#app’,</span><br><span class="line">        data: &#123;</span><br><span class="line">            status : 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果一次判断的是多个元素,可以在 Vue内置的 &lt;template&gt;元素上使用条件指令,最终渲染的结果不会包含该元素,例如:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;template v-if &#x3D;” status &#x3D;&#x3D;&#x3D; 1 ”&gt;</span><br><span class="line">        &lt;p &gt;这是一段文本&lt;&#x2F; p&gt;</span><br><span class="line">        &lt;p &gt;这是一段文本&lt;&#x2F; p&gt;</span><br><span class="line">        &lt;p &gt;这是一段文本&lt;&#x2F; p&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>
<li>Vue 在渲染元素时 ,出于效率考虑,会尽可能地复用已有的元素而非重新渲染</li>
<li>如果你不希望这样做,可以使用 Vue扣提供的 key 属性,它可以让你自己决定是否要复用元<br>素, key 的值必须是唯一 的  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;template v-if &#x3D;” status &#x3D;&#x3D;&#x3D; 1 ”&gt;</span><br><span class="line">        &lt;input placeholder&#x3D;&quot;输入用户名&quot; key&#x3D;&quot;name-input&quot;&gt;</span><br><span class="line">        &lt;p &gt;这是一段文本&lt;&#x2F; p&gt;</span><br><span class="line">        &lt;p &gt;这是一段文本&lt;&#x2F; p&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h5></li>
<li>v-show 的用法与 v-if 基本一致,只不过 v-show 是改变元素的 css 属性 display 。当 v-show 表达式的值为 false 时, 元素会隐藏,查看 DOM 结构会看到元素上加载了内联样式 display : none;,例如 :  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-show&#x3D;&quot;status &#x3D;&#x3D;&#x3D; 1&quot;&gt;当 status 为 1 时显示该行&lt;&#x2F; p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F;渲染后的结果为 :</span><br><span class="line">&lt;p style&#x3D;&quot;display: none;”〉当 status 为 1 时显示该行 &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure></li>
<li>v-show 不能在&lt;template&gt;上使用</li>
</ul>
<h5 id="v-if-与-v-show-的选择"><a href="#v-if-与-v-show-的选择" class="headerlink" title="v-if 与 v-show 的选择"></a>v-if 与 v-show 的选择</h5><ul>
<li>v-if 和 v-show 具有类似的功能,不过 v-if 才是真正的条件渲染,它会根据表达式适当 地销毁或重建元素及绑定的事件或子组件。若表达式初始值为 false ,则 一开始元素/组件并不会渲染,只有当条件第一次变为真时才开始编译。</li>
<li>v-show 只是简单的 css 属性切换,无论条件真与否,都会被编译。</li>
<li>相比之下, v-if 更适合条件不经常改变的场景,因为它切换开销相对较大,而 v-show 适用于频繁切换条件。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>《操作系统精髓与设计原理》</title>
    <url>/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E3%80%8B/</url>
    <content><![CDATA[<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ol>
<li>知识过于繁杂，挑重点简要记录</li>
<li>主要针对Linux操作系统，Windows和Android需要的时候再学</li>
<li>虽然书过了一遍，但深深的知道自己还有很多不动的地方，特别是多处理器那里，想起来刚学操作系统的时候，也是觉得没什么用，不知道在学什么，后来了解到Linux编程，再看操作系统真的有不少感悟，现在看多处理器那部分就是处于不知道干什么的状态，还是没有实践啊</li>
<li>看完后觉得我们大二的时候上操作系统课，为什么不用这本书，觉得这里面的课后习题什么的都挺好的，附录也很好，特别是OS/161，我之前为了做大作业也尝试看过《一个64为操作系统的实现》《30天自制一个操作系统》这种书，没想到这就有一个现成的，难受。<a id="more"></a>
<h1 id="第一章：计算机系统概述"><a href="#第一章：计算机系统概述" class="headerlink" title="第一章：计算机系统概述"></a>第一章：计算机系统概述</h1></li>
</ol>
<h3 id="1-基本构成"><a href="#1-基本构成" class="headerlink" title="1. 基本构成"></a>1. 基本构成</h3><ol>
<li>处理器</li>
<li>内存</li>
<li>IO模块</li>
<li>系统总线</li>
</ol>
<h3 id="2-指令分类"><a href="#2-指令分类" class="headerlink" title="2. 指令分类"></a>2. 指令分类</h3><ol>
<li>处理器&lt;–&gt;存储器</li>
<li>处理器&lt;–&gt;IO</li>
<li>数据处理</li>
<li>控制</li>
</ol>
<h3 id="3-中断"><a href="#3-中断" class="headerlink" title="3. 中断"></a>3. 中断</h3><h5 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h5><table>
<thead>
<tr>
<th>分类</th>
<th>表现</th>
</tr>
</thead>
<tbody><tr>
<td>程序中断</td>
<td>在某些条件下由指令的执行结果产生，如算术溢出，除数为0，试图执行一条非法机器指令，访问用户不允许的位置</td>
</tr>
<tr>
<td>时钟中断</td>
<td>处理器内部的计时器产生，允许操作系统周期性的执行函数</td>
</tr>
<tr>
<td>I/O中断</td>
<td>由IO控制器产生，用于发信号通知一个操作完成或各种错误条件</td>
</tr>
<tr>
<td>硬件失效中断</td>
<td>有掉电，奇偶校验错之类的故障产生</td>
</tr>
</tbody></table>
<h5 id="多个中断"><a href="#多个中断" class="headerlink" title="多个中断"></a>多个中断</h5><ul>
<li>禁止再中断</li>
<li>优先级</li>
</ul>
<h3 id="4-内存层次"><a href="#4-内存层次" class="headerlink" title="4. 内存层次"></a>4. 内存层次</h3><h5 id="板上存储器"><a href="#板上存储器" class="headerlink" title="板上存储器"></a>板上存储器</h5><ol>
<li>寄存器</li>
<li>高速缓存</li>
<li>内存</li>
</ol>
<h5 id="板外存储器"><a href="#板外存储器" class="headerlink" title="板外存储器"></a>板外存储器</h5><ol start="4">
<li>磁盘，CD</li>
</ol>
<h5 id="离线存储器"><a href="#离线存储器" class="headerlink" title="离线存储器"></a>离线存储器</h5><ol start="5">
<li>磁带</li>
</ol>
<h3 id="5-高速缓存"><a href="#5-高速缓存" class="headerlink" title="5. 高速缓存"></a>5. 高速缓存</h3><ol>
<li>CPU&lt;—-字传送(快)—&gt;高速缓存(L1,L2,L3)&lt;—块传送(慢)—-内存</li>
</ol>
<h3 id="6-多处理器和多核"><a href="#6-多处理器和多核" class="headerlink" title="6. 多处理器和多核"></a>6. 多处理器和多核</h3><h5 id="多处理器"><a href="#多处理器" class="headerlink" title="多处理器"></a>多处理器</h5><ul>
<li>是有多个独立的CPU,每个CPU能执行相同的功能，也叫对称处理器</li>
</ul>
<h5 id="多核"><a href="#多核" class="headerlink" title="多核"></a>多核</h5><ul>
<li>是多个处理器组装在同一个硅片上，又名芯片多处理器</li>
</ul>
<h5 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h5><ul>
<li>对于多个处理器而言，它们在执行命令的时候多个处理器之间的通信手段是电脑主板上的总线；而对于多核处理器而言，多个核心处理器之间通信时通过CPU内部总线进行信息的交互的。对于执行效率而言，多核处理器要优于多个处理器</li>
<li>若跑小程序，选多核<br>  对于多处理器：如果跑一个多线程的程序（常见典型情况），不考虑超线程，那么每一个线程就要跑在一个独立的CPU上，线程间的所有协作都要走总线，而共享的数据更是有可能要在好几个Cache里同时存在。这样的话，总线开销相比较而言是很大的，怎么办？那么多Cache，即使我们不心疼存储能力的浪费，一致性怎么保证？如果真正做出来，还要在主板上占多块地盘，给布局布线带来更大的挑战？所以对于个人计算机来说，都采用单处理器多核。只需要一套芯片组，一套存储，多核之间通过芯片内部总线进行通信，共享使用内存。在这样的架构上，如果我们跑一个多线程的程序，那么线程间通信将比上一种情形更快。如果最终实现出来，对板上空间的占用较小，布局布线的压力也较小。</li>
<li>若跑大程序，选多CPU多核<br>  假设俩大程序，每一个程序都好多线程还几乎用满cache，它们分时使用CPU，那在程序间切换的时候，光指令和数据的替换就很费事。所以，需要更强的多任务并发能力，就用多颗多核CPU的机子。</li>
</ul>
<h1 id="第二章：操作系统概述"><a href="#第二章：操作系统概述" class="headerlink" title="第二章：操作系统概述"></a>第二章：操作系统概述</h1><h3 id="1-Linux主要内核组件"><a href="#1-Linux主要内核组件" class="headerlink" title="1. Linux主要内核组件"></a>1. Linux主要内核组件</h3><ol>
<li>信号(Signals)<ul>
<li>内核使用信号向进程提供信息</li>
</ul>
</li>
<li>系统调用(System calls)<ul>
<li>为进程提供系统服务，大致分为6类：文件系统，进程，调度，进程间通信，套接字，其他</li>
</ul>
</li>
<li>进程和调度器(Processes and Scheduler)<ul>
<li>创建，管理，调度进程</li>
</ul>
</li>
<li>虚存(Virtual memory)<ul>
<li>为进程分配和管理虚存</li>
</ul>
</li>
<li>文件系统(File System)<ul>
<li>为文件，目录和其他文件对象提供一个全局的分层命名空间，并提供文件系统函数</li>
</ul>
</li>
<li>网络协议(Network protocols)<ul>
<li>  为用户的TCP/IP协议套件提供套接字接口</li>
</ul>
</li>
<li>字符设备驱动(Character device drivers)<ul>
<li>如打印机，调制解调器，终端</li>
</ul>
</li>
<li>块设备驱动(Block device drivers)<ul>
<li>如各种外存</li>
</ul>
</li>
<li>网络设备驱动(Network device drivers)<ul>
<li>管理网卡和通信端口，即管理连接到网桥或路由的网络设备</li>
</ul>
</li>
<li>陷阱与错误(Traps and faults)<ul>
<li>处理CPU产生的陷阱和错误，如内存错误</li>
</ul>
</li>
<li>物理内存(Physical memory)<ul>
<li>管理实际内存中的内存页池，并为虚存分配内存页</li>
</ul>
</li>
<li>中断(Interrupts)<ul>
<li>处理来自外设的中断</li>
</ul>
</li>
</ol>
<h3 id="2-Windows和Android先不整理，以后需要再学"><a href="#2-Windows和Android先不整理，以后需要再学" class="headerlink" title="2. Windows和Android先不整理，以后需要再学"></a>2. Windows和Android先不整理，以后需要再学</h3><h1 id="第三章：进程"><a href="#第三章：进程" class="headerlink" title="第三章：进程"></a>第三章：进程</h1><h3 id="1-进程介绍"><a href="#1-进程介绍" class="headerlink" title="1. 进程介绍"></a>1. 进程介绍</h3><h5 id="进程的两个基本元素"><a href="#进程的两个基本元素" class="headerlink" title="进程的两个基本元素"></a>进程的两个基本元素</h5><ul>
<li>程序代码</li>
<li>数据集</li>
</ul>
<h5 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块(PCB)"></a>进程控制块(PCB)</h5><ul>
<li>标识符</li>
<li>状态</li>
<li>优先级</li>
<li>程序计数器</li>
<li>内存指针</li>
<li>上下文数据</li>
<li>I/O 状态信息</li>
<li>记账信息</li>
</ul>
<h3 id="2-进程状态"><a href="#2-进程状态" class="headerlink" title="2. 进程状态"></a>2. 进程状态</h3><h5 id="经典5状态"><a href="#经典5状态" class="headerlink" title="经典5状态"></a>经典5状态</h5><ul>
<li>新建态<ul>
<li>空–&gt;新建</li>
</ul>
</li>
<li>就绪<ul>
<li>新建–&gt;就绪</li>
<li>运行–&gt;就绪</li>
<li>阻塞–&gt;就绪</li>
</ul>
</li>
<li>运行<ul>
<li>就绪–&gt;运行</li>
</ul>
</li>
<li>阻塞<ul>
<li>运行–&gt;阻塞</li>
</ul>
</li>
<li>退出态<ul>
<li>运行–&gt;退出</li>
<li>阻塞–&gt;退出</li>
<li>就绪–&gt;退出</li>
</ul>
</li>
</ul>
<h5 id="挂起态"><a href="#挂起态" class="headerlink" title="挂起态"></a>挂起态</h5><ul>
<li>这个主要是内存不足，就把进程先换到外存</li>
</ul>
<h3 id="3-操作系统的控制结构"><a href="#3-操作系统的控制结构" class="headerlink" title="3. 操作系统的控制结构"></a>3. 操作系统的控制结构</h3><ul>
<li>内存–&gt;内存表</li>
<li>设备–&gt;设备表</li>
<li>文件–&gt;文件表</li>
<li>进程–&gt;主进程表–&gt;进程映像</li>
</ul>
<h3 id="4-进程映像"><a href="#4-进程映像" class="headerlink" title="4. 进程映像"></a>4. 进程映像</h3><ul>
<li>进程控制块<ul>
<li>进程id</li>
<li>处理器状态信息</li>
<li>进程控制信息</li>
</ul>
</li>
<li>用户栈</li>
<li>私有用户地址空间(程序，数据)<ul>
<li>堆</li>
<li>静态数据区</li>
<li>代码段</li>
</ul>
</li>
<li>共享地址空间</li>
</ul>
<h1 id="第四章：线程"><a href="#第四章：线程" class="headerlink" title="第四章：线程"></a>第四章：线程</h1><h3 id="1-线程介绍"><a href="#1-线程介绍" class="headerlink" title="1. 线程介绍"></a>1. 线程介绍</h3><ul>
<li>一个进程可以有多个线程</li>
<li>每个线程有自己的线程控制块，用户栈，内核栈</li>
<li>所有线程共享用户地址空间</li>
</ul>
<h3 id="2-线程状态"><a href="#2-线程状态" class="headerlink" title="2. 线程状态"></a>2. 线程状态</h3><ul>
<li>就绪，运行，阻塞</li>
<li>没有挂起</li>
</ul>
<h3 id="3-Linux中的线程"><a href="#3-Linux中的线程" class="headerlink" title="3. Linux中的线程"></a>3. Linux中的线程</h3><ul>
<li>Linux中没有给线程单独定义数据结构，所以Linux中的线程和进程没有区别</li>
<li>Linux提供一种不区分进程和线程的解决方案<ul>
<li>将用户级线程映射到内核级进程上。</li>
<li>组成一个用户级进程的多个用户级线程则映射到共享同一个组ID的多个Linux内核级进程上。</li>
<li>因此，这些进程可以共享文件和内存等资源，使得同一个组中的进程调度切换时不需要切换上下文</li>
</ul>
</li>
<li>当Linux内核执行从一个进程到另一个进程的切换时，会检查当前进程的页目录地址是否与将被调度的进程的相同。<ul>
<li>若相同，则它们共享同一个地址空间，所以此时的上下午切换仅是从代码的一处跳转到另一处</li>
<li>可以共享同一内存空间，但不能共享同一个用户栈。所以每个线程有自己单独的栈空间</li>
</ul>
</li>
</ul>
<h3 id="4-Linux的命名空间"><a href="#4-Linux的命名空间" class="headerlink" title="4. Linux的命名空间"></a>4. Linux的命名空间</h3><ul>
<li>命名空间可以使一个进程(或共享同一命名空间下的多个进程)拥有与其他相关命名空间下的其他进程不同的系统视图。</li>
<li>当前Linux有6种命名空间：mnt,pid,net,ipc,uts,user<ul>
<li>Mount命名空间<br>  为进程提供文件系统层级结构的特定视图，因次两个不同mount命名空间的进程会看到不同的文件系统层次结构</li>
<li>UTS命名空间<br>  UNIX timesharing UNIX 分时，通过UTS命名空间，初始化和配置参数能够根据同一系统上的不同进程而变化</li>
<li>IPC命名空间<br>  隔离某些进程间通信资源，如信号量</li>
<li>PID命名空间<br>  隔离进程ID空间</li>
<li>网络命名空间<br>  隔离与网络相关的系统资源</li>
<li>用户命名空间<br>  为自身的UID集建立一个容器</li>
</ul>
</li>
</ul>
<h1 id="第五章：并发性：互斥和同步"><a href="#第五章：并发性：互斥和同步" class="headerlink" title="第五章：并发性：互斥和同步"></a>第五章：并发性：互斥和同步</h1><h3 id="1-常用的并发机制"><a href="#1-常用的并发机制" class="headerlink" title="-1. 常用的并发机制"></a>-1. 常用的并发机制</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>信号量</td>
<td>用于进程间传递信号的整数值，只有三个原子操作：初始化，递增，递减</td>
</tr>
<tr>
<td>二元信号量</td>
<td>只有0和1的信号量</td>
</tr>
<tr>
<td>互斥量/互斥锁</td>
<td>类似于二元信号量，关键区别在于为其加锁(设定值为0)的进程和解锁(设定值为0)的进程必须为同一个进程</td>
</tr>
<tr>
<td>条件变量</td>
<td>一种数据类型，用于阻塞进程或线程，直到特定的条件为真</td>
</tr>
<tr>
<td>管程</td>
<td>一种编程语言结构</td>
</tr>
<tr>
<td>自旋锁</td>
<td>一种互斥机制，进程在一个无条件循环中执行，等待锁变量的值可用</td>
</tr>
</tbody></table>
<h3 id="0-进程和线程的管理"><a href="#0-进程和线程的管理" class="headerlink" title="0. 进程和线程的管理"></a>0. 进程和线程的管理</h3><ul>
<li>多道程序设计技术<br>  管理单处理器的多个进程</li>
<li>多处理器技术<br>  管理多处理器的多个进程</li>
<li>分布式处理器技术<br>  管理多态分布式计算机系统中多个进程的执行。集群就是这个的典型例子</li>
</ul>
<h5 id="互斥的要求"><a href="#互斥的要求" class="headerlink" title="互斥的要求"></a>互斥的要求</h5><ol>
<li>一次只允许一个进程进入临界区</li>
<li>一个在非临界区停止的进程不能干涉其他进程</li>
<li>不允许出现需要访问临界区的进程被无限延迟的情况，即不会死锁和饥饿</li>
<li>没有进程在临界区时，需要进入的进程要能立刻进入</li>
<li>对相关进程的执行速度和处理器的数量没有任何要求</li>
<li>一个进程驻留在临界区的时间必须是有限的</li>
</ol>
<h3 id="1-互斥：硬件的支持"><a href="#1-互斥：硬件的支持" class="headerlink" title="1. 互斥：硬件的支持"></a>1. 互斥：硬件的支持</h3><h5 id="1-中断禁用"><a href="#1-中断禁用" class="headerlink" title="1. 中断禁用"></a>1. 中断禁用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    &#x2F;&#x2F;禁用中断</span><br><span class="line">    &#x2F;&#x2F;临界区</span><br><span class="line">    &#x2F;&#x2F;启用中断</span><br><span class="line">    &#x2F;&#x2F;其余非临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这种办法执行效率低</li>
<li>不能用于多处理器体系结构中，当有多个处理器，就可能有多个进程同时执行，在这种情况下，禁用中断并不能保证互斥</li>
</ul>
<h5 id="2-专用机器指令"><a href="#2-专用机器指令" class="headerlink" title="2. 专用机器指令"></a>2. 专用机器指令</h5><ul>
<li>保证某些机器指令的原子性</li>
</ul>
<h3 id="2-信号量"><a href="#2-信号量" class="headerlink" title="2. 信号量"></a>2. 信号量</h3><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者/消费者问题"></a>生产者/消费者问题</h5><ul>
<li>有一个缓冲区，生产者往里面放东西(字节或记录)，消费者取东西，一次只能有一个进行操作</li>
</ul>
<h3 id="3-管程"><a href="#3-管程" class="headerlink" title="3. 管程"></a>3. 管程</h3><ul>
<li>为什么感觉第一次听这个概念。。。先跳过</li>
</ul>
<h3 id="4-消息传递"><a href="#4-消息传递" class="headerlink" title="4. 消息传递"></a>4. 消息传递</h3><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><ul>
<li>发送者和接收者都可阻塞或不阻塞。通常有三种组合，但任一特定操作系统通常只实现一种或两种<ul>
<li>阻塞send，阻塞receive<br>  发送者和接收者都阻塞，直到完成消息传递。进程间紧密同步</li>
<li>无阻塞send,阻塞receive<br>  发送者可以继续执行，接收阻塞，这可能是最有用的一种组合</li>
<li>无阻塞send,无阻塞receive<br>  双方都不等待</li>
</ul>
</li>
</ul>
<h5 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h5><ul>
<li>直接寻址<ul>
<li>进程对进程直接发送消息</li>
</ul>
</li>
<li>间接寻址<ul>
<li>消息发送到一个共享的数据结构，如管道</li>
</ul>
</li>
</ul>
<h5 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h5><ul>
<li>直白的说就是：具体情况具体分析</li>
</ul>
<h3 id="5-读者-写者问题"><a href="#5-读者-写者问题" class="headerlink" title="5. 读者/写者问题"></a>5. 读者/写者问题</h3><h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><ol>
<li>任意数量的读进程可以读这个文件</li>
<li>一次只有一个写进程能写这个文件</li>
<li>若一个写进程正在写文件，则禁止任何读进程读文件</li>
</ol>
<h5 id="读者优先"><a href="#读者优先" class="headerlink" title="读者优先"></a>读者优先</h5><h5 id="写者优先"><a href="#写者优先" class="headerlink" title="写者优先"></a>写者优先</h5><h1 id="第六章：并发：死锁和饥饿"><a href="#第六章：并发：死锁和饥饿" class="headerlink" title="第六章：并发：死锁和饥饿"></a>第六章：并发：死锁和饥饿</h1><h3 id="6-1-死锁原理"><a href="#6-1-死锁原理" class="headerlink" title="6.1 死锁原理"></a>6.1 死锁原理</h3><h5 id="6-1-1-可重用资源死锁"><a href="#6-1-1-可重用资源死锁" class="headerlink" title="6.1.1 可重用资源死锁"></a>6.1.1 可重用资源死锁</h5><ul>
<li>资源可重用，如设备</li>
<li>两个进程各自占用一个设备，都需要另一个设备时死锁</li>
</ul>
<h5 id="6-1-2-可消耗资源死锁"><a href="#6-1-2-可消耗资源死锁" class="headerlink" title="6.1.2 可消耗资源死锁"></a>6.1.2 可消耗资源死锁</h5><ul>
<li>资源只能使用一次，消耗性的，如缓冲区中的数据</li>
<li>两个进程都想从缓冲区读数据，没进程写，都处于阻塞等待状态，死锁</li>
</ul>
<h5 id="6-1-3-资源分配图"><a href="#6-1-3-资源分配图" class="headerlink" title="6.1.3 资源分配图"></a>6.1.3 资源分配图</h5><ul>
<li>系统资源和进程的有向状态图</li>
</ul>
<h5 id="6-1-4-死锁条件"><a href="#6-1-4-死锁条件" class="headerlink" title="6.1.4 死锁条件"></a>6.1.4 死锁条件</h5><ul>
<li>互斥<ul>
<li>一次只有一个进程可以使用某个资源</li>
</ul>
</li>
<li>占有且等待<ul>
<li>当一个进程等待其他进程时，继续占有已经占有的资源</li>
<li>解决办法：一次性占有所有资源</li>
</ul>
</li>
<li>不可抢占<ul>
<li>不能强行抢占其他进程已经占有的资源</li>
<li>解决办法：若申请其他资源不成功，则释放已占有的资源</li>
</ul>
</li>
<li>循环等待<ul>
<li>存在一个闭合的进程链，每个进程至少占有此链下一个进程所需的一个资源</li>
<li>这一条实际上是前三条的潜在结果</li>
<li>解决办法：定义资源的线性顺序，若一个进程已经占用了R资源，接下来只能占有R之后的资源</li>
</ul>
</li>
</ul>
<h5 id="6-1-5-处理死锁的办法"><a href="#6-1-5-处理死锁的办法" class="headerlink" title="6.1.5 处理死锁的办法"></a>6.1.5 处理死锁的办法</h5><ul>
<li>预防<ul>
<li>消除某一个死锁条件</li>
</ul>
</li>
<li>避免<ul>
<li>基于资源分配的当前状态做动态选择</li>
</ul>
</li>
<li>检测<ul>
<li>检测死锁的存在并从死锁中恢复</li>
</ul>
</li>
</ul>
<h3 id="6-2-小结"><a href="#6-2-小结" class="headerlink" title="6.2 小结"></a>6.2 小结</h3><table>
<thead>
<tr>
<th>原则</th>
<th>资源分配策略</th>
<th>不同的方案</th>
</tr>
</thead>
<tbody><tr>
<td>预防</td>
<td>保守:预提交资源</td>
<td>一次性请求所有方案</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
<td>抢占</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
<td>资源排序</td>
</tr>
<tr>
<td>避免</td>
<td>介于检测和预防之间</td>
<td>操作以便发现至少一条安全路径</td>
</tr>
<tr>
<td>检测</td>
<td>非常自由：只要有可能，请求的资源都被允许</td>
<td>周期性的调用以便检测死锁</td>
</tr>
</tbody></table>
<h3 id="6-3-哲学家就餐问题"><a href="#6-3-哲学家就餐问题" class="headerlink" title="6.3 哲学家就餐问题"></a>6.3 哲学家就餐问题</h3><p>假设有5跟筷子，5个座位</p>
<h5 id="6-3-1-基于信号量的解决方案"><a href="#6-3-1-基于信号量的解决方案" class="headerlink" title="6.3.1 基于信号量的解决方案"></a>6.3.1 基于信号量的解决方案</h5><ul>
<li>只能允许4个人同时吃</li>
</ul>
<h5 id="6-3-2-基于管程的解决方案"><a href="#6-3-2-基于管程的解决方案" class="headerlink" title="6.3.2 基于管程的解决方案"></a>6.3.2 基于管程的解决方案</h5><ul>
<li>实际上就是左右同时拿，只有左右同时可用才拿，只要有一个不可用，就都不拿</li>
</ul>
<h3 id="6-4-UNIX并发机制"><a href="#6-4-UNIX并发机制" class="headerlink" title="6.4 UNIX并发机制"></a>6.4 UNIX并发机制</h3><ul>
<li>管道<ul>
<li>pipe</li>
<li>mkfifo</li>
</ul>
</li>
<li>消息<ul>
<li>有msgsnd和msgrcv系统调用</li>
</ul>
</li>
<li>共享内存</li>
<li>信号量<ul>
<li>semctl</li>
<li>sem_op</li>
</ul>
</li>
<li>信号</li>
</ul>
<h3 id="6-5-Linux内核并发机制"><a href="#6-5-Linux内核并发机制" class="headerlink" title="6.5 Linux内核并发机制"></a>6.5 Linux内核并发机制</h3><ul>
<li>包含UNIX的所有</li>
<li>原子操作<ul>
<li>atomic_xxx()</li>
</ul>
</li>
<li>自旋锁<ul>
<li>一次只有一个进程能进入临界区</li>
<li>其它试图获得自旋锁的进程将一直进行尝试（即自旋），直到获得该锁</li>
<li>spin_lock系列调用</li>
</ul>
</li>
</ul>
<h1 id="第七章：内存管理"><a href="#第七章：内存管理" class="headerlink" title="第七章：内存管理"></a>第七章：内存管理</h1><h3 id="0-内存管理术语"><a href="#0-内存管理术语" class="headerlink" title="0. 内存管理术语"></a>0. 内存管理术语</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>页框</td>
<td>内存中固定长度的块</td>
</tr>
<tr>
<td>页</td>
<td>固定长度的数据块，存储在二级存储器中(如磁盘)。数据页可以临时复制到内存的页框中</td>
</tr>
<tr>
<td>段</td>
<td>变长数据块，存储在二级存储器中。整个段可以临时复制到内存中的一个可用区域(分段)，或可以将一个段分为许多页，然后将每页单独复制到内存中(分段和分页相结合)</td>
</tr>
</tbody></table>
<h3 id="1-内存管理的需求"><a href="#1-内存管理的需求" class="headerlink" title="1. 内存管理的需求"></a>1. 内存管理的需求</h3><ul>
<li>重定位</li>
<li>保护</li>
<li>共享</li>
<li>逻辑组织</li>
<li>物理组织</li>
</ul>
<h3 id="2-分页和分段"><a href="#2-分页和分段" class="headerlink" title="2. 分页和分段"></a>2. 分页和分段</h3><ul>
<li>分页是对分区的改进，减少了内存碎片</li>
<li>每个进程维护一个页表</li>
<li>使用分段技术，可以把程序和与其相关的数据划分到几个段中</li>
<li>分页对程序员透明，分段通常是可见的</li>
</ul>
<h1 id="第八章：虚拟内存"><a href="#第八章：虚拟内存" class="headerlink" title="第八章：虚拟内存"></a>第八章：虚拟内存</h1><h3 id="0-虚拟内存术语"><a href="#0-虚拟内存术语" class="headerlink" title="0. 虚拟内存术语"></a>0. 虚拟内存术语</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>虚拟内存</td>
<td>程序引用内存使用的地址与内存系统用于识别物理存储站点的地址是不同的，程序生成的地址会自动转换为机器地址。虚拟存储的大小受系统寻址机制和可用的备用内存量的限制，而不受主存储位置实际数量的限制</td>
</tr>
<tr>
<td>虚拟地址</td>
<td>在虚拟内存中分配给某一位置的地址，它使得该位置可被访问，就好像是主存内的一部分那样</td>
</tr>
<tr>
<td>虚拟地址空间</td>
<td>分配给进程的虚拟存储</td>
</tr>
<tr>
<td>地址空间</td>
<td>用于某进程的内存地址范围</td>
</tr>
<tr>
<td>实地址</td>
<td>内存中存储位置的地址</td>
</tr>
</tbody></table>
<h3 id="1-关键概念"><a href="#1-关键概念" class="headerlink" title="1. 关键概念"></a>1. 关键概念</h3><ul>
<li>内存碎片<ul>
<li>内部碎片<br>  已经使用的内存，不能用到的地方</li>
<li>外部碎片<br>  没有使用的内存，但是太小了不能再用的内存</li>
</ul>
</li>
<li>抖动<ul>
<li>频繁中断进行内存页的换进换出，常见于先进先出算法</li>
</ul>
</li>
<li>置换页的基本算法<ul>
<li>最佳<ul>
<li>置换下次访问距当前时间最长的页，需要预测</li>
<li>不可能实现，仅作为衡量其他算法性能的一种标准</li>
</ul>
</li>
<li>最近最少使用<ul>
<li>时钟策略的变体</li>
</ul>
</li>
<li>先进先出<ul>
<li>实现简单，性能较差</li>
</ul>
</li>
<li>时钟<ul>
<li>有一个只能为1或0的使用位，初始为1，若要置换，找下一个，下一个若为0，就换出，若为1就变为0，继续找下一个，就是多给了一次机会，所有的页组成一个环</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第九章：单处理器调度"><a href="#第九章：单处理器调度" class="headerlink" title="第九章：单处理器调度"></a>第九章：单处理器调度</h1><h3 id="1-处理器调度的类型"><a href="#1-处理器调度的类型" class="headerlink" title="1. 处理器调度的类型"></a>1. 处理器调度的类型</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>长程调度</td>
<td>决定加入待执行进程池</td>
</tr>
<tr>
<td>中程调度</td>
<td>决定加入部分或全部位于内存中的进程集合</td>
</tr>
<tr>
<td>短程调度</td>
<td>决定处理器执行哪个可运行进程</td>
</tr>
<tr>
<td>I/O调度</td>
<td>决定可用IO设备处理哪个进程挂起的IO请求</td>
</tr>
</tbody></table>
<ul>
<li><p>长程调度和中程调度主要由与系统并发度相关的性能驱动，如第7,8章的页面置换等。本章主要讲短程调度。</p>
</li>
<li><p>导致当前进程阻塞或抢占当前运行进程的事件发生时，调用短程调度程序。这类事件包括：</p>
<ul>
<li>时钟中断</li>
<li>IO中断</li>
<li>操作系统调用</li>
<li>信号（如信号量）</li>
</ul>
</li>
</ul>
<h3 id="2-调度算法"><a href="#2-调度算法" class="headerlink" title="2. 调度算法"></a>2. 调度算法</h3><h5 id="调度规则"><a href="#调度规则" class="headerlink" title="调度规则"></a>调度规则</h5><h5 id="优先级的使用"><a href="#优先级的使用" class="headerlink" title="优先级的使用"></a>优先级的使用</h5><h5 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h5><ul>
<li>先来先服务</li>
<li>时间片轮转</li>
<li>最短进程优先</li>
<li>最短剩余时间</li>
<li>最短相应比优先</li>
<li>反馈<br>  建立一组调度队列，基于每个进程的执行历史和其他一些规则，把它们分配到各个队列中</li>
<li>调度算法的选择取决于预期的性能和实现的复杂度</li>
</ul>
<h1 id="第十章：多处理器和实时调度"><a href="#第十章：多处理器和实时调度" class="headerlink" title="第十章：多处理器和实时调度"></a>第十章：多处理器和实时调度</h1><h3 id="1-多处理器调度"><a href="#1-多处理器调度" class="headerlink" title="1. 多处理器调度"></a>1. 多处理器调度</h3><h5 id="多处理器系统分类"><a href="#多处理器系统分类" class="headerlink" title="多处理器系统分类"></a>多处理器系统分类</h5><ul>
<li>松耦合、分布式多处理器、集群<ul>
<li>由一系列相对自治的系统组成，每个处理器都有自身的内存和IO通道</li>
</ul>
</li>
<li>专用处理器<ul>
<li>IO处理器是一个典型的例子。此时，有一个通用的主处理器，专用处理器由主处理器控制，并为主处理器提供服务。</li>
</ul>
</li>
<li>紧耦合多处理器<ul>
<li>由一系列共享同一内存并受操作系统完全控制的处理器组成</li>
</ul>
</li>
</ul>
<h5 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h5><table>
<thead>
<tr>
<th>粒度大小</th>
<th>说明</th>
<th>同步间隔(指令)</th>
</tr>
</thead>
<tbody><tr>
<td>细</td>
<td>单指令流中固有的并行</td>
<td>&lt;20</td>
</tr>
<tr>
<td>中等</td>
<td>一个单独应用中的并行处理或多任务处理</td>
<td>20~200</td>
</tr>
<tr>
<td>粗</td>
<td>多道程序环境中并发进程的多处理</td>
<td>200~2000</td>
</tr>
<tr>
<td>极粗</td>
<td>在网络节点上进行分布式处理，形成一个计算环境</td>
<td>2000~1M</td>
</tr>
<tr>
<td>无约束</td>
<td>多个无关进程</td>
<td>不适用</td>
</tr>
</tbody></table>
<ul>
<li>无约束并行性<ul>
<li>进程间没有显式的同步，每个进程都代表独立的应用或作业。这类并行性的一个典型应用是分时系统。每个yoghurt执行一个特定的应用，如字处理。</li>
</ul>
</li>
<li>粗粒度和极粗粒度并行性<ul>
<li>进程间存在同步，但这种同步的级别极粗。</li>
</ul>
</li>
</ul>
<h5 id="设计问题"><a href="#设计问题" class="headerlink" title="设计问题"></a>设计问题</h5><p>多处理器中的调度涉及三个相互关联的问题</p>
<ul>
<li>把进程分配到处理器<ul>
<li>分配到那个处理器</li>
</ul>
</li>
<li>在单处理器上使用多道程序设计</li>
<li>一个进程的实际分派<ul>
<li>选择哪个进程运行</li>
</ul>
</li>
</ul>
<h3 id="2-实时调度"><a href="#2-实时调度" class="headerlink" title="2. 实时调度"></a>2. 实时调度</h3><ul>
<li>负责Linux调度的三个类<ul>
<li>SCHED_FIFO:先进先出实时线程</li>
<li>SCHED_RR:轮转实时线程</li>
<li>SCHED_OTHER:其他非实时线程</li>
</ul>
</li>
<li>这个还有好多没记，主要是不理解什么意思，不知道哪些是重点，以后能有实践机会了深入了解了再学。</li>
</ul>
<h1 id="第十一章：IO管理和磁盘调度"><a href="#第十一章：IO管理和磁盘调度" class="headerlink" title="第十一章：IO管理和磁盘调度"></a>第十一章：IO管理和磁盘调度</h1><h3 id="1-IO设备"><a href="#1-IO设备" class="headerlink" title="1. IO设备"></a>1. IO设备</h3><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul>
<li>人可读<ul>
<li>打印机</li>
<li>终端</li>
<li>鼠标等</li>
</ul>
</li>
<li>机器可读<ul>
<li>USB秘钥</li>
<li>传感器等</li>
</ul>
</li>
<li>通信<ul>
<li>调制解调器</li>
</ul>
</li>
</ul>
<h5 id="各设备主要差异"><a href="#各设备主要差异" class="headerlink" title="各设备主要差异"></a>各设备主要差异</h5><ul>
<li>数据传输速率</li>
<li>应用</li>
<li>控制的复杂度</li>
<li>传送单位</li>
<li>数据表示</li>
<li>错误条件</li>
</ul>
<h3 id="2-IO功能的组织"><a href="#2-IO功能的组织" class="headerlink" title="2. IO功能的组织"></a>2. IO功能的组织</h3><h5 id="三种执行IO的技术"><a href="#三种执行IO的技术" class="headerlink" title="三种执行IO的技术"></a>三种执行IO的技术</h5><ul>
<li>程序控制IO</li>
<li>中断驱动IO</li>
<li>直接存储器访问(DMA)</li>
</ul>
<h3 id="3-IO缓冲"><a href="#3-IO缓冲" class="headerlink" title="3. IO缓冲"></a>3. IO缓冲</h3><h5 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h5><ul>
<li>有一个缓冲区</li>
</ul>
<h5 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h5><ul>
<li>两个系统缓冲区，在一个进程向一个缓冲区中传送数据的同时，操作系统正在清空(或填充)另一个缓冲区，这叫双缓冲或缓冲交换</li>
</ul>
<h5 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h5><ul>
<li>多于两个缓冲区</li>
</ul>
<h5 id="缓冲作用"><a href="#缓冲作用" class="headerlink" title="缓冲作用"></a>缓冲作用</h5><ul>
<li>平滑IO需求的峰值</li>
</ul>
<h3 id="4-磁盘调度"><a href="#4-磁盘调度" class="headerlink" title="4. 磁盘调度"></a>4. 磁盘调度</h3><h5 id="磁盘性能参数"><a href="#磁盘性能参数" class="headerlink" title="磁盘性能参数"></a>磁盘性能参数</h5><ul>
<li>寻道时间</li>
<li>旋转延迟</li>
<li>传输时间</li>
<li>时序比较</li>
</ul>
<h5 id="调度策略-1"><a href="#调度策略-1" class="headerlink" title="调度策略"></a>调度策略</h5><ul>
<li>先进先出</li>
<li>优先级</li>
<li>后进先出</li>
<li>最短服务时间优先</li>
<li>SCAN(电梯算法)</li>
<li>C-SCAN，只向一个方向移动</li>
</ul>
<h5 id="RDIA"><a href="#RDIA" class="headerlink" title="RDIA"></a>RDIA</h5><ul>
<li>这个需要的时候再了解吧，有点抽象，不知道是干嘛的</li>
</ul>
<h1 id="第十二章：文件管理"><a href="#第十二章：文件管理" class="headerlink" title="第十二章：文件管理"></a>第十二章：文件管理</h1><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h5 id="文件和文件系统"><a href="#文件和文件系统" class="headerlink" title="文件和文件系统"></a>文件和文件系统</h5><ul>
<li>一些理想的属性<ul>
<li>长期存在</li>
<li>可在进程间共享</li>
<li>结构</li>
</ul>
</li>
<li>典型的操作<ul>
<li>创建</li>
<li>删除</li>
<li>打开</li>
<li>关闭</li>
<li>读</li>
<li>写</li>
</ul>
</li>
<li>文件系统通常为文件维护一组属性，包括所有者、创建时间、最后修改时间和访问权限</li>
</ul>
<h5 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h5><ul>
<li>4个术语<ul>
<li>域 field<br>  基本的数据单元，如人名，出生日期</li>
<li>记录 record<br>  一组相关域的集合，如一个人作为一条记录，有名字，出生日期等域</li>
<li>文件 file<br>  一组相似记录的集合</li>
<li>数据库<br>  一组相关数据的集合</li>
</ul>
</li>
<li>并非所有文件管理系统都会是这种结构，在类UNIX系统上，文件的基本结构是字节流。例如一个C语言程序以文件的形式存储，而没有物理域、记录等</li>
</ul>
<h5 id="文件管理系统"><a href="#文件管理系统" class="headerlink" title="文件管理系统"></a>文件管理系统</h5><ul>
<li>典型情况下，文件管理系统是用户或应用程序访问文件的唯一方式</li>
<li>文件系统架构<ul>
<li>用户程序</li>
<li>堆 顺序 索引顺序 索引 散列</li>
<li>逻辑IO</li>
<li>基本IO管理程序</li>
<li>基本文件系统</li>
<li>磁盘设备驱动 磁带设备驱动等驱动程序</li>
</ul>
</li>
</ul>
<h3 id="2-文件组织和访问"><a href="#2-文件组织和访问" class="headerlink" title="2. 文件组织和访问"></a>2. 文件组织和访问</h3><ul>
<li>选择文件组织的原则<ul>
<li>快速访问</li>
<li>易于修改</li>
<li>节约存储空间</li>
<li>维护简单</li>
<li>可靠性<br>这些原则的优先级取决于使用这些文件的应用程序</li>
</ul>
</li>
<li>5种基本组织<ul>
<li>堆<ul>
<li>不是数据结构中的堆，是最简单的文件组织形式</li>
<li>堆文件没有结构，访问记录只能穷举查找</li>
<li>对大多数应用都不适用，当数据难以组织时，可以用堆文件</li>
</ul>
</li>
<li>顺序文件<ul>
<li>最常用，每条记录有固定的格式</li>
<li>通常应用于批处理应用中</li>
<li>另一种选择是把顺序文件组织成链表的形式。但增加额外的处理和空间开销</li>
</ul>
</li>
<li>索引文件<ul>
<li>只能通过索引访问</li>
</ul>
</li>
<li>索引顺序文件<ul>
<li>克服顺序文件的缺点，增加了用于支持随机访问的文件索引和溢出文件</li>
</ul>
</li>
<li>直接或散列文件<ul>
<li>记录长度固定，快速访问，一次只能访问一条记录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-B树"><a href="#3-B树" class="headerlink" title="3. B树"></a>3. B树</h3><ul>
<li>用于文件系统和数据库</li>
<li>每个节点有多个关键码的树</li>
</ul>
<h3 id="4-Linux文件系统"><a href="#4-Linux文件系统" class="headerlink" title="4. Linux文件系统"></a>4. Linux文件系统</h3><h5 id="VFS虚拟文件系统"><a href="#VFS虚拟文件系统" class="headerlink" title="VFS虚拟文件系统"></a>VFS虚拟文件系统</h5><ul>
<li>VFS的4个主要对象<ul>
<li>超级块对象 superblock<br>  表示一个已挂载的特定文件系统</li>
<li>索引节点对象 inode<br>  表示一个特定的问价</li>
<li>目录项对象 dentry<br>  表示一个特定的目录项</li>
<li>文件对象 file<br>  表示一个与进程相关的已打开文件</li>
</ul>
</li>
</ul>
<h1 id="第十三章：嵌入式操作系统"><a href="#第十三章：嵌入式操作系统" class="headerlink" title="第十三章：嵌入式操作系统"></a>第十三章：嵌入式操作系统</h1><h3 id="1-嵌入式系统"><a href="#1-嵌入式系统" class="headerlink" title="1. 嵌入式系统"></a>1. 嵌入式系统</h3><ul>
<li>为完成某个特定功能而设计的</li>
</ul>
<h3 id="2-嵌入式Linux"><a href="#2-嵌入式Linux" class="headerlink" title="2. 嵌入式Linux"></a>2. 嵌入式Linux</h3><ul>
<li>内核比普通Linux小队多</li>
<li>交叉编译，在一个平台上编译，在另一个平台上运行</li>
<li>文件系统<ul>
<li>通常使用闪存作为持久性存储设备</li>
</ul>
</li>
</ul>
<h1 id="第十四章：虚拟机"><a href="#第十四章：虚拟机" class="headerlink" title="第十四章：虚拟机"></a>第十四章：虚拟机</h1><ul>
<li>这章……讲的……真抽象</li>
<li>虚拟化技术使得单个PC或服务器能够同时运行多个操作系统或一个操作系统的多个会话</li>
</ul>
<h1 id="第十五章：计算机安全技术"><a href="#第十五章：计算机安全技术" class="headerlink" title="第十五章：计算机安全技术"></a>第十五章：计算机安全技术</h1><h3 id="1-入侵者与恶意软件"><a href="#1-入侵者与恶意软件" class="headerlink" title="1. 入侵者与恶意软件"></a>1. 入侵者与恶意软件</h3><h5 id="入侵者"><a href="#入侵者" class="headerlink" title="入侵者"></a>入侵者</h5><ul>
<li>伪装者<ul>
<li>越过系统访问控制并使用了一个合法的用户账号</li>
<li>来自外部</li>
</ul>
</li>
<li>违法者<ul>
<li>合法用户，但访问了为被授权的数据</li>
<li>来自外部</li>
</ul>
</li>
<li>秘密用户<ul>
<li>能控制系统的个体</li>
<li>来自外部或内部</li>
</ul>
</li>
</ul>
<h5 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h5><ul>
<li>寄生型<ul>
<li>需要宿主程序</li>
<li>如病毒，逻辑炸弹和程序后门</li>
</ul>
</li>
<li>独立运行<ul>
<li>可以被操作系统调度和执行的独立程序</li>
<li>如蠕虫和机器人程序</li>
</ul>
</li>
</ul>
<h5 id="应对措施"><a href="#应对措施" class="headerlink" title="应对措施"></a>应对措施</h5><ul>
<li>入侵检测系统(IDS)<ul>
<li>基于宿主的IDS</li>
<li>基于网络的IDS</li>
</ul>
</li>
<li>认证</li>
<li>访问控制</li>
<li>防火墙</li>
</ul>
<h3 id="2-缓冲区溢出"><a href="#2-缓冲区溢出" class="headerlink" title="2. 缓冲区溢出"></a>2. 缓冲区溢出</h3><h5 id="缓冲区溢出例子"><a href="#缓冲区溢出例子" class="headerlink" title="缓冲区溢出例子"></a>缓冲区溢出例子</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int valid &#x3D; FALSE;</span><br><span class="line">    char str1[8];</span><br><span class="line">    char str2[8];</span><br><span class="line"></span><br><span class="line">    next_tag(str1); &#x2F;&#x2F;另str1里面存STATE</span><br><span class="line">    gets(str2);</span><br><span class="line">    if(strncmp(str1,str2,8)&#x3D;&#x3D;0)&#123;</span><br><span class="line">        valid &#x3D; TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;str1:%s,str2:%s,valid:%d\n&quot;,str1,str2,valid);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个就会造成缓冲区溢出</li>
<li>一般情况下，valid,str1,str2在内存中连续存放</li>
<li>调用next_tag后，str1里面存储字符串”STATE”</li>
<li>C语言库函数gets不对复制的数据量做任何检查。它从程序的标准输入读取下一行文本，知道出现\n，将其复制到缓冲区，并用C语言字符串使用的NULL作为结尾。如果读入时的字符超过7个(NULL还得占一个)，照样会读入，覆盖相邻变量的值，在本例中即覆盖str1的值，从而破坏其他变量的值</li>
<li>运行如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;正确运行的例子</span><br><span class="line">$ .&#x2F;a.out</span><br><span class="line">STATE</span><br><span class="line">str1:STATE,str2:STATE,valid:1</span><br><span class="line">&#x2F;&#x2F;溢出例子,可以看出已经改变了str1的值</span><br><span class="line">$ .&#x2F;a.out</span><br><span class="line">123456789abcde</span><br><span class="line">str1:9abcde,str2:123456789abcde,valid:0</span><br><span class="line">&#x2F;&#x2F;溢出例子，不仅改了str1的值，还使valid为TRUE</span><br><span class="line">$ .&#x2F;a.out</span><br><span class="line">badinputbadinput</span><br><span class="line">str1:badinput,str2:badinputbadinput,valid:1</span><br></pre></td></tr></table></figure></li>
<li>如果这里是比较密码，成功就登入，就可以用这种办法，不需要知道密码，直接比较成功，从而登入</li>
</ul>
<h5 id="编译时防御"><a href="#编译时防御" class="headerlink" title="编译时防御"></a>编译时防御</h5><ul>
<li>编程语言的选择</li>
<li>安全编码技术</li>
<li>语言扩展及使用安全库</li>
<li>栈保护机制</li>
</ul>
<h5 id="运行时防御"><a href="#运行时防御" class="headerlink" title="运行时防御"></a>运行时防御</h5><ul>
<li>可执行的地址空间保护</li>
<li>地址空间布局随机化</li>
<li>守卫页</li>
</ul>
<h1 id="第十六章：分布式处理、客户-服务器和集群"><a href="#第十六章：分布式处理、客户-服务器和集群" class="headerlink" title="第十六章：分布式处理、客户-服务器和集群"></a>第十六章：分布式处理、客户-服务器和集群</h1><h3 id="1-客户-服务器计算"><a href="#1-客户-服务器计算" class="headerlink" title="1. 客户-服务器计算"></a>1. 客户-服务器计算</h3><table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>应用程序编程接口(API)</td>
<td>允许客户和服务器之间相互通信的一组函数和可调用程序集</td>
</tr>
<tr>
<td>客户端</td>
<td>网络上的一个信息请求方，通常是一台PC或工作站，能够从服务器处查询数据库和其他信息</td>
</tr>
<tr>
<td>中间件</td>
<td>一组驱动程序、应用程序编程接口或其他软件集，用于改善客户应用程序和服务器之间的连通性</td>
</tr>
<tr>
<td>关系数据库</td>
<td>一种把对信息的访问限制于满足搜索条件的数据行的数据库</td>
</tr>
<tr>
<td>服务器</td>
<td>一台计算机，通常是一台高性能工作站、小型计算机或大型机，存储并提供信息给网络中的众多客户使用</td>
</tr>
<tr>
<td>结构化查询语言(SQL)</td>
<td>由IBM开发并由ANSI标准化的一种语言，用于对关系数据库的寻址，创建，更新和查询</td>
</tr>
</tbody></table>
<ul>
<li>我的理解，实际上就是C/S,B/S架构，中间件是像代理服务器之类的东西</li>
</ul>
<h3 id="2-分布式消息传递"><a href="#2-分布式消息传递" class="headerlink" title="2. 分布式消息传递"></a>2. 分布式消息传递</h3><ul>
<li>就是客户端和服务器不能直接通过信号等传递消息，可以通过报文，用特定的结构传递信息，如HTTP</li>
<li>可靠和不可靠性<ul>
<li>是否保证传递消息的正确性</li>
</ul>
</li>
<li>阻塞与无阻塞<ul>
<li>发送和接受消息是否等待</li>
</ul>
</li>
</ul>
<h3 id="3-远程过程调用-RPC"><a href="#3-远程过程调用-RPC" class="headerlink" title="3. 远程过程调用(RPC)"></a>3. 远程过程调用(RPC)</h3><ul>
<li><p>是基本消息传递的一种变体</p>
</li>
<li><p>举例就是客户端给服务器发送个消息，服务器就本地调用某个程序</p>
</li>
<li><p>同步和异步</p>
<ul>
<li>同步RPC<br>  和子程序调用行为类似，要等待返回结果。</li>
<li>异步RPC<br>  调用者并不等待应答</li>
</ul>
</li>
</ul>
<h3 id="4-集群"><a href="#4-集群" class="headerlink" title="4. 集群"></a>4. 集群</h3><ul>
<li>集群技术可以替代对称多处理技术(SMP)</li>
<li>集群定义为一组互联的完整计算机，这些完整计算机作为一种统一的计算资源协同工作，就像一台计算机那样。</li>
<li>集群的四个优点<ul>
<li>绝对可伸缩性<ul>
<li>一个集群可以有用数十台至数百台机器，每台机器都可以是多处理机</li>
</ul>
</li>
<li>增加可伸缩性<ul>
<li>集群能这样配置：向集群中添加系统时只需少量的额外工作，即用户可以在一个大小适度的系统上开始工作，在需求增加时可以扩展系统，而不用升级主体来用较大的系统代替较小的系统。</li>
</ul>
</li>
<li>高可用性<ul>
<li>因为集群中的每个节点都是一台独立的计算机，因此某个节点故障并不意味着服务失败。在很多产品中，软件能够自动地进行容错处理</li>
</ul>
</li>
<li>高性价比<ul>
<li>使用普通的计算机来构建集群系统，能够以非常低的价格，获得与一台大型计算机相同或更大的计算能力</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="练习项目"><a href="#练习项目" class="headerlink" title="练习项目"></a>练习项目</h1><ul>
<li>后期可以看一下附录的一些问题，比如理发店问题，各个小作业</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习与深度学习</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ol>
<li>不知道为什么，我就是不想学机器学习。。。但为了完成作业，还是得了解一下。</li>
<li>之前用过sklearn，也学习过机器学习的知识，现在有点忘了，再整理一下。<a id="more"></a>
</li>
</ol>
<hr>
<h1 id="一、机器学习概述"><a href="#一、机器学习概述" class="headerlink" title="一、机器学习概述"></a>一、机器学习概述</h1><h3 id="1-机器学习算法分类"><a href="#1-机器学习算法分类" class="headerlink" title="1. 机器学习算法分类"></a>1. 机器学习算法分类</h3><h5 id="1-监督学习"><a href="#1-监督学习" class="headerlink" title="1. 监督学习"></a>1. 监督学习</h5><ul>
<li>定义<ul>
<li>输入特征值和目标值，输出连续的值(回归)或离散值(分类)</li>
</ul>
</li>
<li>分类算法<ul>
<li>k-近邻算法，贝叶斯分类，决策树和随机森林，逻辑回归，SVM</li>
</ul>
</li>
<li>回归算法  <ul>
<li>线性回归，岭回归</li>
</ul>
</li>
</ul>
<h5 id="2-无监督学习"><a href="#2-无监督学习" class="headerlink" title="2. 无监督学习"></a>2. 无监督学习</h5><ul>
<li>定义<ul>
<li>输入特征值，无标签</li>
</ul>
</li>
<li>算法  <ul>
<li>聚类k-means</li>
</ul>
</li>
</ul>
<h3 id="2-机器学习开发流程"><a href="#2-机器学习开发流程" class="headerlink" title="2. 机器学习开发流程"></a>2. 机器学习开发流程</h3><ol>
<li>获取数据</li>
<li>数据处理(清洗)(可以用pandas)</li>
<li>特征工程</li>
<li>机器学习算法训练模型(可以用sklearn)</li>
<li>模型评估，若不好回到2-4，好的话继续</li>
<li>应用</li>
</ol>
<h3 id="3-一般的算法工程师的工作"><a href="#3-一般的算法工程师的工作" class="headerlink" title="3. 一般的算法工程师的工作"></a>3. 一般的算法工程师的工作</h3><ol>
<li>分析数据</li>
<li>分析业务</li>
<li>应用常见的算法</li>
<li>特征工程，调参，优化</li>
</ol>
<h3 id="4-框架"><a href="#4-框架" class="headerlink" title="4. 框架"></a>4. 框架</h3><ol>
<li>机器学习<ul>
<li>scikit learn(sklearn)</li>
</ul>
</li>
<li>深度学习<ul>
<li>tensorflow(最火)</li>
<li>pytorch/caffe2等</li>
</ul>
</li>
</ol>
<h3 id="5-没有免费的午餐"><a href="#5-没有免费的午餐" class="headerlink" title="5. 没有免费的午餐"></a>5. 没有免费的午餐</h3><ul>
<li>某个算法在某个问题中效果好，在另一个问题中可能效果就不好</li>
</ul>
<h1 id="二、特征工程"><a href="#二、特征工程" class="headerlink" title="二、特征工程"></a>二、特征工程</h1><h3 id="1-获取数据集"><a href="#1-获取数据集" class="headerlink" title="1. 获取数据集"></a>1. 获取数据集</h3><h3 id="2-数据集划分"><a href="#2-数据集划分" class="headerlink" title="2. 数据集划分"></a>2. 数据集划分</h3><ul>
<li>划分为训练集和测试集，比例通常为7:3左右</li>
</ul>
<h3 id="3-特征抽取"><a href="#3-特征抽取" class="headerlink" title="3. 特征抽取"></a>3. 特征抽取</h3><ul>
<li>将任何数据(如文本和图像)转换成可用于机器学习的数字特征<ul>
<li>字典特征处理(特征离散化)</li>
<li>文本特征处理</li>
<li>图像特征处理</li>
</ul>
</li>
</ul>
<h3 id="4-特征预处理"><a href="#4-特征预处理" class="headerlink" title="4. 特征预处理"></a>4. 特征预处理</h3><ul>
<li>数值型数据的无量纲化<ol>
<li>归一化<ul>
<li>即让数据归一到0~1区间</li>
<li>受异常值(特别大的值和特别小的值)影响较大</li>
<li>适用于传统精确小数据场景</li>
</ul>
</li>
<li>标准化<ul>
<li>x’=(x-mean)/a，a为标准差</li>
<li>适用于现代嘈杂大数据场景<h3 id="5-特征降维"><a href="#5-特征降维" class="headerlink" title="5. 特征降维"></a>5. 特征降维</h3></li>
</ul>
</li>
</ol>
</li>
<li>定义：降低特征个数，得到一组”不箱管”主变量的过程<ul>
<li>例如：相关特征：相对湿度和降雨量，二者数据冗余，若冗余过多，降低处理速度</li>
</ul>
</li>
</ul>
<h1 id="三、分类算法"><a href="#三、分类算法" class="headerlink" title="三、分类算法"></a>三、分类算法</h1><h3 id="1-KNN-K-近邻算法"><a href="#1-KNN-K-近邻算法" class="headerlink" title="1. KNN/K-近邻算法"></a>1. KNN/K-近邻算法</h3><ol>
<li>原理<ul>
<li>如果一个样本在特征空间中的k个最相似（即特征空间中最邻近）的样本中的大多数属于某一个类别，则该样本也属于这个类别</li>
</ul>
</li>
<li>问题<ul>
<li>k值取得过小，会受异常点影响</li>
<li>k值取得过大，样本不均衡会影响</li>
</ul>
</li>
<li>优点<ul>
<li>简单易理解，易于实现，无需训练</li>
</ul>
</li>
<li>缺点<ul>
<li>k值选择不当则分类精度不能保证</li>
<li>懒惰算法，对测试样本分类时的计算量大，内存开销大</li>
</ul>
</li>
<li>使用场景<ul>
<li>小数据场景，千级别的数据</li>
</ul>
</li>
</ol>
<h3 id="2-朴素贝叶斯算法-常用与文本分类"><a href="#2-朴素贝叶斯算法-常用与文本分类" class="headerlink" title="2. 朴素贝叶斯算法(常用与文本分类)"></a>2. 朴素贝叶斯算法(常用与文本分类)</h3><ol>
<li>定义<ul>
<li>朴素：假设特征与特征之间是相互独立的</li>
<li>贝叶斯：贝叶斯公式</li>
<li>分类完后样本属于各个类别有不同的概率值，取概率值大的为预测类别</li>
</ul>
</li>
<li>优点<ul>
<li>朴素贝叶斯模型发源于古典数学理论，有稳定的分类效率</li>
<li>对缺失数据不太敏感，算法也较简单，常用于文本分类</li>
<li>分类准确度高，速度快</li>
</ul>
</li>
<li>缺点<ul>
<li>由于使用了样本属性独立性的假说，所以如果特征属性有关联时效果不好</li>
</ul>
</li>
</ol>
<h3 id="3-决策树"><a href="#3-决策树" class="headerlink" title="3. 决策树"></a>3. 决策树</h3><ol>
<li><p>思想与原理   </p>
<ul>
<li>if-else，特征有优先级</li>
<li>原理：信息熵，信息增益等，需要信息论知识</li>
</ul>
</li>
<li><p>信息论基础<br> (1) 信息</p>
<pre><code> - 香农：消除随即不定性的东西
 - 例子：小明：“我今年18岁了”，可以得到一条信息。小华再说：“小明明年19岁”。这句话就不是信息了，是确定的东西，信息熵为0</code></pre>
<p> (2) 信息的衡量(消除不确定性)</p>
<pre><code> - 信息量
 - 信息熵</code></pre>
<p> (3) 信息增益</p>
<pre><code> - 决策树的划分依据之一，值越大，特征优先级越高，还有其他划分依据：信息增益比，基尼系数等</code></pre>
</li>
<li><p>优点</p>
<ul>
<li>理解简单，树木可视化</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>决策树学习者可以创建不能很好地推广数据的过于复杂的树，这被称为过拟合</li>
</ul>
</li>
<li><p>改进</p>
<ul>
<li>剪枝cart算法</li>
<li>随即森林</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li>企业重要决策</li>
</ul>
</li>
</ol>
<h3 id="4-随即森林"><a href="#4-随即森林" class="headerlink" title="4. 随即森林"></a>4. 随即森林</h3><ol>
<li>集成学习方法<ul>
<li>通过建立几个模型组合的来解决单一预测问题</li>
<li>生成多个分类器/模型，各自独立的学习和做出预测。这些预测最后组合城组合预测，因此优于任何一个单分类的预测</li>
</ul>
</li>
<li>随即森林<ul>
<li>包含多个决策树的分类器，属于集成学习方法之一</li>
</ul>
</li>
<li>随即<ul>
<li>训练集随机，从原有N个样本中随即有放回的抽样N个<ul>
<li>为什么随即抽样？为了让各个树不一样</li>
<li>问什么有放回？若不放回，各个树没有交集，每棵树都是“有偏的”“片面的”，各个树训练出来的差异大</li>
</ul>
</li>
<li>特征随即，从M个特征中随即抽取m个特征，M&gt;&gt;m,降维</li>
</ul>
</li>
<li>优点<ul>
<li>在当前算法中，具有较好的准确率</li>
<li>能有效运行在大数据集上，处理具有高纬度特征的样本，而且不需要降维</li>
<li>能评估各个特征在分类问题上的重要性</li>
</ul>
</li>
</ol>
<h1 id="四、回归与聚类算法"><a href="#四、回归与聚类算法" class="headerlink" title="四、回归与聚类算法"></a>四、回归与聚类算法</h1><h3 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1. 线性回归"></a>1. 线性回归</h3><ol>
<li>定义：目标值是连续的数据</li>
<li>通用公式：h(w)=w1x1+w2x2+…+b=Wx+b</li>
<li>线性模型<ul>
<li>线性关系：x的次数都为1</li>
<li>非线性关系：x的次数不定，如x+x^2+x^3</li>
</ul>
</li>
<li>线性回归的损失和优化原理<ul>
<li>目标：求模型参数</li>
<li>损失函数/cost/成本函数/目标函数<ul>
<li>最小二乘法</li>
</ul>
</li>
<li>优化算法<ul>
<li>正规方程：直接求W,当特征值过多过复杂时，求解速度过慢且得不到正确结果，不能解决过拟合的问题</li>
<li>梯度下降：不断试错改进，需要手动指定学习速率(超参数)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-欠拟合与过拟合"><a href="#2-欠拟合与过拟合" class="headerlink" title="2. 欠拟合与过拟合"></a>2. 欠拟合与过拟合</h3><ol>
<li>过拟合<ul>
<li>训练集效果好，测试集效果不好</li>
</ul>
</li>
<li>欠拟合<ul>
<li>学习特征过少</li>
</ul>
</li>
<li>解决方案<ul>
<li>L1正则化：使一些w直接为0，删除影响，又名LASSO回归</li>
<li>L2正则化：更常用，使得其中一些w很小，接近0，削弱某个特征的影响，又名岭回归。损失函数+惩罚项</li>
</ul>
</li>
</ol>
<h3 id="3-岭回归"><a href="#3-岭回归" class="headerlink" title="3. 岭回归"></a>3. 岭回归</h3><ul>
<li>就是用了L2正则化的线性回归</li>
</ul>
<h3 id="4-分类算法–逻辑回归与二分类"><a href="#4-分类算法–逻辑回归与二分类" class="headerlink" title="4. 分类算法–逻辑回归与二分类"></a>4. 分类算法–逻辑回归与二分类</h3><ol>
<li>应用场景<ul>
<li>如是否是垃圾邮件，是否患病等</li>
</ul>
</li>
<li>原理<ul>
<li>输入：逻辑回归的输入就是线性回归的输出结果，h(w)=w1x1+w2x2+…+b=Wx+b</li>
<li>激活函数：sigmoid函数</li>
<li>分析：将回归的结果输入到sigmoid函数中，输出结果为[0,1]间的一个概率值，默认为0.5为阈值，大于这个阈值属于一个类别，小于阈值属于另一个类别</li>
</ul>
</li>
<li>损失函数<ul>
<li>其值越小越好</li>
<li>因为实际分类为1或0,最小二乘法适用于连续数据，在这里不适用，要用对数似然损失</li>
</ul>
</li>
<li>优化损失<ul>
<li>梯度下降</li>
</ul>
</li>
</ol>
<h3 id="5-分类的评估方法"><a href="#5-分类的评估方法" class="headerlink" title="5. 分类的评估方法"></a>5. 分类的评估方法</h3><table>
<thead>
<tr>
<th>真实结果\预测结果</th>
<th>正例</th>
<th>假例</th>
</tr>
</thead>
<tbody><tr>
<td>正例</td>
<td>真正例TP</td>
<td>伪反例FN</td>
</tr>
<tr>
<td>假例</td>
<td>伪正例FP</td>
<td>真反例TN</td>
</tr>
</tbody></table>
<ol>
<li>精确率<ul>
<li>预测结果为正例样本中，真正为正例的比例</li>
<li>TP/(TP+FP)</li>
</ul>
</li>
<li>召回率<ul>
<li>真实为正例的样本中预测结果为正例的比例（对正样本的区分能力，常用）</li>
<li>TP/(TP+FN)</li>
</ul>
</li>
<li>F1-score<ul>
<li>反应模型的文件稳健性</li>
</ul>
</li>
</ol>
<h3 id="6-ROC曲线与AUC指标–衡量样本不均衡下的评估"><a href="#6-ROC曲线与AUC指标–衡量样本不均衡下的评估" class="headerlink" title="6. ROC曲线与AUC指标–衡量样本不均衡下的评估"></a>6. ROC曲线与AUC指标–衡量样本不均衡下的评估</h3><ol>
<li>ROC曲线<ul>
<li>TPR为纵轴，TPR是召回率</li>
<li>FPR为横轴，TPR是在所有真实类别为假的样本中，预测为假的比例</li>
</ul>
</li>
<li>AUC指标<ul>
<li>就是ROC曲线下方的面积</li>
<li>范围[0.5,1],若是0.5,相当于瞎猜</li>
<li>AUC只能用来评价二分类</li>
<li>AUC非常适合评价样本不均衡中的分类器性能</li>
</ul>
</li>
</ol>
<h1 id="五、无监督学习–K-means算法"><a href="#五、无监督学习–K-means算法" class="headerlink" title="五、无监督学习–K-means算法"></a>五、无监督学习–K-means算法</h1><h3 id="1-什么是无监督学习"><a href="#1-什么是无监督学习" class="headerlink" title="1. 什么是无监督学习"></a>1. 什么是无监督学习</h3><ul>
<li>没有目标值</li>
</ul>
<h3 id="2-无监督学习算法"><a href="#2-无监督学习算法" class="headerlink" title="2. 无监督学习算法"></a>2. 无监督学习算法</h3><ul>
<li>聚类：K-means(K均值聚类)</li>
<li>降维：PCA</li>
</ul>
<h3 id="3-K-means原理"><a href="#3-K-means原理" class="headerlink" title="3. K-means原理"></a>3. K-means原理</h3><ol>
<li>随即设置K个特征空间内的点作为初始的聚类中心</li>
<li>对于其他每个点计算到K个中心的距离，未知的点选择最近的一个聚类中心点作为标记类别</li>
<li>接着对着标记的聚类中心后，重新计算出每个聚类的新中心点（平均值）</li>
<li>如果计算的新中心点与原中心点一致，结束。否则重复2</li>
</ol>
<h3 id="4-优点"><a href="#4-优点" class="headerlink" title="4. 优点"></a>4. 优点</h3><ul>
<li>采用迭代式算法，直观易懂且实用</li>
</ul>
<h3 id="5-缺点"><a href="#5-缺点" class="headerlink" title="5. 缺点"></a>5. 缺点</h3><ul>
<li>容易收敛到局部最优解。解决办法：多次聚类</li>
</ul>
<h3 id="6-应用场景"><a href="#6-应用场景" class="headerlink" title="6. 应用场景"></a>6. 应用场景</h3><ul>
<li>一开始没有目标值，可以先聚类获得目标值，再分类</li>
</ul>
<hr>
<h1 id="六、深度学习介绍"><a href="#六、深度学习介绍" class="headerlink" title="六、深度学习介绍"></a>六、深度学习介绍</h1><h3 id="1-深度学习与机器学习的区别"><a href="#1-深度学习与机器学习的区别" class="headerlink" title="1. 深度学习与机器学习的区别"></a>1. 深度学习与机器学习的区别</h3><ol>
<li>特征提取方面<ul>
<li>机器学习：特征工程步骤手动完成，需要大量领域专业知识</li>
<li>深度学习：通常由多个层组成。它们通常将更简单的模型组合在一起，将数据从一层传递到另一层来构建更复杂的模型。通过训练大量数据自动得出模型，不需要人工特征提取环节。<ul>
<li>深度学习适合用在难提取特征的图像，语音，自然语言处理领域</li>
</ul>
</li>
</ul>
</li>
<li>数据量和计算性能要求<ul>
<li>深度学习需要大量的训练数据</li>
<li>训练深度神经网络需要大量的算力<ul>
<li>所有深度学习通常需要强大的GPU服务器来计算</li>
<li>需要全面管理的分布式训练与预测服务——如谷歌Tensorflow云机器学习平台</li>
</ul>
</li>
</ul>
</li>
<li>算法代表<ul>
<li>机器学习：朴素贝叶斯，决策树等</li>
<li>深度学习：神经网络</li>
</ul>
</li>
</ol>
<h3 id="2-深度学习应用场景"><a href="#2-深度学习应用场景" class="headerlink" title="2. 深度学习应用场景"></a>2. 深度学习应用场景</h3><ol>
<li>图像识别<ul>
<li>物体识别，场景识别，车型识别，人脸检测跟踪，人脸关键点定位，人脸身份认证</li>
</ul>
</li>
<li>自然语言处理<ul>
<li>机器翻译，文本识别，聊天对话</li>
</ul>
</li>
<li>语言技术<ul>
<li>语音识别</li>
</ul>
</li>
</ol>
<h3 id="GPU-CPU"><a href="#GPU-CPU" class="headerlink" title="GPU/CPU"></a>GPU/CPU</h3><ol>
<li>CPU<ul>
<li>核心数量少，但每一个核心的速度更快，性能更强</li>
<li>更适用于处理连续性任务(sequential)</li>
</ul>
</li>
<li>GPU<ul>
<li>核心数量多,但每一个核心的速度慢</li>
<li>更适用于处理并行任务(parallel)</li>
</ul>
</li>
</ol>
<h1 id="七、Tensorflow框架"><a href="#七、Tensorflow框架" class="headerlink" title="七、Tensorflow框架"></a>七、Tensorflow框架</h1><h3 id="1-Tensorflow结构"><a href="#1-Tensorflow结构" class="headerlink" title="1. Tensorflow结构"></a>1. Tensorflow结构</h3><ol>
<li>构建阶段：数据（张量）与操作（节点）的执行步骤描述成一个图</li>
<li>执行阶段：使用会话执行构建好的图中的操作。session</li>
<li>数据流图<ul>
<li>Tensor——数据——张量</li>
<li>Flow——操作——节点</li>
</ul>
</li>
</ol>
<h3 id="2-会话"><a href="#2-会话" class="headerlink" title="2. 会话"></a>2. 会话</h3><ol>
<li>创建会话，常用tf.session</li>
<li>会话初始化参数</li>
<li>会话的执行——run(op,feed_dict=None)<ul>
<li>op：单一的operation操作</li>
<li>feed_dict：传入的数据，与tf.placeholder()搭配</li>
</ul>
</li>
</ol>
<h3 id="3-张量"><a href="#3-张量" class="headerlink" title="3. 张量"></a>3. 张量</h3><ol>
<li>定义<ul>
<li>就是数据的定义</li>
<li>n维数组</li>
</ul>
</li>
<li>创建张量<ul>
<li>tf.zeros(),全0</li>
<li>tf.ones()，全1</li>
<li>tf.constrant(),常量</li>
<li>tf.random_normal()，随即</li>
<li>tf.Varinable()，变量</li>
<li>tf.placeholder(),占位符</li>
</ul>
</li>
<li>张量变化<ul>
<li>类型改变</li>
<li>形状改变</li>
<li>张量的数学运算</li>
</ul>
</li>
</ol>
<h3 id="4-变量op-操作"><a href="#4-变量op-操作" class="headerlink" title="4. 变量op(操作)"></a>4. 变量op(操作)</h3><ol>
<li>创建变量<ul>
<li>tf.Variable()</li>
<li>变量需要显式初始化，才能运行值,如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init&#x3D;tf.global_variables_initializer()</span><br><span class="line">with ... as sess:</span><br><span class="line">    sess.run(init)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="5-模型保存与加载"><a href="#5-模型保存与加载" class="headerlink" title="5. 模型保存与加载"></a>5. 模型保存与加载</h3><ul>
<li>用时再搜</li>
</ul>
<h3 id="6-数据IO"><a href="#6-数据IO" class="headerlink" title="6. 数据IO"></a>6. 数据IO</h3><h5 id="1-三种获取数据到Tensorflow程序的方式"><a href="#1-三种获取数据到Tensorflow程序的方式" class="headerlink" title="1. 三种获取数据到Tensorflow程序的方式"></a>1. 三种获取数据到Tensorflow程序的方式</h5><pre><code>- QueueRunner:基于队列的输入管道从Tensorflow图形开头的文件中读取数据（最高效）
- Feeding：运行每一步时，Python代码提供数据，和placeholder()结合使用
- 预加载数据：Tensorflow图中的张量包含所有数据(对于小数据集)</code></pre>
<h5 id="2-文件读取流程"><a href="#2-文件读取流程" class="headerlink" title="2. 文件读取流程"></a>2. 文件读取流程</h5><ol>
<li><p>构建文件名队列</p>
<ul>
<li>tf.train.string_input_producer(string_tensor,shuffle=True)</li>
<li>string_tensor为列表</li>
</ul>
</li>
<li><p>读取</p>
<ul>
<li>tf.TextLineReader,读csv格式文件</li>
<li>tf.WholeFileReader,读取图片文件</li>
<li>tf.TFRecordReader,读取TFRecords文件</li>
<li>用时再查</li>
</ul>
</li>
<li><p>解码</p>
<ul>
<li>读取不同类型的文件，要进行相应的解码操作，解码成统一的Tensor格式</li>
<li>tf.decode_csv,解码csv文本文件</li>
<li>tf.image.decode_jpeg(contents),将JPEG编码的图像解码为uint8张量</li>
<li>tf.image.decode_png(contents),将PNG编码的图像解码为uint8张量</li>
<li>tf.decode_raw:解码二进制文件内容</li>
</ul>
</li>
<li><p>批处理</p>
<ul>
<li>解码后只获得默认的一个样本内容，若想获取多个样本，需要加入到新的队列进行批处理</li>
<li>tf.train.batch</li>
<li>tf.train.shuffle_batch</li>
</ul>
</li>
</ol>
<h3 id="7-TensorBoard可视化"><a href="#7-TensorBoard可视化" class="headerlink" title="7. TensorBoard可视化"></a>7. TensorBoard可视化</h3><ol>
<li><p>图结构</p>
<ul>
<li>数据+操作</li>
</ul>
</li>
<li><p>图相关操作</p>
<ul>
<li>默认图<ul>
<li>查看默认图：tf.get_default_graph()</li>
<li>查看属性：sess.graph</li>
</ul>
</li>
<li>创建图  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_g&#x3D;tf.Graph()</span><br><span class="line">with new_g.as_default():</span><br><span class="line">    定义数据和操作</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>可视化</p>
<ul>
<li>数据序列化为events文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tf.summary.FileWriter(path&#x3D;&quot;写入路径&quot;,graph&#x3D;sess.graph) # 第二个为图的名字</span><br></pre></td></tr></table></figure></li>
<li>查看图<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在命令行输入</span><br><span class="line">tensorboard --logdir&#x3D;&quot;图的目录&quot;</span><br><span class="line">&#x2F;&#x2F;在浏览器输入</span><br><span class="line">127.0.0.1:6006</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h5 id="3-图片数据"><a href="#3-图片数据" class="headerlink" title="3. 图片数据"></a>3. 图片数据</h5><ol>
<li>用张量表示一张图片<ul>
<li>张量形状：Tensor(指令名称，shape,dtype)</li>
<li>对于shape<ul>
<li>一张图片：shape=(height,width,channels通道数)</li>
<li>多张图片：shape=(batch,…如上)，batch表示一个批次的张量数量</li>
</ul>
</li>
</ul>
</li>
<li>图片特征值处理<ul>
<li>若图片大小不一，要进行统一的缩放处理，保持特征数量相同</li>
<li>方法：tf.image.resize_images(images,size)</li>
<li>数据格式：<ul>
<li>存储：uint8</li>
<li>矩阵计算：float32</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="八、神经网络"><a href="#八、神经网络" class="headerlink" title="八、神经网络"></a>八、神经网络</h1><h3 id="1-人工神经网络-Artificial-Neural-Network-ANN"><a href="#1-人工神经网络-Artificial-Neural-Network-ANN" class="headerlink" title="1. 人工神经网络(Artificial Neural Network,ANN)"></a>1. 人工神经网络(Artificial Neural Network,ANN)</h3><ol>
<li>简称神经网络(NN)，经典NN结构包含三个层次的神经网络，分别为输入层，隐藏层，输出层。</li>
<li>感知机<ul>
<li>一种最基础的分类模型，类似于逻辑回归</li>
<li>和逻辑回归激活函数不同，逻辑回归是sigmoid，感知机是sign</li>
<li>感知机只能解决简单的与或问题</li>
</ul>
</li>
</ol>
<h3 id="2-神经网络原理"><a href="#2-神经网络原理" class="headerlink" title="2. 神经网络原理"></a>2. 神经网络原理</h3><ol>
<li>神经网络的主要用途在于分类，分类的原理要围绕损失，优化两块</li>
<li>softmax回归<ul>
<li>将神经网络输出转换成概率结果。类似与逻辑回归中的sigmoid函数，sigmoid输出的是某个类别的概率</li>
<li>logits+softmax能解决多分类问题</li>
</ul>
</li>
<li>交叉熵损失(损失函数)<ul>
<li>真实值要用one-hot形式[0,0,0,0,1,0,0,0],这样才能算离真实值的距离</li>
<li>损失大小<ul>
<li>总损失——求平均</li>
<li>最小二乘法——衡量线性回归的损失——均方误差</li>
</ul>
</li>
<li>优化损失函数</li>
</ul>
</li>
</ol>
<h3 id="3-手写数字识别例子"><a href="#3-手写数字识别例子" class="headerlink" title="3. 手写数字识别例子"></a>3. 手写数字识别例子</h3><ol>
<li>准备数据</li>
<li>构建模型</li>
<li>构造损失函数</li>
<li>优化损失</li>
</ol>
<h3 id="4-卷积神经网络-CNN"><a href="#4-卷积神经网络-CNN" class="headerlink" title="4. 卷积神经网络(CNN)"></a>4. 卷积神经网络(CNN)</h3><h5 id="1-CNN和NN的区别"><a href="#1-CNN和NN的区别" class="headerlink" title="1. CNN和NN的区别"></a>1. CNN和NN的区别</h5><ol>
<li>NN<ul>
<li>只有输入层，隐藏层，输出层。</li>
<li>隐藏层的层数根据需要而定，没有明确说多少层合适</li>
</ul>
</li>
<li>CNN<ul>
<li>在原多层网络的基础上，加入了更有效的特征学习部分，具体操作如下<ul>
<li>在原来的全连接层前加入了卷积层和池化层</li>
</ul>
</li>
<li>卷积神经网络出现，使得神经网络层数得以加深，“深度”学习由此而来</li>
<li>2012年被重视</li>
</ul>
</li>
<li>深度学习<ul>
<li>一般指的是这些CNN等新的结构以及一些新的方法(比如一些新的激活函数Relu等)，解决了传统多层神经网络的一些难以解决的问题。</li>
</ul>
</li>
</ol>
<h5 id="2-卷积层"><a href="#2-卷积层" class="headerlink" title="2. 卷积层"></a>2. 卷积层</h5><ol>
<li>通过在原始图像上平移来提取特征</li>
<li>卷积核（Filter过滤器）四大要素<ul>
<li>卷积核个数</li>
<li>大小，3*3,5*5</li>
<li>步长</li>
<li>零填充大小</li>
</ul>
</li>
<li>卷积运算的目的是提取特征</li>
<li>每层卷积层由若干卷积单元(卷积核)组成</li>
<li>每个卷积单元的参数是通过反向传播算法以最佳化得到的</li>
</ol>
<h5 id="3-激活层"><a href="#3-激活层" class="headerlink" title="3. 激活层"></a>3. 激活层</h5><ol>
<li>使用激活函数，增加非线性分割能力</li>
<li>sigmoid不能满足，效果不好，计算量大，且反向传播时，容易出现梯度消失</li>
<li>Relu<ul>
<li>解决梯度消失问题</li>
<li>计算速度快</li>
<li>对图像没有负的像素值</li>
</ul>
</li>
</ol>
<h5 id="4-池化层pooling"><a href="#4-池化层pooling" class="headerlink" title="4. 池化层pooling"></a>4. 池化层pooling</h5><ol>
<li>主要作用是特征提取。通过去掉Feature Map中不重要的样本，进一步减少参数数量，降低网络的复杂度，防止过拟合。</li>
</ol>
<h5 id="5-全连接层"><a href="#5-全连接层" class="headerlink" title="5. 全连接层"></a>5. 全连接层</h5><ol>
<li>前面的卷积和池化相当于做特征工程</li>
<li>最后的全连接层在整个CNN中起到“分类器”的作用，最后的输出层，进行损失计算</li>
</ol>
<h3 id="5-网络设计"><a href="#5-网络设计" class="headerlink" title="5. 网络设计"></a>5. 网络设计</h3><h5 id="1-一个简单的网络结构"><a href="#1-一个简单的网络结构" class="headerlink" title="1. 一个简单的网络结构"></a>1. 一个简单的网络结构</h5><ul>
<li>卷积|激活|池化—&gt;卷积|激活|池化—&gt;全连接</li>
</ul>
<h5 id="2-具体参数"><a href="#2-具体参数" class="headerlink" title="2. 具体参数"></a>2. 具体参数</h5><ol>
<li>第一层：<ul>
<li>卷积：<ul>
<li>输入图像(None,28,28,1)</li>
<li>32个filter,5*5,strides=1(步长)，padding=SAME</li>
<li>输出形状(None,28,28,32)</li>
</ul>
</li>
<li>激活：Relu</li>
<li>池化：大小2*2，步长2<ul>
<li>输入图像(None,28,28,32)</li>
<li>2*2,strides=2(步长)</li>
<li>输出形状(None,14,14,32)</li>
</ul>
</li>
</ul>
</li>
<li>第二层：<ul>
<li>卷积：<ul>
<li>输入图像(None,14,14，32)</li>
<li>64个filter,5*5,strides=1(步长)，padding=SAME</li>
<li>输出形状(None,14,14,64)</li>
</ul>
</li>
<li>激活：Relu</li>
<li>池化：大小2*2，步长2<ul>
<li>输入图像(None,14,14,64)</li>
<li>2*2,strides=2(步长)</li>
<li>输出形状(None,7,7,64)</li>
</ul>
</li>
</ul>
</li>
<li>全连接层<ul>
<li>[None,7,7,64]–&gt;[None,7*7*64]</li>
<li>[None,7*7*64]*[7*7*64,10]=[None,10]</li>
<li>[None,1024]*[1024,10]=[None,10]</li>
<li>y_predict=tf.matmul(pool2,weights)+bias</li>
</ul>
</li>
</ol>
<h5 id="3-调参提高准确率"><a href="#3-调参提高准确率" class="headerlink" title="3. 调参提高准确率"></a>3. 调参提高准确率</h5><ol>
<li>改变学习率，梯度下降的学习率</li>
<li>随即初始化的权重，偏置的值</li>
<li>选择好的优化器，梯度下降用的</li>
</ol>
<h5 id="4-CNN几种经典模型"><a href="#4-CNN几种经典模型" class="headerlink" title="4. CNN几种经典模型"></a>4. CNN几种经典模型</h5><ol>
<li>AlexNet</li>
<li>ResNet</li>
<li>GoogleNet</li>
</ol>
<h3 id="6-MNIST例子"><a href="#6-MNIST例子" class="headerlink" title="6. MNIST例子"></a>6. MNIST例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import os</span><br><span class="line">from tensorflow.python.framework import graph_util</span><br><span class="line">from tensorflow.python.saved_model import builder as saved_model_builder</span><br><span class="line">from tensorflow.python.saved_model import (signature_constants, signature_def_utils, tag_constants, utils)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot; </span><br><span class="line">0 表示训练并存成ckpt和pb</span><br><span class="line">1 表示读取ckpt测试</span><br><span class="line">2 表示存成pb文件</span><br><span class="line">3 表示读取pb测试</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">choise&#x3D;0</span><br><span class="line"></span><br><span class="line"># 加载数据，没有的话会自动下载</span><br><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line">mnist&#x3D;input_data.read_data_sets(&quot;MNIST_data&quot;,one_hot&#x3D;True)</span><br><span class="line"></span><br><span class="line">##################### build net model ##########################</span><br><span class="line"></span><br><span class="line">########## define conv process ##########</span><br><span class="line"># 2维卷积</span><br><span class="line">def conv2d(name,x,W,b,strides&#x3D;1, padding&#x3D;&#39;SAME&#39;):</span><br><span class="line">	x&#x3D;tf.nn.conv2d(x,W,strides&#x3D;[1,strides,strides,1],padding&#x3D;padding)</span><br><span class="line">	x&#x3D;tf.nn.bias_add(x,b)</span><br><span class="line">	return tf.nn.relu(x,name&#x3D;name)</span><br><span class="line"></span><br><span class="line">########## define pool process ##########</span><br><span class="line"># 池化</span><br><span class="line">def maxpool2d(name, x, k&#x3D;3, s&#x3D;2, padding&#x3D;&#39;SAME&#39;):</span><br><span class="line">	return tf.nn.max_pool(x,ksize&#x3D;[1,k,k,1],strides&#x3D;[1,s,s,1],padding&#x3D;padding,name&#x3D;name)</span><br><span class="line"></span><br><span class="line">########## set net parameters ##########</span><br><span class="line">def weight_var2(shape):</span><br><span class="line">	return tf.Variable(initial_value&#x3D;tf.random_normal(shape&#x3D;shape))	# 正态分布随机数初始化</span><br><span class="line">	</span><br><span class="line">def weight_var(shape):</span><br><span class="line">	initial &#x3D; tf.truncated_normal(shape, stddev&#x3D;0.1)</span><br><span class="line">	return tf.Variable(initial)</span><br><span class="line">def bias_var(shape):</span><br><span class="line">	initial &#x3D; tf.constant(0.1, shape&#x3D;shape)</span><br><span class="line">	return tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot; </span><br><span class="line">1. 第一层：</span><br><span class="line">    - 卷积：</span><br><span class="line">        - 输入图像(None,28,28,1)</span><br><span class="line">        - 32个filter,5*5,strides&#x3D;1(步长)，padding&#x3D;SAME</span><br><span class="line">        - 输出形状(None,28,28,32)</span><br><span class="line">    - 激活：Relu</span><br><span class="line">    - 池化：大小2*2，步长2</span><br><span class="line">        - 输入图像(None,28,28,32)</span><br><span class="line">        - 2*2,strides&#x3D;2(步长)</span><br><span class="line">        - 输出形状(None,14,14,32)</span><br><span class="line">2. 第二层：</span><br><span class="line">    - 卷积：</span><br><span class="line">        - 输入图像(None,14,14，32)</span><br><span class="line">        - 64个filter,5*5,strides&#x3D;1(步长)，padding&#x3D;SAME</span><br><span class="line">        - 输出形状(None,14,14,64)</span><br><span class="line">    - 激活：Relu</span><br><span class="line">    - 池化：大小2*2，步长2</span><br><span class="line">        - 输入图像(None,14,14,64)</span><br><span class="line">        - 2\*2,strides&#x3D;2(步长)</span><br><span class="line">        - 输出形状(None,7,7,64)</span><br><span class="line">3. 全连接层</span><br><span class="line">    - [None,7,7,64]--&gt;[None,7*7*64]</span><br><span class="line">    - [None,7*7*64]*[7*7*64,1024]&#x3D;[None,1024]</span><br><span class="line">	- [None,1024]*[1024,10]&#x3D;[None,10]</span><br><span class="line">    - y_predict&#x3D;tf.matmul(pool2,weights)+bias</span><br><span class="line"></span><br><span class="line"> &quot;&quot;&quot;</span><br><span class="line">def my_net(x):</span><br><span class="line">	&quot;&quot;&quot; </span><br><span class="line">	卷积神经网络</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	y_pred&#x3D;0</span><br><span class="line">	# 第一层</span><br><span class="line">	# 卷积层</span><br><span class="line">	# 将x[None,784]形状修改</span><br><span class="line">	# shape第一个是载入样本数量，不知道一次性载入多少，所以用-1,1为通道数</span><br><span class="line">	input_x &#x3D; tf.reshape(x,shape&#x3D;[-1,28,28,1])</span><br><span class="line">	# 定义filter和偏置</span><br><span class="line">	conv1_weights &#x3D; weight_var2(shape&#x3D;[5,5,1,32])	# 5*5的filter,通道数为1,32个filter</span><br><span class="line">	conv1_bias &#x3D; weight_var2(shape&#x3D;[32])</span><br><span class="line">	conv1_x &#x3D; tf.nn.conv2d(input&#x3D;input_x,filter&#x3D;conv1_weights,strides&#x3D;[1,1,1,1],padding&#x3D;&quot;SAME&quot;)+conv1_bias	#步长为[batch, height, width, channels]这样的shape，一般为[1,s,s,1],s表示步长</span><br><span class="line">																											#padding为0填充，SAME表示输入图片大小和输出图片大小是一致的，如果是VALID则图片经过滤波器后可能会变小。</span><br><span class="line">	# 激活层</span><br><span class="line">	relu1_x&#x3D;tf.nn.relu(conv1_x)</span><br><span class="line">	# 池化层</span><br><span class="line">	pool1_x &#x3D; tf.nn.max_pool(value&#x3D;relu1_x,ksize&#x3D;[1,2,2,1],strides&#x3D;[1,2,2,1],padding&#x3D;&quot;SAME&quot;)	# ksize为池化窗口的大小，一般是[1, height, width, 1]，因为我们不想在batch和channels上做池化，所以这两个维度设为了1</span><br><span class="line">																								</span><br><span class="line">	# 第二层</span><br><span class="line">	# 定义filter和偏置</span><br><span class="line">	conv2_weights &#x3D; weight_var2(shape&#x3D;[5,5,32,64])	# 5*5的filter,通道数为1,32个filter</span><br><span class="line">	conv2_bias &#x3D; weight_var2(shape&#x3D;[64])</span><br><span class="line">	conv2_x &#x3D; tf.nn.conv2d(input&#x3D;pool1_x,filter&#x3D;conv2_weights,strides&#x3D;[1,1,1,1],padding&#x3D;&quot;SAME&quot;)+conv2_bias																											</span><br><span class="line">	# 激活层</span><br><span class="line">	relu2_x&#x3D;tf.nn.relu(conv2_x)</span><br><span class="line">	# 池化层</span><br><span class="line">	pool2_x &#x3D; tf.nn.max_pool(value&#x3D;relu2_x,ksize&#x3D;[1,2,2,1],strides&#x3D;[1,2,2,1],padding&#x3D;&quot;SAME&quot;)</span><br><span class="line"></span><br><span class="line">	# 全连接层</span><br><span class="line">	&quot;&quot;&quot; </span><br><span class="line">		[None,7,7,64]--&gt;[None,7*7*64]</span><br><span class="line">    	[None,7*7*64]*[7*7*64,10]&#x3D;[None,10]</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	x_fc&#x3D;tf.reshape(pool2_x,shape&#x3D;[-1,7*7*64])</span><br><span class="line">	weights_fc&#x3D;weight_var(shape&#x3D;[7*7*64,10])</span><br><span class="line">	bias_fc&#x3D;weight_var(shape&#x3D;[10])</span><br><span class="line">	y_pred&#x3D;tf.matmul(x_fc,weights_fc)+bias_fc</span><br><span class="line">	# y_pred2&#x3D;tf.nn.softmax(tf.matmul(x_fc, weights_fc) + bias_fc,name&#x3D;&quot;final_result&quot;)</span><br><span class="line">	return y_pred</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">		</span><br><span class="line">	########## placeholder ##########</span><br><span class="line">	x&#x3D;tf.placeholder(&quot;float&quot;,[None,784],name&#x3D;&quot;x&quot;)</span><br><span class="line">	y_true&#x3D;tf.placeholder(&quot;float&quot;,[None,10],name&#x3D;&quot;y_true&quot;)</span><br><span class="line"></span><br><span class="line">	W &#x3D; tf.Variable(tf.zeros([784,10]))</span><br><span class="line">	b &#x3D; tf.Variable(tf.zeros([10]))</span><br><span class="line"></span><br><span class="line">	#### model ####	</span><br><span class="line">	y_pred &#x3D; my_net(x)</span><br><span class="line"></span><br><span class="line">	# softmax 回归及交叉熵损失计算</span><br><span class="line">	# labels 真实值</span><br><span class="line">	# logits 预测值</span><br><span class="line">	loss&#x3D;tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels&#x3D;y_true,logits&#x3D;y_pred))</span><br><span class="line">	loss2&#x3D;tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels&#x3D;y_true,logits&#x3D;y_pred,name&#x3D;&#39;final_result&#39;))</span><br><span class="line">	</span><br><span class="line">	# tf.add_to_collection(&#39;output&#39;, y_conv2)</span><br><span class="line">	#梯度下降损失优化</span><br><span class="line">	train_step &#x3D; tf.train.GradientDescentOptimizer(0.001).minimize(loss)</span><br><span class="line">	# train_step &#x3D; tf.train.AdamOptimizer(0.001).minimize(cross_entropy)	# 这个比梯度下降损失优化差一点</span><br><span class="line">	correct_prediction &#x3D; tf.equal(tf.argmax(y_pred,1), tf.argmax(y_true,1))</span><br><span class="line">	accuracy &#x3D; tf.reduce_mean(tf.cast(correct_prediction, &quot;float&quot;))</span><br><span class="line">	########## initialize variables ##########</span><br><span class="line">	init&#x3D;tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line">	saver&#x3D;tf.train.Saver(max_to_keep&#x3D;1)</span><br><span class="line">	</span><br><span class="line">	with tf.Session() as sess:</span><br><span class="line">		sess.run(init)</span><br><span class="line">		if(choise&#x3D;&#x3D;0):	# 训练阶段</span><br><span class="line">			max_acc&#x3D;0</span><br><span class="line">			for i in range(1000):</span><br><span class="line">				mnist_x,mnist_y &#x3D; mnist.train.next_batch(50)</span><br><span class="line">				sess.run(train_step,feed_dict&#x3D;&#123;x:mnist_x,y_true:mnist_y&#125;)</span><br><span class="line">				val_loss,val_acc&#x3D;sess.run([loss,accuracy], feed_dict&#x3D;&#123;x: mnist_x, y_true: mnist_y&#125;)</span><br><span class="line">				# val_loss,val_acc&#x3D;sess.run([loss,accuracy], feed_dict&#x3D;&#123;x: mnist.test.images, y_true: mnist.test.labels&#125;)</span><br><span class="line">				if val_acc&gt;max_acc:</span><br><span class="line">					max_acc&#x3D;val_acc</span><br><span class="line">					saver.save(sess,&#39;ckpt&#x2F;mnist.ckpt&#39;,global_step&#x3D;i+1)	#global_step是一个计数器，可以用于保存多个中间结果</span><br><span class="line">				if(i%50&#x3D;&#x3D;0):</span><br><span class="line">					print(&quot;准确率为：&#123;0&#125;, 损失为：&#123;1&#125;&quot;.format(val_acc,val_loss))</span><br><span class="line">			# # 保存图</span><br><span class="line">			# # tensorboard --logdir&#x3D;&quot;path&quot; 再通过浏览器查看图</span><br><span class="line">			# tf.summary.FileWriter(&quot;.&#x2F;graph&#x2F;one&quot;,graph&#x3D;sess.graph)</span><br><span class="line">			# # 保存为pb文件</span><br><span class="line">			# #将当前图设置为默认图</span><br><span class="line">			# graph_def &#x3D; tf.get_default_graph().as_graph_def() </span><br><span class="line">			# #将上面的变量转化成常量，保存模型为pb模型时需要,注意这里的final_result和前面的y_con2是同名，只有这样才会保存它，否则会报错，</span><br><span class="line">			# # 如果需要保存其他tensor只需要让tensor的名字和这里保持一直即可</span><br><span class="line">			# output_graph_def &#x3D; tf.graph_util.convert_variables_to_constants(sess,  </span><br><span class="line">			# 				graph_def, [&#39;final_result&#39;])  </span><br><span class="line">			# #保存前面训练后的模型为pb文件</span><br><span class="line">			# with tf.gfile.GFile(&quot;.&#x2F;pb_model&#x2F;three&#x2F;model.pb&quot;, &#39;wb&#39;) as f:  </span><br><span class="line">			# 		f.write(output_graph_def.SerializeToString())</span><br><span class="line"></span><br><span class="line">		elif(choise&#x3D;&#x3D;1):	# ckpt测试阶段</span><br><span class="line">			model_file&#x3D;tf.train.latest_checkpoint(&#39;ckpt&#x2F;&#39;)</span><br><span class="line">			saver.restore(sess,model_file)</span><br><span class="line">			val_loss,val_acc&#x3D;sess.run([loss,accuracy], feed_dict&#x3D;&#123;x: mnist.test.images, y_true: mnist.test.labels&#125;)</span><br><span class="line">			print(&#39;准确率为: &#123;0&#125;, 损失为： &#123;1&#125;&#39;.format(val_acc,val_loss))</span><br><span class="line">		elif(choise&#x3D;&#x3D;2):	# 训练保存为pb</span><br><span class="line">			model_file&#x3D;tf.train.latest_checkpoint(&#39;ckpt&#x2F;&#39;)</span><br><span class="line">			saver.restore(sess,model_file)</span><br><span class="line">			constant_graph &#x3D; graph_util.convert_variables_to_constants(sess, sess.graph_def, [&#39;final_result&#39;])			</span><br><span class="line">			with tf.gfile.FastGFile(&quot;.&#x2F;pb_model&#x2F;two&#x2F;mymnist_model.pb&quot;, mode&#x3D;&#39;wb&#39;) as f:</span><br><span class="line">				f.write(constant_graph.SerializeToString())</span><br><span class="line">		elif(choise&#x3D;&#x3D;3):	# pb测试</span><br><span class="line">			# load_pb()</span><br><span class="line">			pass</span><br><span class="line">		else:</span><br><span class="line">			print(&quot;choise出错&quot;)</span><br><span class="line">			</span><br></pre></td></tr></table></figure>
<ul>
<li>为了保存为pb文件在安卓上运行而找的代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line"># 保存模型需要的库</span><br><span class="line">from tensorflow.python.framework.graph_util import convert_variables_to_constants </span><br><span class="line">from tensorflow.python.framework import graph_util </span><br><span class="line"># 导入其他库</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np </span><br><span class="line"></span><br><span class="line">#权重</span><br><span class="line">def weight_variable(shape):</span><br><span class="line">  initial &#x3D; tf.truncated_normal(shape, stddev&#x3D;0.1)</span><br><span class="line">  return tf.Variable(initial)</span><br><span class="line">#偏差</span><br><span class="line">def bias_variable(shape):</span><br><span class="line">  initial &#x3D; tf.constant(0.1, shape&#x3D;shape)</span><br><span class="line">  return tf.Variable(initial)</span><br><span class="line">#卷积</span><br><span class="line">def conv2d(x, W):</span><br><span class="line">  return tf.nn.conv2d(x, W, strides&#x3D;[1, 1, 1, 1], padding&#x3D;&#39;SAME&#39;)</span><br><span class="line">#最大池化</span><br><span class="line">def max_pool_2x2(x):</span><br><span class="line">  return tf.nn.max_pool(x, ksize&#x3D;[1, 2, 2, 1],</span><br><span class="line">                        strides&#x3D;[1, 2, 2, 1], padding&#x3D;&#39;SAME&#39;)</span><br><span class="line"></span><br><span class="line">#获取MINIST数据</span><br><span class="line">mnist&#x3D;input_data.read_data_sets(&quot;MNIST_data&quot;,one_hot&#x3D;True)</span><br><span class="line"># 创建会话 </span><br><span class="line">sess &#x3D; tf.InteractiveSession()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x &#x3D; tf.placeholder(&quot;float&quot;, shape&#x3D;[None, 784], name&#x3D;&quot;x&quot;)</span><br><span class="line">y_true &#x3D; tf.placeholder(&quot;float&quot;,shape&#x3D;[None, 10],  name&#x3D;&quot;y_true&quot;)</span><br><span class="line">W &#x3D; tf.Variable(tf.zeros([784,10]),name&#x3D;&#39;w&#39;)</span><br><span class="line">b &#x3D; tf.Variable(tf.zeros([10]),&#39;b&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第一层，卷积激活池化</span><br><span class="line">W_conv1 &#x3D; weight_variable([5, 5, 1, 32])</span><br><span class="line">b_conv1 &#x3D; bias_variable([32])</span><br><span class="line">x_image &#x3D; tf.reshape(x, [-1,28,28,1])</span><br><span class="line">h_conv1 &#x3D; tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)</span><br><span class="line">h_pool1 &#x3D; max_pool_2x2(h_conv1)</span><br><span class="line"></span><br><span class="line"># 第二层，卷积激活池化</span><br><span class="line">W_conv2 &#x3D; weight_variable([5, 5, 32, 64])</span><br><span class="line">b_conv2 &#x3D; bias_variable([64])</span><br><span class="line">h_conv2 &#x3D; tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)</span><br><span class="line">h_pool2 &#x3D; max_pool_2x2(h_conv2)</span><br><span class="line"></span><br><span class="line"># 全连接层</span><br><span class="line">W_fc1 &#x3D; weight_variable([7 * 7 * 64, 1024])</span><br><span class="line">b_fc1 &#x3D; bias_variable([1024])</span><br><span class="line">h_pool2_flat &#x3D; tf.reshape(h_pool2, [-1, 7*7*64])</span><br><span class="line">h_fc1 &#x3D; tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</span><br><span class="line"></span><br><span class="line"># dropout防止过拟合</span><br><span class="line"># keep_prob &#x3D; tf.placeholder(&quot;float&quot;,name&#x3D;&#39;rob&#39;)</span><br><span class="line"># h_fc1_drop &#x3D; tf.nn.dropout(h_fc1, keep_prob)</span><br><span class="line"></span><br><span class="line">#用于训练用的softmax函数</span><br><span class="line">W_fc2 &#x3D; weight_variable([1024, 10])</span><br><span class="line">b_fc2 &#x3D; bias_variable([10])</span><br><span class="line">y_conv&#x3D;tf.nn.softmax(tf.matmul(h_fc1, W_fc2) + b_fc2,name&#x3D;&#39;res&#39;)</span><br><span class="line">#用于训练作完后，作测试用的softmax函数</span><br><span class="line">y_conv2&#x3D;tf.nn.softmax(tf.matmul(h_fc1, W_fc2) + b_fc2,name&#x3D;&quot;final_result&quot;)</span><br><span class="line"></span><br><span class="line">#交叉熵的计算，返回包含了损失值的Tensor。</span><br><span class="line">cross_entropy &#x3D; -tf.reduce_sum(y_true*tf.log(y_conv))</span><br><span class="line"></span><br><span class="line">#优化器，负责最小化交叉熵</span><br><span class="line">train_step &#x3D; tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)</span><br><span class="line">#梯度下降损失优化</span><br><span class="line"># train_step &#x3D; tf.train.GradientDescentOptimizer(0.001).minimize(loss)</span><br><span class="line">correct_prediction &#x3D; tf.equal(tf.argmax(y_conv,1), tf.argmax(y_true,1))</span><br><span class="line">#计算准确率</span><br><span class="line">accuracy &#x3D; tf.reduce_mean(tf.cast(correct_prediction, &quot;float&quot;))</span><br><span class="line">#初始化所以变量</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line"> # 保存输入输出，可以为之后用</span><br><span class="line"># tf.add_to_collection(&#39;res&#39;, y_conv)</span><br><span class="line"># tf.add_to_collection(&#39;output&#39;, y_conv2)</span><br><span class="line"># tf.add_to_collection(&#39;result&#39;, res)</span><br><span class="line"># tf.add_to_collection(&#39;x&#39;, x)</span><br><span class="line"></span><br><span class="line">#训练开始</span><br><span class="line">for i in range(200):</span><br><span class="line">  batch &#x3D; mnist.train.next_batch(50)</span><br><span class="line">  if i%100 &#x3D;&#x3D; 0:</span><br><span class="line">    train_accuracy &#x3D; accuracy.eval(feed_dict&#x3D;&#123;</span><br><span class="line">        x:batch[0], y_true: batch[1]&#125;)</span><br><span class="line">    print(&quot;step &#123;0&#125;, training accuracy &#123;1&#125;&quot;.format(i, train_accuracy))</span><br><span class="line">#run()可以看做输入相关值给到函数中的占位符，然后计算的出结果，这里将batch[0]，给xbatch[1]给y_</span><br><span class="line">  train_step.run(feed_dict&#x3D;&#123;x: batch[0], y_true: batch[1]&#125;)</span><br><span class="line"></span><br><span class="line">#将当前图设置为默认图</span><br><span class="line">graph_def &#x3D; tf.get_default_graph().as_graph_def() </span><br><span class="line">#将上面的变量转化成常量，保存模型为pb模型时需要,注意这里的final_result和前面的y_con2是同名，只有这样才会保存它，否则会报错，</span><br><span class="line"># 如果需要保存其他tensor只需要让tensor的名字和这里保持一直即可</span><br><span class="line">output_graph_def &#x3D; tf.graph_util.convert_variables_to_constants(sess,  </span><br><span class="line">                graph_def, [&#39;final_result&#39;])  </span><br><span class="line">#保存前面训练后的模型为pb文件</span><br><span class="line">with tf.gfile.GFile(&quot;.&#x2F;model&#x2F;pb&#x2F;mnist.pb&quot;, &#39;wb&#39;) as f:  </span><br><span class="line">        f.write(output_graph_def.SerializeToString())</span><br><span class="line">print(&quot;保存pb成功&quot;)</span><br><span class="line"></span><br><span class="line">#保存模型</span><br><span class="line">saver &#x3D; tf.train.Saver()   </span><br><span class="line">saver.save(sess, &quot;.&#x2F;model&#x2F;ckpt&#x2F;mnist.ckpt&quot;)  </span><br><span class="line">print(&quot;保存ckpt成功&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix网络编程》</title>
    <url>/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第2章：传输层：TCP、UDP和SCTP"><a href="#第2章：传输层：TCP、UDP和SCTP" class="headerlink" title="第2章：传输层：TCP、UDP和SCTP"></a>第2章：传输层：TCP、UDP和SCTP</h1><a id="more"></a>
<h3 id="1-SCTP"><a href="#1-SCTP" class="headerlink" title="1. SCTP"></a>1. SCTP</h3><ul>
<li>流控制传输协议</li>
</ul>
<h3 id="2-TCP连接的建立和终止"><a href="#2-TCP连接的建立和终止" class="headerlink" title="2. TCP连接的建立和终止"></a>2. TCP连接的建立和终止</h3><h5 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1. 三次握手"></a>1. 三次握手</h5><!-- ![TCP三次握手](./img/UNIX_network_TCP1.png) -->
<img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/UNIX_network_TCP1.png" class="" title="UNIX_network_TCP1.png">

<p><span id="tcp_connect">Hello World</span></p>
<h5 id="2-四次握手"><a href="#2-四次握手" class="headerlink" title="2. 四次握手"></a>2. 四次握手</h5><!-- ![TCP三次握手](./img/UNIX_network_TCP2.png) -->
<img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/UNIX_network_TCP2.png" class="" title="UNIX_network_TCP2.png">

<h5 id="3-TCP状态转换图"><a href="#3-TCP状态转换图" class="headerlink" title="3. TCP状态转换图"></a>3. TCP状态转换图</h5><!-- ![TCP三次握手](./img/UNIX_network_TCP3.png) -->
<img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/UNIX_network_TCP3.png" class="" title="UNIX_network_TCP3.png">

<h5 id="4-TCP连接的分组交换"><a href="#4-TCP连接的分组交换" class="headerlink" title="4. TCP连接的分组交换"></a>4. TCP连接的分组交换</h5><!-- ![TCP三次握手](./img/UNIX_network_TCP4.png) -->
<img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/UNIX_network_TCP4.png" class="" title="UNIX_network_TCP4.png">
<ul>
<li>图中使用粗箭头表示者两个数据分节，服务器对客户请求的确认是伴随其应答发送的，这种做法成为捎带（piggybacking）,它通常在服务器处理请求并产生应答的时间少于200ms时发生。如果时间过长就会先确认再应答。</li>
</ul>
<h3 id="3-TIME-WAIT状态"><a href="#3-TIME-WAIT状态" class="headerlink" title="3. TIME_WAIT状态"></a>3. TIME_WAIT状态</h3><ol>
<li>停留在这个状态的持续时间是最长分节生命期(maximum segment lifetime,MSL)的两倍，称之为2MSL</li>
<li>TIME_WAIT状态存在的两个理由<ol>
<li>可靠地实现TCP全双工连接的终止</li>
<li>允许老的重复分节在网络中消逝。<ul>
<li>就是万一第一个报文没到目的地，超时了，第二个发出了，然后就有两个同样的报文到达目的地</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="4-RST-非书中内容"><a href="#4-RST-非书中内容" class="headerlink" title="4. RST(非书中内容)"></a>4. RST(非书中内容)</h3><ul>
<li>有三个条件可以产生RST:<ol>
<li>SYN到达某端口但此端口上没有正在监听的服务器。</li>
<li>TCP想取消一个已有连接</li>
<li>TCP接收了一个根本不存在的连接上的分节。</li>
</ol>
</li>
<li>Connect 函数返回错误ECONNREFUSED:<ul>
<li>如果对客户的SYN的响应是RST，则表明该服务器主机在我们指定的端口上没有进程在等待与之连接（例如服务器进程也许没有启动），这称为硬错（hard error），客户一接收到RST，马上就返回错误ECONNREFUSED.</li>
</ul>
</li>
<li>如果杀掉服务器端处理客户端的子进程，进程退出后，关闭它打开的所有文件描述符，此时，当服务器TCP接收到来自此客户端的数据时，由于先前打开的那个套接字接口的进程已终止，所以以RST响应。<ul>
<li>如果不判断read , write函数的返回值，就不知道服务器是否响应了RST, 此时客户端如果向接收了RST的套接口进行写操作时，内核给该进程发一个SIGPIPE信号。此信号的缺省行为就是终止进程，所以，进程必须捕获它以免不情愿地被终止。</li>
<li>进程不论是捕获了该信号并从其信号处理程序返回，还是不理会该信号，写操作都返回EPIPE错误。</li>
</ul>
</li>
<li>服务器主机崩溃后重启<ul>
<li>如果服务器主机与客户端建立连接后崩溃，如果此时，客户端向服务器发送数据，而服务器已经崩溃不能响应客户端ACK，客户TCP将持续重传数据分节，试图从服务器上接收一个ACK;如果服务器一直崩溃客户端会发现服务器已经崩溃或目的地不可达，但可能需要比较长的时间；</li>
<li> 如果服务器在客户端发现崩溃前重启，服务器的TCP丢失了崩溃前的所有连接信息，所以服务器TCP对接收的客户数据分节以RST响应。</li>
</ul>
</li>
</ul>
<h1 id="第3章：套接字编程简介"><a href="#第3章：套接字编程简介" class="headerlink" title="第3章：套接字编程简介"></a>第3章：套接字编程简介</h1><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul>
<li>地址的文本和二进制转换函数<ul>
<li>老的，用于ipv4<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inet_addr()</span><br><span class="line">inet_ntoa()</span><br></pre></td></tr></table></figure></li>
<li>新的，用于ipv4和ipv6<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inet_pton()</span><br><span class="line">inet_ntop()</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="2-套接字地址结构"><a href="#2-套接字地址结构" class="headerlink" title="2. 套接字地址结构"></a>2. 套接字地址结构</h3><h5 id="1-IPv4套接字地址结构"><a href="#1-IPv4套接字地址结构" class="headerlink" title="1. IPv4套接字地址结构"></a>1. IPv4套接字地址结构</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct in_addr&#123;</span><br><span class="line">    in_addr_t s_addr;   &#x2F;&#x2F;32-bit IPv4 address</span><br><span class="line">                        &#x2F;&#x2F; network byte ordered网络字节序</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct sockaddr_in&#123;</span><br><span class="line">    uint8_t     sin_len;    &#x2F;&#x2F;length of sturcture,一般不用管，置0；</span><br><span class="line">    sa_family_t sin_family; &#x2F;&#x2F;AF_INET,表示使用IPv4</span><br><span class="line">    struct in_addr  sin_addr;   &#x2F;&#x2F;网络字节序的IP地址</span><br><span class="line">    char    sin_zero[8];    &#x2F;&#x2F;不用，置0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-通用套接字地址结构"><a href="#2-通用套接字地址结构" class="headerlink" title="2. 通用套接字地址结构"></a>2. 通用套接字地址结构</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct sockaddr&#123;</span><br><span class="line">    uint8_t     sin_len; </span><br><span class="line">    sa_family_t sa_family;</span><br><span class="line">    char    sa_data[14];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这主要是在bind函数中用，解决历史遗留问题<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;bind原型</span><br><span class="line">int bind(int,struct sockaddr*,socklen_t);</span><br><span class="line">&#x2F;&#x2F;bind第二个参数要强制转换类型(struct sockaddr*).</span><br></pre></td></tr></table></figure>
<h5 id="3-IPv6套接字地址结构"><a href="#3-IPv6套接字地址结构" class="headerlink" title="3. IPv6套接字地址结构"></a>3. IPv6套接字地址结构</h5><!-- ![1.IPv6套接字.png](./img/1.IPv6套接字.png) -->
<img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/1.IPv6%E5%A5%97%E6%8E%A5%E5%AD%97.png" class="" title="1.IPv6套接字.png">
<h5 id="4-新的通用套接字地址结构"><a href="#4-新的通用套接字地址结构" class="headerlink" title="4. 新的通用套接字地址结构"></a>4. 新的通用套接字地址结构</h5><!-- ![2.新的通用.png](./img/2.新的通用.png) -->
<img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/2.%E6%96%B0%E7%9A%84%E9%80%9A%E7%94%A8.png" class="" title="2.新的通用.png">
<h5 id="5-几种套接字地址结构比较"><a href="#5-几种套接字地址结构比较" class="headerlink" title="5. 几种套接字地址结构比较"></a>5. 几种套接字地址结构比较</h5></li>
<li>IPv4</li>
<li>IPv6</li>
<li>Unix</li>
<li>数据链路</li>
<li>存储<!-- ![3.套接字比较.png](./img/3.套接字比较.png) -->
<img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/3.%E5%A5%97%E6%8E%A5%E5%AD%97%E6%AF%94%E8%BE%83.png" class="" title="3.套接字比较.png">

</li>
</ul>
<h3 id="3-值-结果参数"><a href="#3-值-结果参数" class="headerlink" title="3. 值-结果参数"></a>3. 值-结果参数</h3><h5 id="1-从进程到内核有3个函数，bind-connect-sendto"><a href="#1-从进程到内核有3个函数，bind-connect-sendto" class="headerlink" title="1. 从进程到内核有3个函数，bind,connect,sendto"></a>1. 从进程到内核有3个函数，bind,connect,sendto</h5><ul>
<li>这些函数要指定套接字结构的整数大小，如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connect(sockfd,(struct sockaddr*)&amp;serv,sizeof(serv));</span><br></pre></td></tr></table></figure></li>
<li>此时的长度为”值”<!-- ![4.进程到内核.png](./img/4.进程到内核.png) -->
<img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/4.%E8%BF%9B%E7%A8%8B%E5%88%B0%E5%86%85%E6%A0%B8.png" class="" title="4.进程到内核.png">

</li>
</ul>
<h5 id="2-从内核到进程有4个函数，accept-recvfrom-getsockname-getpeername"><a href="#2-从内核到进程有4个函数，accept-recvfrom-getsockname-getpeername" class="headerlink" title="2. 从内核到进程有4个函数，accept,recvfrom,getsockname,getpeername"></a>2. 从内核到进程有4个函数，accept,recvfrom,getsockname,getpeername</h5><ul>
<li>也有个参数指定长度</li>
<li>此时的长度为”结果”<!-- ![5.内核到进程.png](./img/5.内核到进程.png) -->
<img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/5.%E5%86%85%E6%A0%B8%E5%88%B0%E8%BF%9B%E7%A8%8B.png" class="" title="5.内核到进程.png">

</li>
</ul>
<h5 id="3-recvmsg-sendmsg"><a href="#3-recvmsg-sendmsg" class="headerlink" title="3. recvmsg,sendmsg"></a>3. recvmsg,sendmsg</h5><ul>
<li>这两个函数的长度不是作为参数，而是作为结构字段传递的。<h5 id="4-其他的值-结果参数"><a href="#4-其他的值-结果参数" class="headerlink" title="4. 其他的值-结果参数"></a>4. 其他的值-结果参数</h5></li>
<li>最常见的就是返回套接字地址结构的长度</li>
<li>其他的值-结果参数<ul>
<li>select的第三个参数</li>
<li>getsockopt的长度参数</li>
<li>ifconf的ifc_len字段</li>
<li>sysctl函数两个长度参数的第一个</li>
<li>recvmsg函数中，msghdr结构中的msg_namelen和msg_controllen字段</li>
</ul>
</li>
</ul>
<h3 id="4-大小端转换"><a href="#4-大小端转换" class="headerlink" title="4. 大小端转换"></a>4. 大小端转换</h3><h5 id="1-大小端"><a href="#1-大小端" class="headerlink" title="1. 大小端"></a>1. 大小端</h5><ul>
<li>小端是高位在高地址，x86用的小端</li>
<li>大端是高位在低地址，网络字节序为大端<h5 id="2-主机字节序"><a href="#2-主机字节序" class="headerlink" title="2. 主机字节序"></a>2. 主机字节序</h5></li>
<li>把某个给定系统所用的字节序称为主机字节序<h5 id="3-转换函数"><a href="#3-转换函数" class="headerlink" title="3. 转换函数"></a>3. 转换函数</h5></li>
<li>头文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;netinet&#x2F;in.h&gt;</span><br></pre></td></tr></table></figure></li>
<li>返回网络字节序<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint16_t htons(uint16_t host16bitvalue);</span><br><span class="line">uint32_t htonl(uint32_t host32bitvalue);</span><br></pre></td></tr></table></figure></li>
<li>返回主机字节序<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint16_t ntohs(uint16_t net16bitvalue);</span><br><span class="line">uint32_t ntohl(uint32_t net32bitvalue);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-字节操纵函数"><a href="#5-字节操纵函数" class="headerlink" title="5. 字节操纵函数"></a>5. 字节操纵函数</h3><ul>
<li>Berkeley函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;strings.h&gt;</span><br><span class="line">void bzero(void* dest,size_t nbytes);</span><br><span class="line">void bcopy(const void* srt,void* dest,size_t nbytes);</span><br><span class="line">int bcmp(const void* ptr1,const void* ptr2,size_t nbytes);  &#x2F;&#x2F;相等返回0,不等返回非0</span><br></pre></td></tr></table></figure></li>
<li>ANSI C函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;string.h&gt;</span><br><span class="line">void* memset(void* dest,int c,size_t len);</span><br><span class="line">void* memcpy(void* dest,const void* src,size_t nbytes); &#x2F;&#x2F;当源字符串和目标字符串有重叠时，bcopy能正确处理，但memcpy结果未知，可以用memmove()</span><br><span class="line">int memcmp(const void* ptr1,const void* ptr2,size_t nbytes);    &#x2F;&#x2F;相等返回0,否则小于返回&lt;0,大于返回＞0</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-inet-aton-inet-addr和inet-ntoa函数"><a href="#6-inet-aton-inet-addr和inet-ntoa函数" class="headerlink" title="6. inet_aton,inet_addr和inet_ntoa函数"></a>6. inet_aton,inet_addr和inet_ntoa函数</h3><ul>
<li>作用：在ASCII字符串与网络字节序的二进制值(这是存放在套接字地址结构中的值)之间转换IP地址，如把”127.0.0.1”转换成32位的二进制值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;arpa&#x2F;inet.h&gt;</span><br><span class="line">int inet_aton(const char* strptr,struct in_addr* addrptr);  &#x2F;&#x2F;将点分十进制转换成二进制地址</span><br><span class="line">in_addr_t inet_addr(const char *strptr);    &#x2F;&#x2F;已弃用，不能解析255.255.255.255</span><br><span class="line">char* inet_ntoa(struct in_addr inaddr); &#x2F;&#x2F;返回一个指向点分十进制的指针</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="7-inet-pton和inet-ntop函数"><a href="#7-inet-pton和inet-ntop函数" class="headerlink" title="7. inet_pton和inet_ntop函数"></a>7. inet_pton和inet_ntop函数</h3><ul>
<li>这两个对于IPv4和IPv6都适用，p为表达式(presentation),n为数值(numeric)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;arpa&#x2F;inet.h&gt;</span><br><span class="line">int inet_pton(int family,const char* strptr,void* addrptr); &#x2F;&#x2F;将strptr所指字符串转换为二进制，存放在addrptr中，成功返回1，若strptr格式不对，返回0</span><br><span class="line">const char* inet_ntop(int family,const void* addrptr,char* strptr,size_t len);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第4章：基本的TCP套接字编程"><a href="#第4章：基本的TCP套接字编程" class="headerlink" title="第4章：基本的TCP套接字编程"></a>第4章：基本的TCP套接字编程</h1><h3 id="1-socket-函数"><a href="#1-socket-函数" class="headerlink" title="1. socket 函数"></a>1. socket 函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;sys&#x2F;socket.h&gt;</span><br><span class="line">int socket(int family,int type,int protocol);</span><br><span class="line">&#x2F;&#x2F;成功返回非负，出错返回-1</span><br></pre></td></tr></table></figure>
<ul>
<li><p>family IP协议簇</p>
<table>
<thead>
<tr>
<th>family</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AF_INET</td>
<td>IPv4协议</td>
</tr>
<tr>
<td>AF_INET6</td>
<td>IPv6协议</td>
</tr>
<tr>
<td>AF_LOCAL</td>
<td>Unix域协议</td>
</tr>
<tr>
<td>AF_ROUTE</td>
<td>路由套接字</td>
</tr>
<tr>
<td>AF_KEY</td>
<td>秘钥套接字</td>
</tr>
</tbody></table>
</li>
<li><p>type 套接字种类</p>
<table>
<thead>
<tr>
<th>type</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SOCK_STREAM</td>
<td>字节流套接字</td>
</tr>
<tr>
<td>SOCK_DGRAM</td>
<td>数据报套接字</td>
</tr>
<tr>
<td>SOCK_SEQPACKET</td>
<td>有序分组套接字</td>
</tr>
<tr>
<td>SOCK_RAM</td>
<td>原始套接字</td>
</tr>
</tbody></table>
</li>
<li><p>protocol 协议种类</p>
<table>
<thead>
<tr>
<th>protocol</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>IPPROTO_CP</td>
<td>TCP传输协议</td>
</tr>
<tr>
<td>IPPROTO_UDP</td>
<td>UDP传输协议</td>
</tr>
<tr>
<td>IPPROTO_SCTP</td>
<td>SCTP传输协议</td>
</tr>
</tbody></table>
</li>
<li><p>socket 返回的非负数和文件描述符类似，称为套接字描述符</p>
</li>
</ul>
<h3 id="2-connect-函数"><a href="#2-connect-函数" class="headerlink" title="2. connect 函数"></a>2. connect 函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;sys&#x2F;socket.h&gt;</span><br><span class="line">int connect(int sockfd,const struct sockaddr* servaddr, socklen_t addrlen);</span><br><span class="line">&#x2F;&#x2F;成功返回0，出错返回-1</span><br></pre></td></tr></table></figure>
<ul>
<li>sockfd 是socket()函数返回的描述符</li>
<li>servaddr 是sockaddr_in地址强转，是要连接的服务器的协议地址</li>
<li>addrlen 是servaddr长度</li>
<li>connect()函数导致当前套接字从CLOSED状态转移到SYN_SENT状态，若成功再转移到ESTABLISHED状态</li>
<li>若connect失败则该套接字不可再用，必须关闭，不能对这样的套接字再次调用connect</li>
</ul>
<h3 id="3-bind-函数"><a href="#3-bind-函数" class="headerlink" title="3. bind 函数"></a>3. bind 函数</h3><ul>
<li>bind 函数把一个本地协议地址(IPv4/IPv6+端口号)赋予一个套接字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;sys&#x2F;socket.h&gt;</span><br><span class="line">int bind(int sockfd,const struct sockaddr* myaddr,socklen_t addrlen);</span><br><span class="line">&#x2F;&#x2F;成功返回0，失败-1</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于myaddr的设置</p>
<ul>
<li>sin_addr设置为通配地址，则内核选择IP地址；指定IP地址，则进程指定IP地址</li>
<li>sin_port设置为0，则内核选择端口；非0，进程指定端口</li>
<li>通配地址通常为 INADDR_ANY, s_addr=htonl(INADDR_ANY);  //IPv6不是这样的，需要时候再搜索吧</li>
</ul>
</li>
<li><p>bind 函数返回的一个常见错误是EADDRINUSE(Address already in use,地址已使用)</p>
</li>
</ul>
<h3 id="4-listen-函数"><a href="#4-listen-函数" class="headerlink" title="4. listen 函数"></a>4. listen 函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;sys&#x2F;socket.h&gt;</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">&#x2F;&#x2F;成功返回0，失败-1</span><br></pre></td></tr></table></figure>

<ul>
<li>listen 仅由TCP服务器调用，它做两件事：<ol>
<li>listen 函数把一个为连接的套接字转换成一个被动套接字，指示内核应接受该套接字的连接请求。调用listen导致套接字从CLOSED状态转换到LISTEN状态。</li>
<li>第二个参数规定内核应该为相应套接字排队的最大连接个数。</li>
</ol>
</li>
<li>对backlog的理解，内核为任何一个给定的监听套接字维护两个队列：<ol>
<li>未完成连接队列，每个这样的SYN分节对应其中一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三次握手过程。这些套接字处于SYN_RCVD状态，</li>
<li>已完成连接队列，每个已完成TCP三次握手过程的客户对应其中一项。这些套接字处于ESTABLISHED状态。</li>
<li>曾经把 backlog 参数规定为这两个队列总和的最大值，Berkeley给backlog增设了一个模糊因子：把它乘以1.5，例如backlog=5，则实际允许最多有8项在排队</li>
</ol>
</li>
</ul>
<h3 id="5-accept-函数"><a href="#5-accept-函数" class="headerlink" title="5. accept 函数"></a>5. accept 函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;sys&#x2F;socket.h&gt;</span><br><span class="line">int accept(int sockfd,struct sockaddr* cliaddr,socklen_t* addrlen);</span><br><span class="line">&#x2F;&#x2F;成功返回非负描述符，失败-1</span><br></pre></td></tr></table></figure>
<ul>
<li>sockfd 为监听套接字，服务器socket()创建的</li>
<li>cliaddr 返回已连接的客户进程的协议地址</li>
<li>addrlen 是一个值-结果函数，调用时为cliaddr大小，返回时是内核存放在该套接字地址结构内的确切字节数</li>
<li>成功返回一个已连接套接字描述符</li>
<li>该函数最多返回三个值：<ol>
<li>已连接套接字</li>
<li>客户协议地址,cliaddr</li>
<li>客户协议地址长度，addrlen</li>
</ol>
<ul>
<li>后两个如果不想要可以置空<h3 id="6-fork-和-exec-函数"><a href="#6-fork-和-exec-函数" class="headerlink" title="6. fork 和 exec 函数"></a>6. fork 和 exec 函数</h3></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">pid_t fork(void);</span><br><span class="line">&#x2F;&#x2F;在子进程中返回0，父进程中返回子进程id，出错返回-1</span><br></pre></td></tr></table></figure>
<ul>
<li>fork的两种典型用法：<ol>
<li>创建一个进程执行子任务</li>
<li>想执行另一个程序，在子进程中执行exec把自身替换成新的程序</li>
</ol>
</li>
<li>exec 6种函数的区别在于：<ol>
<li>待执行的程序文件是由文件名还是路径名指定</li>
<li>新程序的参数是一一列出还是由一个指针数组来引用</li>
<li>把调用进程的环境传递给新程序还是给新程序指定新的环境<!-- ![6.exec1.png](./img/6.exec1.png) -->
<img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/6.exec1.png" class="" title="6.exec1.png">
<!-- ![7.exec2.png](./img/7.exec2.png) -->
<img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/7.exec2.png" class="" title="7.exec2.png">
<!-- ![8.6个exec.png](./img/8.6个exec.png) -->
<img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/8.6%E4%B8%AAexec.png" class="" title="8.6个exec.png">

</li>
</ol>
</li>
</ul>
<h3 id="7-并发服务器"><a href="#7-并发服务器" class="headerlink" title="7. 并发服务器"></a>7. 并发服务器</h3><ul>
<li>就是创建子进程来处理连接请求</li>
<li>子进程要关闭父进程的socketid,父进程要关闭子进程中的sockedid,也就是accept()返回的id</li>
<li>为什么close后没有关闭连接？<ul>
<li>因为每个文件或套接字都有一个引用计数，是打开的个数，close后个数-1，只要个数不为0，资源就不会释放<h3 id="8-close-函数"><a href="#8-close-函数" class="headerlink" title="8. close 函数"></a>8. close 函数</h3></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int close(int sockfd);</span><br><span class="line">&#x2F;&#x2F;成功返回0，失败-1</span><br></pre></td></tr></table></figure>
<ul>
<li><p>close 默认行为是把套接字标记为已关闭，不能在对其read/write，然而TCP将尝试发送已排队等待发送到对端的任何数据，发送完成后发生的是正常的TCP连接。（就是服务器端收到FIN,发了ACK，再发送已经准备好发送的数据，再发送FIN,客户端再回应ACK，完成四次握手）</p>
</li>
<li><p>close 实际上不一定发送FIN，只是引用数-1，若到0后才发送FIN</p>
</li>
<li><p>如果想发送FIN，可以用shutdown函数代替close</p>
</li>
<li><p>如果父进程中不调用close关闭accept返回的套接字，最后会耗尽可用描述符，而且没有一个客户连接会终止，因为在子进程中调用close也只是把连接引用数-1.</p>
<h3 id="9-getsockname-和-getpeername-函数"><a href="#9-getsockname-和-getpeername-函数" class="headerlink" title="9. getsockname 和 getpeername 函数"></a>9. getsockname 和 getpeername 函数</h3></li>
<li><p>前者返回与某个套接字关联的本地协议地址，后者返回与某个套接字关联的外地协议地址</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;sys&#x2F;socket.h&gt;</span><br><span class="line">int getsockname(int sockfd,struct sockaddr* localaddr,socklen_t* addrlen);</span><br><span class="line">int getsockname(int sockfd,struct sockaddr* peeraddr,socklen_t* addrlen);</span><br><span class="line">&#x2F;&#x2F;成功返回0，失败-1</span><br></pre></td></tr></table></figure>
<ul>
<li>最后一个参数是值-结果参数</li>
<li>函数名中的 name 可能让人误解，和域名没有任何练习，就是IP地址和端口的组合</li>
<li>不知道套接字地址结构的类型，可以用sockaddr_storage类型的结构传入localaddr变量，它能承载系统支持的任何套接字结构</li>
<li>可以在客户端调用获得当前连接的服务器的协议地址信息</li>
<li>服务端可以通过它获得客户端的协议地址信息</li>
</ul>
<h3 id="10-小结"><a href="#10-小结" class="headerlink" title="10. 小结"></a>10. 小结</h3><ul>
<li>服务器<ol>
<li>socket()</li>
<li>bind()</li>
<li>listen()</li>
<li>accept()</li>
</ol>
</li>
<li>客户端<ol>
<li>socket()</li>
<li>connect()</li>
</ol>
</li>
<li>大多数TCP服务器是并发的，UDP服务器是迭代的</li>
</ul>
<h1 id="第5章：TCP客户-服务器程序示例"><a href="#第5章：TCP客户-服务器程序示例" class="headerlink" title="第5章：TCP客户/服务器程序示例"></a>第5章：TCP客户/服务器程序示例</h1><h3 id="1-简单服务器"><a href="#1-简单服务器" class="headerlink" title="1. 简单服务器"></a>1. 简单服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;arpa&#x2F;inet.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;signal.h&gt;</span><br><span class="line">#include&lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line"></span><br><span class="line">#define SERV_PORT 9999</span><br><span class="line">#define BUFFSIZE 1024</span><br><span class="line"></span><br><span class="line">void wait_child(int signo)&#123;</span><br><span class="line">    while(waitpid(0,NULL,WNOHANG)&gt;0);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void do_something(int client_fd)&#123;</span><br><span class="line">    char buf[1024];</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        int n&#x3D;read(client_fd,buf,sizeof(buf));</span><br><span class="line">        if(n&#x3D;&#x3D;0)&#123;</span><br><span class="line">            close(client_fd);</span><br><span class="line">            return;</span><br><span class="line">        &#125;else if(n&#x3D;&#x3D;-1)&#123;</span><br><span class="line">            perror(&quot;n&#x3D;&#x3D;-1\n&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;recive: %s\n&quot;,buf);</span><br><span class="line">            for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">                buf[i]&#x3D;toupper(buf[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            write(client_fd,buf,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int listen_fd,client_fd;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    char buf[BUFFSIZE];</span><br><span class="line">    struct sockaddr_in serv_addr,clie_addr;</span><br><span class="line">    listen_fd&#x3D;socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line"></span><br><span class="line">    memset(&amp;serv_addr,0,sizeof(serv_addr));</span><br><span class="line">    serv_addr.sin_family&#x3D;AF_INET;</span><br><span class="line">    serv_addr.sin_port&#x3D;htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);</span><br><span class="line">    &#x2F;&#x2F; inet_pton(AF_INET,&quot;127.0.0.1&quot;,&amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">    bind(listen_fd,(struct sockaddr*) &amp;serv_addr,sizeof(serv_addr));</span><br><span class="line"></span><br><span class="line">    listen(listen_fd,128);    &#x2F;&#x2F;允许最多有128个连接，操作系统允许最大为128</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;父进程不断创建子进程，建立连接</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        int len&#x3D;sizeof(clie_addr);</span><br><span class="line">        client_fd&#x3D;accept(listen_fd,(struct sockaddr*)&amp;clie_addr,&amp;len);</span><br><span class="line">        printf(&quot;a chile connected\n&quot;);</span><br><span class="line">        pid&#x3D;fork();</span><br><span class="line">        if(pid&lt;0)&#123;</span><br><span class="line">            perror(&quot;fork error&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;else if(pid&#x3D;&#x3D;0)&#123;</span><br><span class="line">            close(listen_fd);</span><br><span class="line">            do_something(client_fd);</span><br><span class="line">            break;&#x2F;&#x2F;子进程跳出循环，执行子进程代码</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            close(client_fd);</span><br><span class="line">            signal(SIGCHLD,wait_child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-简单客户端"><a href="#2-简单客户端" class="headerlink" title="2. 简单客户端"></a>2. 简单客户端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys&#x2F;socket.h&gt;</span><br><span class="line">#include&lt;arpa&#x2F;inet.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in s;</span><br><span class="line"></span><br><span class="line">    memset(&amp;s,0,sizeof(s));</span><br><span class="line">    s.sin_family&#x3D;AF_INET;</span><br><span class="line">    s.sin_addr.s_addr&#x3D;inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">    s.sin_port&#x3D;htons(9999);</span><br><span class="line"></span><br><span class="line">    int sock_id&#x3D;socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line"></span><br><span class="line">    connect(sock_id,(struct sockaddr*)&amp;s,sizeof(s));</span><br><span class="line"></span><br><span class="line">    char buf[1024]&#x3D;&#123;0&#125;;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,buf);</span><br><span class="line">        write(sock_id,buf,1024);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以用telnet<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 127.0.0.1 9999</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-处理sigchld信号"><a href="#3-处理sigchld信号" class="headerlink" title="3. 处理sigchld信号"></a>3. 处理sigchld信号</h3><ol>
<li>当fork子进程时，必须捕获SIGCHLD信号。</li>
<li>SIGCHLD的信号处理函数必须正确编写，应使用waitpid以免留下僵死进程</li>
<li>也可以用signal(SIGCHLD,SIG_IGN); 交给系统init去回收。<ul>
<li>注意signal设置的信号句柄只能起一次作用，信号被捕获一次后，信号句柄就会被还原成默认值了。</li>
<li>sigaction设置的信号句柄，可以一直有效，直到你再次改变它的设置。</li>
</ul>
</li>
</ol>
<h3 id="4-accept返回前连接中止"><a href="#4-accept返回前连接中止" class="headerlink" title="4. accept返回前连接中止"></a>4. accept返回前连接中止</h3><ul>
<li><p>accept()调用时机<br>  <a href="#tcp_connect">TCP三次握手</a></p>
</li>
<li><p>这种情况accept返回一个非致命错误，在这种情况下，只需要再次调用accept就行了。下图在较忙的服务器(典型的是较忙的Web服务器)上出现过</p>
<!-- ![客户端发送RST](./img/UNIX_network_TCP5.png) -->
<img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/UNIX_network_TCP5.png" class="" title="UNIX_network_TCP5.png"></li>
<li><p>客户端发送一个RST，在服务器端看来，就在该连接已由TCP排队，等着服务器进程调用accept的时候RST到达。稍后，服务器进程调用accept</p>
</li>
<li><p>不幸的是，如何处理这种已终止的连接是与实现相关的。继承自Berkeley的实现完全由内核来处理已终止连接，服务器进程永远看不到它。然而，大部分的SVR4实现，在accept返回时返回一个错误给进程，而返回的错误又是依赖于实现的。这些SVR4实现返回值为EPROTO的errno（“protocol error”），但是POSIX指定在这种情况必须返回ECONNABORTED(“Software caused connection abort”)。POSIX这样规定是考虑到，当流子系统中一些致命的协议相关的事件发生时，同样会返回EPROTO。为client已建立连接的非致命终止返回相同的错误，可以让server知道是否应该再次调用accept。在出现ECONABORTED错误的情况下，server可以忽略该错误而继续调用accept等待连接。</p>
</li>
<li><p>在Berkeley-derived实现</p>
<ul>
<li>  继承自Berkeley的内核实现不会把该错误传递到用户进程。所涉及的步骤如下：处理RST，导致tcp_close被调用。这个函数先调用in_pcbdetach ，接着调用sofree，然后发现这个已被终止的socket仍然在监听套接字连接完成队列中（连接就绪，等待accept返回给进程），就把该socket删除并且释放相应的资源。当server抽出时间调用accept时，它重来不知道一个已经就绪的连接被从队列中删除了</li>
</ul>
</li>
<li><p>在Linux系统中</p>
<ul>
<li>此时服务端的accept并不知道这条完成“三次握手”的未决连接已经从未决连接队列中删除掉了，所以accept调用最后会返回成功。不过当服务器收到RST时，如果阻塞在read调用，会返回了一个ECONNRESET 错误,如果客户端调用了close(sockfd)，read返回0，表示对方关闭连接</li>
</ul>
</li>
</ul>
<h3 id="5-服务器进程中止"><a href="#5-服务器进程中止" class="headerlink" title="5. 服务器进程中止"></a>5. 服务器进程中止</h3><ul>
<li>直接杀死服务器进程</li>
<li>服务器进程崩溃和服务器主机崩溃不一样，步骤如下：<ol>
<li>服务器子进程中所有打开的描述符都被关闭。向客户发送FIN,客户端相应一个ACK(这是TCP关闭连接的前半部分)</li>
<li>SIGCHLD信号被发送给服务器父进程，并得到正确处理</li>
<li>客户端接受来自服务器的FIN并相应一个ACK,然而客户进程阻塞在fgets调用上，等待从终端接受一行文本,此时服务器进程处于CLOSE_WAIT状态，客户端处于FIN_WAIT2状态</li>
<li>当在客户端输入一行文本，即满足fgets调用，客户端接着把输入的文本发送给服务器</li>
<li>当服务器TCP接收到来自客户的数据时，先前的那个套接字进程已经终止，于是相应一个RST。</li>
<li>writen后调用readline,根据时序此时有两种可能<ul>
<li>若服务器响应的RST先到达，readline返回一个ECONNRESET错误</li>
<li>若readline先执行，客户端得到一个未预期的EOF,立刻返回0</li>
</ul>
</li>
</ol>
</li>
<li>简单理解就是客户端继续往服务器发数据时会收到RST响应，从而自身出错返回，关闭所有描述符。</li>
<li>本例子的问题在于：当FIN到达套接字时，客户正阻塞在fgets调用上。客户实际上在应对两个描述符–套接字和用户输入，它不能单纯阻塞在这两个源中某个特定源的输入上，而是应该阻塞在其中任何一个源的输入上。这正是select和poll这两个函数的目的之一。一旦杀死服务器子进程，客户会立刻被告知已经收到FIN.</li>
</ul>
<h3 id="6-sigpipe信号"><a href="#6-sigpipe信号" class="headerlink" title="6. sigpipe信号"></a>6. sigpipe信号</h3><ul>
<li>当服务器close一个连接时，若client端接着发数据。根据TCP协议的规定，会收到一个RST响应，client再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，告诉进程这个连接已经断开了，不要再写了。</li>
<li>又或者当一个进程向某个已经收到RST的socket执行写操作是，内核向该进程发送一个SIGPIPE信号。该信号的缺省学位是终止进程，因此进程必须捕获它以免不情愿的被终止。(如服务器崩溃重启就会已经接收的数据分节发送RST相应，而不是ACK)</li>
<li>我理解就是发送信息到一个没有连接的socket上时就会收到SIGPIPE信号</li>
<li>根据信号的默认处理规则SIGPIPE信号的默认执行动作是terminate(终止、退出),所以client会退出。若不想客户端退出可以把 SIGPIPE设为SIG_IGN</li>
</ul>
<h3 id="7-服务器主机崩溃"><a href="#7-服务器主机崩溃" class="headerlink" title="7. 服务器主机崩溃"></a>7. 服务器主机崩溃</h3><ul>
<li>服务器一直没有应答，即没有ACK,客户端就会不断重传，等一段时间才放弃重传（Berkeley的实现约等待9分钟）</li>
<li>如果客户端最后放弃重传（服务器没有重启），不同的调用有不同的返回<ul>
<li>如果阻塞在readline(),则该调用返回一个错误：ETIMEOUT</li>
<li>若中间某个路由器判定服务器主机已不可达，相应一个destination unreachable(目的地不可达)ICMP报文，那么返回的错误是EHOSTUNREACH或ENETUNREACH</li>
</ul>
</li>
<li>等待的时间过长，可以在readliine调用设置一个超时</li>
<li>以上只有客户端向服务器发送数据时才能检测出服务器主机的崩溃，若想不主动向它发送数据也想检测出服务器的崩溃，可以采用SO_KEEPALLIVE套接字选项。</li>
</ul>
<h3 id="8-服务器主机崩溃后重启"><a href="#8-服务器主机崩溃后重启" class="headerlink" title="8. 服务器主机崩溃后重启"></a>8. 服务器主机崩溃后重启</h3><ul>
<li>在重启后，它的TCP丢失了崩溃前的所有连接信息，因此服务器TCP对于所受到的来自客户的数据分节响应一个RST</li>
<li>当客户TCP收到该RST时，再发送数据就会收到SIGPIPE信号，若阻塞于readline调用，该调用会返回ECONNRESET错误</li>
</ul>
<h3 id="9-服务器主机关机"><a href="#9-服务器主机关机" class="headerlink" title="9. 服务器主机关机"></a>9. 服务器主机关机</h3><ul>
<li>Unix系统关机时，init进程通常先给所有进程发送SIGTERM信号(该信号可以捕捉)，等待一段固定时间(通常5-20s),然后给所有仍在运行的进程发送sigkill信号(不能被捕捉，还有一个是sigstop)。所没有SIGTERM就直接SIGKILL</li>
</ul>
<h3 id="10-数据格式"><a href="#10-数据格式" class="headerlink" title="10. 数据格式"></a>10. 数据格式</h3><ul>
<li>客户和服务器之间进行交换的数据要有特定格式，可以解析数据信息</li>
<li>可以把数据封装在结构体中</li>
<li>存在的问题：<ol>
<li>不同的实现以不同的格式存储二进制数。最常见的格式就是大端字节序和小端字节序</li>
<li>不同的系统实现（如32位和64位）存储相同的C数据类型可能存在差异</li>
<li>不同的实现给结构打包的方式存在差异，对齐方式等可能不同</li>
</ol>
<ul>
<li>综上，传送二进制结构（如结构体）不是明智选择</li>
</ul>
</li>
<li>解决办法：<ol>
<li>把所有数值数据作为文本串来传递，假设客户和服务器主机具有相同的字符集</li>
<li>显式定义所支持数据类型的二进制格式（位数，大小端），远程过程调用（Remote Procedure Call,RPC，第三方的客户程序通过接口调用SAP内部的标准或自定义函数，获得函数返回的数据进行处理后显示或打印。）软件包通常使用这种技术。</li>
</ol>
</li>
</ul>
<h1 id="第六章：IO复用：select和poll函数"><a href="#第六章：IO复用：select和poll函数" class="headerlink" title="第六章：IO复用：select和poll函数"></a>第六章：IO复用：select和poll函数</h1><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul>
<li><p>在上一章CS模型中，若服务器断开连接，发送FIN，但此时客户端阻塞在read读取数据，需要读取完后才能处理服务器发来的FIN，这时候就需要用IO复用</p>
</li>
<li><p>IO复用使用的典型的网络应用场合</p>
<ol>
<li>当客户处理多个描述符(通常是交互式输入和网络套接字)时，必须使用IO复用</li>
<li>一个客户同时处理多个套接字是可能的，不过比较少见。在16章中有一个Web客户使用select</li>
<li>如果一个TCP服务器既要处理监听套接字，又要处理已连接套接字，一般就要使用IO复用(本章后面有例子)</li>
<li>如果一个服务器既要处理TCP，又要处理UDP，一般就要使用IO复用。(第八章有个例子)</li>
<li>如果一个服务器要处理多个服务或者多个协议(第十三章的inetd守护进程)</li>
</ol>
</li>
<li><p>IO复用并非只限于网络编程，许多重要的应用程序也需要使用这项技术。</p>
</li>
</ul>
<h3 id="2-IO模型"><a href="#2-IO模型" class="headerlink" title="2. IO模型"></a>2. IO模型</h3><ul>
<li>UNIX下可用的5种IO模型<ol>
<li>阻塞式IO</li>
<li>非阻塞式IO</li>
<li>IO复用(select和poll)</li>
<li>信号驱动式IO(SIGIO)</li>
<li>异步IO(POSIX的aio_系列函数)</li>
</ol>
</li>
<li>一个输入操作通常包括两个不同的阶段<ol>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ol>
<ul>
<li>对于一个套接字上的输入操作，第一步通常设计等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</li>
</ul>
</li>
</ul>
<ol>
<li><p>阻塞式IO模型</p>
<ul>
<li>默认情况下，所有套接字都是阻塞的。</li>
<li>进程调用recvfrom，其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回，最常见的错误是信号中断。<!-- ![阻塞IO](./img/阻塞IO.png) -->
<img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/%E9%98%BB%E5%A1%9EIO.png" class="" title="阻塞IO.png"></li>
<li>recvfrom成功返回后，应用进程才继续向下执行</li>
</ul>
</li>
<li><p>非阻塞式IO模型</p>
 <!-- ![非阻塞IO](./img/非阻塞IO.png) -->
 <img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.png" class="" title="非阻塞IO.png">
<ul>
<li>前三次调用recvfrom时没有数据可返回，因此内核立即返回一个EWOULDBLOCK错误</li>
<li>当一个进程向这样对一个非阻塞描述符循环调用recvfrom时，我们称之为轮询(polling)。这么做往往耗费大量CPU时间</li>
<li>这种模型偶尔也会遇到，通常在专门提供某一种功能的系统中才有</li>
</ul>
</li>
<li><p>IO复用模型</p>
 <!-- ![IO复用](./img/IO复用.png) -->
 <img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/IO%E5%A4%8D%E7%94%A8.png" class="" title="IO复用.png">

<ul>
<li>有了IO复用，就可以调用select或poll，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的IO系统调用上。</li>
<li>阻塞在select调用，等待数据报套接字变为可读</li>
<li>与IO复用密切相关的另一种IO模型是在多线程中使用阻塞式IO</li>
</ul>
</li>
<li><p>信号驱动式IO模型</p>
 <!-- ![信号驱动IO](./img/信号驱动IO.png) -->
 <img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO.png" class="" title="信号驱动IO.png">

<ul>
<li>首先开启套接字的信号驱动式IO功能，并通过sigaction系统调用安装一个信号处理函数</li>
<li>当数据报准备好读取时，内核就为该进程产生一个SIGIO信号，随后可以在信号处理函数中调用recvfrom</li>
</ul>
</li>
<li><p>异步IO模型</p>
 <!-- ![异步IO](./img/异步IO.png) -->
 <img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/%E5%BC%82%E6%AD%A5IO.png" class="" title="异步IO.png">
<ul>
<li>工作机制<ul>
<li>告知内核启动某个操作，并让内核在整个操作(包括将数据从内核复制到我们自己的缓冲区)完成后通知我们</li>
</ul>
</li>
<li>与信号驱动式IO的区别<ul>
<li>信号驱动式IO是由内核告诉我们何时可以启动一个IO操作</li>
<li>异步IO是由内核通知我们IO操作何时完成</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>各种IO模型比较  <!-- ![IO比较](./img/IO模型比较.png) -->
  <img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/IO%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83.png" class="" title="IO模型比较.png">
<ul>
<li>POSIX术语定义<ul>
<li>同步IO操作，导致请求进程阻塞，知道IO操作完成</li>
<li>异步IO操作，不导致请求进程阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-select函数"><a href="#3-select函数" class="headerlink" title="3. select函数"></a>3. select函数</h3><ul>
<li>该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或者经历一段指定的时间后才唤醒它。</li>
<li>例如，我们可以调用select，告知内核仅在下列情况发生时才返回<ul>
<li>集合{1,4,5}中的任何描述符准备好读</li>
<li>已经历了10.2秒</li>
</ul>
</li>
<li>不仅是套接字，任何描述符都可以使用select来测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;sys&#x2F;select.h&gt;</span><br><span class="line">#include&lt;sys&#x2F;time.h&gt;</span><br><span class="line"></span><br><span class="line">int select(int maxfdpl,fd_set* readset,fd_set* writeset,fd_set* exceptset,const struct timeval* timeout);</span><br><span class="line">    &#x2F;&#x2F;若有就绪描述符就返回其数目，若超时则为0，出错为-1</span><br></pre></td></tr></table></figure>

<h5 id="1-参数介绍"><a href="#1-参数介绍" class="headerlink" title="1. 参数介绍"></a>1. 参数介绍</h5><ol>
<li><p>timeout</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct timeval&#123;</span><br><span class="line">    long tv_sec;    &#x2F;&#x2F;秒</span><br><span class="line">    long tv_usec;   &#x2F;&#x2F;毫秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个参数有三种可能：<ol>
<li>永远等待下去：仅在有一个描述符准备好IO时返回。把该参数设置为NULL</li>
<li>等待一段固定时间：在有一个描述符准备好IO时返回，但是不超过指定的时间</li>
<li>不等待：检查描述符后立即返回，这称为轮询(polling)。定时器的值设置为0</li>
</ol>
</li>
<li>前两种情形的等待通常会被进程在等待期间捕获的信号中断，并从信号处理函数返回<ul>
<li>源自Berkeley的内核不允许自动重启被中断的select</li>
<li>SVR4可以自动重启被中断的select,在安装信号处理函数时指定SA_RESTART标志</li>
</ul>
</li>
</ul>
</li>
<li><p>中间的三个参数指定让内核测试的读写和异常条件的描述符</p>
<ul>
<li>目前支持的异常条件只有两个：<ol>
<li>某个套接字的带外数据的到达</li>
<li>某个已置为分组模式的伪终端存在可从其主端读取的控制状态信息</li>
</ol>
</li>
<li>用以下四个宏操作fd_set集合<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void FD_ZERO(fd_set* fdset);    &#x2F;&#x2F;clear all</span><br><span class="line">void FD_SET(int fd,fd_set* fdset);    &#x2F;&#x2F;add fd in fdset</span><br><span class="line">void FD_CLR(int fd,fd_set* fdset);    &#x2F;&#x2F;delete fd</span><br><span class="line">void FD_ISSET(int fd,fd_set* fdset);    &#x2F;&#x2F;Does fd exist in fdset?</span><br></pre></td></tr></table></figure></li>
<li>如果对这三个的某个不感兴趣，可以置为NULL,若三个都为NULL,可以当毫秒级定时器用。。。</li>
<li>这三个是值-结果参数，该函数返回后，结果将指示哪些描述符已就绪</li>
<li>重新调用select函数时，都得再次把所有描述符集内所关心的位均置为1</li>
</ul>
</li>
<li><p>maxfdpl指定待测试的描述符个数，它的值是待测试的最大描述符+1(描述符是从0开始的。所以个数要+1)</p>
<ul>
<li>这个并不是fdset集合描述符的个数，比如maxfdpl=5,它就会测试0，1，2，3，4</li>
</ul>
</li>
</ol>
<h5 id="2-描述符就绪条件"><a href="#2-描述符就绪条件" class="headerlink" title="2. 描述符就绪条件"></a>2. 描述符就绪条件</h5><ul>
<li>满足下列条件之一，一个套接字准备好读<ol>
<li>该套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小。可以用SO_RCVLOWAT套接字选项设置该套接字的低水位标记。对于TCP和UDP套接字其默认值为1.</li>
<li>该连接的读半部关闭(也就是接收了FIN的TCP连接)</li>
<li>该套接字是一个监听套接字且已完成的连接数不为0.</li>
<li>其上有一个套接字错误待处理。返回-1，也就是返回一个错误，同时把errno设置成确切的错误条件。</li>
</ol>
</li>
<li>满足下列条件之一，一个套接字准备好写<ol>
<li>该套接字发送缓冲区中的数据字节数大于等于套接字发送缓冲区低水位标记的当前大小，并且该套接字已连接，或者该套接字不需要连接(UDP)。对于TCP和UDP而言，其默认值通常为2048</li>
<li>该连接的写半部关闭。对于这样的套接字的写操作将产生SIGPIPE信号。</li>
<li>使用非阻塞式connect的套接字已建立连接，或者connect已经以失败告终。</li>
<li>其上有一个套接字错误待处理。返回-1，也就是返回一个错误，同时把errno设置成确切的错误条件。</li>
</ol>
</li>
</ul>
<h5 id="3-select的最大描述符数"><a href="#3-select的最大描述符数" class="headerlink" title="3. select的最大描述符数"></a>3. select的最大描述符数</h5><ul>
<li>多路复用函数select采用描述符集表示处理的描述符。描述符集的大小就是它所能处理的最大描述符限制。通常情况下该值为1024，等同于每个进程所能打开的描述符个数。</li>
<li>增大描述符集大小的唯一方法是先增大FD_SETSIZE的值，然后重新编译内核，不重新编译内核而改变其值是不够的。</li>
</ul>
<h3 id="5-批量输入"><a href="#5-批量输入" class="headerlink" title="5. 批量输入"></a>5. 批量输入</h3><h3 id="6-shutdown函数"><a href="#6-shutdown函数" class="headerlink" title="6. shutdown函数"></a>6. shutdown函数</h3><ul>
<li>终止网络连接的通常方法是调用close函数，不过close有两个限制，却可以使用shutdown来避免<ol>
<li>close把描述符的引用计数-1，仅在该计数变为0时才关闭套接字，使用shutdown可以不管引用计数就激发TCP的正常连接终止序列</li>
<li>close终止读和写两个方向的数据传送。既然TCP连接是全双工的，有时候我们需要告知对端我们已经完成了数据发送。即使对端仍有数据要发送给我们。<!-- ![调用shutdown](./img/调用shutdown.png) -->
<img src="/%E3%80%8AUnix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B/%E8%B0%83%E7%94%A8shutdown.png" class="" title="调用shutdown.png">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;sys&#x2F;socket.h&gt;</span><br><span class="line">int shutdown(int sockfd,int howto)</span><br><span class="line">    &#x2F;&#x2F; 成功返回0，出错返回-1</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>该函数的行为取决于howto参数<ul>
<li>SHUTS_RD:关闭连接的读这一半</li>
<li>SHUTS_WR:关闭连接的写这一半</li>
<li>SHUTS_RDWR:关闭连接的读写</li>
</ul>
</li>
</ul>
<h3 id="9-pselect函数"><a href="#9-pselect函数" class="headerlink" title="9. pselect函数"></a>9. pselect函数</h3><h3 id="10-poll函数"><a href="#10-poll函数" class="headerlink" title="10. poll函数"></a>10. poll函数</h3><ul>
<li>poll提供的功能与select类似，不过在处理流设备时，它能够提供额外的信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;poll.h&gt;</span><br><span class="line">int poll(struct pollfd *fdarray,unsigned long nfds,int timeout);</span><br><span class="line">    &#x2F;&#x2F; 若有就绪描述符则返回其数目，超时返回0，出错返回-1</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>《图解HTTP》</title>
    <url>/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第1章：了解Web及网络基础"><a href="#第1章：了解Web及网络基础" class="headerlink" title="第1章：了解Web及网络基础"></a>第1章：了解Web及网络基础</h1><h3 id="1-HTTP"><a href="#1-HTTP" class="headerlink" title="1. HTTP"></a>1. HTTP</h3><ul>
<li>HTTP/0.9: HTTP于1990年问世</li>
<li>HTTP/1.0: 在1996年5月正式作为标准被公布，称为1.0版本,至今仍被广泛使用</li>
<li>HTTP/1.1: 1997年1月公布，之后又有修订</li>
<li>HTTP/2.0: 正在制定完善中</li>
</ul>
<h3 id="2-TCP-IP-DNS"><a href="#2-TCP-IP-DNS" class="headerlink" title="2. TCP/IP/DNS"></a>2. TCP/IP/DNS</h3><a id="more"></a>
<ul>
<li>TCP: 负责可靠传输</li>
<li>IP: 负责传输</li>
<li>DNS: 负责域名解析（应用层）</li>
</ul>
<h3 id="3-URI-URL"><a href="#3-URI-URL" class="headerlink" title="3. URI/URL"></a>3. URI/URL</h3><ul>
<li>URI: 统一资源标识符，标识某一互联网资源</li>
<li>URL: 统一资源定位符，标识资源的地点，URL是URI的子集<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;URI例子</span><br><span class="line">ftp:&#x2F;&#x2F;ftp.is.co.za&#x2F;rfc&#x2F;rfc1808.txt</span><br><span class="line">http:&#x2F;&#x2F;www.ietf.org&#x2F;rfc&#x2F;rfc2396.txt</span><br><span class="line">ldap:&#x2F;&#x2F;[2001:db8::7]&#x2F;c&#x3D;GB?objectClass?one</span><br><span class="line">mailto:John.Doe@example.com</span><br><span class="line">news:comp.infosystems.www.servers.unix</span><br><span class="line">tel:+1-816-555-1212</span><br><span class="line">telnet:&#x2F;&#x2F;192.0.2.16:80&#x2F;</span><br><span class="line">urn:oasis:names:specification:docbook:dtd:xml:4.1.2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-RFC"><a href="#4-RFC" class="headerlink" title="4. RFC"></a>4. RFC</h3><ul>
<li>有一些用来制定 HTTP 协议技术标准的文档,它们被称为RFC(Request for Comments,征求修正意见书)。</li>
<li>通常,应用程序会遵照由 RFC 确定的标准实现。但是也有些不遵守。</li>
</ul>
<h1 id="第2章：简单的HTTP协议"><a href="#第2章：简单的HTTP协议" class="headerlink" title="第2章：简单的HTTP协议"></a>第2章：简单的HTTP协议</h1><h3 id="1-请求头与响应头"><a href="#1-请求头与响应头" class="headerlink" title="1. 请求头与响应头"></a>1. 请求头与响应头</h3><ul>
<li>请求头<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法 URI 协议版本</span><br><span class="line">请求首部字段（可选）</span><br><span class="line">\r\n</span><br><span class="line">内容实体</span><br></pre></td></tr></table></figure></li>
<li>响应头<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">协议版本 状态码 状态码的原因短语</span><br><span class="line">响应首部字段（可选）</span><br><span class="line">\r\n</span><br><span class="line">内容主体</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-HTTP是不保存状态的协议"><a href="#2-HTTP是不保存状态的协议" class="headerlink" title="2. HTTP是不保存状态的协议"></a>2. HTTP是不保存状态的协议</h3><ul>
<li>也就是说，在HTTP这个级别，协议对于发送过的请求和相应都不做持久化处理</li>
<li>但是有些需要保持登录状态的网站，需要保存用户的状态</li>
<li>HTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。Cookie在后面详解</li>
</ul>
<h3 id="3-HTTP方法"><a href="#3-HTTP方法" class="headerlink" title="3. HTTP方法"></a>3. HTTP方法</h3><ul>
<li><p>总览</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>支持的 HTTP 协议版本</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取资源</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>POST</td>
<td>传输实体主体</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>PUT</td>
<td>传输文件</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>HEAD</td>
<td>获得报文首部</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除文件</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>询问支持的方法</td>
<td>1.1</td>
</tr>
<tr>
<td>TRACE</td>
<td>追踪路径</td>
<td>1.1</td>
</tr>
<tr>
<td>CONNECT</td>
<td>要求用隧道协议连接代理</td>
<td>1.1</td>
</tr>
<tr>
<td>LINK</td>
<td>建立和资源之间的联系</td>
<td>1.0</td>
</tr>
<tr>
<td>UNLINE</td>
<td>断开连接关系</td>
<td>1.0</td>
</tr>
</tbody></table>
</li>
<li><p>GET</p>
<ul>
<li>请求<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回 index.html 的页面资源</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>POST</p>
<ul>
<li>请求 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;submit.cgi HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br><span class="line">Content-Length: 1560(1560字节的数据)</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回 submit.cgi 接收数据的处理结果</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>PUT</p>
<ul>
<li>PUT 方法用来传输文件。就像 FTP 协议的文件上传一样,要求在请<br>求报文的主体中包含文件内容,然后保存到请求 URI 指定的位置。但是,鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制,任何人都可以上传文件 , 存在安全性问题,因此一般的 Web 网站不使用该方法。若配合 Web 应用程序的验证机制,或架构设计采用REST(REpresentational State Transfer,表征状态转移)标准的同类Web 网站,就可能会开放使用 PUT 方法。</li>
<li>请求 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;example.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Content-Length: 1560(1560 字节的数据)</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">响应返回状态码 204 No Content(比如 :该 html 已存在于服务器上)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>HEAD</p>
<ul>
<li>HEAD 方法和 GET 方法一样,只是不返回报文主体部分。用于确认URI 的有效性及资源更新的日期时间等。</li>
<li>请求 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEAD &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回index.html有关的响应首部</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>DELETE</p>
<ul>
<li>DELETE 方法用来删除文件,是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。但是,HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制,所以一般的 Web 网站也不使用 DELETE 方法。</li>
<li>请求 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE &#x2F;example.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">响应返回状态码 204 No Content(比如 :该 html 已从该服务器上删除)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>OPTIONS</p>
<ul>
<li>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</li>
<li>请求 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPTIONS * HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Allow: GET, POST, HEAD, OPTIONS(返回服务器支持的方法)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>TRACE</p>
<ul>
<li>TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。</li>
<li>客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为,请求想要连接到源目标服务器可能会通过代理中转,TRACE 方法就是用来确认连接过程中发生的一系列操作。</li>
<li>请求<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRACE &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Max-Forwards: 2</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: message&#x2F;http</span><br></pre></td></tr></table></figure></li>
<li>响应<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Length: 1024</span><br><span class="line">TRACE &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Max-Forwards: 2(返回响应包含请求内容)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>CONNECT</p>
<ul>
<li>CONNECT 方法要求在与代理服务器通信时建立隧道,实现用隧道协议进行 TCP 通信。主要使用 SSL(Secure Sockets Layer,安全套接层)和 TLS(Transport Layer Security,传输层安全)协议把通信内容加密后经网络隧道传输。</li>
<li>请求<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONNECT proxy.hackr.jp:8080 HTTP&#x2F;1.1</span><br><span class="line">Host: proxy.hackr.jp</span><br></pre></td></tr></table></figure></li>
<li>响应<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK(之后进入网络隧道)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="4-持久连接节省通信量"><a href="#4-持久连接节省通信量" class="headerlink" title="4. 持久连接节省通信量"></a>4. 持久连接节省通信量</h3><ul>
<li>问题：<br>   HTTP 协议的初始版本中,每进行一次 HTTP 通信就要断开一次 TCP连接。因此,每次的请求都会造成无谓的 TCP 连接建立和断开,增加通信量的开销。</li>
<li><ol>
<li>持久性连接<br> 为解决上述 TCP 连接的问题,HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接(HTTP Persistent Connections,也称为 HTTP keep-alive 或HTTP connection reuse)的方法。持久连接的特点是,只要任意一端没有明确提出断开连接,则保持 TCP 连接状态。</li>
</ol>
<ul>
<li>减少TCP连接次数，减轻服务器负载</li>
<li>Web页面显示速度加快</li>
</ul>
</li>
<li><ol start="2">
<li>管线化</li>
</ol>
<ul>
<li>简单来说就是不等待响应，直接发送下一个请求</li>
<li>从前发送请求后需等待并收到响应,才能发送下一个请求。管线化技术出现后,不用等待响应亦可直接发送下一个请求。管线化技术则比持久连接还要快。请求数越多,时间差就越明显。</li>
</ul>
</li>
</ul>
<h3 id="5-使用Cookie的状态管理"><a href="#5-使用Cookie的状态管理" class="headerlink" title="5. 使用Cookie的状态管理"></a>5. 使用Cookie的状态管理</h3><ul>
<li><ol>
<li>HTTP是无状态的，即服务器不保存客户端的情况，响应之后就不管它是谁谁了。如果让服务器管理全部客户端状态则会成为负担。但这样就不能处理需要登录的情况，所以引入了Cookie技术</li>
</ol>
</li>
<li><ol start="2">
<li>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</li>
</ol>
</li>
<li><ol start="3">
<li>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息,通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入 Cookie 值后发送出去。</li>
</ol>
</li>
<li><ol start="4">
<li>服务器端发现客户端发送过来的 Cookie 后,会去检查究竟是从哪一个客户端发来的连接请求,然后对比服务器上的记录,最后得到之前的状态信息。</li>
</ol>
</li>
<li><ol start="5">
<li>Cookie交互</li>
</ol>
<ul>
<li><ol>
<li>请求报文(没有 Cookie 信息的状态)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第一次连接</span><br><span class="line">GET &#x2F;reader&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">*首部字段内没有Cookie的相关信息</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>响应报文(服务器端生成 Cookie 信息)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">&lt;Set-Cookie: sid&#x3D;1342077140226724; path&#x3D;&#x2F;; expires&#x3D;Wed,10-Oct-12 07:12:20 GMT&gt;</span><br><span class="line">Content-Type: text&#x2F;plain; charset&#x3D;UTF-8</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="3">
<li>请求报文(自动发送保存着的 Cookie 信息)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;image&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Cookie: sid&#x3D;1342077140226724</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="4">
<li>服务器根据再收到的cookie知道是谁连接的</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="第3章：HTTP报文内的HTTP信息"><a href="#第3章：HTTP报文内的HTTP信息" class="headerlink" title="第3章：HTTP报文内的HTTP信息"></a>第3章：HTTP报文内的HTTP信息</h1><h3 id="1-HTTP报文"><a href="#1-HTTP报文" class="headerlink" title="1. HTTP报文"></a>1. HTTP报文</h3><ul>
<li>请求报文<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">报文首部</span><br><span class="line">    - 请求行（包含用于请求的方法,请求 URI 和 HTTP 版本。）</span><br><span class="line">    - 请求首部字段</span><br><span class="line">    - 通用首部字段</span><br><span class="line">    - 实体首部字段</span><br><span class="line">    - 其他（如Cookie等RFC未规定的内容）</span><br><span class="line">空行（CR+LF）</span><br><span class="line">报文主体</span><br></pre></td></tr></table></figure></li>
<li>响应报文<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">报文首部</span><br><span class="line">    - 状态行（包含表明响应结果的状态码,原因短语和 HTTP 版本。）</span><br><span class="line">    - 响应首部字段</span><br><span class="line">    - 通用首部字段</span><br><span class="line">    - 实体首部字段</span><br><span class="line">    - 其他（如Cookie等RFC未定义的内容）</span><br><span class="line">空行（CR+LF）</span><br><span class="line">报文主体</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-编码提高传输效率"><a href="#2-编码提高传输效率" class="headerlink" title="2. 编码提高传输效率"></a>2. 编码提高传输效率</h3><ul>
<li><ol>
<li>报文主体和实体主体的区别</li>
</ol>
<ul>
<li>通常,报文主体等于实体主体。</li>
<li>只有当传输中进行编码操作时,实体主体的内容发生变化,才导致它和报文主体产生差异。</li>
</ul>
</li>
<li><ol start="2">
<li>压缩传输的内容编码</li>
</ol>
<ul>
<li>内容编码指明应用在实体内容上的编码格式,并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。（类似于压缩文件）</li>
<li>常用的内容编码<ul>
<li>gzip(GNU zip)</li>
<li>compress(UNIX 系统的标准压缩)</li>
<li>deflate(zlib)</li>
<li>identity(不进行编码)</li>
</ul>
</li>
</ul>
</li>
<li><ol start="3">
<li>分割发送的分块传输编码</li>
</ol>
<ul>
<li>在 HTTP 通信过程中,请求的编码实体资源尚未全部传输完成之前,浏览器无法显示请求页面。在传输大容量数据时,通过把数据分割成多块,能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码(Chunked TransferCoding)</li>
</ul>
</li>
</ul>
<h3 id="3-发送多种数据的多部分对象集合"><a href="#3-发送多种数据的多部分对象集合" class="headerlink" title="3. 发送多种数据的多部分对象集合"></a>3. 发送多种数据的多部分对象集合</h3><ul>
<li>发送邮件时,我们可以在邮件里写入文字并添加多份附件。这是因为采用了 MIME(Multipurpose Internet Mail Extensions,多用途因特网邮件扩展)机制,它允许邮件处理文本、图片、视频等多个不同类型的数据。</li>
<li>相应地,HTTP 协议中也采纳了多部分对象集合,发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。<ul>
<li>multipart/form-data<br>在 Web 表单文件上传时使用。</li>
<li>multipart/byteranges<br>状态码 206(Partial Content,部分内容)响应报文包含了多</li>
<li>在 HTTP 报文中使用多部分对象集合时,需要在首部字段里加上Content-type。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Type: multipart&#x2F;form-data;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="4-获取部分内容的范围请求"><a href="#4-获取部分内容的范围请求" class="headerlink" title="4. 获取部分内容的范围请求"></a>4. 获取部分内容的范围请求</h3><ul>
<li>以前,用户不能使用现在这种高速的带宽访问互联网,当时,下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况,那就必须重头开始。为了解决上述问题,需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。</li>
<li>对一份 10 000 字节大小的资源,如果使用范围请求,可以只请求5001~10 000 字节内的资源。</li>
<li>例子<ul>
<li>5001~10 000 字节<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Range: bytes&#x3D;5001-10000</span><br></pre></td></tr></table></figure></li>
<li>从 5001 字节之后全部的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Range: bytes&#x3D;5001-</span><br></pre></td></tr></table></figure></li>
<li>从一开始到 3000 字节和 5000~7000 字节的多重范围<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Range: bytes&#x3D;-3000, 5000-7000</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>针对范围请求,响应会返回状态码为 206 Partial Content 的响应报文。另外,对于多重范围的范围请求,响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。</li>
<li>如果服务器端无法响应范围请求,则会返回状态码 200 OK 和完整的实体内容。</li>
</ul>
<h3 id="5-内容协商返回最合适的内容"><a href="#5-内容协商返回最合适的内容" class="headerlink" title="5. 内容协商返回最合适的内容"></a>5. 内容协商返回最合适的内容</h3><ul>
<li>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉,然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</li>
<li>包含在请求报文中的某些首部字段(如下)就是判断的基准。<ul>
<li>Accept</li>
<li>Accept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language</li>
</ul>
</li>
<li>内容协商技术有以下 3 种类型。<ul>
<li>服务器驱动协商(Server-driven Negotiation)<br>由服务器端进行内容协商。以请求的首部字段为参考,在服务器端自动处理。但对用户来说,以浏览器发送的信息作为判定的依据,并不一定能筛选出最优内容。</li>
<li>客户端驱动协商(Agent-driven Negotiation)<br>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型,自行切换成 PC 版页面或手机版页面。</li>
<li>透明协商(Transparent Negotiation)<br>是服务器驱动和客户端驱动的结合体,是由服务器端和客户端各自进行内容协商的一种方法。</li>
</ul>
</li>
</ul>
<h1 id="第4章：返回结果的HTTP状态码"><a href="#第4章：返回结果的HTTP状态码" class="headerlink" title="第4章：返回结果的HTTP状态码"></a>第4章：返回结果的HTTP状态码</h1><h3 id="1-状态码类别"><a href="#1-状态码类别" class="headerlink" title="1. 状态码类别"></a>1. 状态码类别</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational(信息性状态码)</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error(客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error(服务器错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<p>以下为常用的14中状态码</p>
<h3 id="2-2XX成功"><a href="#2-2XX成功" class="headerlink" title="2. 2XX成功"></a>2. 2XX成功</h3><h4 id="2-1-200-OK"><a href="#2-1-200-OK" class="headerlink" title="2.1 200 OK"></a>2.1 200 OK</h4><ul>
<li>正常处理</li>
</ul>
<h4 id="2-2-204-No-Content"><a href="#2-2-204-No-Content" class="headerlink" title="2.2 204 No Content"></a>2.2 204 No Content</h4><ul>
<li>该状态码代表服务器接收的请求已成功处理,但在返回的响应报文中不含实体的主体部分。另外,也不允许返回任何实体的主体。比如,当从浏览器发出请求处理后,返回 204 响应,那么浏览器显示的页面不发生更新。</li>
<li>一般在只需要从客户端往服务器发送信息,而对客户端不需要发送新信息内容的情况下使用</li>
</ul>
<h4 id="2-3-206-Partial-Content"><a href="#2-3-206-Partial-Content" class="headerlink" title="2.3 206 Partial Content"></a>2.3 206 Partial Content</h4><ul>
<li>该状态码表示客户端进行了范围请求,而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<h3 id="3-3XX-重定向"><a href="#3-3XX-重定向" class="headerlink" title="3. 3XX 重定向"></a>3. 3XX 重定向</h3><h4 id="3-1-301-Moved-Permanently"><a href="#3-1-301-Moved-Permanently" class="headerlink" title="3.1 301 Moved Permanently"></a>3.1 301 Moved Permanently</h4><ul>
<li>永久性重定向。该状态码表示请求的资源已被分配了新的 URI,以后应使用资源现在所指的 URI。也就是说,如果已经把资源对应的 URI保存为书签了,这时应该按 Location 首部字段提示的 URI 重新保存。</li>
<li>像下方给出的请求 URI,当指定资源路径的最后忘记添加斜杠“/”,就会产生 301 状态码。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;example.com&#x2F;sample</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-2-302-Found"><a href="#3-2-302-Found" class="headerlink" title="3.2 302 Found"></a>3.2 302 Found</h4><ul>
<li>临时性重定向。该状态码表示请求的资源已被分配了新的 URI,希望用户(本次)能使用新的 URI 访问。</li>
<li>和 301 Moved Permanently 状态码相似,但 302 状态码代表的资源不是被永久移动,只是临时性质的。换句话说,已移动的资源对应的URI 将来还有可能发生改变。比如,用户把 URI 保存成书签,但不会像 301 状态码出现时那样去更新书签,而是仍旧保留返回 302 状态码的页面对应的 URI。</li>
</ul>
<h4 id="3-3-303-See-Other"><a href="#3-3-303-See-Other" class="headerlink" title="3.3 303 See Other"></a>3.3 303 See Other</h4><ul>
<li>该状态码表示由于请求对应的资源存在着另一个 URI,应使用 GET方法定向获取请求的资源。</li>
<li>303 状态码和 302 Found 状态码有着相同的功能,但 303 状态码明确表示客户端应当采用 GET 方法获取资源,这点与 302 状态码有区别。</li>
<li>比如,当使用 POST 方法访问 CGI 程序,其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时,返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能,但这里使用 303状态码是最理想的。</li>
</ul>
<h4 id="3-4-304-Not-Modified"><a href="#3-4-304-Not-Modified" class="headerlink" title="3.4 304 Not Modified"></a>3.4 304 Not Modified</h4><ul>
<li>该状态码表示客户端发送附带条件的请求 2 时,服务器端允许请求访问资源,但未满足条件的情况。304 状态码返回时,不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中,但是和重定向没有关系。</li>
<li>附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match,If-Modified-Since,If-None-Match,If-Range，If-Unmodified-Since 中任一首部。</li>
<li>服务器说：资源已经找到，但是不符合条件请求</li>
</ul>
<h4 id="3-5-307-Temporary-Redirect"><a href="#3-5-307-Temporary-Redirect" class="headerlink" title="3.5 307 Temporary Redirect"></a>3.5 307 Temporary Redirect</h4><ul>
<li>临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET,但实际使用时大家并不遵守。</li>
<li>307 会遵照浏览器标准,不会从 POST 变成 GET。但是,对于处理响应时的行为,每种浏览器有可能出现不同的情况。</li>
</ul>
<h3 id="4-4XX-客户端错误"><a href="#4-4XX-客户端错误" class="headerlink" title="4. 4XX 客户端错误"></a>4. 4XX 客户端错误</h3><h4 id="4-1-400-Bad-Request"><a href="#4-1-400-Bad-Request" class="headerlink" title="4.1 400 Bad Request"></a>4.1 400 Bad Request</h4><ul>
<li>该状态码表示请求报文中存在语法错误。当错误发生时,需修改请求的内容后再次发送请求。另外,浏览器会像 200 OK 一样对待该状态码。</li>
<li>服务器无法理解请求</li>
</ul>
<h4 id="4-2-401-Unauthorized"><a href="#4-2-401-Unauthorized" class="headerlink" title="4.2 401 Unauthorized"></a>4.2 401 Unauthorized</h4><ul>
<li>该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、 DIGEST 认证)的认证信息。另外若之前已进行过 1 次请求,则表示用户认证失败。</li>
<li>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应,会弹出认证用的对话窗口。</li>
</ul>
<h4 id="4-3-403-Forbidden"><a href="#4-3-403-Forbidden" class="headerlink" title="4.3 403 Forbidden"></a>4.3 403 Forbidden</h4><ul>
<li>该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由,但如果想作说明的话,可以在实体的主体部分对原因进行描述,这样就能让用户看到了。</li>
<li>未获得文件系统的访问授权,访问权限出现某些问题(从未授权的发送源 IP 地址试图访问)等列举的情况都可能是发生 403 的原因。</li>
<li>即服务器不允许访问那个资源</li>
</ul>
<h4 id="4-4-404-Not-Found"><a href="#4-4-404-Not-Found" class="headerlink" title="4.4 404 Not Found"></a>4.4 404 Not Found</h4><ul>
<li>该状态码表明服务器上无法找到请求的资源。除此之外,也可以在服务器端拒绝请求且不想说明理由时使用。</li>
</ul>
<h3 id="5-5XX-服务器错误"><a href="#5-5XX-服务器错误" class="headerlink" title="5. 5XX 服务器错误"></a>5. 5XX 服务器错误</h3><h4 id="5-1-500-Internal-Server-Error"><a href="#5-1-500-Internal-Server-Error" class="headerlink" title="5.1 500 Internal Server Error"></a>5.1 500 Internal Server Error</h4><ul>
<li>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。</li>
<li>服务器内部资源出故障</li>
</ul>
<h4 id="5-2-503-Service-Unavailable"><a href="#5-2-503-Service-Unavailable" class="headerlink" title="5.2 503 Service Unavailable"></a>5.2 503 Service Unavailable</h4><ul>
<li>服务器正忙</li>
<li>该状态码表明服务器暂时处于超负载或正在进行停机维护,现在无法处理请求。如果事先得知解除以上状况需要的时间,最好写入RetryAfter 首部字段再返回给客户端。</li>
</ul>
<h3 id="6-状态码和状况的不一致"><a href="#6-状态码和状况的不一致" class="headerlink" title="6. 状态码和状况的不一致"></a>6. 状态码和状况的不一致</h3><ul>
<li>不少返回的状态码响应都是错误的,但是用户可能察觉不到这点。</li>
<li>比如 Web 应用程序内部发生错误,状态码依然返回 200 OK,这种情况也经常遇到。</li>
</ul>
<h1 id="第5章：与-HTTP-协作的-Web-服务器"><a href="#第5章：与-HTTP-协作的-Web-服务器" class="headerlink" title="第5章：与 HTTP 协作的 Web 服务器"></a>第5章：与 HTTP 协作的 Web 服务器</h1><h3 id="1-用单台虚拟主机实现多个域名"><a href="#1-用单台虚拟主机实现多个域名" class="headerlink" title="1. 用单台虚拟主机实现多个域名"></a>1. 用单台虚拟主机实现多个域名</h3><ul>
<li>HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。比如,提供 Web 托管服务(Web Hosting Service)的供应商,可以用一台服务器为多位客户服务,也可以以每位客户持有的域名运行各自不同的网站。这是因为利用了虚拟主机(Virtual Host,又称虚拟服务器)的功能。</li>
<li>若一台服务器上有多个域名，这些域名解析后的IP地址会相同</li>
<li>在相同的 IP 地址下,由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站,因此在发送 HTTP 请求时,必须在 Host 首部内完整指定主机名或域名的 URI。</li>
</ul>
<h3 id="2-通信数据转发程序-代理、网关、隧道"><a href="#2-通信数据转发程序-代理、网关、隧道" class="headerlink" title="2. 通信数据转发程序 :代理、网关、隧道"></a>2. 通信数据转发程序 :代理、网关、隧道</h3><ul>
<li><ol>
<li>代理</li>
</ol>
<ul>
<li>代理是一种有转发功能的应用程序,它扮演了位于服务器和客户端“中间人”的角色,接收由客户端发送的请求并转发给服务器,同时也接收服务器返回的响应并转发给客户端。</li>
<li>使用代理服务器的理由有:<ul>
<li>利用缓存技术(稍后讲解)减少网络带宽的流量</li>
<li>组织内部针对特定网站的访问控制</li>
<li>以获取访问日志为主要目的,等等。</li>
</ul>
</li>
<li>代理有多种使用方法,按两种基准分类。一种是是否使用缓存,另一种是是否会修改报文。<ul>
<li>缓存代理<br>代理转发响应时,缓存代理(Caching Proxy)会预先将资源的副本(缓存)保存在代理服务器上。当代理再次接收到对相同资源的请求时,就可以不从源服务器那里获取资源,而是将之前缓存的资源作为响应返回。</li>
<li>透明代理<br>转发请求或响应时,不对报文做任何加工的代理类型被称为透明代理(Transparent Proxy)。反之,对报文内容进行加工的代理被称为非透明代理。</li>
</ul>
</li>
</ul>
</li>
<li><ol start="2">
<li>网关</li>
</ol>
<ul>
<li>网关是转发其他服务器通信数据的服务器,接收从客户端发送来的请求时,它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉,自己的通信目标是一个网关。</li>
<li>利用网关可以由 HTTP 请求转化为其他协议通信  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端&lt;---------------&gt;网关&lt;---------&gt;非HTTP服务器</span><br><span class="line">    Http请求和响应        其他协议</span><br></pre></td></tr></table></figure></li>
<li>利用网关能提高通信的安全性,因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如,网关可以连接数据库,使用SQL 语句查询数据。另外,在 Web 购物网站上进行信用卡结算时,网关可以和信用卡结算系统联动。</li>
</ul>
</li>
<li><ol start="3">
<li>隧道</li>
</ol>
<ul>
<li>隧道是在相隔甚远的客户端和服务器两者之间进行中转,并保持双方通信连接的应用程序。</li>
<li>隧道可按要求建立起一条与其他服务器的通信线路,届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</li>
<li>隧道本身是透明的,客户端不用在意隧道的存在</li>
</ul>
</li>
</ul>
<h3 id="3-保存资源的缓存"><a href="#3-保存资源的缓存" class="headerlink" title="3. 保存资源的缓存"></a>3. 保存资源的缓存</h3><ul>
<li>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问,因此也就节省了通信流量和通信时间。</li>
<li>缓存有有效期限</li>
<li>客户端(浏览器)也可以缓存，也有有效期限</li>
</ul>
<h1 id="第6章：HTTP首部"><a href="#第6章：HTTP首部" class="headerlink" title="第6章：HTTP首部"></a>第6章：HTTP首部</h1><h3 id="1-HTTP-首部字段一览"><a href="#1-HTTP-首部字段一览" class="headerlink" title="1. HTTP 首部字段一览"></a>1. HTTP 首部字段一览</h3><ul>
<li>通用首部字段</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、连接的管理</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody></table>
<ul>
<li>请求首部字段</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言(自然语言)</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记(ETag)</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记(与 If-Match 相反)</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间(与If-Modified-Since相反)</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP 客户端程序的信息</td>
</tr>
</tbody></table>
<ul>
<li>响应首部字段</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody></table>
<ul>
<li>实体首部字段</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>资源可支持的HTTP方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小(单位:字节)</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody></table>
<h3 id="2-非-HTTP-1-1-首部字段"><a href="#2-非-HTTP-1-1-首部字段" class="headerlink" title="2. 非 HTTP/1.1 首部字段"></a>2. 非 HTTP/1.1 首部字段</h3><ul>
<li>在 HTTP 协议通信交互中使用到的首部字段,不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、Set-Cookie 和Content-Disposition 等在其他 RFC 中定义的首部字段,它们的使用频率也很高。</li>
<li>这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。</li>
</ul>
<h3 id="3-通用首部字段"><a href="#3-通用首部字段" class="headerlink" title="3. 通用首部字段"></a>3. 通用首部字段</h3><h3 id="4-请求首部字段"><a href="#4-请求首部字段" class="headerlink" title="4. 请求首部字段"></a>4. 请求首部字段</h3><h3 id="5-响应首部字段"><a href="#5-响应首部字段" class="headerlink" title="5. 响应首部字段"></a>5. 响应首部字段</h3><h3 id="6-实体首部字段"><a href="#6-实体首部字段" class="headerlink" title="6. 实体首部字段"></a>6. 实体首部字段</h3><ul>
<li>这四个都是讲字段的具体内容，先不做笔记了，有点多和麻烦，需要的时候再搜吧。</li>
</ul>
<h3 id="7-为Cookie服务的首部字段"><a href="#7-为Cookie服务的首部字段" class="headerlink" title="7. 为Cookie服务的首部字段"></a>7. 为Cookie服务的首部字段</h3><ul>
<li>总览</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>首部类型</th>
</tr>
</thead>
<tbody><tr>
<td>Set-Cookie</td>
<td>开始状态管理所使用的Cookie信息</td>
<td>响应首部字段</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器接收到的Cookie信息</td>
<td>请求首部字段</td>
</tr>
</tbody></table>
<ul>
<li><p>set-cookie</p>
<ul>
<li>当服务器准备开始管理客户端的状态时,会事先告知各种信息。下面的表格列举了 Set-Cookie 的字段值。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: status&#x3D;enable; expires&#x3D;Tue, 05 Jul 2011 07:26:31 GMT; path</span><br></pre></td></tr></table></figure>
属性 |说明</li>
</ul>
</li>
<li><p>-|–<br>NAME=VALUE |赋予 Cookie 的名称和其值(必需项)<br>expires=DATE |Cookie 的有效期(若不明确指定则默认为浏览器关闭前为止)<br>path=PATH |将服务器上的文件目录作为Cookie的适用对象(若不指定则默认为文档所在的文件目录)<br>domain=域名 |作为 Cookie 适用对象的域名 (若不指定则默认为创建 Cookie的服务器的域名)<br>Secure |仅在 HTTPS 安全通信时才会发送 Cookie<br>HttpOnly |加以限制,使 Cookie 不能被 JavaScript 脚本访问</p>
</li>
<li><p>cookie</p>
<ul>
<li>首部字段 Cookie 会告知服务器,当客户端想获得 HTTP 状态管理支持时,就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时,同样可以以多个 Cookie 形式发送。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cookie: status&#x3D;enable</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="8-其他首部字段"><a href="#8-其他首部字段" class="headerlink" title="8. 其他首部字段"></a>8. 其他首部字段</h3><ul>
<li>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上,会出现各种非标准的首部字段。</li>
<li>X-Frame-Options<ul>
<li>首部字段 X-Frame-Options 属于 HTTP 响应首部,用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持(clickjacking)攻击。</li>
<li>首部字段 X-Frame-Options 有以下两个可指定的字段值。<ul>
<li>DENY :拒绝</li>
<li>SAMEORIGIN :仅同源域名下的页面(Top-level-browsing-context)匹配时许可。(比如,当指定 <a href="http://hackr.jp/sample.html%E9%A1%B5%E9%9D%A2%E4%B8%BA">http://hackr.jp/sample.html页面为</a> SAMEORIGIN 时,那么 hackr.jp 上所有页面的 frame 都被允许可加载该页面,而 example.com 等其他域名的页面就不行了)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X-Frame-Options: DENY</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>X-XSS-Protection<ul>
<li>首部字段 X-XSS-Protection 属于 HTTP 响应首部,它是针对跨站脚本攻击(XSS)的一种对策,用于控制浏览器 XSS 防护机制的开关。</li>
<li>首部字段 X-XSS-Protection 可指定的字段值如下。<ul>
<li>0 :将 XSS 过滤设置成无效状态</li>
<li>1 :将 XSS 过滤设置成有效状态<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X-XSS-Protection: 1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>DNT<ul>
<li>首部字段 DNT 属于 HTTP 请求首部,其中 DNT 是 Do Not Track 的简称,意为拒绝个人信息被收集,是表示拒绝被精准广告追踪的一种方法。</li>
<li>首部字段 DNT 可指定的字段值如下。<ul>
<li>0 :同意被追踪</li>
<li>1 :拒绝被追踪</li>
</ul>
</li>
<li>由于首部字段 DNT 的功能具备有效性,所以 Web 服务器需要对 DNT做对应的支持。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DNT: 1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>P3P<ul>
<li>首部字段 P3P 属于 HTTP 相应首部,通过利用 P3P(The Platform for Privacy Preferences,在线隐私偏好平台)技术,可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式,以达到保护用户隐私的目的。</li>
<li>要进行 P3P 的设定,需按以下操作步骤进行。<ul>
<li>步骤 1:创建 P3P 隐私</li>
<li>步骤 2:创建 P3P 隐私对照文件后,保存命名在 /w3c/p3p.xml</li>
<li>步骤 3:从 P3P 隐私中新建 Compact policies 后,输出到 HTTP 响应中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第7章-确保-Web-安全的-HTTPS"><a href="#第7章-确保-Web-安全的-HTTPS" class="headerlink" title="第7章 确保 Web 安全的 HTTPS"></a>第7章 确保 Web 安全的 HTTPS</h1><h3 id="1-HTTP-主要有这些不足-例举如下。"><a href="#1-HTTP-主要有这些不足-例举如下。" class="headerlink" title="1. HTTP 主要有这些不足,例举如下。"></a>1. HTTP 主要有这些不足,例举如下。</h3><h5 id="1-通信使用明文-不加密-内容可能会被窃听"><a href="#1-通信使用明文-不加密-内容可能会被窃听" class="headerlink" title="1. 通信使用明文(不加密),内容可能会被窃听"></a>1. 通信使用明文(不加密),内容可能会被窃听</h5><ul>
<li>TCP/IP是可能被窃听的网络<ul>
<li>即使已经过加密处理的通信,也会被窥视到通信内容,这点和未加密的通信是相同的。只是说如果通信经过加密,就有可能让人无法破解报文信息的含义,但加密处理后的报文信息本身还是会被看到的。</li>
</ul>
</li>
<li>加密处理防止被窃听<ul>
<li>通信的加密<ul>
<li>HTTP 协议中没有加密机制,但可以通过和 SSL(Secure Socket Layer,安全套接层)或TLS(Transport Layer Security,安全层传输协议)的组合使用,加密 HTTP 的通信内容。</li>
<li>用 SSL 建立安全通信线路之后,就可以在这条线路上进行 HTTP通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS(HTTP Secure,超文本传输安全协议)或 HTTP over SSL。</li>
</ul>
</li>
<li>内容的加密<ul>
<li>即对报文首部不加密，对报文主体加密</li>
<li>为了做到有效的内容加密,前提是要求客户端和服务器同时具备加密和解密机制。</li>
<li>由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理,所以内容仍有被篡改的风险。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-不验证通信方的身份-因此有可能遭遇伪装"><a href="#2-不验证通信方的身份-因此有可能遭遇伪装" class="headerlink" title="2. 不验证通信方的身份,因此有可能遭遇伪装"></a>2. 不验证通信方的身份,因此有可能遭遇伪装</h5><ul>
<li>任何人都可发起请求<ul>
<li>由于不存在确认通信方的处理步骤,任何人都可以发起请求。另外,服务器只要接收到请求,不管对方是谁都会返回一个响应</li>
<li>仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下</li>
<li>存在的各种隐患<ul>
<li>无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。</li>
<li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。</li>
<li>无法确定正在通信的对方是否具备访问权限。因为某些Web 服务器上保存着重要的信息,只想发给特定用户通信的权限。</li>
<li>无法判定请求是来自何方、出自谁手。</li>
<li>即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击(Denial of Service,拒绝服务攻击)</li>
</ul>
</li>
</ul>
</li>
<li>查明对手的证书<ul>
<li>虽然使用 HTTP 协议无法确定通信方,但如果使用 SSL 则可以。SSL 不仅提供加密处理,而且还使用了一种被称为证书的手段,可用于确定方。</li>
<li>证书由值得信任的第三方机构颁发,用以证明服务器和客户端是实际存在的。另外,伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方(服务器或客户端)持有的证书,即可判断通信方的真实意图。</li>
<li>通过使用证书,以证明通信方就是意料中的服务器。这对使用者个人来讲,也减少了个人信息泄露的危险性。</li>
<li>另外,客户端持有证书即可完成个人身份的确认,也可用于对 Web 网站的认证环节。</li>
</ul>
</li>
</ul>
<h5 id="3-无法证明报文的完整性-所以有可能已遭篡改"><a href="#3-无法证明报文的完整性-所以有可能已遭篡改" class="headerlink" title="3. 无法证明报文的完整性,所以有可能已遭篡改"></a>3. 无法证明报文的完整性,所以有可能已遭篡改</h5><ul>
<li>接收到的内容可能有误<ul>
<li>请求或响应在传输途中,遭攻击者拦截并篡改内容的攻击称为中间人攻击(Man-in-the-Middle attack,MITM)。</li>
</ul>
</li>
<li>如何防止篡改<ul>
<li>虽然有使用 HTTP 协议确定报文完整性的方法,但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法,以及用来确认文件的数字签名方法。这些问题不仅在 HTTP 上出现,其他未加密的协议中也会存在这类问题。</li>
<li>提供文件下载服务的 Web 网站也会提供相应的以 PGP(PrettyGood Privacy,完美隐私)创建的数字签名及 MD5 算法生成的散列值。PGP 是用来证明创建文件的数字签名,MD5 是由单向函数生成的散列值。不论使用哪一种方法,都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件。浏览器无法自动帮用户检查。</li>
<li>可惜的是,用这些方法也依然无法百分百保证确认结果正确。因为 PGP 和 MD5 本身被改写的话,用户是没有办法意识到的。</li>
<li>为了有效防止这些弊端,有必要使用 HTTPS。SSL 提供认证和加密处理及摘要功能。仅靠 HTTP 确保完整性是非常困难的,因此通过和其他协议组合使用来实现这个目标。</li>
</ul>
</li>
</ul>
<h3 id="2-7-2-HTTP-加密-认证-完整性保护-HTTPS"><a href="#2-7-2-HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="2. 7.2 HTTP+ 加密 + 认证 + 完整性保护=HTTPS"></a>2. 7.2 HTTP+ 加密 + 认证 + 完整性保护=HTTPS</h3><h5 id="1-HTTP-加上加密处理和认证以及完整性保护后即是-HTTPS"><a href="#1-HTTP-加上加密处理和认证以及完整性保护后即是-HTTPS" class="headerlink" title="1. HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS"></a>1. HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS</h5><ul>
<li>我们把添加了加密及认证机制的 HTTP 称为 HTTPS(HTTP Secure)。</li>
</ul>
<h5 id="2-HTTPS-是身披-SSL-外壳的-HTTP"><a href="#2-HTTPS-是身披-SSL-外壳的-HTTP" class="headerlink" title="2. HTTPS 是身披 SSL 外壳的 HTTP"></a>2. HTTPS 是身披 SSL 外壳的 HTTP</h5><ul>
<li>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL(Secure Socket Layer)和 TLS(Transport Layer Security)协议代替而已。</li>
<li>通常,HTTP 直接和 TCP 通信。当使用 SSL 时,则演变成先和 SSL 通信,再由 SSL 和 TCP 通信了。简言之,所谓 HTTPS,其实就是身披SSL 协议这层外壳的 HTTP。</li>
<li>SSL 是独立于 HTTP 的协议,所以不光是 HTTP 协议,其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</li>
</ul>
<h5 id="3-相互交换密钥的公开密钥加密技术"><a href="#3-相互交换密钥的公开密钥加密技术" class="headerlink" title="3. 相互交换密钥的公开密钥加密技术"></a>3. 相互交换密钥的公开密钥加密技术</h5><ul>
<li>SSL 采用一种叫做公开密钥加密(Public-key cryptography)的加密处理方式。近代的加密方法中加密算法是公开的,而密钥却是保密的。通过这种方式得以保持加密方法的安全性。加密和解密都会用到密钥。没有密钥就无法对密码解密,反过来说,任何人只要持有密钥就能解密了。如果密钥被攻击者获得,那加密也就失去了意义。</li>
<li>共享密钥加密的困境（对称加密）<ul>
<li>加密和解密同用一个密钥的方式称为共享密钥加密(Common key crypto system),也被叫做对称密钥加密。</li>
<li>密钥发送问题，怎么保证秘钥不会被劫持监听</li>
</ul>
</li>
<li>使用两把密钥的公开密钥加密（非对称加密）<ul>
<li>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥(private key),另一把叫做公开密钥(public key)。顾名思义,私有密钥不能让其他任何人知道,而公开密钥则可以随意发布,任何人都可以获得。</li>
<li>使用公开密钥加密方式,发送密文的一方使用对方的公开密钥进行加密处理,对方收到被加密的信息后,再使用自己的私有密钥进行解密。利用这种方式,不需要发送用来解密的私有密钥,也不必担心密钥被攻击者窃听而盗走。</li>
</ul>
</li>
<li>HTTPS 采用混合加密机制<ul>
<li>若密钥能够实现安全交换,那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比,其处理速度要慢。</li>
<li>充分利用两者各自的优势,将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式,之后的建立通信交换报文阶段则使用共享密钥加密方式。</li>
</ul>
</li>
</ul>
<h5 id="4-证明公开密钥正确性的证书"><a href="#4-证明公开密钥正确性的证书" class="headerlink" title="4. 证明公开密钥正确性的证书"></a>4. 证明公开密钥正确性的证书</h5><ul>
<li>公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。</li>
<li>为了解决上述问题,可以使用由数字证书认证机构(CA,Certificate Authority)和其相关机关颁发的公开密钥证书。</li>
<li>可证明组织真实性的 EV SSL 证书<ul>
<li>证书的一个作用是用来证明作为通信一方的服务器是否规范,另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是 EV SSL 证书(Extended Validation SSL Certificate)。</li>
<li>持有 EV SSL 证书的 Web 网站的浏览器地址栏处的背景色是绿色的,从视觉上就能一眼辨别出。而且在地址栏的左侧显示了 SSL证书中记录的组织名称以及颁发证书的认证机构的名称。</li>
<li>上述机制的原意图是为了防止用户被钓鱼攻击(Phishing),但就效果上来讲,还得打一个问号。很多用户可能不了解 EV SSL证书相关的知识,因此也不太会留意它。</li>
</ul>
</li>
<li>用以确认客户端的客户端证书<ul>
<li>HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认证,证明服务器正在通信的对方始终是预料之内的客户端,其作用跟服务器证书如出一辙。</li>
<li>现状是,安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务。比如那些可支撑客户端证书支出费用的业务。例如,银行的网上银行就采用了客户端证书。在登录网银时不仅要求用户确认输入 ID 和密码,还会要求用户的客户端证书,以确认用户是否从特定的终端访问网银。</li>
</ul>
</li>
<li>认证机构信誉第一</li>
<li>由自认证机构颁发的证书称为自签名证书<ul>
<li>如果使用 OpenSSL 这套开源程序,每个人都可以构建一套属于自己的认证机构,从而自己给自己颁发服务器证书。但该服务器证书在互联网上不可作为证书使用,似乎没什么帮助。</li>
<li>浏览器访问该服务器时,会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。</li>
<li>多数浏览器内预先已植入备受信赖的认证机构的证书,但也有一小部分浏览器会植入中级认证机构的证书。对于中级认证机构颁发的服务器证书,某些浏览器会以正规的证书来对待,可有的浏览器会当作自签名证书。</li>
</ul>
</li>
</ul>
<h5 id="5-HTTPS-通信过程"><a href="#5-HTTPS-通信过程" class="headerlink" title="5. HTTPS 通信过程"></a>5. HTTPS 通信过程</h5><ul>
<li><ol>
<li>Client—&gt;Server Handshake:ClientHello<br> 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件(Cipher Suite)列表(所使用的加密算法及密钥长度等)。</li>
</ol>
</li>
<li><ol start="2">
<li>Server—&gt;Client Handshake:ServerHello<br> 服务器可进行 SSL 通信时,会以 Server Hello 报文作为应答。和客户端一样,在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li>
</ol>
</li>
<li><ol start="3">
<li>Server—&gt;Client Handshake:Certificate<br> 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</li>
</ol>
</li>
<li><ol start="4">
<li>Server—&gt;Client Handshake:ServerHelloDone<br> 最后服务器发送 Server Hello Done 报文通知客户端,最初阶段的 SSL 握手协商部分结束。</li>
</ol>
</li>
<li><ol start="5">
<li>Client—&gt;Server Handshake:ClientKeyExchange<br> SSL 第一次握手结束之后,客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</li>
</ol>
</li>
<li><ol start="6">
<li>Client—&gt;Server ChangeCipherSpec<br> 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器,在此报文之后的通信会采用 Pre-master secret 密钥加密。</li>
</ol>
</li>
<li><ol start="7">
<li>Client—&gt;Server Handshake:Finished<br> 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功,要以服务器是否能够正确解密该报文作为判定标准。</li>
</ol>
</li>
<li><ol start="8">
<li>Server—&gt;Client ChangeCipherSpec<br> 服务器同样发送 Change Cipher Spec 报文。</li>
</ol>
</li>
<li><ol start="9">
<li>Server—&gt;Client Handshake:Finished<br> 服务器同样发送 Finished 报文。</li>
</ol>
</li>
<li><ol start="10">
<li>Client—&gt;Server Application Data(HTTP)<br>服务器和客户端的 Finished 报文交换完毕之后,SSL 连接就算建立完成。当然,通信会受到 SSL 的保护。从此处开始进行应用层协议的通信,即发送 HTTP 请求。</li>
</ol>
</li>
<li><ol start="11">
<li>Server—&gt;Client Application Data(HTTP)<br>应用层协议通信,即发送 HTTP 响应。</li>
</ol>
</li>
<li><ol start="12">
<li>Client—&gt;Server Alert:warning,close_notify<br>最后由客户端断开连接。断开连接时,发送 close_notify 报文。上图做了一些省略,这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。</li>
</ol>
</li>
</ul>
<h5 id="6-HTTPS-的安全通信机制"><a href="#6-HTTPS-的安全通信机制" class="headerlink" title="6. HTTPS 的安全通信机制"></a>6. HTTPS 的安全通信机制</h5><ul>
<li>SSL 和 TLS<ul>
<li>SSL 技术最初是由浏览器开发商网景通信公司率先倡导的,开发过 SSL3.0 之前的版本。目前主导权已转移到 IETF(InternetEngineering Task Force,Internet 工程任务组)的手中。</li>
<li>IETF 以 SSL3.0 为基准,后又制定了 TLS1.0、TLS1.1 和TLS1.2。TSL 是以 SSL 为原型开发的协议,有时会统一称该协议为 SSL。当前主流的版本是 SSL3.0 和 TLS1.0。</li>
<li>由于 SSL1.0 协议在设计之初被发现出了问题,就没有实际投入使用。SSL2.0 也被发现存在问题,所以很多浏览器直接废除了该协议版本。</li>
</ul>
</li>
<li>SSL 速度慢吗<ul>
<li>HTTPS 也存在一些问题,那就是当使用 SSL 时,它的处理速度会变慢。</li>
<li>HTTPS 比 HTTP 要慢 2 到 100 倍</li>
<li>SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源,导致处理速度变慢。<ul>
<li>通信慢：除去和TCP 连接、发送 HTTP 请求 • 响应以外,还必须进行 SSL 通信,因此整体上处理通信量不可避免会增加。</li>
<li>消耗大：SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲,比起 HTTP 会更多地消耗服务器和客户端的硬件资源,导致负载增强。</li>
</ul>
</li>
</ul>
</li>
<li>为什么不全使用HTTPS<ul>
<li><ol>
<li>比HTTP慢，消耗资源多</li>
</ol>
</li>
<li><ol start="2">
<li>证书要钱，减少开销</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="第8章-确认访问用户身份的认证"><a href="#第8章-确认访问用户身份的认证" class="headerlink" title="第8章 确认访问用户身份的认证"></a>第8章 确认访问用户身份的认证</h1><h3 id="1-何为认证"><a href="#1-何为认证" class="headerlink" title="1. 何为认证"></a>1. 何为认证</h3><ul>
<li>计算机本身无法判断坐在显示器前的使用者的身份。进一步说,也无法确认网络的那头究竟有谁。可见,为了弄清究竟是谁在访问服务器,就得让对方的客户端自报家门。</li>
<li>核对的信息有如下几个<ul>
<li>密码:只有本人才会知道的字符串信息。</li>
<li>动态令牌:仅限本人持有的设备内显示的一次性密码。</li>
<li>数字证书:仅限本人(终端)持有的信息。</li>
<li>生物认证:指纹和虹膜等本人的生理信息。</li>
<li>IC 卡等:仅限本人持有的信息。</li>
</ul>
</li>
<li>HTTP/1.1 使用的认证方式<ul>
<li>BASIC 认证(基本认证)</li>
<li>DIGEST 认证(摘要认证)</li>
<li>SSL 客户端认证</li>
<li>FormBase 认证(基于表单认证)</li>
</ul>
</li>
</ul>
<h3 id="2-BASIC-认证"><a href="#2-BASIC-认证" class="headerlink" title="2. BASIC 认证"></a>2. BASIC 认证</h3><ul>
<li>BASIC 认证(基本认证)是从 HTTP/1.0 就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是 Web 服务器与通信客户端之间进行的认证方式。</li>
<li>BASIC 认证使用上不够便捷灵活,且达不到多数 Web 网站期望的安全性等级,因此它并不常用</li>
<li>步骤<ul>
<li><ol>
<li>Client—&gt;Server   GET<br> 请求的资源需要 BASIC 认证</li>
</ol>
</li>
<li><ol start="2">
<li>Server—&gt;Client   401<br> 服务器会随状态码 401 Authorization Required,返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式(BASIC) 及 Request-URI 安全域字符串(realm)。</li>
</ol>
</li>
<li><ol start="3">
<li>Client—&gt;Server<br> 接收到状态码 401 的客户端为了通过 BASIC 认证,需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成,两者中间以冒号(:)连接后,再经过 Base64 编码处理。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;例子</span><br><span class="line">&#x2F;&#x2F;假设用户 ID 为 guest,密码是 guest,连接起来就会形成guest:guest 这样的字符串。</span><br><span class="line">&#x2F;&#x2F;然后经过 Base64 编码,最后的结果即是Z3Vlc3Q6Z3Vlc3Q&#x3D;。</span><br><span class="line">&#x2F;&#x2F;把这串字符串写入首部字段 Authorization 后,发送请求。</span><br><span class="line">GET &#x2F;private&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Authorization: Basic Z3Vlc3Q6Z3Vlc3Q&#x3D;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="4">
<li>Server—&gt;Client<br> 服务器认证成功返回200，失败返回401</li>
</ol>
</li>
</ul>
</li>
<li>BASIC 认证虽然采用 Base64 编码方式,但这不是加密处理。不需要任何附加信息即可对其解码。换言之,由于明文解码后就是用户 ID和密码,在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中,如果被人窃听,被盗的可能性极高。</li>
<li>另外,除此之外想再进行一次 BASIC 认证时,一般的浏览器却无法实现认证注销操作,这也是问题之一。</li>
</ul>
<h3 id="3-DIGEST-认证"><a href="#3-DIGEST-认证" class="headerlink" title="3. DIGEST 认证"></a>3. DIGEST 认证</h3><ul>
<li><p>为弥补 BASIC 认证存在的弱点,从 HTTP/1.1 起就有了 DIGEST 认证。 DIGEST 认证同样使用质询 / 响应的方式(challenge/response),但不会像 BASIC 认证那样直接发送明文密码。</p>
</li>
<li><p>质询响应方式<br>  是指,一开始一方会先发送认证要求给另一方,接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。</p>
</li>
<li><p>步骤</p>
<ul>
<li><ol>
<li>Client—&gt;Server   GET<br> 请求的资源需要 BASIC 认证</li>
</ol>
</li>
<li><ol start="2">
<li>Server—&gt;Client   401<br> 服务器会随状态码 401 Authorization Required,返回带 WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码(随机数,nonce)</li>
</ol>
</li>
<li><ol start="3">
<li>Client—&gt;Server<br> 接收到 401 状态码的客户端,返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。</li>
</ol>
</li>
<li><ol start="4">
<li>Server—&gt;Client<br> 接收到包含首部字段 Authorization 请求的服务器,会确认认证信息的正确性。认证通过后则返回包含 Request-URI 资源的响应。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="4-SSL-客户端认证"><a href="#4-SSL-客户端认证" class="headerlink" title="4. SSL　客户端认证"></a>4. SSL　客户端认证</h3><ul>
<li><p>从使用用户 ID 和密码的认证方式方面来讲,只要二者的内容正确,即可认证是本人的行为。但如果用户 ID 和密码被盗,就很有可能被第三者冒充。利用 SSL 客户端认证则可以避免该情况的发生。</p>
</li>
<li><p>SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书(在 HTTPS 一章已讲解)认证,服务器可确认访问是否来自已登录的客户端。</p>
</li>
<li><p>步骤</p>
<ul>
<li>接收到需要认证资源的请求,服务器会发送 Certificate Request 报文,要求客户端提供客户端证书。</li>
<li>用户选择将发送的客户端证书后,客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。</li>
<li>服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥,然后开始 HTTPS 加密通信。</li>
</ul>
</li>
<li><p>SSL 客户端认证必要的费用</p>
<ul>
<li>使用 SSL 客户端认证需要用到客户端证书。而客户端证书需要支付一定费用才能使用。</li>
</ul>
</li>
</ul>
<h3 id="5-基于表单认证"><a href="#5-基于表单认证" class="headerlink" title="5. 基于表单认证"></a>5. 基于表单认证</h3><ul>
<li>基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息(Credential),按登录信息的验证结果认证。</li>
</ul>
<h5 id="1-认证多半为基于表单认证"><a href="#1-认证多半为基于表单认证" class="headerlink" title="1. 认证多半为基于表单认证"></a>1. 认证多半为基于表单认证</h5><ul>
<li>由于使用上的便利性及安全性问题,HTTP 协议标准提供的 BASIC 认证和 DIGEST 认证几乎不怎么使用。另外,SSL 客户端认证虽然具有高度的安全等级,但因为导入及维持费用等问题,还尚未普及。</li>
<li>不具备共同标准规范的表单认证,在每个 Web 网站上都会有各不相同的实现方式。</li>
</ul>
<h5 id="2-Session-管理及-Cookie-应用"><a href="#2-Session-管理及-Cookie-应用" class="headerlink" title="2. Session 管理及 Cookie 应用"></a>2. Session 管理及 Cookie 应用</h5><ul>
<li>基于表单认证本身是通过服务器端的 Web 应用,将客户端发送过来的用户 ID 和密码与之前登录过的信息做匹配来进行认证的。</li>
<li>但鉴于 HTTP 是无状态协议,之前已认证成功的用户状态无法通过协议层面保存下来。即,无法实现状态管理,因此即使当该用户下一次继续访问,也无法区分他与其他的用户。于是我们会使用 Cookie 来管理 Session,以弥补 HTTP 协议中不存在的状态管理功能。</li>
<li>步骤<ul>
<li><ol>
<li>客户端把用户 ID 和密码等登录信息放入报文的实体部分,通常是以 POST 方法把请求发送给服务器。而这时,会使用 HTTPS通信来进行 HTML 表单画面的显示和用户输入数据的发送。</li>
</ol>
</li>
<li><ol start="2">
<li>服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证,然后把用户的认证状态与Session ID 绑定后记录在服务器端。<br>向客户端返回响应时,会在首部字段 Set-Cookie 内写入 SessionID(如 PHPSESSID=028a8c…)。<br>另外,为减轻跨站脚本攻击(XSS)造成的损失,建议事先在 Cookie内加上 httponly 属性。</li>
</ol>
</li>
<li><ol start="3">
<li>客户端接收到从服务器端发来的 Session ID 后,会将其作为Cookie 保存在本地。下次向服务器发送请求时,浏览器会自动发送Cookie,所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。</li>
</ol>
</li>
</ul>
</li>
<li>通常,一种安全的保存方法是,先利用给密码加盐(salt) 1 的方式增加额外信息,再使用散列(hash)函数计算出散列值后保存。但是我们也经常看到直接保存明文密码的做法,而这样的做法具有导致密码泄露的风险。</li>
</ul>
<h1 id="第9章：基于-HTTP-的功能追加协议"><a href="#第9章：基于-HTTP-的功能追加协议" class="headerlink" title="第9章：基于 HTTP 的功能追加协议"></a>第9章：基于 HTTP 的功能追加协议</h1><h3 id="1-消除-HTTP-瓶颈的-SPDY"><a href="#1-消除-HTTP-瓶颈的-SPDY" class="headerlink" title="1. 消除 HTTP 瓶颈的 SPDY"></a>1. 消除 HTTP 瓶颈的 SPDY</h3><ul>
<li><p>互联网工程任务组（IETF）对谷歌提出的SPDY协议进行了标准化，于2015年5推出了类似于SPDY协议的 HTTP 2.0 协议标准（简称HTTP/2）。谷歌因此宣布放弃对SPDY协议的支持，转而支持HTTP/2。谷歌称，计划于 2016 年初在 Chrome 中移除 SPDY，并将为Chrome 40 添加 HTTP/2 协议支持。</p>
</li>
<li><p>总之就是弃用了</p>
</li>
<li><p>HTTP的瓶颈</p>
<ul>
<li>一条连接上只可发送一个请求。</li>
<li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。</li>
<li>请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。发送冗长的首部。每次互相发送相同的首部造成的浪费较多。</li>
<li>可任意选择数据压缩格式。非强制压缩发送。</li>
</ul>
</li>
<li><p>Ajax 的解决方法</p>
<ul>
<li>Ajax(Asynchronous JavaScript and XML, 异 步 JavaScript 与 XML 技术)是一种有效利用 JavaScript 和 DOM(Document Object Model,文档对象模型)的操作,以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比,由于它只更新一部分页面,响应中传输的数据量会因此而减少,这一优点显而易见。</li>
<li>而利用 Ajax 实时地从服务器获取内容,有可能会导致大量请求产生。另外,Ajax 仍未解决 HTTP 协议本身存在的问题。</li>
</ul>
</li>
<li><p>Comet 的解决方法</p>
<ul>
<li>一旦服务器端有内容更新了,Comet 不会让请求等待,而是直接给客户端返回响应。这是一种通过延迟应答,模拟实现服务器端向客户端推送(Server Push)的功能。</li>
<li>通常,服务器端接收到请求,在处理完毕后就会立即返回响应,但为了实现推送功能,Comet 会先将响应置于挂起状态,当服务器端有内容更新时,再返回该响应。因此,服务器端一旦有更新,就可以立即反馈给客户端。</li>
<li>内容上虽然可以做到实时更新,但为了保留响应,一次连接的持续时间也变长了。期间,为了维持连接会消耗更多的资源。另外,Comet也仍未解决 HTTP 协议本身存在的问题。</li>
</ul>
</li>
</ul>
<h3 id="2-使用浏览器进行全双工通信的-WebSocket"><a href="#2-使用浏览器进行全双工通信的-WebSocket" class="headerlink" title="2. 使用浏览器进行全双工通信的 WebSocket"></a>2. 使用浏览器进行全双工通信的 WebSocket</h3><ul>
<li><p>利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题在于通信若使用 HTTP 协议,就无法彻底解决瓶颈问题。WebSocket网络技术正是为解决这些问题而实现的一套新协议及 API。</p>
</li>
<li><p>WebSocket 协议</p>
<ul>
<li>一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接,之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML 或图片等任意格式的数据。</li>
<li>由于是建立在 HTTP 基础上的协议,因此连接的发起方仍是客户端,而一旦确立 WebSocket 通信连接,不论服务器还是客户端,任意一方都可直接向对方发送报文。</li>
</ul>
</li>
<li><p>WebSocket 协议的主要特点。</p>
<ul>
<li>推送功能<br>支持由服务器向客户端推送数据的推送功能。这样,服务器可直接发送数据,而不必等待客户端的请求。</li>
<li>减少通信量<br>只要建立起 WebSocket 连接,就希望一直保持连接状态。和 HTTP 相比,不但每次连接时的总开销减少,而且由于 WebSocket 的首部信息很小,通信量也相应减少了。</li>
<li>握手<br>为了实现 WebSocket 通信,在 HTTP 连接建立之后,需要完成一次“握手”(Handshaking)的步骤。<ul>
<li>握手·请求<br>为了实现 WebSocket 通信,需要用到 HTTP 的 Upgrade 首部字段,告知服务器通信协议发生改变,以达到握手的目的。<br>Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值。<br>Sec-WebSocket-Protocol 字段内记录使用的子协议。子协议按 WebSocket 协议标准在连接分开使用时,定义那些连接的名称。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ&#x3D;&#x3D;</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></li>
<li>握手·响应<br>对于之前的请求,返回状态码 101 Switching Protocols 的响应。<br>Sec-WebSocket-Accept 的字段值是由握手请求中的 Sec-WebSocket-Key 的字段值生成的。<br>成功握手确立 WebSocket 连接之后,通信时不再使用 HTTP 的数据帧,而采用 WebSocket 独立的数据帧。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第10章：构建-Web-内容的技术"><a href="#第10章：构建-Web-内容的技术" class="headerlink" title="第10章：构建 Web 内容的技术"></a>第10章：构建 Web 内容的技术</h1><h3 id="1-HTML-CSS-JS"><a href="#1-HTML-CSS-JS" class="headerlink" title="1. HTML/CSS/JS"></a>1. HTML/CSS/JS</h3><h3 id="2-Web-应用"><a href="#2-Web-应用" class="headerlink" title="2. Web 应用"></a>2. Web 应用</h3><ul>
<li>Web 应用是指通过 Web 功能提供的应用程序。比如购物网站、网上银行、SNS、BBS、搜索引擎和 e-learning 等。互联网(Internet)或企业内网(Intranet)上遍布各式各样的 Web 应用。原本应用 HTTP 协议的 Web 的机制就是对客户端发来的请求,返回事前准备好的内容。可随着 Web 越来越普及,仅靠这样的做法已不足以应对所有的需求,更需要引入由程序创建 HTML 内容的做法。</li>
</ul>
<h5 id="1-与-Web-服务器及程序协作的-CGI"><a href="#1-与-Web-服务器及程序协作的-CGI" class="headerlink" title="1. 与 Web 服务器及程序协作的 CGI"></a>1. 与 Web 服务器及程序协作的 CGI</h5><ul>
<li>CGI(Common Gateway Interface,通用网关接口)是指 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在 CGI 的作用下,程序会对请求内容做出相应的动作,比如创建 HTML 等动态内容。</li>
<li>使用 CGI 的程序叫做 CGI 程序,通常是用 Perl、PHP、Ruby 和 C 等编程语言编写而成。</li>
</ul>
<h5 id="2-因-Java-而普及的-Servlet"><a href="#2-因-Java-而普及的-Servlet" class="headerlink" title="2. 因 Java 而普及的 Servlet"></a>2. 因 Java 而普及的 Servlet</h5><ul>
<li>Servlet 是一种能在服务器上创建动态内容的程序。Servlet 是用 Java语言实现的一个接口,属于面向企业级 Java(JavaEE,Java Enterprise Edition)的一部分</li>
<li>CGI,由于每次接到请求,程序都要跟着启动一次。因此一旦访问量过大,Web 服务器要承担相当大的负载。而 Servlet 运行在与 Web 服务器相同的进程中,因此受到的负载较小。Servlet 的运行环境叫做 Web 容器或 Servlet 容器。</li>
<li>随着 CGI 的普及,每次请求都要启动新 CGI 程序的 CGI 运行机制逐渐变成了性能瓶颈,所以之后 Servlet 和 mod_perl 等可直接在 Web 服务器上运行的程序才得以开发、普及。</li>
</ul>
<h3 id="3-数据发布的格式及语言"><a href="#3-数据发布的格式及语言" class="headerlink" title="3. 数据发布的格式及语言"></a>3. 数据发布的格式及语言</h3><h5 id="1-XML"><a href="#1-XML" class="headerlink" title="1. XML"></a>1. XML</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;研讨会 编号&#x3D;&quot;TR001&quot; 主题&#x3D;&quot;Web应用程序脆弱性诊断讲座&quot;&gt;</span><br><span class="line">    &lt;类别&gt;安全&lt;&#x2F;类别&gt;</span><br><span class="line">    &lt;概要&gt;为深入研究Web应用程序脆弱性诊断必要的...&lt;&#x2F;概要&gt;</span><br><span class="line">&lt;&#x2F;研讨会&gt;</span><br><span class="line">&lt;研讨会 编号&#x3D;&quot;TR002&quot; 主题&#x3D;&quot;网络系统脆弱性诊断讲座&quot;&gt;</span><br><span class="line">    &lt;类别&gt;安全&lt;&#x2F;类别&gt;</span><br><span class="line">    &lt;概要&gt;为深入研究网络系统脆弱性诊断必要的...&lt;&#x2F;概要&gt;</span><br><span class="line">&lt;&#x2F;研讨会&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-JSON"><a href="#2-JSON" class="headerlink" title="2. JSON"></a>2. JSON</h5><ul>
<li>JSON(JavaScript Object Notation)是一种以JavaScript(ECMAScript)的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有 false/null/true/ 对象 / 数组 / 数字 / 字符串,这 7 种类型。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Web Application Security&quot;,</span><br><span class="line">    &quot;num&quot;: &quot;TR001&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="3-发布更新信息的-RSS-Atom"><a href="#3-发布更新信息的-RSS-Atom" class="headerlink" title="3. 发布更新信息的 RSS/Atom"></a>3. 发布更新信息的 RSS/Atom</h5><ul>
<li>RSS(简易信息聚合,也叫聚合内容)和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了 XML。</li>
</ul>
<h1 id="第11章：Web-的攻击技术"><a href="#第11章：Web-的攻击技术" class="headerlink" title="第11章：Web 的攻击技术"></a>第11章：Web 的攻击技术</h1><h3 id="0-说明"><a href="#0-说明" class="headerlink" title="0. 说明"></a>0. 说明</h3><ul>
<li>因对安全知识了解不多，本章只是做了个大概的笔记，对很多还不懂。</li>
</ul>
<h3 id="1-针对-Web-应用的攻击模式"><a href="#1-针对-Web-应用的攻击模式" class="headerlink" title="1. 针对 Web 应用的攻击模式"></a>1. 针对 Web 应用的攻击模式</h3><h5 id="以服务器为目标的主动攻击"><a href="#以服务器为目标的主动攻击" class="headerlink" title="以服务器为目标的主动攻击"></a>以服务器为目标的主动攻击</h5><ul>
<li>主动攻击(active attack)是指攻击者通过直接访问 Web 应用,把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击,因此攻击者需要能够访问到那些资源。</li>
<li>主动攻击模式里具有代表性的攻击是 SQL 注入攻击和 OS 命令注入攻击。</li>
</ul>
<h5 id="以服务器为目标的被动攻击"><a href="#以服务器为目标的被动攻击" class="headerlink" title="以服务器为目标的被动攻击"></a>以服务器为目标的被动攻击</h5><ul>
<li>被动攻击(passive attack)是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中,攻击者不直接对目标 Web 应用访问发起攻击。</li>
<li>攻击模式<ul>
<li>步骤 1: 攻击者诱使用户触发已设置好的陷阱,而陷阱会启动发送已嵌入攻击代码的 HTTP 请求。</li>
<li>步骤 2: 当用户不知不觉中招之后,用户的浏览器或邮件客户端就会触发这个陷阱。</li>
<li>步骤 3: 中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用,运行攻击代码。</li>
<li>步骤 4: 执行完攻击代码,存在安全漏洞的 Web 应用会成为攻击者的跳板,可能导致用户所持的 Cookie 等个人信息被窃取,登录状态中的用户权限遭恶意滥用等后果。</li>
<li>被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。</li>
</ul>
</li>
<li>利用用户的身份攻击企业内部网络<ul>
<li>利用被动攻击,可发起对原本从互联网上无法直接访问的企业内网等网络的攻击。只要用户踏入攻击者预先设好的陷阱,在用户能够访问到的网络范围内,即使是企业内网也同样会受到攻击。</li>
<li>很多企业内网依然可以连接到互联网上,访问 Web 网站,或接收互联网发来的邮件。这样就可能给攻击者以可乘之机,诱导用户触发陷阱后对企业内网发动攻击。</li>
</ul>
</li>
</ul>
<h3 id="2-因输出值转义不完全引发的安全漏洞"><a href="#2-因输出值转义不完全引发的安全漏洞" class="headerlink" title="2. 因输出值转义不完全引发的安全漏洞"></a>2. 因输出值转义不完全引发的安全漏洞</h3><ul>
<li>实施 Web 应用的安全对策可大致分为以下两部分。<ul>
<li>客户端的验证</li>
<li>Web 应用端(服务器端)的验证<ul>
<li>输入值验证</li>
<li>输出值转义</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h5><ul>
<li>跨站脚本攻击(Cross-Site Scripting,XSS)是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。</li>
<li>跨站脚本攻击有可能造成以下影响<ul>
<li>利用虚假输入表单骗取用户个人信息。</li>
<li>利用脚本窃取用户的 Cookie 值,被害者在不知情的情况下,帮助攻击者发送恶意请求。</li>
<li>显示伪造的文章或图片。</li>
<li>对用户 Cookie 的窃取攻击</li>
</ul>
</li>
</ul>
<h5 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h5><ul>
<li>会执行非法 SQL 的 SQL 注入攻击<br>  例如查询到用户密码</li>
</ul>
<h5 id="OS-命令注入攻击"><a href="#OS-命令注入攻击" class="headerlink" title="OS 命令注入攻击"></a>OS 命令注入攻击</h5><ul>
<li>OS 命令注入攻击(OS Command Injection)是指通过 Web 应用,执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。</li>
</ul>
<h5 id="HTTP-首部注入攻击"><a href="#HTTP-首部注入攻击" class="headerlink" title="HTTP 首部注入攻击"></a>HTTP 首部注入攻击</h5><ul>
<li>HTTP 首部注入攻击(HTTP Header Injection)是指攻击者通过在响应首部字段内插入换行,添加任意响应首部或主体的一种攻击。属于被动攻击模式</li>
<li>HTTP 首部注入攻击有可能会造成以下一些影响<ul>
<li>设置任何 Cookie 信息</li>
<li>重定向至任意 URL</li>
<li>显示任意的主体(HTTP 响应截断攻击)</li>
<li>HTTP 响应截断攻击</li>
</ul>
</li>
</ul>
<h5 id="邮件首部注入攻击"><a href="#邮件首部注入攻击" class="headerlink" title="邮件首部注入攻击"></a>邮件首部注入攻击</h5><ul>
<li>邮件首部注入(Mail Header Injection)是指 Web 应用中的邮件发送功能,攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。利用存在安全漏洞的 Web 网站,可对任意邮件地址发送广告邮件或病毒邮件。</li>
</ul>
<h5 id="目录遍历攻击"><a href="#目录遍历攻击" class="headerlink" title="目录遍历攻击"></a>目录遍历攻击</h5><ul>
<li>目录遍历(Directory Traversal)攻击是指对本无意公开的文件目录,通过非法截断其目录路径后,达成访问目的的一种攻击。这种攻击有时也称为路径遍历(Path Traversal)攻击。</li>
</ul>
<h5 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h5><ul>
<li>远程文件包含漏洞(Remote File Inclusion)是指当部分脚本内容需要从其他文件读入时,攻击者利用指定外部服务器的 URL 充当依赖文件,让脚本读取之后,就可运行任意脚本的一种攻击。</li>
</ul>
<h3 id="3-因设置或设计上的缺陷引发的安全漏洞"><a href="#3-因设置或设计上的缺陷引发的安全漏洞" class="headerlink" title="3. 因设置或设计上的缺陷引发的安全漏洞"></a>3. 因设置或设计上的缺陷引发的安全漏洞</h3><h5 id="强制浏览"><a href="#强制浏览" class="headerlink" title="强制浏览"></a>强制浏览</h5><ul>
<li>强制浏览有可能会造成以下一些影响。<ul>
<li>泄露顾客的个人信息等重要情报</li>
<li>泄露原本需要具有访问权限的用户才可查阅的信息内容</li>
<li>泄露未外连到外界的文件</li>
</ul>
</li>
<li>对那些原本不愿公开的文件,为了保证安全会隐蔽其 URL。可一旦知道了那些 URL,也就意味着可浏览 URL 对应的文件。直接显示容易推测的文件名或文件目录索引时,通过某些方法可能会使 URL 产生泄露。</li>
<li>例子<br>  如加锁日记不想让别人看，但是别人知道日记中的某个图片的存放地址，就能直接通过URL访问这个图片</li>
</ul>
<h5 id="不正确的错误消息处理"><a href="#不正确的错误消息处理" class="headerlink" title="不正确的错误消息处理"></a>不正确的错误消息处理</h5><ul>
<li>不正确的错误消息处理(Error Handling Vulnerability)的安全漏洞是指,Web 应用的错误信息内包含对攻击者有用的信息。</li>
<li>Web 应用不必在用户的浏览画面上展现详细的错误消息。对攻击者来说,详细的错误消息有可能给他们下一次攻击以提示。</li>
<li>与 Web 应用有关的主要错误信息如下所示。<ul>
<li>Web 应用抛出的错误消息</li>
<li>数据库等系统抛出的错误消息</li>
</ul>
</li>
</ul>
<h5 id="开放重定向"><a href="#开放重定向" class="headerlink" title="开放重定向"></a>开放重定向</h5><ul>
<li>开放重定向(Open Redirect)是一种对指定的任意 URL 作重定向跳转的功能。而于此功能相关联的安全漏洞是指,假如指定的重定向 URL到某个具有恶意的 Web 网站,那么用户就会被诱导至那个 Web 网站。</li>
</ul>
<h3 id="4-因会话管理疏忽引发的安全漏洞"><a href="#4-因会话管理疏忽引发的安全漏洞" class="headerlink" title="4. 因会话管理疏忽引发的安全漏洞"></a>4. 因会话管理疏忽引发的安全漏洞</h3><h5 id="会话劫持"><a href="#会话劫持" class="headerlink" title="会话劫持"></a>会话劫持</h5><ul>
<li>会话劫持(Session Hijack)是指攻击者通过某种手段拿到了用户的会话 ID,并非法使用此会话 ID 伪装成用户,达到攻击的目的。</li>
<li>几种攻击者可获得会话 ID 的途径。<ul>
<li>通过非正规的生成方法推测会话 ID</li>
<li>通过窃听或 XSS 攻击盗取会话 ID</li>
<li>通过会话固定攻击(Session Fixation)强行获取会话 ID</li>
</ul>
</li>
</ul>
<h5 id="会话固定攻击"><a href="#会话固定攻击" class="headerlink" title="会话固定攻击"></a>会话固定攻击</h5><ul>
<li>对以窃取目标会话 ID 为主动攻击手段的会话劫持而言,会话固定攻击(Session Fixation)攻击会强制用户使用攻击者指定的会话 ID,属于被动攻击。</li>
</ul>
<h5 id="跨站点请求伪造"><a href="#跨站点请求伪造" class="headerlink" title="跨站点请求伪造"></a>跨站点请求伪造</h5><ul>
<li>跨站点请求伪造(Cross-Site Request Forgeries,CSRF)攻击是指攻击者通过设置好的陷阱,强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新,属于被动攻击。</li>
<li>跨站点请求伪造有可能会造成以下等影响。<ul>
<li>利用已通过认证的用户权限更新设定信息等</li>
<li>利用已通过认证的用户权限购买商品</li>
<li>利用已通过认证的用户权限在留言板上发表言论</li>
</ul>
</li>
</ul>
<h3 id="5-其他安全漏洞"><a href="#5-其他安全漏洞" class="headerlink" title="5. 其他安全漏洞"></a>5. 其他安全漏洞</h3><h5 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h5><ul>
<li>通过网络的密码试错<ul>
<li>穷举法,全试一遍</li>
<li>字典攻击，构造好密码字典，一一尝试</li>
</ul>
</li>
<li>对已加密密码的破解(指攻击者入侵系统,已获得加密或散列处理的密码数据的情况)</li>
</ul>
<h5 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h5><ul>
<li>点击劫持(Clickjacking)是指利用透明的按钮或链接做成陷阱,覆盖在 Web 页面之上。然后诱使用户在不知情的情况下,点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing)。</li>
</ul>
<h5 id="DoS-攻击"><a href="#DoS-攻击" class="headerlink" title="DoS 攻击"></a>DoS 攻击</h5><ul>
<li>DoS 攻击(Denial of Service attack)是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站,还包括网络设备及服务器等。</li>
<li>主要有以下两种 DoS 攻击方式。<ul>
<li>集中利用访问请求造成资源过载,资源用尽的同时,实际上服务也就呈停止状态。</li>
<li>通过攻击安全漏洞使服务停止。</li>
</ul>
</li>
</ul>
<h5 id="后门程序"><a href="#后门程序" class="headerlink" title="后门程序"></a>后门程序</h5><ul>
<li>后门程序(Backdoor)是指开发设置的隐藏入口,可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。</li>
<li>通常的后门程序分为以下 3 种类型。<ul>
<li>开发阶段作为 Debug 调用的后门程序</li>
<li>开发者为了自身利益植入的后门程序</li>
<li>攻击者通过某种方法设置的后门程序</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL必知必会》</title>
    <url>/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/</url>
    <content><![CDATA[<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ol>
<li>虽然去年上过数据库的课，但是发现基本只是学了增删该查的语句而已，优化什么的，还有很多要学的。</li>
<li>这本书更教导实践，上课时学的更多的理论</li>
</ol>
<a id="more"></a>
<h1 id="第一章：了解SQL"><a href="#第一章：了解SQL" class="headerlink" title="第一章：了解SQL"></a>第一章：了解SQL</h1><h3 id="1-数据库基础"><a href="#1-数据库基础" class="headerlink" title="1. 数据库基础"></a>1. 数据库基础</h3><ul>
<li>表</li>
<li>模式<ul>
<li>关于数据库和表的布局及特性的信息</li>
</ul>
</li>
<li>列和数据类型</li>
<li>行</li>
<li>主键<ul>
<li>对行来说，唯一不为NULL</li>
<li>每个表都应该定义</li>
<li>对列来说，可以有多个主键，即主键不唯一。</li>
</ul>
</li>
</ul>
<h3 id="2-SQL"><a href="#2-SQL" class="headerlink" title="2. SQL"></a>2. SQL</h3><ul>
<li>结构化查询语言 Structured Query Language</li>
<li>SQL不是某个特定数据库供应商专有的语言，几乎所有重要的DBMS都支持SQL</li>
<li>但各个数据库的SQL并不完全相同，有细微差别</li>
</ul>
<h1 id="第二章：MySQL简介"><a href="#第二章：MySQL简介" class="headerlink" title="第二章：MySQL简介"></a>第二章：MySQL简介</h1><h3 id="1-DBMS分为两类"><a href="#1-DBMS分为两类" class="headerlink" title="1. DBMS分为两类"></a>1. DBMS分为两类</h3><ul>
<li>基于共享文件系统的DBMS<ul>
<li>如Microsoft Access和FileMaker</li>
<li>用于桌面用途，通常不用于高端或更关键的应用</li>
</ul>
</li>
<li>基于客户机-服务器的DBMS<ul>
<li>如MySQL,Oracle等</li>
<li>服务器部分是负责所有数据访问和处理的一个软件，把请求的结果送回客户机软件</li>
<li>客户机可以是MySQL提供的工具，脚本语言，Web应用开发语言，程序设计语言等<h3 id="2-工具"><a href="#2-工具" class="headerlink" title="2. 工具"></a>2. 工具</h3></li>
</ul>
</li>
<li>命令行</li>
<li>图形界面</li>
</ul>
<h1 id="第三章：使用MySQL"><a href="#第三章：使用MySQL" class="headerlink" title="第三章：使用MySQL"></a>第三章：使用MySQL</h1><h3 id="1-连接"><a href="#1-连接" class="headerlink" title="1. 连接"></a>1. 连接</h3><ul>
<li><p>需要的信息</p>
<ul>
<li>主机名，本地localhost</li>
<li>端口，默认3306</li>
<li>用户名</li>
<li>密码<h3 id="2-选择数据库"><a href="#2-选择数据库" class="headerlink" title="2. 选择数据库"></a>2. 选择数据库</h3></li>
</ul>
</li>
<li><p>切换数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输入</span><br><span class="line">use student &#x2F;&#x2F;切换到student数据库</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-了解数据库和表"><a href="#3-了解数据库和表" class="headerlink" title="3. 了解数据库和表"></a>3. 了解数据库和表</h3><ul>
<li><p>显示数据库信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输入</span><br><span class="line">show database;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示表信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输入</span><br><span class="line">show tablename;</span><br></pre></td></tr></table></figure></li>
<li><p>显示列信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show colume from tablename;</span><br></pre></td></tr></table></figure></li>
<li><p>其他show</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status; &#x2F;&#x2F;显示广泛的服务器状态信息</span><br><span class="line">show grants; &#x2F;&#x2F;显示授予用户的安全权限</span><br><span class="line">show errors;</span><br><span class="line">show warnings; &#x2F;&#x2F;显示服务器错误或警告消息</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第四章：检索数据"><a href="#第四章：检索数据" class="headerlink" title="第四章：检索数据"></a>第四章：检索数据</h1><h3 id="1-检索单个列"><a href="#1-检索单个列" class="headerlink" title="1. 检索单个列"></a>1. 检索单个列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student;</span><br></pre></td></tr></table></figure>
<ul>
<li>以分号结束<h3 id="2-检索多个列"><a href="#2-检索多个列" class="headerlink" title="2. 检索多个列"></a>2. 检索多个列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,id,sex</span><br><span class="line">from student;</span><br></pre></td></tr></table></figure>
<h3 id="3-检索所有列"><a href="#3-检索所有列" class="headerlink" title="3. 检索所有列"></a>3. 检索所有列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from student;</span><br></pre></td></tr></table></figure></li>
<li>一般，除非确定要检索每个列，要不然不要使用*通配符，这样会降低检索和应用程序的性能</li>
<li>*的优点是能检索出名字未知的列</li>
</ul>
<h3 id="4-检索不同的行，distinct"><a href="#4-检索不同的行，distinct" class="headerlink" title="4. 检索不同的行，distinct"></a>4. 检索不同的行，distinct</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct name</span><br><span class="line">from student;</span><br></pre></td></tr></table></figure>
<ul>
<li>distinct能去掉重复的行，这样显示出来的就没有重名的了</li>
</ul>
<h3 id="5-限制结果，limit"><a href="#5-限制结果，limit" class="headerlink" title="5. 限制结果，limit"></a>5. 限制结果，limit</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">limit 5;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回不多于5行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">limit 5,5;</span><br></pre></td></tr></table></figure></li>
<li>为得出下一个5行，指明开始行和行数</li>
<li>新语法：limit 4 offset 3<br>  等价于 limit 4,3</li>
</ul>
<h3 id="6-使用完全限定的表名"><a href="#6-使用完全限定的表名" class="headerlink" title="6. 使用完全限定的表名"></a>6. 使用完全限定的表名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select student.name</span><br><span class="line">from student;</span><br></pre></td></tr></table></figure>

<h1 id="第五章：排序检索数据"><a href="#第五章：排序检索数据" class="headerlink" title="第五章：排序检索数据"></a>第五章：排序检索数据</h1><h3 id="1-排序数据，order-by"><a href="#1-排序数据，order-by" class="headerlink" title="1. 排序数据，order by"></a>1. 排序数据，order by</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">order by name;</span><br></pre></td></tr></table></figure>
<ul>
<li>若不排序，数据一般将以它在底层表中出现的顺序显示。若增删后，顺序会发生变化</li>
</ul>
<h3 id="2-按多个列排序"><a href="#2-按多个列排序" class="headerlink" title="2. 按多个列排序"></a>2. 按多个列排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">order by name,id;</span><br></pre></td></tr></table></figure>
<ul>
<li>先按照name，再按照id排序</li>
</ul>
<h3 id="3-指定排序方向-desc-asc"><a href="#3-指定排序方向-desc-asc" class="headerlink" title="3. 指定排序方向,desc/asc"></a>3. 指定排序方向,desc/asc</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">order by name desc,id;</span><br></pre></td></tr></table></figure>
<ul>
<li>desc为降序，默认为asc升序</li>
<li>例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;找出最贵的</span><br><span class="line">select name</span><br><span class="line">from product</span><br><span class="line">order by price desc</span><br><span class="line">limit 1;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第六章：过滤数据"><a href="#第六章：过滤数据" class="headerlink" title="第六章：过滤数据"></a>第六章：过滤数据</h1><h3 id="1-使用where子句"><a href="#1-使用where子句" class="headerlink" title="1. 使用where子句"></a>1. 使用where子句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from product</span><br><span class="line">where price&#x3D;10.0;</span><br></pre></td></tr></table></figure>
<ul>
<li>同时使用where和order by时，where必须在前面</li>
<li>数据也可以在应用层过滤，把所有数据检索到，写代码过滤数据，但是效率低，不推荐</li>
</ul>
<h3 id="2-where子句操作符"><a href="#2-where子句操作符" class="headerlink" title="2. where子句操作符"></a>2. where子句操作符</h3><table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
</tbody></table>
<blockquote>
<p>|大于<br>=|大于等于<br>between|两个指定值之间</p>
</blockquote>
<ul>
<li><p>匹配检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from product</span><br><span class="line">where price&lt;&#x3D;10.0;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不匹配检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查找价格不为10.0的物品名</span><br><span class="line">select name</span><br><span class="line">from product</span><br><span class="line">where price&lt;&gt;10.0;</span><br></pre></td></tr></table></figure></li>
<li><p>范围值检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from product</span><br><span class="line">where price between 5.0 and 10.0;</span><br></pre></td></tr></table></figure></li>
<li><p>空值检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;空值不是price&#x3D;0</span><br><span class="line">select name</span><br><span class="line">from product</span><br><span class="line">where price is null;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第七章-数据过滤-进阶"><a href="#第七章-数据过滤-进阶" class="headerlink" title="第七章:数据过滤(进阶)"></a>第七章:数据过滤(进阶)</h1><h3 id="1-组合where子句，and-or"><a href="#1-组合where子句，and-or" class="headerlink" title="1. 组合where子句，and/or"></a>1. 组合where子句，and/or</h3><ul>
<li><p>and</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where grade&#x3D;100 and sex&#x3D;male;</span><br></pre></td></tr></table></figure>
</li>
<li><p>or</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where grade&#x3D;100 or sex&#x3D;male;</span><br></pre></td></tr></table></figure></li>
<li><p>计算次序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where grade&#x3D;100 or grade&#x3D;99 and sex&#x3D;male;</span><br><span class="line">&#x2F;&#x2F;这样会先计算and，再计算or，想用or应该括起来</span><br><span class="line">where (grade&#x3D;100 or grade&#x3D;99) and sex&#x3D;male;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-in-操作符"><a href="#2-in-操作符" class="headerlink" title="2. in 操作符"></a>2. in 操作符</h3><ul>
<li>in 操作符用来指定条件范<br>围,范围中的每个条件都可以进行匹配。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where grade in (99,100);</span><br></pre></td></tr></table></figure></li>
<li>为什么用in不用or<ul>
<li>在选项较多时,in更清晰明了</li>
<li>in一般比or执行更快</li>
<li>in里面也可以用where</li>
</ul>
</li>
</ul>
<h3 id="3-not-操作符"><a href="#3-not-操作符" class="headerlink" title="3. not 操作符"></a>3. not 操作符</h3><ul>
<li>否定它之后所跟的任何条件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where grade in (99,100);</span><br></pre></td></tr></table></figure></li>
<li>mysql支持not 对in,between,exists取反，这和多数其他的DBMS有区别</li>
</ul>
<h1 id="第八章：用通配符进行过滤"><a href="#第八章：用通配符进行过滤" class="headerlink" title="第八章：用通配符进行过滤"></a>第八章：用通配符进行过滤</h1><h3 id="1-like-操作符"><a href="#1-like-操作符" class="headerlink" title="1. like 操作符"></a>1. like 操作符</h3><h5 id="百分号-通配符"><a href="#百分号-通配符" class="headerlink" title="百分号 % 通配符"></a>百分号 % 通配符</h5><ul>
<li>在搜索串中, % 表示任何字符出现任意次数。例如,为了找出所有高姓的名字,可使用以下 SELECT语句:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where name like &#39;吕%&#39;;</span><br></pre></td></tr></table></figure></li>
<li>名字中带‘钰’的人<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where name like &#39;%潇%&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="下划线-通配符"><a href="#下划线-通配符" class="headerlink" title="下划线 _ 通配符"></a>下划线 _ 通配符</h5><ul>
<li>下划线的用途与 % 一样,但下划线只匹配单个字符而不是多个字符。</li>
<li>匹配 高某，_匹配任意一个字，不能多也不能少，%可以匹配0到多个<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where name like &#39;吕_&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-使用通配符的技巧"><a href="#2-使用通配符的技巧" class="headerlink" title="2. 使用通配符的技巧"></a>2. 使用通配符的技巧</h3><ul>
<li>通配符的处理一般比其他搜索花时间更长</li>
<li>一些技巧<ul>
<li>不要过度使用通配符，如果其他操作符能达到目的，就用其他的。</li>
<li>在确实需要通配符时，除非有必要，否则不要放在搜索模式的开始处。放在开始处搜索起来最慢</li>
</ul>
</li>
</ul>
<h1 id="第九章：用正则表达式进行搜索"><a href="#第九章：用正则表达式进行搜索" class="headerlink" title="第九章：用正则表达式进行搜索"></a>第九章：用正则表达式进行搜索</h1><h3 id="MySQL正则表达式"><a href="#MySQL正则表达式" class="headerlink" title="MySQL正则表达式"></a>MySQL正则表达式</h3><ul>
<li>MySQL正则表达是并不是支持所有的正则语法</li>
</ul>
<h5 id="基本字符匹配"><a href="#基本字符匹配" class="headerlink" title="基本字符匹配"></a>基本字符匹配</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where name regexp &#39;aaa&#39;;</span><br><span class="line">&#x2F;&#x2F;这个并不是只匹配 ‘aaa’,而是匹配所有名字中带aaa的，例如</span><br><span class="line">ccaaaasf</span><br><span class="line">aaasaf</span><br><span class="line">sadaaa</span><br></pre></td></tr></table></figure>
<ul>
<li>默认的regexp不区分大小写，若想区分要加binary<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where name regexp binary &#39;AAA&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="其他的一些正则表达式规则"><a href="#其他的一些正则表达式规则" class="headerlink" title="其他的一些正则表达式规则"></a>其他的一些正则表达式规则</h5><ul>
<li>因为这些规则本人已经掌握的差不多了，所以不再赘述，直接列出来MySQL支持哪些</li>
<li>or匹配<ul>
<li>a|b</li>
</ul>
</li>
<li>匹配几个字符之一<ul>
<li>[abc]</li>
</ul>
</li>
<li>匹配范围<ul>
<li>[a-z]</li>
<li>[0-9]</li>
</ul>
</li>
<li>匹配特殊字符<ul>
<li>要加两个\转义</li>
<li>\. 表示匹配.</li>
</ul>
</li>
<li>匹配字符类</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[:alnum:]</td>
<td>任意字母和数字(同[a-zA-Z0-9])</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>任意字符(同[a-zA-Z])</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空格和制表(同[\t])</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>ASCII控制字符(ASCII 0到31和127)</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>任意数字(同[0-9])</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>与[:print:]相同,但不包括空格</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>任意小写字母(同[a-z])</td>
</tr>
<tr>
<td>[:print:]</td>
<td>任意可打印字符</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>既不在[:alnum:]又不在[:cntrl:]中的任意字符</td>
</tr>
<tr>
<td>[:space:]</td>
<td>包括空格在内的任意空白字符(同[\f\n\r\t\v])</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>任意大写字母(同[A-Z])</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>任意十六进制数字(同[a-fA-F0-9])</td>
</tr>
</tbody></table>
<ul>
<li>匹配多个实例</li>
</ul>
<table>
<thead>
<tr>
<th>元 字 符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>0个或多个匹配</td>
</tr>
<tr>
<td>+</td>
<td>1个或多个匹配(等于{1,})</td>
</tr>
<tr>
<td>?</td>
<td>0个或1个匹配(等于{0,1})</td>
</tr>
<tr>
<td>{n}</td>
<td>指定数目的匹配</td>
</tr>
<tr>
<td>{n,}</td>
<td>不少于指定数目的匹配</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配数目的范围(m不超过255)</td>
</tr>
</tbody></table>
<ul>
<li>定位符</li>
</ul>
<table>
<thead>
<tr>
<th>元 字 符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>文本的开始</td>
</tr>
<tr>
<td>$</td>
<td>文本的结尾</td>
</tr>
<tr>
<td>[[:&lt;:]]</td>
<td>词的开始</td>
</tr>
<tr>
<td>[[:&gt;:]]</td>
<td>词的结尾</td>
</tr>
</tbody></table>
<h1 id="第十章：创建计算字段"><a href="#第十章：创建计算字段" class="headerlink" title="第十章：创建计算字段"></a>第十章：创建计算字段</h1><h3 id="1-拼接字段，Concat"><a href="#1-拼接字段，Concat" class="headerlink" title="1. 拼接字段，Concat()"></a>1. 拼接字段，Concat()</h3><ul>
<li>多数DBMS使用 + 或 || 来实现拼接，MySQL使用Concat()函数来实现<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select Concat(name,&#39;-&#39;,sex)</span><br><span class="line">from student</span><br><span class="line">order by name;</span><br><span class="line">&#x2F;&#x2F;结果为：</span><br><span class="line">aname-male</span><br><span class="line">bname-female</span><br></pre></td></tr></table></figure></li>
<li>Rtrim()函数去掉值右边的所有空格<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select Concat(Rtrim(name),&#39;-&#39;,Rtrim(sex))</span><br><span class="line">from student</span><br><span class="line">order by name;</span><br></pre></td></tr></table></figure>
<h5 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h5></li>
<li>若如上面拼接，只能查看，不能使用，要想使用得用别名</li>
<li>别名是一个值或字段的替换名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select Concat(Rtrim(name),&#39;-&#39;,Rtrim(sex))</span><br><span class="line">as name_sex</span><br><span class="line">from student</span><br><span class="line">order by name;</span><br></pre></td></tr></table></figure></li>
<li>别名也称作导出列</li>
</ul>
<h3 id="2-执行算术计算"><a href="#2-执行算术计算" class="headerlink" title="2. 执行算术计算"></a>2. 执行算术计算</h3><ul>
<li>MySQL支持的基本运算符</li>
</ul>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
</table>
<ul>
<li>|加</li>
</ul>
<ul>
<li>|减</li>
</ul>
<ul>
<li>|乘<br>/ |除</li>
</ul>
<ul>
<li>例如知道单价和数量，求总价格<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select a_price,num,a_price*num</span><br><span class="line">as expanded_price</span><br><span class="line">from product</span><br><span class="line">where id&#x3D;111;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第十一章：使用数据处理函数"><a href="#第十一章：使用数据处理函数" class="headerlink" title="第十一章：使用数据处理函数"></a>第十一章：使用数据处理函数</h1><h3 id="1-SQL函数"><a href="#1-SQL函数" class="headerlink" title="1. SQL函数"></a>1. SQL函数</h3><ul>
<li><p>函数的可移植性差，各个DBMS支持的函数可能不相同</p>
</li>
<li><p>大多数SQL实现支持以下类型的函数</p>
<ul>
<li>用于处理文本串的文本函数</li>
<li>用于在数值数据上进行算术操作的数值函数</li>
<li>用于处理日期和时间值并从这些值中提取特定成分的日期和时间函数</li>
<li>返回DBMS正使用的特殊信息的系统函数，如用户的登录信息，检查版本细节</li>
</ul>
</li>
</ul>
<h3 id="2-文本处理函数"><a href="#2-文本处理函数" class="headerlink" title="2. 文本处理函数"></a>2. 文本处理函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Left()</td>
<td>返回串左边的字符</td>
</tr>
<tr>
<td>Length()</td>
<td>返回串的长度</td>
</tr>
<tr>
<td>Locate()</td>
<td>找出串的一个子串</td>
</tr>
<tr>
<td>Lower()</td>
<td>将串转换为小写</td>
</tr>
<tr>
<td>Upper()</td>
<td>将串转换为大写</td>
</tr>
<tr>
<td>LTrim()</td>
<td>去掉串左边的空格</td>
</tr>
<tr>
<td>RTrim()</td>
<td>去掉串右边的空格</td>
</tr>
<tr>
<td>Right()</td>
<td>返回串右边的字符</td>
</tr>
<tr>
<td>Soundex()</td>
<td>返回串的SOUNDEX值</td>
</tr>
<tr>
<td>SubString()</td>
<td>返回子串的字符</td>
</tr>
</tbody></table>
<ul>
<li>使用方法上面已经演示</li>
<li>SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法<br>SOUNDEX考虑的类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。</li>
<li>SOUNDEX不是SQL概念，但多数DBMS都提供对SOUNDEX的支持</li>
<li>SOUNDEX例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">customers 表中有一个顾客 Coyote Inc. ,其联系名为 Y.Lee 。</span><br><span class="line">但如果这是输入错误,此联系名实际应该是 Y.Lie ,怎么办?</span><br><span class="line">显然,按正确的联系名搜索不会返回数据,如下所示:</span><br><span class="line">    select sex</span><br><span class="line">    from customers</span><br><span class="line">    where name&#x3D;&#39;Y.Lee&#39;;</span><br><span class="line">    &#x2F;&#x2F;输错了，没有Y.Lee,想要搜的是Y.Lie</span><br></pre></td></tr></table></figure></li>
<li>可以用Soundex()函数解决<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sex</span><br><span class="line">from customers</span><br><span class="line">where Soundex(name)&#x3D;Soundex(&#39;Y.Lee&#39;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-时间和日期处理函数"><a href="#3-时间和日期处理函数" class="headerlink" title="3. 时间和日期处理函数"></a>3. 时间和日期处理函数</h3><ul>
<li>日期和时间采用相应的数据类型和特殊的格式存储,以便能快速和有效地排序或过滤,并且节省物理存储空间。</li>
<li>常用日期和时间处理函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AddDate()</td>
<td>增加一个日期(天、周等)</td>
</tr>
<tr>
<td>AddTime()</td>
<td>增加一个时间(时、分等)</td>
</tr>
<tr>
<td>CurDate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CurTime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>Date()</td>
<td>返回日期时间的日期部分</td>
</tr>
<tr>
<td>DateDiff()</td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td>Date_Add()</td>
<td>高度灵活的日期运算函数</td>
</tr>
<tr>
<td>Date_Format()</td>
<td>返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td>Day()</td>
<td>返回一个日期的天数部分</td>
</tr>
<tr>
<td>DayOfWeek()</td>
<td>对于一个日期,返回对应的星期几</td>
</tr>
<tr>
<td>Hour()</td>
<td>返回一个时间的小时部分</td>
</tr>
<tr>
<td>Minute()</td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr>
<td>Month()</td>
<td>返回一个日期的月份部分</td>
</tr>
<tr>
<td>Now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>Second()</td>
<td>返回一个时间的秒部分</td>
</tr>
<tr>
<td>Time()</td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td>Year()</td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody></table>
<ul>
<li><p>不管是插入或更新表值还是用 WHERE 子句进行过滤,日期必须为格式yyyy-mm-dd</p>
</li>
<li><p>例子,为什么不直接用=？因为time中可能有具体的时分秒时间，这样的话和日期比较就永远不会相等，用Date()函数转成日期比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from products</span><br><span class="line">where Date(time) between &#39;2019-01-01&#39; and &#39;2019-01-10&#39;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-数值处理函数"><a href="#4-数值处理函数" class="headerlink" title="4. 数值处理函数"></a>4. 数值处理函数</h3><ul>
<li>在主要DBMS的函数中,数值函数是最一致最统一的函数</li>
<li>常用的数值处理函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Abs()</td>
<td>返回一个数的绝对值</td>
</tr>
<tr>
<td>Cos()</td>
<td>返回一个角度的余弦</td>
</tr>
<tr>
<td>Exp()</td>
<td>返回一个数的指数值</td>
</tr>
<tr>
<td>Mod()</td>
<td>返回除操作的余数</td>
</tr>
<tr>
<td>Pi()</td>
<td>返回圆周率</td>
</tr>
<tr>
<td>Rand()</td>
<td>返回一个随机数</td>
</tr>
<tr>
<td>Sin()</td>
<td>返回一个角度的正弦</td>
</tr>
<tr>
<td>Sqrt()</td>
<td>返回一个数的平方根</td>
</tr>
<tr>
<td>Tan()</td>
<td>返回一个角度的正切</td>
</tr>
</tbody></table>
<h1 id="第十二章：汇总数据"><a href="#第十二章：汇总数据" class="headerlink" title="第十二章：汇总数据"></a>第十二章：汇总数据</h1><h3 id="1-聚集函数"><a href="#1-聚集函数" class="headerlink" title="1. 聚集函数"></a>1. 聚集函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AVG()</td>
<td>返回某列的平均值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>返回某列的行数</td>
</tr>
<tr>
<td>MAX()</td>
<td>返回某列的最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>返回某列的最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>返回某列值之和</td>
</tr>
</tbody></table>
<h5 id="avg-求列平均"><a href="#avg-求列平均" class="headerlink" title="avg()求列平均"></a>avg()求列平均</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select avg(price)</span><br><span class="line">as avg_price</span><br><span class="line">from products;</span><br></pre></td></tr></table></figure>
<ul>
<li>avg忽略值为NULL的行</li>
<li>avg只能求一列，若想求多列，要多个avg</li>
</ul>
<h5 id="count-计行数"><a href="#count-计行数" class="headerlink" title="count()计行数"></a>count()计行数</h5><ul>
<li>count(*)统计行数，NULL也统计<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count(*)</span><br><span class="line">as all_num</span><br><span class="line">from products;</span><br></pre></td></tr></table></figure></li>
<li>count(column)对特定列计数，忽略NULL<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;只对price列不为NULL的计数</span><br><span class="line">select count(price)</span><br><span class="line">as have_price_num</span><br><span class="line">from products;</span><br></pre></td></tr></table></figure>
<h5 id="max-min"><a href="#max-min" class="headerlink" title="max()/min()"></a>max()/min()</h5></li>
<li>一般对值和日期使用，也可以对文本使用</li>
<li>忽略NULL</li>
</ul>
<h5 id="sum-求列值的和，count是统计行数"><a href="#sum-求列值的和，count是统计行数" class="headerlink" title="sum()求列值的和，count是统计行数"></a>sum()求列值的和，count是统计行数</h5><ul>
<li>得出订单的总金额<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sum(price*num)</span><br><span class="line">as all_price</span><br><span class="line">from orderitems</span><br></pre></td></tr></table></figure></li>
<li>忽略NULL</li>
</ul>
<h3 id="2-聚集不同值，distinct"><a href="#2-聚集不同值，distinct" class="headerlink" title="2. 聚集不同值，distinct"></a>2. 聚集不同值，distinct</h3><ul>
<li><p>统计有多少种价格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count(distinct price)</span><br><span class="line">as num_price</span><br><span class="line">from items;</span><br></pre></td></tr></table></figure>
<h3 id="3-组合聚集函数"><a href="#3-组合聚集函数" class="headerlink" title="3. 组合聚集函数"></a>3. 组合聚集函数</h3></li>
<li><p>可以使用多个函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count(distinct price) as num_price，</span><br><span class="line">min(price) as min_price</span><br><span class="line">from items;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在SQL中使用这些函数比在应用中用代码要快得多</p>
</li>
</ul>
<h1 id="第十三章：分组数据"><a href="#第十三章：分组数据" class="headerlink" title="第十三章：分组数据"></a>第十三章：分组数据</h1><h3 id="1-创建分组，group-by"><a href="#1-创建分组，group-by" class="headerlink" title="1. 创建分组，group by"></a>1. 创建分组，group by</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id,count(*) as num</span><br><span class="line">from items</span><br><span class="line">group by id;</span><br><span class="line">&#x2F;&#x2F;同一id为一组，分别统计每组的数量</span><br></pre></td></tr></table></figure>
<ul>
<li>若分组列中有NULL值，NULL单独作为一组，如果有多个NULL,这些NULL一组</li>
<li>group by必须出现在where子句之后，order by子句之前</li>
<li>使用rollup<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用 WITH ROLLUP 关键字,可以得到每个分组以及每个分组汇总级别(针对每个分组)的值,如下所示:</span><br><span class="line">    select id,count(*) as num</span><br><span class="line">    from items</span><br><span class="line">    group by id with rollup;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-过滤分组，having"><a href="#2-过滤分组，having" class="headerlink" title="2. 过滤分组，having"></a>2. 过滤分组，having</h3><ul>
<li>所学过的有关 WHERE 的所有这些技术和选项都适用于HAVING 。它们的句法是相同的,只是关键字有差别。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id,count(*) as num</span><br><span class="line">from items</span><br><span class="line">group by id</span><br><span class="line">having count(*) &gt;&#x3D; 2;</span><br></pre></td></tr></table></figure>

<h3 id="3-select-子句顺序"><a href="#3-select-子句顺序" class="headerlink" title="3. select 子句顺序"></a>3. select 子句顺序</h3><table>
<thead>
<tr>
<th>子句</th>
<th>说明</th>
<th>是否必须使用</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT</td>
<td>要返回的列或表达式</td>
<td>是</td>
</tr>
<tr>
<td>FROM</td>
<td>从中检索数据的表</td>
<td>仅在从表选择数据时使用</td>
</tr>
<tr>
<td>WHERE</td>
<td>行级过滤</td>
<td>否</td>
</tr>
<tr>
<td>GROUP BY</td>
<td>分组说明</td>
<td>仅在按组计算聚集时使用</td>
</tr>
<tr>
<td>HAVING</td>
<td>组级过滤</td>
<td>否</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>输出排序顺序</td>
<td>否</td>
</tr>
<tr>
<td>LIMIT</td>
<td>要检索的行数</td>
<td>否</td>
</tr>
</tbody></table>
<h1 id="第十四章：使用子查询"><a href="#第十四章：使用子查询" class="headerlink" title="第十四章：使用子查询"></a>第十四章：使用子查询</h1><h3 id="1-利用子查询进行过滤"><a href="#1-利用子查询进行过滤" class="headerlink" title="1. 利用子查询进行过滤"></a>1. 利用子查询进行过滤</h3><ul>
<li>找成绩等于100的学生名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from student</span><br><span class="line">where id in (</span><br><span class="line">    select id</span><br><span class="line">    from grade_table</span><br><span class="line">    where grade&#x3D;100</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-作为计算字段使用子查询"><a href="#2-作为计算字段使用子查询" class="headerlink" title="2. 作为计算字段使用子查询"></a>2. 作为计算字段使用子查询</h3><ul>
<li><p>要显示 customers表中每个客户的订单总数。订单与相应的客户ID存储在 orders 表中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select cust_name,cust_state,(select count(*)</span><br><span class="line">                            from orders</span><br><span class="line">                            where orders.cust_id&#x3D;customers.cust_id) as orders</span><br><span class="line">from customers</span><br><span class="line">order by cust_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>相关子查询<br>  设计外部查询的子查询</p>
</li>
</ul>
<h1 id="第十五章：联结表"><a href="#第十五章：联结表" class="headerlink" title="第十五章：联结表"></a>第十五章：联结表</h1><ul>
<li>维护引用完整性<ul>
<li>要理解联结不是物理实体。换句话说,它在实际的数据库表中不存在。</li>
<li>如果在 products 表中插入拥有非法供应商ID(即没有在 vendors 表中出现)的供应商生产的产品,则这些产品是不可访问的,因为它们没有关联到某个供应商。</li>
<li>为防止这种情况发生,可指示MySQL只允许在 products 表的供应商ID列中出现合法值(即出现在 vendors 表中的供应商)。这就是维护引用完整性,它是通过在表的定义中指定主键和外键来实现的。(这将在第21章介绍。)</li>
</ul>
</li>
</ul>
<h3 id="1-创建联结-等值连接"><a href="#1-创建联结-等值连接" class="headerlink" title="1. 创建联结(等值连接)"></a>1. 创建联结(等值连接)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select vend_name,prod_name</span><br><span class="line">from vendors,products</span><br><span class="line">where vendors.vend_id&#x3D;products.vend_id</span><br><span class="line">order by vend_name,prod_name;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在引用的列可能出现二义性时,必须使用完全限定列名(用一个点分隔的表名和列名)。</p>
</li>
<li><p>where 子句很重要,如果没有where,就会变成笛卡尔积，vendors里的每一行和products里的每一行连接</p>
</li>
<li><p>所有用联结的语句都要用where</p>
</li>
</ul>
<h3 id="2-内部联结"><a href="#2-内部联结" class="headerlink" title="2. 内部联结"></a>2. 内部联结</h3><ul>
<li>上述联结为等值联结，也称作内部联结</li>
<li>可以用不同的语法表示内部联结<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select vend_name,prod_name</span><br><span class="line">from vendors</span><br><span class="line">inner join products</span><br><span class="line">on vendors.vend_id&#x3D;products.vend_id</span><br><span class="line">order by vend_name,prod_name;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-联结多个表"><a href="#3-联结多个表" class="headerlink" title="3. 联结多个表"></a>3. 联结多个表</h3><ul>
<li>就是from后面多写几个表，where多几个条件</li>
<li>性能考虑<ul>
<li>MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的,因此应该仔细,不要联结不必要的表。联结的表越多,性能下降越厉害。</li>
</ul>
</li>
<li>联结和嵌套子查询(十四章)没有绝对的性能优劣，受数据量，操作类型，是否有索引等的影响</li>
</ul>
<h1 id="第十六章：创建高级联结"><a href="#第十六章：创建高级联结" class="headerlink" title="第十六章：创建高级联结"></a>第十六章：创建高级联结</h1><h3 id="1-使用表别名"><a href="#1-使用表别名" class="headerlink" title="1. 使用表别名"></a>1. 使用表别名</h3><ul>
<li>优点<ul>
<li>缩短SQL语句</li>
<li>允许在单条select语句中多次使用相同的表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select vend_name,prod_name</span><br><span class="line">from vendors as v,products as p</span><br><span class="line">where v.vend_id&#x3D;p.vend_id</span><br><span class="line">order by vend_name,prod_name;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>应该注意,表别名只在查询执行中使用。与列别名不一样,表别名不返回到客户机。</li>
</ul>
<h3 id="2-使用不同类型的联结"><a href="#2-使用不同类型的联结" class="headerlink" title="2. 使用不同类型的联结"></a>2. 使用不同类型的联结</h3><ul>
<li>之前的是等值联结/内部联结</li>
<li>下面讲自联结，自然联结，外部联结</li>
</ul>
<h5 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h5><ul>
<li>假如你发现某物品(其ID为 DTNTR )存在问题,因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为 111 的物品的供应商,然后找出这个供应商生产的其他物品。</li>
<li>可以用子查询<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select prod_name</span><br><span class="line">from products</span><br><span class="line">where vend_id &#x3D; (</span><br><span class="line">    select vend_id</span><br><span class="line">    from products</span><br><span class="line">    where prod_id&#x3D;&#39;111&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>也可以用自联结<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select prod_name</span><br><span class="line">from products as p1,products as p2</span><br><span class="line">where p1.vend_id&#x3D;p2.vend_id and p2.vend_id&#x3D;&#39;111&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h5><ul>
<li>事实上,迄今为止我们建立的每个内部联结都是自然联结,很可能我们永远都不会用到不是自然联结的内部联结。</li>
<li>标准的联结(前一章中介绍的内部联结)返回所有数据,甚至相同的列多次出现。自然联结排除多次出现,使每个列只返回一次。</li>
<li>就是万一两个表有相同的列，去掉重复的，要自己实现<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select c.*,o.num</span><br><span class="line">from customers as c,orders as 0</span><br><span class="line">where c.id&#x3D;o.id;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h5><ul>
<li>许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。</li>
<li>例如<ul>
<li>对每个客户下了多少订单进行计数,包括那些至今尚未下订单的客户;</li>
</ul>
</li>
<li>如下为内部联结，检索所有客户及其订单:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select customers.id,orders.num</span><br><span class="line">from customers inner join orders</span><br><span class="line">on customers.id&#x3D;orders.id;</span><br></pre></td></tr></table></figure></li>
<li>外部联结语法蕾西，但是检索所有客户,包括那些没有订单的客户,就是左边的表每行都有，若右边表没有与之对应的，就为NULL<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select customers.id,orders.num</span><br><span class="line">from customers left outer join orders</span><br><span class="line">on customers.id&#x3D;orders.id;</span><br><span class="line">&#x2F;&#x2F;left 可以换成right，就变成右边的表每行否有</span><br><span class="line">&#x2F;&#x2F;检索结果</span><br><span class="line">id  num</span><br><span class="line">1   11</span><br><span class="line">2   12</span><br><span class="line">3   NULL</span><br><span class="line">4   10</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-使用带聚集函数的联结"><a href="#3-使用带聚集函数的联结" class="headerlink" title="3. 使用带聚集函数的联结"></a>3. 使用带聚集函数的联结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select customers.id,count(orders.num) as num_ord</span><br><span class="line">from customers left outer join orders</span><br><span class="line">on customers.id&#x3D;orders.id</span><br><span class="line">group by customers.id</span><br></pre></td></tr></table></figure>

<h3 id="4-使用联结和联结条件"><a href="#4-使用联结和联结条件" class="headerlink" title="4. 使用联结和联结条件"></a>4. 使用联结和联结条件</h3><ul>
<li>注意所使用的联结类型。一般我们使用内部联结,但使用外部联<br>结也是有效的。</li>
<li>保证使用正确的联结条件,否则将返回不正确的数据。</li>
<li>应该总是提供联结条件,否则会得出笛卡儿积。</li>
<li>在一个联结中可以包含多个表,甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的,一般也很有用,但应该在一起测试它们前,分别测试每个联结。这将使故障排除更为简单。</li>
</ul>
<h1 id="第十七章：组合查询"><a href="#第十七章：组合查询" class="headerlink" title="第十七章：组合查询"></a>第十七章：组合查询</h1><h3 id="1-有两种基本情况-其中需要使用组合查询"><a href="#1-有两种基本情况-其中需要使用组合查询" class="headerlink" title="1. 有两种基本情况,其中需要使用组合查询:"></a>1. 有两种基本情况,其中需要使用组合查询:</h3><ul>
<li>在单个查询中从不同的表返回类似结构的数据;</li>
<li>对单个表执行多个查询,按单个查询返回数据。</li>
</ul>
<h3 id="2-创建组合查询，union"><a href="#2-创建组合查询，union" class="headerlink" title="2. 创建组合查询，union"></a>2. 创建组合查询，union</h3><ul>
<li>假如需要价格小于等于 5 的所有物品的一个列表,而且还想包括供应商 1001 和 1002 生产的所有物品(不考虑价格)。当然,可以利用 WHERE 子句来完成此工作,不过这次我们将使用 UNION 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select v_id,p_id,p_price</span><br><span class="line">from products</span><br><span class="line">where p_price&lt;&#x3D;5</span><br><span class="line">union</span><br><span class="line">select v_id,p_id,p_price</span><br><span class="line">from products</span><br><span class="line">where v_id in (1001,1002)</span><br></pre></td></tr></table></figure>
<ul>
<li>where 子句格式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select v_id,p_id,p_price</span><br><span class="line">from products</span><br><span class="line">where p_price&lt;&#x3D;5 and v_id in (1001,1002)</span><br></pre></td></tr></table></figure></li>
<li>上面这个例子where比union简单，但有时候用union更简单</li>
</ul>
<h3 id="3-union规则"><a href="#3-union规则" class="headerlink" title="3. union规则"></a>3. union规则</h3><ul>
<li>UNION 必须由两条或两条以上的 SELECT 语句组成,语句之间用关键字 UNION 分隔(因此,如果组合4条 SELECT 语句,将要使用3个UNION 关键字)。</li>
<li>UNION 中的每个查询必须包含相同的列、表达式或聚集函数(不过各个列不需要以相同的次序列出)。</li>
<li>列数据类型必须兼容:类型不必完全相同,但必须是DBMS可以隐含地转换的类型(例如,不同的数值类型或不同的日期类型)。</li>
</ul>
<h3 id="4-包含或取消重复行，union-all"><a href="#4-包含或取消重复行，union-all" class="headerlink" title="4. 包含或取消重复行，union all"></a>4. 包含或取消重复行，union all</h3><ul>
<li>UNION 从查询结果集中自动去除了重复的行(换句话说,它的行为与。因为供应商 1002 生产<br>单条 SELECT 语句中使用多个 WHERE 子句条件一样)的一种物品的价格也低于 5 ,所以两条 SELECT 语句都返回该行。在使用UNION 时,重复的行被自动取消。</li>
<li>这是 UNION 的默认行为,但是如果需要,可以改变它。事实上,如果想返回所有匹配行,可使用 UNION ALL 而不是 UNION 。</li>
<li>如下这样，有重复行就重复显示<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select v_id,p_id,p_price</span><br><span class="line">from products</span><br><span class="line">where p_price&lt;&#x3D;5</span><br><span class="line">union all</span><br><span class="line">select v_id,p_id,p_price</span><br><span class="line">from products</span><br><span class="line">where v_id in (1001,1002)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-对组合查询结果排序-order-by"><a href="#5-对组合查询结果排序-order-by" class="headerlink" title="5. 对组合查询结果排序,order by"></a>5. 对组合查询结果排序,order by</h3><ul>
<li>在用 UNION 组合查询时,只能使用一条 ORDER BY 子句,它必须出现在最后一条 SELECT 语句之后。</li>
</ul>
<h1 id="第十八章：全文本搜索"><a href="#第十八章：全文本搜索" class="headerlink" title="第十八章：全文本搜索"></a>第十八章：全文本搜索</h1><h3 id="1-理解全文本搜索"><a href="#1-理解全文本搜索" class="headerlink" title="1. 理解全文本搜索"></a>1. 理解全文本搜索</h3><ul>
<li>并非所有引擎都支持全文本搜索<ul>
<li>两个最常使用的引擎为MyISAM 和 InnoDB ,前者支持全文本搜索,而后者不支持。</li>
</ul>
</li>
<li>正则表达式匹配的限制<ul>
<li>性能——通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行(而且这些搜索极少使用表索引)。因此,由于被搜索行数不断增加,这些搜索可能非常耗时。</li>
<li>明确控制——使用通配符和正则表达式匹配,很难(而且并不总是能)明确地控制匹配什么和不匹配什么。例如,指定一个词必须匹配,一个词必须不匹配,而一个词仅在第一个词确实匹配的情况下才可以匹配或者才可以不匹配。</li>
<li>智能化的结果——虽然基于通配符和正则表达式的搜索提供了非常灵活的搜索,但它们都不能提供一种智能化的选择结果的方法。例如,一个特殊词的搜索将会返回包含该词的所有行,而不区分包含单个匹配的行和包含多个匹配的行(按照可能是更好的匹配来排列它们)。类似,一个特殊词的搜索将不会找出不包含该词但包含其他相关词的行。</li>
</ul>
</li>
</ul>
<h3 id="2-使用全文本搜索"><a href="#2-使用全文本搜索" class="headerlink" title="2. 使用全文本搜索"></a>2. 使用全文本搜索</h3><ul>
<li>为了进行全文本搜索,必须索引被搜索的列,而且要随着数据的改变不断地重新索引。</li>
<li>一般在创建表时启用全文本搜索。 CREATE TABLE 语句接受 FULLTEXT 子句<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table students(</span><br><span class="line">    id  int not null auto_increment,</span><br><span class="line">    name not null,</span><br><span class="line">    primary key(id),</span><br><span class="line">    fulltext(name)</span><br><span class="line">)enging&#x3D;MyISAM</span><br></pre></td></tr></table></figure></li>
<li>使用Match()和Against()执行全文本搜索，其中Match() 指定被搜索的列,Against() 指定要使用的搜索表达式。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where Match(name) Against(&#39;hello&#39;);</span><br><span class="line">&#x2F;&#x2F;返回包含‘hello’的行</span><br><span class="line">&#x2F;&#x2F;like的方式</span><br><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where name like &#39;%hello%&#39;;</span><br></pre></td></tr></table></figure></li>
<li>上述两条 SELECT 语句都不包含 ORDER BY 子句。后者(使用 LIKE )以不特别有用的顺序返回数据。前者(使用全文本搜索)返回以文本匹配的良好程度排序的数据。两个行都包含词 rabbit ,但包含词 rabbit 作为第3个词的行的等级比作为第20个词的行高。这很重要。全文本搜索的一个重要部分就是对结果排序。具有较高等级的行先返回(因为这些行很可能是你真正想要的行)。</li>
<li>使 用 完 整 的 Match() 说 明 <ul>
<li>传 递 给 Match() 的 值 必 须 与FULLTEXT() 定义中的相同。如果指定多个列,则必须列出它们(而且次序正确)。</li>
</ul>
</li>
<li>搜索不区分大小写 <ul>
<li>除非使用 BINARY 方式(本章中没有介绍),否则全文本搜索不区分大小写。</li>
</ul>
</li>
<li>由于数据是索引的,全文本搜索比like快。</li>
</ul>
<h3 id="3-使用查询扩展"><a href="#3-使用查询扩展" class="headerlink" title="3. 使用查询扩展"></a>3. 使用查询扩展</h3><ul>
<li>什么是查询扩展<ul>
<li>查询扩展用来设法放宽所返回的全文本搜索结果的范围。考虑下面的情况。你想找出所有提到 anvils 的注释。只有一个注释包含词 anvils ,但你还想找出可能与你的搜索有关的所有其他行,即使它们不包含词anvils 。</li>
</ul>
</li>
<li>查询扩展原理<ul>
<li>这也是查询扩展的一项任务。在使用查询扩展时,MySQL对数据和索引进行两遍扫描来完成搜索:</li>
<li>首先,进行一个基本的全文本搜索,找出与搜索条件匹配的所有行;</li>
<li>其次,MySQL检查这些匹配行并选择所有有用的词(我们将会简要地解释MySQL如何断定什么有用,什么无用)。</li>
<li>再其次, MySQL再次进行全文本搜索,这次不仅使用原来的条件,而且还使用所有有用的词。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where Match(name) Against(&#39;hello&#39; with query expansion);</span><br><span class="line">&#x2F;&#x2F;返回不只是包含hello的行，和有hello的行关联较大的行也会返回</span><br></pre></td></tr></table></figure>
<ul>
<li>行越多越好 <ul>
<li>表中的行越多(这些行中的文本就越多),使用查询扩展返回的结果越好。</li>
</ul>
</li>
</ul>
<h3 id="4-布尔文本搜索"><a href="#4-布尔文本搜索" class="headerlink" title="4. 布尔文本搜索"></a>4. 布尔文本搜索</h3><ul>
<li><p>布尔方式,可以提供关于如下内容的细节:</p>
<ul>
<li>要匹配的词;</li>
<li>要排斥的词(如果某行包含这个词,则不返回该行,即使它包含其他指定的词也是如此);</li>
<li>排列提示(指定某些词比其他词更重要,更重要的词等级更高);</li>
<li>表达式分组;</li>
<li>另外一些内容。</li>
</ul>
</li>
<li><p>即使没有 FULLTEXT 索引也可以使用</p>
<ul>
<li>布尔方式不同于迄今为止使用的全文本搜索语法的地方在于,即使没有定义FULLTEXT 索引,也可以使用它。但这是一种非常缓慢的操作(其性能将随着数据量的增加而降低)。</li>
</ul>
</li>
<li><p>IN BOOLEAN MODE</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;匹配包含hello但不包含任意以lv开头的名字</span><br><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where Match(name) Against(&#39;hello -lv*&#39; in boolean mode);</span><br><span class="line">&#x2F;&#x2F;-lv*,排除lv*的词</span><br></pre></td></tr></table></figure>
</li>
<li><p>全文本布尔操作符</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>布尔操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>包含,词必须存在</td>
</tr>
<tr>
<td>-</td>
<td>排除,词必须不出现</td>
</tr>
</tbody></table>
<blockquote>
<p>|包含,而且增加等级值<br>&lt;|包含,且减少等级值<br>()|把词组成子表达式(允许这些子表达式作为一个组被包含、排除、排列等)<br>~|取消一个词的排序值<br>*|词尾的通配符<br>“”|定义一个短语(与单个词的列表不一样,它匹配整个短语以便包含或排除这个短语)</p>
</blockquote>
<ul>
<li><p>几个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;name中必须有gao和ling</span><br><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where Match(name) Against(&#39;+gao +ling&#39; in boolean mode);</span><br><span class="line">&#x2F;&#x2F;name中至少有gao和ling的一个</span><br><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where Match(name) Against(&#39;gao ling&#39; in boolean mode);</span><br><span class="line">&#x2F;&#x2F;name中匹配短语 rabbit bait 而不是匹配两个词 rabbit 和bait 。</span><br><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where Match(name) Against(&#39;&quot;gao ling&quot;&#39; in boolean mode);</span><br><span class="line">&#x2F;&#x2F;增加gao的等级，降低ling的等级</span><br><span class="line">select name</span><br><span class="line">from students</span><br><span class="line">where Match(name) Against(&#39;&gt;gao &lt;ling&#39; in boolean mode);</span><br></pre></td></tr></table></figure>
</li>
<li><p>排列而不排序</p>
<ul>
<li>在布尔方式中,不按等级值降序排序返回的行。</li>
</ul>
</li>
</ul>
<h3 id="5-一些说明"><a href="#5-一些说明" class="headerlink" title="5. 一些说明"></a>5. 一些说明</h3><pre><code>- 在索引全文本数据时,短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词(如果需要,这个数目可以更改)。
- MySQL带有一个内建的非用词(stopword)列表,这些词在索引全文本数据时总是被忽略。如果需要,可以覆盖这个列表(请参阅MySQL文档以了解如何完成此工作)。
- 许多词出现的频率很高,搜索它们没有用处(返回太多的结果)。因此,MySQL规定了一条50%规则,如果一个词出现在50%以上的行中,则将它作为一个非用词忽略。 50%规则不用于 IN BOOLEAN MODE 。
- 如果表中的行数少于3行,则全文本搜索不返回结果(因为每个词或者不出现,或者至少出现在50%的行中)。
- 忽略词中的单引号。例如, don&#39;t 索引为 dont 。
- 不具有词分隔符(包括日语和汉语)的语言不能恰当地返回全文本搜索结果。
- 如前所述,仅在 MyISAM 数据库引擎中支持全文本搜索</code></pre>
<h1 id="第十九章：插入数据"><a href="#第十九章：插入数据" class="headerlink" title="第十九章：插入数据"></a>第十九章：插入数据</h1><h3 id="1-数据插入"><a href="#1-数据插入" class="headerlink" title="1. 数据插入"></a>1. 数据插入</h3><ul>
<li>插入完整的行;</li>
<li>插入行的一部分;</li>
<li>插入多行;</li>
<li>插入某些查询的结果。</li>
</ul>
<h3 id="2-插入完整的行"><a href="#2-插入完整的行" class="headerlink" title="2. 插入完整的行"></a>2. 插入完整的行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into student</span><br><span class="line">values(</span><br><span class="line">    &#39;1001&#39;,</span><br><span class="line">    &#39;zhangsan&#39;,</span><br><span class="line">    &#39;male&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然这种语法很简单,但并不安全,应该尽量避免使用。上面的SQL语句高度依赖于表中列的定义次序,并且还依赖于其次序容易获得的信息。即使可得到这种次序信息,也不能保证下一次表结构变动后各个列保持完全相同的次序。因此,编写依赖于特定列次序的SQL语句是很不安全的。如果这样做,有时难免会出问题。</li>
<li>编写 INSERT 语句的更安全(不过更烦琐)的方法如下:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into student(</span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    sex</span><br><span class="line">)</span><br><span class="line">values(</span><br><span class="line">    &#39;1001&#39;,</span><br><span class="line">    &#39;zhangsan&#39;,</span><br><span class="line">    &#39;male&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>降低优先级，low priority<br>如果数据检索是最重要的(通常是这样),则你可以通过在INSERT 和 INTO 之间添加关键字 LOW_PRIORITY ,指示MySQL降低 INSERT 语句的优先级,如下所示:<ul>
<li>insert low priority into student</li>
<li>low priority 也适用于update和delete</li>
</ul>
</li>
</ul>
<h3 id="3-插入多个行"><a href="#3-插入多个行" class="headerlink" title="3. 插入多个行"></a>3. 插入多个行</h3><ul>
<li>可以适用多条insert语句</li>
<li>只要每条 INSERT 语句中的列名(和次序)相同,可以如下组合各语句:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into student(</span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    sex</span><br><span class="line">)</span><br><span class="line">values(</span><br><span class="line">    &#39;1001&#39;,</span><br><span class="line">    &#39;zhangsan&#39;,</span><br><span class="line">    &#39;male&#39;</span><br><span class="line">),(</span><br><span class="line">    &#39;1002&#39;,</span><br><span class="line">    &#39;lisi&#39;,</span><br><span class="line">    &#39;female&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-插入检索出的数据"><a href="#4-插入检索出的数据" class="headerlink" title="4. 插入检索出的数据"></a>4. 插入检索出的数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into student(</span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    sex</span><br><span class="line">)</span><br><span class="line">select id,name,sex</span><br><span class="line">from people;</span><br></pre></td></tr></table></figure>

<h1 id="第二十章：更新和删除数据"><a href="#第二十章：更新和删除数据" class="headerlink" title="第二十章：更新和删除数据"></a>第二十章：更新和删除数据</h1><h3 id="1-更新数据"><a href="#1-更新数据" class="headerlink" title="1. 更新数据"></a>1. 更新数据</h3><ul>
<li>更新表中特定行;</li>
<li>更新表中所有行。</li>
<li>不要省略 WHERE 子句 在使用 UPDATE 时一定要注意细心。因为稍不注意,就会更新表中所有行。</li>
<li>UPDATE 语句由3部分组成<ul>
<li>要更新的表;</li>
<li>列名和它们的新值;</li>
<li>确定要更新行的过滤条件。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update student</span><br><span class="line">set name&#x3D;&#39;hhh&#39;</span><br><span class="line">where id&#x3D;&#39;1001&#39;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>UPDATE 语句中可以使用子查询,使得能用 SELECT 语句检索出的数据更新列数据。</li>
<li>IGNORE 关键字<ul>
<li>如果用 UPDATE 语句更新多行,并且在更新这些行中的一行或多行时出一个现错误,则整个 UPDATE 操作被取消(错误发生前更新的所有行被恢复到它们原来的值)</li>
<li>即使是发生错误,也继续进行更新,可使用 IGNORE 关键字,如下所示:<ul>
<li>update ignore student…</li>
</ul>
</li>
</ul>
</li>
<li>为了删除某个列的值,可设置它为 NULL (假如表定义允许 NULL 值)。</li>
</ul>
<h3 id="2-删除数据"><a href="#2-删除数据" class="headerlink" title="2. 删除数据"></a>2. 删除数据</h3><ul>
<li><p>两种方式使用 DELETE :</p>
<ul>
<li>从表中删除特定的行;</li>
<li>从表中删除所有行。</li>
</ul>
</li>
<li><p>不要省略 WHERE 子句</p>
</li>
<li><p>从 customers 表中删除一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from student</span><br><span class="line">where id&#x3D;1001;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DELETE 不需要列名或通配符。 DELETE 删除整行而不是删除列。为了删除指定的列,请使用 UPDATE 语句。</p>
</li>
<li><p>删除表的内容而不是表</p>
</li>
<li><p>更快的删除</p>
<ul>
<li>如果想从表中删除所有行,不要使用 DELETE 。可使用 TRUNCATE TABLE 语句,它完成相同的工作,但速度更快( TRUNCATE 实际是删除原来的表并重新创建一个表,而不是逐行删除表中的数据)。</li>
</ul>
</li>
</ul>
<h3 id="3-更新和删除的指导原则"><a href="#3-更新和删除的指导原则" class="headerlink" title="3. 更新和删除的指导原则"></a>3. 更新和删除的指导原则</h3><ul>
<li>除非确实打算更新和删除每一行,否则绝对不要使用不带 WHERE子句的 UPDATE 或 DELETE 语句。</li>
<li>保证每个表都有主键(如果忘记这个内容,请参阅第15章),尽可能像 WHERE 子句那样使用它(可以指定各主键、多个值或值的范围)。</li>
<li>在对 UPDATE 或 DELETE 语句使用 WHERE 子句前,应该先用 SELECT 进行测试,保证它过滤的是正确的记录,以防编写的 WHERE 子句不正确。</li>
<li>使用强制实施引用完整性的数据库(关于这个内容,请参阅第15章),这样MySQL将不允许删除具有与其他表相关联的数据的行。</li>
</ul>
<h1 id="第二十一章：创建和操纵表"><a href="#第二十一章：创建和操纵表" class="headerlink" title="第二十一章：创建和操纵表"></a>第二十一章：创建和操纵表</h1><h3 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1. 创建表"></a>1. 创建表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table students(</span><br><span class="line">    id int not null auto_increment,</span><br><span class="line">    name char(20) not null,</span><br><span class="line">    sex char(10) null,</span><br><span class="line">    is_good int null default 1,</span><br><span class="line">    primary key(id)</span><br><span class="line">)enging&#x3D;InnoDB;</span><br></pre></td></tr></table></figure>
<ul>
<li>主键<ul>
<li>主键可以有多个列，但每行必须唯一</li>
<li>primary key(id1，id2)</li>
</ul>
</li>
<li>auto_increment<ul>
<li>每个表只允许一个 AUTO_INCREMENT 列,而且它必须被索引(如,通过使它成为主键)。</li>
<li>AUTO_INCREMENT 告诉MySQL,本列每当增加一行时自动增量。</li>
<li>select last_insert_id()获得最后一个auto_increment值</li>
</ul>
</li>
<li>default设置默认值</li>
</ul>
<h5 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h5><ul>
<li><p>MySQL与其他DBMS不一样,它具有多种引擎。</p>
</li>
<li><p>如果省略 ENGINE= 语句,则,多数SQL语句都会默认使用它。使用默认引擎(很可能是 MyISAM)</p>
</li>
<li><p>几个需要知道的引擎:</p>
<ul>
<li>InnoDB 是一个可靠的事务处理引擎(参见第26章),它不支持全文本搜索;</li>
<li>MEMORY 在功能等同于 MyISAM ,但由于数据存储在内存(不是磁盘)中,速度很快(特别适合于临时表);</li>
<li>MyISAM 是一个性能极高的引擎,它支持全文本搜索(参见第18章),但不支持事务处理。</li>
</ul>
</li>
<li><p>引擎类型可以混用。希望支持事务处理的话使用 InnoDB,需要支持全文本搜索的话使用 MyISAM</p>
</li>
<li><p>外键不能跨引擎混用引擎类型有一个大缺陷。外键(用于强制实施引用完整性,如第1章所述)不能跨引擎,即使用一个引擎的表不能引用具有使用不同引擎的表的外键。</p>
</li>
</ul>
<h3 id="2-更新表，alert-table"><a href="#2-更新表，alert-table" class="headerlink" title="2. 更新表，alert table"></a>2. 更新表，alert table</h3><ul>
<li>理想状态下,当表中存储数据以后,该表就不应该再被更新。</li>
<li>alert更改<ul>
<li>在 ALTER TABLE 之后给出要更改的表名(该表必须存在,否则将出错);</li>
<li>所做更改的列表。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert table students</span><br><span class="line">add phone char(20);</span><br><span class="line"></span><br><span class="line">alert table students</span><br><span class="line">drop column phone;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>ALTER TABLE 的一种常见用途是定义外键。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert table students</span><br><span class="line">add constraint fk_students_class</span><br><span class="line">foreign key(id) references class(stu_id);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-删除表"><a href="#3-删除表" class="headerlink" title="3. 删除表"></a>3. 删除表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop table students;</span><br></pre></td></tr></table></figure>

<h3 id="4-重命名表"><a href="#4-重命名表" class="headerlink" title="4. 重命名表"></a>4. 重命名表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rename table students to students2,</span><br><span class="line">            class to class2;</span><br></pre></td></tr></table></figure>

<h1 id="第二十二章：使用视图"><a href="#第二十二章：使用视图" class="headerlink" title="第二十二章：使用视图"></a>第二十二章：使用视图</h1><h3 id="1-视图"><a href="#1-视图" class="headerlink" title="1. 视图"></a>1. 视图</h3><ul>
<li>视图是虚拟的表。与包含数据的表不一样,视图只包含使用时动态检索数据的查询。</li>
<li>如下例：从两个表中检索数据<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,grade</span><br><span class="line">from students,grades</span><br><span class="line">where students.id&#x3D;grades.id and students.id&#x3D;1111;</span><br></pre></td></tr></table></figure></li>
<li>若是上面这种方式，任何需要这个数据的人都必须理解相关表的结构,并且知道如何创建查询和对表进行联结。为了检索其他产品(或多个产品)的相同数据,必须修改最后的 WHERE 子句。</li>
<li>可以使用试图作为虚拟表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,grade</span><br><span class="line">from students_grades</span><br><span class="line">where id&#x3D;1111;</span><br><span class="line">&#x2F;&#x2F;students_grades是一个试图</span><br></pre></td></tr></table></figure></li>
<li>性能问题<ul>
<li>因为视图不包含数据,所以每次使用视图时,都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图,可能会发现性能下降得很厉害。因此,在部署使用了大量视图的应用前,应该进行测试</li>
</ul>
</li>
</ul>
<h3 id="2-视图的应用"><a href="#2-视图的应用" class="headerlink" title="2. 视图的应用"></a>2. 视图的应用</h3><ul>
<li>重用SQL语句。</li>
<li>简化复杂的SQL操作。在编写查询后,可以方便地重用它而不必知道它的基本查询细节。</li>
<li>使用表的组成部分而不是整个表。</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<h3 id="3-视图的规则和限制"><a href="#3-视图的规则和限制" class="headerlink" title="3. 视图的规则和限制"></a>3. 视图的规则和限制</h3><ul>
<li>与表一样,视图必须唯一命名(不能给视图取与别的视图或表相同的名字)。</li>
<li>对于可以创建的视图数目没有限制。</li>
<li>为了创建视图,必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</li>
<li>视图可以嵌套,即可以利用从其他视图中检索数据的查询来构造一个视图。</li>
<li>ORDER BY 可以用在视图中,但如果从该视图检索数据 SELECT 中也含有 ORDER BY ,那么该视图中的 ORDER BY 将被覆盖。</li>
<li>视图不能索引,也不能有关联的触发器或默认值。</li>
<li>视图可以和表一起使用。例如,编写一条联结表和视图的 SELECT语句。</li>
</ul>
<h3 id="4-使用视图"><a href="#4-使用视图" class="headerlink" title="4. 使用视图"></a>4. 使用视图</h3><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><ul>
<li>视图用 CREATE VIEW 语句来创建。</li>
<li>使用 SHOW CREATE VIEW viewname ;来查看创建视图的语句。</li>
<li>用 DROP 删除视图,其语法为 DROP VIEW viewname;。</li>
<li>更新视图时,可以先用DROP再用CREATE,也可以直接用CREATE ORREPLACE VIEW。如果要更新的视图不存在,则第 2 条更新语句会创建一个视图;如果要更新的视图存在,则第 2 条更新语句会替换原有视图。</li>
</ul>
<h5 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create view student_class as</span><br><span class="line">select student.id,student.name,class.cls_id</span><br><span class="line">from student,class</span><br><span class="line">where student.id&#x3D;class.stu_id</span><br></pre></td></tr></table></figure>

<h5 id="用视图重新格式化检索出的数据"><a href="#用视图重新格式化检索出的数据" class="headerlink" title="用视图重新格式化检索出的数据"></a>用视图重新格式化检索出的数据</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select Concat(RTrim(name),&#39;(&#39;,RTrim(id),&#39;)&#39;) as new_line</span><br><span class="line">from student</span><br><span class="line">order by name;</span><br></pre></td></tr></table></figure>
<ul>
<li>若经常使用上述格式，可以写成视图<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create view student_new as</span><br><span class="line">select Concat(RTrim(name),&#39;(&#39;,RTrim(id),&#39;)&#39;) as new_line</span><br><span class="line">from student</span><br><span class="line">order by name;</span><br><span class="line">&#x2F;&#x2F;查询时</span><br><span class="line">select *</span><br><span class="line">from student_new</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h5><ul>
<li>和上面的格式化类似</li>
</ul>
<h5 id="视图更新"><a href="#视图更新" class="headerlink" title="视图更新"></a>视图更新</h5><ul>
<li>视图是可以更新的，可以使用insert,updata,delete,同时对基表也会更新，但是更新有许多限制</li>
<li>一般,应该将视图用于检索( SELECT 语句)，而不用于更新( INSERT 、 UPDATE 和 DELETE )。</li>
</ul>
<h1 id="第二十三章：使用存储过程"><a href="#第二十三章：使用存储过程" class="headerlink" title="第二十三章：使用存储过程"></a>第二十三章：使用存储过程</h1><h3 id="1-存储过程"><a href="#1-存储过程" class="headerlink" title="1. 存储过程"></a>1. 存储过程</h3><ul>
<li>存储过程简单来说,就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件,虽然它们的作用不仅限于批处理。</li>
<li>就像封装的函数</li>
</ul>
<h3 id="2-为什么使用存储过程"><a href="#2-为什么使用存储过程" class="headerlink" title="2. 为什么使用存储过程"></a>2. 为什么使用存储过程</h3><h5 id="优点：简单、安全、高性能"><a href="#优点：简单、安全、高性能" class="headerlink" title="优点：简单、安全、高性能"></a>优点：简单、安全、高性能</h5><ul>
<li>通过把处理封装在容易使用的单元中,简化复杂的操作(正如前面例子所述)。</li>
<li>由于不要求反复建立一系列处理步骤,这保证了数据的完整性。如果所有开发人员和应用程序都使用同一(试验和测试)存储过<br>程,则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多,出错的可能性就越大。防止错误保证了数据的一致性。</li>
<li>简化对变动的管理。如果表名、列名或业务逻辑(或别的内容)有变化,只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。</li>
<li>提高性能。因为使用存储过程比使用单独的SQL语句要快。</li>
<li>存在一些只能用在单个请求中的MySQL元素和特性,存储过程可以使用它们来编写功能更强更灵活的代码(在下一章的例子中可<br>以看到。</li>
</ul>
<h5 id="缺点：复杂"><a href="#缺点：复杂" class="headerlink" title="缺点：复杂"></a>缺点：复杂</h5><ul>
<li>一般来说,存储过程的编写比基本SQL语句复杂,编写存储过程需要更高的技能,更丰富的经验。</li>
<li>你可能没有创建存储过程的安全访问权限。许多数据库管理员限制存储过程的创建权限,允许用户使用存储过程,但不允许他们创建存储过程。</li>
</ul>
<h3 id="3-执行存储过程，call"><a href="#3-执行存储过程，call" class="headerlink" title="3. 执行存储过程，call"></a>3. 执行存储过程，call</h3><ul>
<li>执行名为 productpricing 的存储过程,它计算并返回产品的最低、最高和平均价格。存储在传进去的参数里<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call productpricing(</span><br><span class="line">    @pricelow,</span><br><span class="line">    @pricehigh,</span><br><span class="line">    @priceaverage</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-创建存储过程"><a href="#4-创建存储过程" class="headerlink" title="4. 创建存储过程"></a>4. 创建存储过程</h3><ul>
<li>返回产品平均价格的存储过程。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure productpricing()</span><br><span class="line">begin</span><br><span class="line">    select avg(prod_price)</span><br><span class="line">    as avg_price</span><br><span class="line">    from product;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure></li>
<li>调用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call productprining();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-删除存储过程"><a href="#5-删除存储过程" class="headerlink" title="5. 删除存储过程"></a>5. 删除存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;删除没有括号()</span><br><span class="line">call procedure productprining;</span><br></pre></td></tr></table></figure>

<h3 id="6-使用参数"><a href="#6-使用参数" class="headerlink" title="6. 使用参数"></a>6. 使用参数</h3><ul>
<li><p>变量(variable)</p>
<ul>
<li>内存中一个特定的位置,用来临时存储数据。</li>
</ul>
</li>
<li><p>变量名 </p>
<ul>
<li>所有MySQL变量都必须以 @ 开始<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure productpricing(</span><br><span class="line">    out pl decimal(8,2),</span><br><span class="line">    out ph decimal(8,2)</span><br><span class="line">)</span><br><span class="line">begin</span><br><span class="line">    select min(prod_price)</span><br><span class="line">    into pl</span><br><span class="line">    from product;</span><br><span class="line">    select max(prod_price)</span><br><span class="line">    into ph</span><br><span class="line">    from product;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>pl，ph为从外面传进的变量(相当于引用参数),decimal指定为十进制类型</p>
</li>
<li><p>out指明为传进，MySQL支持 IN (传递给存储过程)、 OUT (从存储过程传出,如这里所用)和 INOUT (对存储过程传入和传出)类型的参数。</p>
</li>
<li><p>参数的数据类型，见后面附录D</p>
</li>
<li><p>存储过程的参数允许的数据类型与表中使用的数据类型相同。</p>
</li>
<li><p>记录集不是允许的类型,因此,不能通过一个参数返回多个行和列。</p>
</li>
<li><p>变量使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call productpricing(</span><br><span class="line">    @pricelow,</span><br><span class="line">    @pricehigh</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;调用上述call后，如下查看变量内容</span><br><span class="line">select @pricelow;</span><br></pre></td></tr></table></figure></li>
<li><p>使用in传参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure productpricing(</span><br><span class="line">    in num int,</span><br><span class="line">    out total decimal(8,2)</span><br><span class="line">)</span><br><span class="line">begin</span><br><span class="line">    select prod_total</span><br><span class="line">    from product</span><br><span class="line">    where id&#x3D;num</span><br><span class="line">    into pl;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="7-建立智能存储过程"><a href="#7-建立智能存储过程" class="headerlink" title="7. 建立智能存储过程"></a>7. 建立智能存储过程</h3><ul>
<li>就是更复杂的过程</li>
<li>COMMENT 关键字<ul>
<li>在 CREATE PROCEDURE 语句中可以包含了 COMMENT 值。它不是必需的,但如果给出,将在 SHOW PROCEDURE STATUS 的结果中显示。</li>
</ul>
</li>
<li>注释<ul>
<li>两个杠表示注释：–</li>
</ul>
</li>
<li>局部变量<ul>
<li>在begin,end中声明</li>
<li>declare var int default 0;</li>
</ul>
</li>
<li>完整例子：需要获得与以前一样的订单合计,但需要对合计增加营业税,不过只针对某些顾客(或许是你所在州中那些顾客)。那么,需要做下面几件事情:<ul>
<li>获得合计(与以前一样);</li>
<li>把营业税有条件地添加到合计;</li>
<li>返回合计(带或不带税)。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure ordertotal(</span><br><span class="line">    in onum int,</span><br><span class="line">    int taxable boolean,</span><br><span class="line">    out ototal decimal(8,2)</span><br><span class="line">)comment &#39;this is a test&#39;</span><br><span class="line">begin</span><br><span class="line">    declare total decimal(8,2),</span><br><span class="line">    declare taxrate int default 6;</span><br><span class="line">    select sum(item_price*quantity)</span><br><span class="line">    from orderitems</span><br><span class="line">    where order_num&#x3D;onum</span><br><span class="line">    into total;</span><br><span class="line">    if taxable then</span><br><span class="line">        select total+(total&#x2F;100*taxrate)</span><br><span class="line">        into total;</span><br><span class="line">    ebd if;</span><br><span class="line">    select total into ototal;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="8-检查存储过程"><a href="#8-检查存储过程" class="headerlink" title="8. 检查存储过程"></a>8. 检查存储过程</h3><ul>
<li>显示用来创建一个存储过程的 CREATE 语句<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create procedure print;</span><br></pre></td></tr></table></figure></li>
<li>获得包括何时、由谁创建等详细信息的存储过程列表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show procedure status;</span><br></pre></td></tr></table></figure></li>
<li>限制过程状态结果,SHOW PROCEDURE STATUS 列出所有存储过程。为限制其输出,可使用 LIKE 指定一个过滤模式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show procedure status like &#39;lvkou&#39;;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="第二十四章：使用游标"><a href="#第二十四章：使用游标" class="headerlink" title="第二十四章：使用游标"></a>第二十四章：使用游标</h1><h3 id="1-游标"><a href="#1-游标" class="headerlink" title="1. 游标"></a>1. 游标</h3><ul>
<li>游标(cursor)是一个存储在MySQL服务器上的数据库查询,它不是一条 SELECT 语句,而是被该语句检索出来的结果集。在存储了游标之后,应用程序可以根据需要滚动或浏览其中的数据。</li>
<li>只能用于存储过程不像多数DBMS,MySQL游标只能用于存储过程(和函数)。</li>
</ul>
<h3 id="2-游标使用步骤"><a href="#2-游标使用步骤" class="headerlink" title="2. 游标使用步骤"></a>2. 游标使用步骤</h3><ul>
<li>在能够使用游标前,必须声明(定义)它。这个过程实际上没有检索数据,它只是定义要使用的 SELECT 语句。</li>
<li>一旦声明后,必须打开游标以供使用。这个过程用前面定义的SELECT 语句把数据实际检索出来。</li>
<li>对于填有数据的游标,根据需要取出(检索)各行。</li>
<li>在结束游标使用时,必须关闭游标。</li>
</ul>
<h3 id="3-创建游标"><a href="#3-创建游标" class="headerlink" title="3. 创建游标"></a>3. 创建游标</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure func()</span><br><span class="line">begin</span><br><span class="line">    declere ordernumbers cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个存储过程并没有做很多事情,DECLARE 语句用来定义和命名游标,这里为 ordernumbers 。 存储过程处理完成后,游标就消失(因为它局限于存储过程)。</li>
</ul>
<h3 id="4-打开和关闭游标"><a href="#4-打开和关闭游标" class="headerlink" title="4. 打开和关闭游标"></a>4. 打开和关闭游标</h3><ul>
<li>打开<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open oredernumbers;</span><br></pre></td></tr></table></figure></li>
<li>在处理 OPEN 语句时执行查询,存储检索出的数据以供浏览和滚动。游标处理完成后,应当使用如下语句关闭游标:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">close oredernumbers;</span><br></pre></td></tr></table></figure></li>
<li>隐含关闭 <ul>
<li>如果你不明确关闭游标, MySQL将会在到达 END 语句时自动关闭它。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure func()</span><br><span class="line">begin</span><br><span class="line">    declare ordernumbers cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line">    open ordernumbers;</span><br><span class="line">    -- do something;</span><br><span class="line">    close ordernumbers;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h3 id="5-使用游标数据"><a href="#5-使用游标数据" class="headerlink" title="5. 使用游标数据"></a>5. 使用游标数据</h3><h5 id="简单fetch"><a href="#简单fetch" class="headerlink" title="简单fetch"></a>简单fetch</h5><ul>
<li>在一个游标被打开后,可以使用 FETCH 语句分别访问它的每一行。FETCH 指定检索什么数据(所需的列),检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针,使下一条 FETCH 语句检索下一行(不重复读取同一行)。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure func()</span><br><span class="line">begin</span><br><span class="line">    declare temp int;</span><br><span class="line">    declare ordernumbers cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line">    open ordernumbers;</span><br><span class="line">    fetch ordernumbers into temp;</span><br><span class="line">    close ordernumbers;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure></li>
<li>其中 FETCH 用来检索当前行的 order_num 列(将自动从第一行开始)到一个名为 o 的局部声明的变量中。对检索出的数据不做任何处理。</li>
</ul>
<h5 id="循环检索数据"><a href="#循环检索数据" class="headerlink" title="循环检索数据"></a>循环检索数据</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure func()</span><br><span class="line">begin</span><br><span class="line">    declare done boolean default 0;</span><br><span class="line">    declare temp int;</span><br><span class="line">    declare ordernumbers cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line">    declare continue handler for sqlstate &#39;02000&#39; set done&#x3D;1;</span><br><span class="line">    open ordernumbers;</span><br><span class="line">    -- loop through all rows</span><br><span class="line">    repeat</span><br><span class="line">        fetch ordernumbers into temp;</span><br><span class="line">    until done end repeat;</span><br><span class="line">    close ordernumbers;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>定义了一个 CONTINUE HANDLER ,它是在条件出现时被执行的代码。这里,它指出当 SQLSTATE ‘02000’ 出现时, SET done=1。 SQLSTATE’02000’ 是一个未找到条件,当 REPEAT 由于没有更多的行供循环而不能继续时,出现这个条件。</p>
</li>
<li><p>在过程中可以调用过程，可以在循环中进行更复杂的操作，具体情况具体分析。</p>
</li>
</ul>
<h1 id="第二十五章：使用触发器"><a href="#第二十五章：使用触发器" class="headerlink" title="第二十五章：使用触发器"></a>第二十五章：使用触发器</h1><h3 id="1-触发器"><a href="#1-触发器" class="headerlink" title="1. 触发器"></a>1. 触发器</h3><ul>
<li>触发器是MySQL响应以下任意语句而<br>自动执行的一条MySQL语句(或位于BEGIN 和 END 语句之间的一组语句):<ul>
<li>DELETE ;</li>
<li>INSERT ;</li>
<li>UPDATE 。</li>
<li>其他MySQL语句不支持触发器。</li>
</ul>
</li>
</ul>
<h3 id="2-创建触发器，create-trigger"><a href="#2-创建触发器，create-trigger" class="headerlink" title="2. 创建触发器，create trigger"></a>2. 创建触发器，create trigger</h3><ul>
<li>在创建触发器时,需要给出4条信息:</li>
<li>唯一的触发器名;</li>
<li>触发器关联的表;</li>
<li>触发器应该响应的活动( DELETE 、 INSERT 或 UPDATE );</li>
<li>触发器何时执行(处理之前或之后)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger t_name</span><br><span class="line">after insert on products</span><br><span class="line">for each row </span><br><span class="line">select &#39;Product added&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个触发器还指定 FOR EACH ROW ,因此代码对每个插入行执行。在这个例子中,文本 Product added 将对每个插入的行显示一次。</li>
<li>仅支持表<ul>
<li>只有表才支持触发器,视图不支持(临时表也不支持)</li>
<li>每个表最多支持6个触发器</li>
</ul>
</li>
<li>触发器失败 <ul>
<li>如果 BEFORE 触发器失败,则MySQL将不执行请求的操作。此外,如果 BEFORE 触发器或语句本身失败, MySQL将不执行 AFTER 触发器(如果有的话)</li>
</ul>
</li>
</ul>
<h3 id="3-删除触发器"><a href="#3-删除触发器" class="headerlink" title="3. 删除触发器"></a>3. 删除触发器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop trigger t_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>触发器不能更新或覆盖。为了修改一个触发器,必须先删除它,然后再重新创建。</li>
</ul>
<h3 id="4-使用触发器"><a href="#4-使用触发器" class="headerlink" title="4. 使用触发器"></a>4. 使用触发器</h3><h5 id="INSERT-触发器"><a href="#INSERT-触发器" class="headerlink" title="INSERT 触发器"></a>INSERT 触发器</h5><ul>
<li>INSERT 触发器在 INSERT 语句执行之前或之后执行。需要知道以下几点:</li>
<li>在 INSERT 触发器代码内,可引用一个名为 NEW 的虚拟表,访问被插入的行;</li>
<li>在 BEFORE INSERT 触发器中, NEW 中的值也可以被更新(允许更改被插入的值);</li>
<li>对于 AUTO_INCREMENT 列, NEW 在 INSERT 执行之前包含 0 ,在 INSERT执行之后包含新的自动生成值。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger t_name</span><br><span class="line">after insert on products</span><br><span class="line">for each row </span><br><span class="line">select NEW.id;</span><br></pre></td></tr></table></figure></li>
<li>此触发器必须按照 AFTER INSERT 执行,因为在 BEFOREINSERT 语句执行之前,新 id 还没有生成。对于 products 的每次插入使用这个触发器将总是返回新的id号。</li>
</ul>
<h5 id="DELETE-触发器"><a href="#DELETE-触发器" class="headerlink" title="DELETE 触发器"></a>DELETE 触发器</h5><ul>
<li>DELETE 触发器在 DELETE 语句执行之前或之后执行。需要知道以下两点:<ul>
<li>在 DELETE 触发器代码内,你可以引用一个名为 OLD 的虚拟表,访问被删除的行;</li>
<li>OLD 中的值全都是只读的,不能更新。</li>
</ul>
</li>
<li>下面的例子演示使用 OLD 保存将要被删除的行到一个存档表中:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger t_name</span><br><span class="line">after insert on products</span><br><span class="line">for each row </span><br><span class="line">begin</span><br><span class="line">    insert into backup(id,name)</span><br><span class="line">    values(old.id,old.name);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="UPDATE触发器"><a href="#UPDATE触发器" class="headerlink" title="UPDATE触发器"></a>UPDATE触发器</h5><ul>
<li>UPDATE 触发器在 UPDATE 语句执行之前或之后执行。需要知道以下几点:<ul>
<li>在 UPDATE 触发器代码中,你可以引用一个名为 OLD 的虚拟表访问以前( UPDATE 语句前)的值,引用一个名为 NEW 的虚拟表访问新更新的值;</li>
<li>在 BEFORE UPDATE 触发器中, NEW 中的值可能也被更新(允许更改将要用于 UPDATE 语句中的值);</li>
<li>OLD 中的值全都是只读的,不能更新。</li>
</ul>
</li>
</ul>
<h1 id="第二十六章：管理事务处理"><a href="#第二十六章：管理事务处理" class="headerlink" title="第二十六章：管理事务处理"></a>第二十六章：管理事务处理</h1><h3 id="1-事务处理"><a href="#1-事务处理" class="headerlink" title="1. 事务处理"></a>1. 事务处理</h3><ul>
<li><p>并非所有引擎都支持事务处理</p>
<ul>
<li>MyISAM 和 InnoDB 是两种最常使用的引擎。前者不支持明确的事务处理管理,而后者支持。</li>
</ul>
</li>
<li><p>事务处理(transaction processing)可以用来维护数据库的完整性,它保证成批的MySQL操作要么完全执行,要么完全不执行。</p>
</li>
<li><p>几个术语:</p>
<ul>
<li>事务( transaction )指一组SQL语句;</li>
<li>回退( rollback )指撤销指定SQL语句的过程;</li>
<li>提交( commit )指将未存储的SQL语句结果写入数据库表;</li>
<li>保留点( savepoint )指事务处理中设置的临时占位符(place-holder),你可以对它发布回退(与回退整个事务处理不同)。</li>
</ul>
</li>
</ul>
<h3 id="2-控制事务处理"><a href="#2-控制事务处理" class="headerlink" title="2. 控制事务处理"></a>2. 控制事务处理</h3><h5 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start transaction</span><br></pre></td></tr></table></figure>

<h5 id="使用rollback"><a href="#使用rollback" class="headerlink" title="使用rollback"></a>使用rollback</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from ordertotals;</span><br><span class="line">strat transaction;</span><br><span class="line">delete from ordertotals;</span><br><span class="line">select *</span><br><span class="line">from ordertotals;</span><br><span class="line">rollback;</span><br><span class="line">select *</span><br><span class="line">from ordertotals;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述rollback取消了delete操作</li>
<li>ROLLBACK 只能在一个事务处理内使用(在执行一条 STARTTRANSACTION 命令之后)。</li>
<li>哪些语句可以回退?<ul>
<li>insert,update,delete可以回退</li>
<li>create和drop不能回退</li>
</ul>
</li>
</ul>
<h5 id="使用commit"><a href="#使用commit" class="headerlink" title="使用commit"></a>使用commit</h5><ul>
<li>隐含提交<ul>
<li>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交(implicit commit),即提交(写或保存)操作是自动进行的。</li>
</ul>
</li>
<li>在事务处理块中,提交不会隐含地进行。为进行明确的提交,使用 COMMIT 语句,如下所示:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strat transaction;</span><br><span class="line">delete from ordertotals</span><br><span class="line">where id&#x3D;111;</span><br><span class="line">delete from ordertotals</span><br><span class="line">where id&#x3D;222;</span><br><span class="line">commit;&#x2F;&#x2F;显式提交</span><br></pre></td></tr></table></figure></li>
<li>若提交前出错，自动撤销事务中的所有能撤销的操作(create,drop不能撤销)。</li>
<li>隐含事务关闭<ul>
<li>当 COMMIT 或 ROLLBACK 语句执行后,事务会自动关闭(将来的更改会隐含提交)。</li>
</ul>
</li>
</ul>
<h5 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h5><ul>
<li>为了支持回退部分事务处理,必须能在事务处理块中合适的位置放置占位符。这样,如果需要回退,可以回退到某个占位符。</li>
<li>创建占位符<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">savepoint point1;</span><br></pre></td></tr></table></figure></li>
<li>每个保留点都取标识它的唯一名字,以便在回退时,MySQL知道要回退到何处。为了回退到本例给出的保留点,可如下进行:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rollback to point1;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="更改默认的提交行为"><a href="#更改默认的提交行为" class="headerlink" title="更改默认的提交行为"></a>更改默认的提交行为</h5><ul>
<li>默认的MySQL行为是自动提交所有更改。换句话说,任何时候你执行一条MySQL语句,该语句实际上都是针对表执行的,而且所做的更改立即生效。为指示MySQL不自动提交更改,需要使用以下语句:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set autocommit&#x3D;0;</span><br></pre></td></tr></table></figure></li>
<li>autocommit 标志决定是否自动提交更改,不管有没有 COMMIT语句。设置 autocommit 为 0 (假)指示MySQL不自动提交更改(直到 autocommit 被设置为真为止)。</li>
</ul>
<h1 id="第二十七章：全球化和本地化"><a href="#第二十七章：全球化和本地化" class="headerlink" title="第二十七章：全球化和本地化"></a>第二十七章：全球化和本地化</h1><ul>
<li>本章介绍MySQL处理不同字符集和语言的基础知识。</li>
</ul>
<h3 id="1-字符集和校对顺序"><a href="#1-字符集和校对顺序" class="headerlink" title="1. 字符集和校对顺序"></a>1. 字符集和校对顺序</h3><ul>
<li>术语<ul>
<li>字符集为字母和符号的集合;</li>
<li>编码为某个字符集成员的内部表示;</li>
<li>校对为规定字符如何比较的指令。</li>
</ul>
</li>
<li>使用何种字符集和校对的决定在服务器、数据库和表级进行。</li>
<li>查看所支持的字符集完整列表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show character set;</span><br></pre></td></tr></table></figure></li>
<li>查看所支持校对的完整列表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show collation;</span><br></pre></td></tr></table></figure></li>
<li>创建表的时候指定字符集和校对顺序。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table mytable(</span><br><span class="line">    column1 int,</span><br><span class="line">    column2 char(10)</span><br><span class="line">)default character set hebrew</span><br><span class="line">collate hebrew_general_ci;</span><br><span class="line">&#x2F;&#x2F;不指定的话用数据库默认的</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第二十八章：安全管理"><a href="#第二十八章：安全管理" class="headerlink" title="第二十八章：安全管理"></a>第二十八章：安全管理</h1><h3 id="1-访问控制"><a href="#1-访问控制" class="headerlink" title="1. 访问控制"></a>1. 访问控制</h3><ul>
<li>MySQL服务器的安全基础是:用户应该对他们需要的数据具有适当的访问权,既不能多也不能少。</li>
<li>在现实世界的日常工作中,决不能使用 root 。应该创建一系列的账号,有的用于管理,有的供用户使用,有的供开发人员使用,等等。</li>
</ul>
<h3 id="2-管理用户"><a href="#2-管理用户" class="headerlink" title="2. 管理用户"></a>2. 管理用户</h3><ul>
<li>MySQL用户账号和信息存储在名为 mysql 的MySQL数据库中。</li>
</ul>
<h5 id="创建用户账号"><a href="#创建用户账号" class="headerlink" title="创建用户账号"></a>创建用户账号</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user lvkou</span><br><span class="line">identified by &#39;123456&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li>重新命名一个用户账号,使用 RENAME USER 语句<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rename user lvkou to test;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="删除用户账号"><a href="#删除用户账号" class="headerlink" title="删除用户账号"></a>删除用户账号</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop user lvkou;</span><br></pre></td></tr></table></figure>

<h5 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h5><ul>
<li>在创建用户账号后,必须接着分配访问权限。新创建的用户账号没有访问权限。它们能登录MySQL,但不能看到数据,不能执行任何数据库操作。</li>
<li>查看赋予用户账号的权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show grants for lvkou;</span><br></pre></td></tr></table></figure></li>
<li>使用grant语句赋予权限<ul>
<li>要授予的权限;</li>
<li>被授予访问权限的数据库或表;</li>
<li>用户名。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant select on student.* to lvkou;</span><br><span class="line">&#x2F;&#x2F;赋予lvkou用户在student数据库中所有表的查询权限</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>撤销权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">revoke select on student.* from lvkou;</span><br></pre></td></tr></table></figure></li>
<li>GRANT 和 REVOKE 可在几个层次上控制访问权限:<ul>
<li>整个服务器,使用 GRANT ALL 和 REVOKE ALL;</li>
<li>整个数据库,使用 ON database.*;</li>
<li>特定的表,使用 ON database.table;</li>
<li>特定的列;</li>
<li>特定的存储过程。</li>
</ul>
</li>
</ul>
<h5 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h5><table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ALL</td>
<td>除GRANT OPTION外的所有权限</td>
</tr>
<tr>
<td>ALTER</td>
<td>使用ALTER TABLE</td>
</tr>
<tr>
<td>ALTER ROUTINE</td>
<td>使用ALTER PROCEDURE和DROP PROCEDURE</td>
</tr>
<tr>
<td>CREATE</td>
<td>使用CREATE TABLE</td>
</tr>
<tr>
<td>CREATE ROUTINE</td>
<td>使用CREATE PROCEDURE</td>
</tr>
<tr>
<td>CREATE TEMPORARY TABLES</td>
<td>使用CREATE TEMPORARY TABLE</td>
</tr>
<tr>
<td>CREATE USER</td>
<td>使用CREATE USER、 DROP USER、 RENAME USER和REVOKE ALL PRIVILEGES</td>
</tr>
<tr>
<td>CREATE VIEW</td>
<td>使用CREATE VIEW</td>
</tr>
<tr>
<td>DELETE</td>
<td>使用DELETE</td>
</tr>
<tr>
<td>DROP</td>
<td>使用DROP TABLE</td>
</tr>
<tr>
<td>EXECUTE</td>
<td>使用CALL和存储过程</td>
</tr>
<tr>
<td>FILE</td>
<td>使用SELECT INTO OUTFILE和LOAD DATA INFILE</td>
</tr>
<tr>
<td>GRANT OPTION</td>
<td>使用GRANT和REVOKE</td>
</tr>
<tr>
<td>INDEX</td>
<td>使用CREATE INDEX和DROP INDEX</td>
</tr>
<tr>
<td>INSERT</td>
<td>使用INSERT</td>
</tr>
<tr>
<td>LOCK TABLES</td>
<td>使用LOCK TABLES</td>
</tr>
<tr>
<td>PROCESS</td>
<td>使用SHOW FULL PROCESSLIST</td>
</tr>
<tr>
<td>RELOAD</td>
<td>使用FLUSH</td>
</tr>
<tr>
<td>REPLICATION CLIENT</td>
<td>服务器位置的访问</td>
</tr>
<tr>
<td>REPLICATION SLAVE</td>
<td>由复制从属使用</td>
</tr>
<tr>
<td>SELECT</td>
<td>使用SELECT</td>
</tr>
<tr>
<td>SHOW DATABASES</td>
<td>使用SHOW DATABASES</td>
</tr>
<tr>
<td>SHOW VIEW</td>
<td>使用SHOW CREATE VIEW</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>使用mysqladmin shutdown(用来关闭MySQL)</td>
</tr>
<tr>
<td>SUPER</td>
<td>使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER和SET GLOBAL。还允许mysqladmin调试登录</td>
</tr>
<tr>
<td>UPDATE</td>
<td>使用UPDATE</td>
</tr>
<tr>
<td>USAGE</td>
<td>无访问权限</td>
</tr>
</tbody></table>
<h5 id="更改口令，SET-PASSWORD"><a href="#更改口令，SET-PASSWORD" class="headerlink" title="更改口令，SET PASSWORD"></a>更改口令，SET PASSWORD</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set password for lvkou&#x3D;Password(&#39;123456&#39;);</span><br><span class="line">set PASSWORD&#x3D;Password(&#39;123456&#39;);&#x2F;&#x2F;更新当前用户的口令</span><br></pre></td></tr></table></figure>

<h1 id="第二十九章：数据库维护"><a href="#第二十九章：数据库维护" class="headerlink" title="第二十九章：数据库维护"></a>第二十九章：数据库维护</h1><h3 id="1-备份数据"><a href="#1-备份数据" class="headerlink" title="1. 备份数据"></a>1. 备份数据</h3><ul>
<li>由于MySQL数据库是基于磁盘的文件,普通的备份系统和例程就能备份MySQL的数据。但是,由于这些文件总是处于打开和使用状态,普通的文件副本备份不一定总是有效。</li>
<li>下面列出这个问题的可能解决方案。<ul>
<li>使用命令行实用程序 mysqldump 转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行,以便能正确地备份转储文件。</li>
<li>可用命令行实用程序 mysqlhotcopy 从一个数据库复制所有数据(并非所有数据库引擎都支持这个实用程序)。</li>
<li>可以使用MySQL的 BACKUP TABLE 或 SELECT INTO OUTFILE 转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名,此系统文件必须不存在,否则会出错。数据可以用 RESTORETABLE 来复原。</li>
</ul>
</li>
<li>首先刷新未写数据 <ul>
<li>为了保证所有数据被写到磁盘(包括索引数据),可能需要在进行备份前使用 FLUSH TABLES 语句。</li>
</ul>
</li>
</ul>
<h3 id="2-数据维护"><a href="#2-数据维护" class="headerlink" title="2. 数据维护"></a>2. 数据维护</h3><ul>
<li>MySQL提供了一系列的语句,可以(应该)用来保证数据库正确和正常运行。<ul>
<li>ANALYZE TABLE ,用来检查表键是否正确。</li>
<li>CHECK TABLE 用来针对许多问题对表进行检查。在 MyISAM 表上还对索引进行检查<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">analyze table students;</span><br><span class="line">check table students;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="3-查看日志文件"><a href="#3-查看日志文件" class="headerlink" title="3. 查看日志文件"></a>3. 查看日志文件</h3><ul>
<li>错误日志。它包含启动和关闭问题以及任意关键错误的细节。此日志通常名为 hostname.err ,位于 data 目录中。此日志名可用–log-error 命令行选项更改。</li>
<li>查询日志。它记录所有MySQL活动,在诊断问题时非常有用。此日志文件可能会很快地变得非常大,因此不应该长期使用它。此日志通常名为 hostname.log ,位于 data 目录中。此名字可以用–log 命令行选项更改。</li>
<li>二进制日志。它记录更新过数据(或者可能更新过数据)的所有语句。此日志通常名为 hostname-bin ,位于 data 目录内。此名字可以用 –log-bin 命令行选项更改。注意,这个日志文件是MySQL5中添加的,以前的MySQL版本中使用的是更新日志。</li>
<li>缓慢查询日志。顾名思义,此日志记录执行缓慢的任何查询。这个日志在确定数据库何处需要优化很有用。此日志通常名为hostname-slow.log , 位 于 data 目 录 中 。 此 名 字可 以 用–log-slow-queries 命令行选项更改。</li>
<li>在使用日志时,可用 FLUSH LOGS 语句来刷新和重新开始所有日志文件。</li>
</ul>
<h1 id="第三十章：改善性能"><a href="#第三十章：改善性能" class="headerlink" title="第三十章：改善性能"></a>第三十章：改善性能</h1><ul>
<li>首先,MySQL(与所有DBMS一样)具有特定的硬件建议。在学习和研究MySQL时,使用任何旧的计算机作为服务器都可以。但对用于生产的服务器来说,应该坚持遵循这些硬件建议。</li>
<li>一般来说,关键的生产DBMS应该运行在自己的专用服务器上。</li>
<li>MySQL是用一系列的默认设置预先配置的,从这些设置开始通常是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大小 等 。( 为 查 看 当 前 设 置 , 可 使 用 SHOW VARIABLES; 和 SHOWSTATUS; 。)</li>
<li>MySQL一个多用户多线程的DBMS,换言之,它经常同时执行多个任务。如果这些任务中的某一个执行缓慢,则所有请求都会执行缓慢。如果你遇到显著的性能不良,可使用 SHOW PROCESSLIST显示所有活动进程(以及它们的线程ID和执行时间)。你还可以用KILL 命令终结某个特定的进程(使用这个命令需要作为管理员登录)。</li>
<li>总是有不止一种方法编写同一条 SELECT 语句。应该试验联结、并、子查询等,找出最佳的方法。</li>
<li>使用 EXPLAIN 语句让MySQL解释它将如何执行一条 SELECT 语句。一般来说,存储过程执行得比一条一条地执行其中的各条MySQL语句快。</li>
<li>应该总是使用正确的数据类型。</li>
<li>决不要检索比需求还要多的数据。换言之,不要用 SELECT * (除非你真正需要每个列)。</li>
<li>有的操作(包括 INSERT )支持一个可选的 DELAYED 关键字,如果使用它,将把控制立即返回给调用程序,并且一旦有可能就实际执行该操作。</li>
<li>在导入数据时,应该关闭自动提交。你可能还想删除索引(包括FULLTEXT 索引),然后在导入完成后再重建它们。</li>
<li>必须索引数据库表以改善数据检索的性能。确定索引什么不是一件微不足道的任务,需要分析使用的 SELECT 语句以找出重复的WHERE 和 ORDER BY 子句。如果一个简单的 WHERE 子句返回结果所花的时间太长,则可以断定其中使用的列(或几个列)就是需要索引的对象。</li>
<li>你的 SELECT 语句中有一系列复杂的 OR 条件吗?通过使用多条SELECT 语句和连接它们的 UNION 语句,你能看到极大的性能改进。</li>
<li>索引改善数据检索的性能,但损害数据插入、删除和更新的性能。如果你有一些表,它们收集数据且不经常被搜索,则在有必要之前不要索引它们。(索引可根据需要添加和删除。)</li>
<li>LIKE 很慢。一般来说,最好是使用 FULLTEXT 而不是 LIKE 。数据库是不断变化的实体。一组优化良好的表一会儿后可能就面目全非了。由于表的使用和内容的更改,理想的优化和配置也会改变。</li>
<li>最重要的规则就是,每条规则在某些条件下都会被打破。</li>
</ul>
<h1 id="附录B-样例"><a href="#附录B-样例" class="headerlink" title="附录B,样例"></a>附录B,样例</h1><h3 id="1-样例表"><a href="#1-样例表" class="headerlink" title="1. 样例表"></a>1. 样例表</h3><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><pre><code>- 管理供应商;
- 管理产品目录;
- 管理顾客列表;
- 录入顾客订单。</code></pre>
<h5 id="vendors表"><a href="#vendors表" class="headerlink" title="vendors表"></a>vendors表</h5><ul>
<li>vendors 表存储销售产品的供应商。每个供应商在这个表中有一个记录,供应商ID( vend_id )列用来匹配产品和供应商。</li>
</ul>
<table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>vend_id</td>
<td>唯一的供应商ID</td>
</tr>
<tr>
<td>vend_name</td>
<td>供应商名</td>
</tr>
<tr>
<td>vend_address</td>
<td>供应商的地址</td>
</tr>
<tr>
<td>vend_city</td>
<td>供应商的城市</td>
</tr>
<tr>
<td>vend_state</td>
<td>供应商的州</td>
</tr>
<tr>
<td>vend_zip</td>
<td>供应商的邮政编码</td>
</tr>
<tr>
<td>vend_country</td>
<td>供应商的国家</td>
</tr>
</tbody></table>
<ul>
<li>所有表都应该有主键。这个表使用 vend_id 作为主键。 vend_id 为一个自动增量字段。</li>
</ul>
<h5 id="products-表"><a href="#products-表" class="headerlink" title="products 表"></a>products 表</h5><ul>
<li>products 表包含产品目录,每行一个产品。每个产品有唯一的ID( prod_id 列),通过 vend_id (供应商的唯一ID)关联到它的供应商。</li>
</ul>
<table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>prod_id</td>
<td>唯一的产品ID</td>
</tr>
<tr>
<td>vend_id</td>
<td>产品供应商ID(关联到vendors表中的vend_id)</td>
</tr>
<tr>
<td>prod_name</td>
<td>产品名</td>
</tr>
<tr>
<td>prod_price</td>
<td>产品价格</td>
</tr>
<tr>
<td>prod_desc</td>
<td>产品描述</td>
</tr>
</tbody></table>
<ul>
<li>所有表都应该有一个主键,这个表用 prod_id 作为其主键。</li>
<li>为实施引用完整性,应该在 vend_id 上定义一个外键,关联到vendors 的 vend_id 。</li>
</ul>
<h5 id="customers-表"><a href="#customers-表" class="headerlink" title="customers 表"></a>customers 表</h5><ul>
<li>customers 表存储所有顾客的信息。每个顾客有唯一的ID( cust_id列)。</li>
</ul>
<table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>cust_id</td>
<td>唯一的顾客ID</td>
</tr>
<tr>
<td>cust_name</td>
<td>顾客名</td>
</tr>
<tr>
<td>cust_address</td>
<td>顾客的地址</td>
</tr>
<tr>
<td>cust_city</td>
<td>顾客的城市</td>
</tr>
<tr>
<td>cust_state</td>
<td>顾客的州</td>
</tr>
<tr>
<td>cust_zip</td>
<td>顾客的邮政编码</td>
</tr>
<tr>
<td>cust_country</td>
<td>顾客的国家</td>
</tr>
<tr>
<td>cust_contact</td>
<td>顾客的联系名</td>
</tr>
<tr>
<td>cust_email</td>
<td>顾客的联系email地址</td>
</tr>
</tbody></table>
<ul>
<li>所有表都应该定义主键,这个表将使用 cust_id 作为它的主键。cust_id 是一个自动增量字段。</li>
</ul>
<h5 id="orders-表"><a href="#orders-表" class="headerlink" title="orders 表"></a>orders 表</h5><ul>
<li>orders 表存储顾客订单(但不是订单细节)。每个订单唯一地编号( order_num 列)。订单用 cust_id 列(它关联到 customer 表的顾客唯一ID)与相应的顾客关联。</li>
</ul>
<table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>order_num</td>
<td>唯一订单号</td>
</tr>
<tr>
<td>order_date</td>
<td>订单日期</td>
</tr>
<tr>
<td>cust_id</td>
<td>订 单 顾 客 ID ( 关 系 到 customers 表 的cust_id)</td>
</tr>
</tbody></table>
<ul>
<li>所有表都应该定义主键,这个表使用 order_num 作为它的主键。order_num 是一个自动增量字段。</li>
<li>为实施引用完整性,应该在 cust_id 上定义一个外键,关联到customers 的 cust_id 。</li>
</ul>
<h5 id="orderitems-表"><a href="#orderitems-表" class="headerlink" title="orderitems 表"></a>orderitems 表</h5><ul>
<li>orderitems 表存储每个订单中的实际物品,每个订单的每个物品占一行。对 orders 中的每一行, orderitems 中有一行或多行。每个订单物品由订单号加订单物品(第一个物品、第二个物品等)唯一标识。订单物品通过 order_num 列(关联到 orders 中订单的唯一ID)与它们相应的订单相关联。此外,每个订单项包含订单物品的产品ID(它关联物品到products 表)。、</li>
</ul>
<table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>order_num</td>
<td>订单号(关联到orders表的order_num)</td>
</tr>
<tr>
<td>order_item</td>
<td>订单物品号(在某个订单中的顺序)</td>
</tr>
<tr>
<td>prod_id</td>
<td>产品ID(关联到products表的prod_id)</td>
</tr>
<tr>
<td>quantity</td>
<td>物品数量</td>
</tr>
<tr>
<td>item_price</td>
<td>物品价格</td>
</tr>
</tbody></table>
<ul>
<li>所有表都应该有主键,这个表使用 order_num 和 order_item 作为其主键。</li>
<li>为实施引用完整性,应该在 order_num 上定义外键,关联它到orders 的 order_num ,在 prod_id 上定义外键,关联它到 products的 prod_id 。</li>
</ul>
<h5 id="productnotes-表"><a href="#productnotes-表" class="headerlink" title="productnotes 表"></a>productnotes 表</h5><ul>
<li>productnotes 表存储与特定产品有关的注释。并非所有产品都有相关的注释,而有的产品可能有许多相关的注释。</li>
</ul>
<table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>note_id</td>
<td>唯一注释ID</td>
</tr>
<tr>
<td>prod_id</td>
<td>产品ID(对应于products表中的prod_id)</td>
</tr>
<tr>
<td>note_date</td>
<td>增加注释的日期</td>
</tr>
<tr>
<td>note_text</td>
<td>注释文本</td>
</tr>
</tbody></table>
<h3 id="2-脚本"><a href="#2-脚本" class="headerlink" title="2. 脚本"></a>2. 脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">########################################</span><br><span class="line"># MySQL Crash Course</span><br><span class="line"># http:&#x2F;&#x2F;www.forta.com&#x2F;books&#x2F;0672327120&#x2F;</span><br><span class="line"># Example table creation scripts</span><br><span class="line">########################################</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">########################</span><br><span class="line"># Create customers table</span><br><span class="line">########################</span><br><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line">  cust_id      int       NOT NULL AUTO_INCREMENT,</span><br><span class="line">  cust_name    char(50)  NOT NULL ,</span><br><span class="line">  cust_address char(50)  NULL ,</span><br><span class="line">  cust_city    char(50)  NULL ,</span><br><span class="line">  cust_state   char(5)   NULL ,</span><br><span class="line">  cust_zip     char(10)  NULL ,</span><br><span class="line">  cust_country char(50)  NULL ,</span><br><span class="line">  cust_contact char(50)  NULL ,</span><br><span class="line">  cust_email   char(255) NULL ,</span><br><span class="line">  PRIMARY KEY (cust_id)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">#########################</span><br><span class="line"># Create orderitems table</span><br><span class="line">#########################</span><br><span class="line">CREATE TABLE orderitems</span><br><span class="line">(</span><br><span class="line">  order_num  int          NOT NULL ,</span><br><span class="line">  order_item int          NOT NULL ,</span><br><span class="line">  prod_id    char(10)     NOT NULL ,</span><br><span class="line">  quantity   int          NOT NULL ,</span><br><span class="line">  item_price decimal(8,2) NOT NULL ,</span><br><span class="line">  PRIMARY KEY (order_num, order_item)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#####################</span><br><span class="line"># Create orders table</span><br><span class="line">#####################</span><br><span class="line">CREATE TABLE orders</span><br><span class="line">(</span><br><span class="line">  order_num  int      NOT NULL AUTO_INCREMENT,</span><br><span class="line">  order_date datetime NOT NULL ,</span><br><span class="line">  cust_id    int      NOT NULL ,</span><br><span class="line">  PRIMARY KEY (order_num)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">#######################</span><br><span class="line"># Create products table</span><br><span class="line">#######################</span><br><span class="line">CREATE TABLE products</span><br><span class="line">(</span><br><span class="line">  prod_id    char(10)      NOT NULL,</span><br><span class="line">  vend_id    int           NOT NULL ,</span><br><span class="line">  prod_name  char(255)     NOT NULL ,</span><br><span class="line">  prod_price decimal(8,2)  NOT NULL ,</span><br><span class="line">  prod_desc  text          NULL ,</span><br><span class="line">  PRIMARY KEY(prod_id)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">######################</span><br><span class="line"># Create vendors table</span><br><span class="line">######################</span><br><span class="line">CREATE TABLE vendors</span><br><span class="line">(</span><br><span class="line">  vend_id      int      NOT NULL AUTO_INCREMENT,</span><br><span class="line">  vend_name    char(50) NOT NULL ,</span><br><span class="line">  vend_address char(50) NULL ,</span><br><span class="line">  vend_city    char(50) NULL ,</span><br><span class="line">  vend_state   char(5)  NULL ,</span><br><span class="line">  vend_zip     char(10) NULL ,</span><br><span class="line">  vend_country char(50) NULL ,</span><br><span class="line">  PRIMARY KEY (vend_id)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">###########################</span><br><span class="line"># Create productnotes table</span><br><span class="line">###########################</span><br><span class="line">CREATE TABLE productnotes</span><br><span class="line">(</span><br><span class="line">  note_id    int           NOT NULL AUTO_INCREMENT,</span><br><span class="line">  prod_id    char(10)      NOT NULL,</span><br><span class="line">  note_date datetime       NOT NULL,</span><br><span class="line">  note_text  text          NULL ,</span><br><span class="line">  PRIMARY KEY(note_id),</span><br><span class="line">  FULLTEXT(note_text)</span><br><span class="line">) ENGINE&#x3D;MyISAM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#####################</span><br><span class="line"># Define foreign keys</span><br><span class="line">#####################</span><br><span class="line">ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_orders FOREIGN KEY (order_num) REFERENCES orders (order_num);</span><br><span class="line">ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id);</span><br><span class="line">ALTER TABLE orders ADD CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id) REFERENCES customers (cust_id);</span><br><span class="line">ALTER TABLE products ADD CONSTRAINT fk_products_vendors FOREIGN KEY (vend_id) REFERENCES vendors (vend_id);</span><br></pre></td></tr></table></figure>

<h1 id="附录D-数据类型"><a href="#附录D-数据类型" class="headerlink" title="附录D.数据类型"></a>附录D.数据类型</h1><h3 id="1-串数据类型"><a href="#1-串数据类型" class="headerlink" title="1. 串数据类型"></a>1. 串数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td>1~255个字符的定长串。它的长度必须在创建时指定,否则MySQL假定为CHAR(1)</td>
</tr>
<tr>
<td>ENUM</td>
<td>接受最多64 K个串组成的一个预定义集合的某个串</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>与TEXT相同,但最大长度为4 GB</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>与TEXT相同,但最大长度为16 K</td>
</tr>
<tr>
<td>SET</td>
<td>接受最多64个串组成的一个预定义集合的零个或多个串</td>
</tr>
<tr>
<td>TEXT</td>
<td>最大长度为64 K的变长文本</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>与TEXT相同,但最大长度为255字节</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>长度可变,最多不超过255字节。如果在创建时指定为VARCHAR(n),则可存储0到n个字符的变长串(其中n≤255)</td>
</tr>
</tbody></table>
<ul>
<li>使用引号 <ul>
<li>不管使用何种形式的串数据类型,串值都必须括在引号内(通常单引号更好)。</li>
</ul>
</li>
</ul>
<h3 id="2-数值数据类型"><a href="#2-数值数据类型" class="headerlink" title="2. 数值数据类型"></a>2. 数值数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BIT</td>
<td>位字段,1~64位。(在MySQL 5之前,BIT在功能上等价于TINYINT</td>
</tr>
<tr>
<td>BIGINT</td>
<td>整数值,支持-9223372036854775808<del>9223372036854775807(如果是UNSIGNED,为0</del>18446744073709551615)的数</td>
</tr>
<tr>
<td>BOOLEAN(或BOOL)</td>
<td>布尔标志,或者为0或者为1,主要用于开/关(on/off)标志</td>
</tr>
<tr>
<td>DECIMAL(或DEC)</td>
<td>精度可变的浮点值</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>双精度浮点值</td>
</tr>
<tr>
<td>FLOAT</td>
<td>单精度浮点值</td>
</tr>
<tr>
<td>INT(或INTEGER)</td>
<td>整数值,支持2147483648<del>2147483647 (如果是UNSIGNED,为0</del>4294967295)的数</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>整数值,支持-8388608<del>8388607(如果是UNSIGNED,为0</del>16777215)的数</td>
</tr>
<tr>
<td>REAL</td>
<td>4字节的浮点值</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>整数值,支持-32768<del>32767(如果是UNSIGNED,为0</del>65535)的数</td>
</tr>
<tr>
<td>TINYINT</td>
<td>整数值,支持128<del>127(如果为UNSIGNED,为0</del>255)的数</td>
</tr>
</tbody></table>
<ul>
<li>不使用引号 <ul>
<li>与串不一样,数值不应该括在引号内。</li>
</ul>
</li>
<li>存储货币数据类型<ul>
<li>MySQL中没有专门存储货币的数据类型,一般情况下使用 DECIMAL(8, 2)</li>
</ul>
</li>
</ul>
<h3 id="3-日期和时间数据类型"><a href="#3-日期和时间数据类型" class="headerlink" title="3. 日期和时间数据类型"></a>3. 日期和时间数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>表示1000-01-01~9999-12-31的日期,格式为YYYY-MM-DD</td>
</tr>
<tr>
<td>DATETIME</td>
<td>DATE和TIME的组合</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>功能和DATETIME相同(但范围较小)</td>
</tr>
<tr>
<td>TIME</td>
<td>格式为HH:MM:SS</td>
</tr>
<tr>
<td>YEAR</td>
<td>用2位数字表示,范围是70(1970年)<del>69(2069年),用4位数字表示,范围是1901年</del>2155年</td>
</tr>
</tbody></table>
<h3 id="4-二进制数据类型"><a href="#4-二进制数据类型" class="headerlink" title="4. 二进制数据类型"></a>4. 二进制数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BLOB</td>
<td>Blob最大长度为64 KB</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>Blob最大长度为16 MB</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>Blob最大长度为4 GB</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>Blob最大长度为255字节</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>《head first设计模式》</title>
    <url>/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/</url>
    <content><![CDATA[<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ol>
<li>本书用到java，把每个设计模式都用C++实现了一遍，项目地址为：<a href="https://github.com/xtlvlv/Design-patterns">github</a></li>
<li>真.受益匪浅<a id="more"></a>

</li>
</ol>
<h1 id="一、设计模式入门"><a href="#一、设计模式入门" class="headerlink" title="一、设计模式入门"></a>一、设计模式入门</h1><h3 id="1-入门的duck，注意接口的使用"><a href="#1-入门的duck，注意接口的使用" class="headerlink" title="1. 入门的duck，注意接口的使用"></a>1. 入门的duck，注意接口的使用</h3><!-- ![simple_duck](./img/simple_duck.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/simple_duck.png" class="" title="simple_duck.png">

<h3 id="2-『有一个』可能比『是一个』更好。"><a href="#2-『有一个』可能比『是一个』更好。" class="headerlink" title="2.『有一个』可能比『是一个』更好。"></a>2.『有一个』可能比『是一个』更好。</h3><ul>
<li>『有一个』关系相当有趣:每一鸭子都有一个FlyBehavior且有一个QuackBehavior,让鸭子将飞行和呱呱叫委托它们代为处理。</li>
<li>当你将两个类结合起来使用,如同本例一般,这就是组合(composition)。这种作法和『继承』不同的地方在于,鸭子的行为不是继承而来,而是和适当的行为对象『组合』而来。</li>
<li>这是一个很重要的技巧。其实是使用了我们的第三个设计原则:多用组合,少用继承。</li>
</ul>
<h3 id="3-策略模式"><a href="#3-策略模式" class="headerlink" title="3. 策略模式"></a>3. 策略模式</h3><ul>
<li>刚刚用的就是策略模式(Strategy Pattern)。</li>
<li>策略模式：定义了算法族,分别封装起来,让它们之间可以互相替换,此模式让算法的变化独立于使用算法的客户。</li>
</ul>
<h3 id="4-设计谜题"><a href="#4-设计谜题" class="headerlink" title="4. 设计谜题"></a>4. 设计谜题</h3><ul>
<li>在下面,你将看到一堆杂乱的类与接口,这是取自一个动作冒险游戏。你将看到代表游戏角色的类,以及武器行为的类。每个角色一次只能使用一个武器,但是可以在游戏的过程中换武器。你的工作是要弄清楚这一切…  <!-- ![换武器题](./img/换武器题.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E6%8D%A2%E6%AD%A6%E5%99%A8%E9%A2%98.png" class="" title="换武器题.png"></li>
<li>解答  <!-- ![换武器解答](./img/换武器解答.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E6%8D%A2%E6%AD%A6%E5%99%A8%E8%A7%A3%E7%AD%94.png" class="" title="换武器解答.png">

</li>
</ul>
<h3 id="5-本章总结"><a href="#5-本章总结" class="headerlink" title="5. 本章总结"></a>5. 本章总结</h3><ul>
<li>OO基础<ol>
<li>抽象</li>
<li>封装</li>
<li>多态</li>
<li>继承</li>
</ol>
</li>
<li>OO原则<ol>
<li>封装变化。</li>
<li>多用组合,少用继承。</li>
<li>针对接口编程，不针对实现编程。</li>
</ol>
</li>
<li>OO模式<ul>
<li>策略：定义了算法族,分别封装起来,让它们之间可以互相替换,此模式让算法的变化独立于使用算法的客户。</li>
</ul>
</li>
</ul>
<h1 id="二、观察者模式，让你的对象知悉现状"><a href="#二、观察者模式，让你的对象知悉现状" class="headerlink" title="二、观察者模式，让你的对象知悉现状"></a>二、观察者模式，让你的对象知悉现状</h1><h3 id="1-气象监测应用的概况"><a href="#1-气象监测应用的概况" class="headerlink" title="1. 气象监测应用的概况"></a>1. 气象监测应用的概况</h3><!-- ![气象监测应用的概况.png](./img/气象监测应用的概况.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E6%B0%94%E8%B1%A1%E7%9B%91%E6%B5%8B%E5%BA%94%E7%94%A8%E7%9A%84%E6%A6%82%E5%86%B5.png" class="" title="气象监测应用的概况.png">
<ul>
<li>我们的工作就是建立一个应用,利用WeatherData对象取得数据,并更新三个布告板:目前状况、气象统计和天气预报。<h3 id="2-一个错误示范"><a href="#2-一个错误示范" class="headerlink" title="2. 一个错误示范"></a>2. 一个错误示范</h3><!-- ![一个错误示范.png](./img/一个错误示范.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%A4%BA%E8%8C%83.png" class="" title="一个错误示范.png"></li>
<li>错误点<!-- ![观察者模式答案.png](./img/观察者模式答案.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AD%94%E6%A1%88.png" class="" title="观察者模式答案.png">
<h3 id="3-认识观察者模式"><a href="#3-认识观察者模式" class="headerlink" title="3. 认识观察者模式"></a>3. 认识观察者模式</h3></li>
<li>我们看看报纸和杂志的订阅是怎么回事:<ol>
<li>报社的业务就是出版报纸。</li>
<li>向某家报社订阅报纸,只要他们有新报纸出版,就会给你送来。只要你是他们的订户,你就会一直收到新报纸。</li>
<li>当你不想再看报纸的时候,取消订阅,他们就不会再送新报纸来。</li>
<li>只要报社还在运营,就会一直有人(或单位)向他们订阅报纸或取消订阅报纸。</li>
</ol>
</li>
<li>出版者+订阅者=观察者模式=主题(被观察者，observable)+观察者(observer)  <!-- ![观察者模式.png](./img/观察者模式.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" class="" title="观察者模式.png">

</li>
</ul>
<h3 id="4-定义观察者模式"><a href="#4-定义观察者模式" class="headerlink" title="4. 定义观察者模式"></a>4. 定义观察者模式</h3><ul>
<li>观察者模式<ul>
<li>定义了对象之间的一对多依赖,这样一来,当一个对象改变状态时,它的所有依赖者都会收到通知并自动更新。</li>
</ul>
</li>
<li>类图  <!-- ![观察者模式类图.png](./img/观察者模式类图.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" class="" title="观察者模式类图.png">

</li>
</ul>
<h3 id="5-设计气象站"><a href="#5-设计气象站" class="headerlink" title="5. 设计气象站"></a>5. 设计气象站</h3><ul>
<li>气象站类图<!-- ![气象站类图.png](./img/气象站类图.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/%E6%B0%94%E8%B1%A1%E7%AB%99%E7%B1%BB%E5%9B%BE.png" class="" title="气象站类图.png">

</li>
</ul>
<h3 id="6-拉推"><a href="#6-拉推" class="headerlink" title="6. 拉推"></a>6. 拉推</h3><ul>
<li>以上是推的方式，被观察者改变就主动告诉所有观察者</li>
<li>还有拉的方式，被观察者提供get接口，观察者主动获取数据</li>
<li>这两种都用代码实现了，在github项目中</li>
</ul>
<h3 id="6-java内置观察者模式接口"><a href="#6-java内置观察者模式接口" class="headerlink" title="6. java内置观察者模式接口"></a>6. java内置观察者模式接口</h3><ul>
<li>java.util.Observable,被观察者</li>
<li>java.util.Observer,观察者</li>
<li>java.util.Observable的黑暗面<ol>
<li>Observable是一个类<ul>
<li>首先,因为Observable是一个“类”,你必须设计一个类继承它。如果某类想同时具有Observable类和另一个超类的行为,就会陷入两难,毕竟Java不支持多重继承。这限制了Observable的复用潜力</li>
<li>再者,因为没有Observable接口,所以你无法建立自己的实现,和Java内置的Observer API搭配使用,也无法将java.util的实现换成另一套做法的实现</li>
</ul>
</li>
<li>Observable将关键的方法保护起来<ul>
<li>你会发现setChanged()方法被保护起来了(被定义成protected)。那又怎么样呢?这意味着:除非你继承自Observable,否则你无法创建Observable实例并组合到你自己的对象中来。这个设计违反了第二个设计原则:“多用组合,少用继承”。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><ul>
<li>OO基础<ol>
<li>抽象</li>
<li>封装</li>
<li>多态</li>
<li>继承</li>
</ol>
</li>
<li>OO原则<ol>
<li>封装变化。</li>
<li>多用组合,少用继承。</li>
<li>针对接口编程，不针对实现编程。</li>
<li>为交互对象之间的松耦合设计而努力</li>
</ol>
</li>
<li>OO模式<ul>
<li>观察者模式：定义了对象之间的一对多依赖,这样一来,当一个对象改变状态时,它的所有依赖者都会收到通知并自动更新。<h3 id="8-要点"><a href="#8-要点" class="headerlink" title="8. 要点"></a>8. 要点</h3></li>
</ul>
</li>
</ul>
<ol>
<li>观察者模式定义了对象之间一对多的关系。</li>
<li>主题(也就是可观察者)用一个共同的接口来更新观察者</li>
<li>观察者和可观察者之间用松耦合方式结合(loosecoupl-ing),可观察者不知道观察者的细节,只知道观察者实现了观察者接口。</li>
<li>使用此模式时,你可从被观察者处推(push)或拉(pull)数据(然而,推的方式被认为更“正确”)。</li>
<li>有多个观察者时,不可以依赖特定的通知次序。</li>
<li>Java有多种观察者模式的实现,包括了通用的java.util.Observable。</li>
<li>要注意java.util.Observable实现上所带来的一些问题。</li>
<li>如果有必要的话,可以实现自己的Observable,这并不难,不要害怕。</li>
<li>Swing大量使用观察者模式,许多GUI框架也是如此。</li>
<li>此模式也被应用在许多地方,例如:JavaBeans、RMI。</li>
</ol>
<h1 id="三、装饰者模式，装饰对象"><a href="#三、装饰者模式，装饰对象" class="headerlink" title="三、装饰者模式，装饰对象"></a>三、装饰者模式，装饰对象</h1><h3 id="1-认识装饰者模式"><a href="#1-认识装饰者模式" class="headerlink" title="1. 认识装饰者模式"></a>1. 认识装饰者模式</h3><ul>
<li>我们要以饮料为主体,然后在运行时以调料来“装饰”(decorate)饮料。比方说,如果顾客想要摩卡和奶泡深焙咖啡,那么,要做的是:<ol>
<li>拿一个深焙咖啡(DarkRoast)对象</li>
<li>以摩卡(Mocha)对象装饰它</li>
<li>以奶泡(Whip)对象装饰它</li>
<li>调用cost()方法,并依赖委托(delegate)将调料的价钱加上去。<h3 id="2-以装饰者构造饮料订单"><a href="#2-以装饰者构造饮料订单" class="headerlink" title="2. 以装饰者构造饮料订单"></a>2. 以装饰者构造饮料订单</h3><!-- ![以装饰者构造饮料订单1](./img/1.以装饰者构造饮料订单1.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/1.%E4%BB%A5%E8%A3%85%E9%A5%B0%E8%80%85%E6%9E%84%E9%80%A0%E9%A5%AE%E6%96%99%E8%AE%A2%E5%8D%951.png" class="" title="1.以装饰者构造饮料订单1.png">
<!-- ![以装饰者构造饮料订单2](./img/2.以装饰者构造饮料订单2.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/2.%E4%BB%A5%E8%A3%85%E9%A5%B0%E8%80%85%E6%9E%84%E9%80%A0%E9%A5%AE%E6%96%99%E8%AE%A2%E5%8D%952.png" class="" title="2.以装饰者构造饮料订单2.png">

</li>
</ol>
</li>
</ul>
<h3 id="3-定义装饰者模式"><a href="#3-定义装饰者模式" class="headerlink" title="3. 定义装饰者模式"></a>3. 定义装饰者模式</h3><ul>
<li>装饰者模式<ul>
<li>动态地将责任附加到对象上。若要扩展功能,装饰者提供了比继承更有弹性的替代方案。</li>
</ul>
</li>
<li>装饰者模式类图<!-- ![3.装饰者模式类图.png](./img/3.装饰者模式类图.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/3.%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" class="" title="3.装饰者模式类图.png">

</li>
</ul>
<h3 id="4-装饰我们的饮料"><a href="#4-装饰我们的饮料" class="headerlink" title="4. 装饰我们的饮料"></a>4. 装饰我们的饮料</h3><!-- ![4.装饰我们的饮料.png](./img/4.装饰我们的饮料.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/4.%E8%A3%85%E9%A5%B0%E6%88%91%E4%BB%AC%E7%9A%84%E9%A5%AE%E6%96%99.png" class="" title="4.装饰我们的饮料.png">

<h3 id="5-真实世界的装饰者-Java-I-O"><a href="#5-真实世界的装饰者-Java-I-O" class="headerlink" title="5. 真实世界的装饰者:Java I/O"></a>5. 真实世界的装饰者:Java I/O</h3><!-- ![5.装饰者例子.png](./img/5.装饰者例子.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/5.%E8%A3%85%E9%A5%B0%E8%80%85%E4%BE%8B%E5%AD%90.png" class="" title="5.装饰者例子.png">
<ul>
<li>装饰javaio类<!-- ![装饰javaio类](./img/6.装饰javaio类.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/6.%E8%A3%85%E9%A5%B0javaio%E7%B1%BB.png" class="" title="6.装饰javaio类.png"></li>
<li>但是JavaAI/O也引出装饰者模式的一个“缺点”:利用装饰者模式,常常造成设计中有大量的小类,数量实在太多,可能会造成使用此API程序员的困扰。但是,现在你已经了解了装饰者的工作原理,以后当使用别人的大量装饰的API时,就可以很容易地辨别出他们的装饰者类是如何组织的,以方便用包装方式取得想要的行为。</li>
</ul>
<h3 id="6-编写自己的Java-I-0装饰者"><a href="#6-编写自己的Java-I-0装饰者" class="headerlink" title="6. 编写自己的Java I/0装饰者"></a>6. 编写自己的Java I/0装饰者</h3><ul>
<li>编写一个装饰者,把输入流内的所有大写字符转成小写。<!-- ![7.自己的javaio装饰者.png](./img/7.自己的javaio装饰者.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/7.%E8%87%AA%E5%B7%B1%E7%9A%84javaio%E8%A3%85%E9%A5%B0%E8%80%85.png" class="" title="7.自己的javaio装饰者.png"></li>
<li>测试<!-- ![8.javaio装饰者测试.png](./img/8.javaio装饰者测试.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/8.javaio%E8%A3%85%E9%A5%B0%E8%80%85%E6%B5%8B%E8%AF%95.png" class="" title="8.javaio装饰者测试.png">

</li>
</ul>
<h3 id="7-总结-1"><a href="#7-总结-1" class="headerlink" title="7. 总结"></a>7. 总结</h3><ul>
<li>OO基础<ol>
<li>抽象</li>
<li>封装</li>
<li>多态</li>
<li>继承</li>
</ol>
</li>
<li>OO原则<ol>
<li>封装变化。</li>
<li>多用组合,少用继承。</li>
<li>针对接口编程，不针对实现编程。</li>
<li>为交互对象之间的松耦合设计而努力</li>
<li>对扩展开放，对修改关闭</li>
</ol>
</li>
<li>OO模式<ul>
<li>装饰者模式：动态地将责任附加到对象上。若要扩展功能,装饰者提供了比继承更有弹性的替代方案。</li>
</ul>
</li>
</ul>
<h3 id="8-要点-1"><a href="#8-要点-1" class="headerlink" title="8. 要点"></a>8. 要点</h3><ol>
<li>继承属于扩展形式之一,但不见得是达到弹性设计的最佳方式。</li>
<li>在我们的设计中,应该允许行为可以被扩展,而无须修改现有的代码。</li>
<li>组合和委托可用于在运行时动态地加上新的行为。</li>
<li>除了继承,装饰者模式也可以让我们扩展行为。</li>
<li>装饰者模式意味着一群装饰者类,这些类用来包装具体组件。</li>
<li>装饰者类反映出被装饰的组件类型(事实上,他们具有相同的类型,都经过接口或继承实现)。</li>
<li>装饰者可以在被装饰者的行为前面与 / 或后面加上自己的行为,甚至将被装饰者的行为整个取代掉,而达到特定的目的。</li>
<li>你可以用无数个装饰者包装一个组件。</li>
<li>装饰者一般对组件的客户是透明的,除非客户程序依赖于组件的具体类型。</li>
<li>装饰者会导致设计中出现许多小对象,如果过度使用,会让程序变得很复杂。</li>
</ol>
<h1 id="四、工厂模式，烘烤OO的精华"><a href="#四、工厂模式，烘烤OO的精华" class="headerlink" title="四、工厂模式，烘烤OO的精华"></a>四、工厂模式，烘烤OO的精华</h1><h3 id="1-定义简单工厂"><a href="#1-定义简单工厂" class="headerlink" title="1. 定义简单工厂"></a>1. 定义简单工厂</h3><ul>
<li>简单工厂其实并不是一个设计模式，比较像是一种编程习惯。它并不是“工厂模式”<!-- ![9.简单工厂.png](./img/9.简单工厂.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/9.%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.png" class="" title="9.简单工厂.png">

</li>
</ul>
<h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h3><ul>
<li>所有工厂模式都用来封装对象的创建。</li>
<li>工厂方法模式通过让子类决定创建的对象是什么，来达到将对象创建的过程封装的目的。</li>
<li>类图<!-- ![工厂模式创建者类](./img/10.工厂模式创建者类.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/10.%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E8%80%85%E7%B1%BB.png" class="" title="10.工厂模式创建者类.png">
<!-- ![工厂模式产品类](./img/11.工厂模式产品类.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/11.%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BA%A7%E5%93%81%E7%B1%BB.png" class="" title="11.工厂模式产品类.png">

</li>
</ul>
<h3 id="3-另一个观点：平行的类层级"><a href="#3-另一个观点：平行的类层级" class="headerlink" title="3. 另一个观点：平行的类层级"></a>3. 另一个观点：平行的类层级</h3><!-- ![12.平行的类层级.png](./img/12.平行的类层级.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/12.%E5%B9%B3%E8%A1%8C%E7%9A%84%E7%B1%BB%E5%B1%82%E7%BA%A7.png" class="" title="12.平行的类层级.png">

<h3 id="4-定义工厂方法模式"><a href="#4-定义工厂方法模式" class="headerlink" title="4. 定义工厂方法模式"></a>4. 定义工厂方法模式</h3><ul>
<li>工厂方法模式<ul>
<li>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂模式让类把实例化推迟到子类。</li>
</ul>
</li>
<li>工厂类图<!-- ![13.工厂类图.png](./img/13.工厂类图.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/13.%E5%B7%A5%E5%8E%82%E7%B1%BB%E5%9B%BE.png" class="" title="13.工厂类图.png">

</li>
</ul>
<h3 id="5-对象依赖"><a href="#5-对象依赖" class="headerlink" title="5. 对象依赖"></a>5. 对象依赖</h3><ul>
<li>当直接实例化一个对象时，就是在依赖它的具体类，也就是new的时候</li>
<li>下面是一个依赖性很高的披萨例子<!-- ![18.高依赖性披萨.png](./img/18.高依赖性披萨.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/18.%E9%AB%98%E4%BE%9D%E8%B5%96%E6%80%A7%E6%8A%AB%E8%90%A8.png" class="" title="18.高依赖性披萨.png">

</li>
</ul>
<h3 id="6-依赖倒置原则"><a href="#6-依赖倒置原则" class="headerlink" title="6. 依赖倒置原则"></a>6. 依赖倒置原则</h3><ul>
<li><p>设计原则：要依赖抽象，不要依赖具体类。</p>
</li>
<li><p>这个原则听起来很像是“针对接口编程，不针对实现编程”，然而这里更强调“抽象”</p>
</li>
<li><p>什么意思？</p>
<ul>
<li>之前的PizzaStore是“高层组件”，而披萨是“低层组件”，很清楚的，PizzaStore依赖这些具体披萨类</li>
<li>现在，这个原则告诉我们，应该重写代码以便于我们依赖抽象类，而不依赖具体类。对于高层和底层模块都应该如此。</li>
</ul>
</li>
<li><p>什么是“高层”和“低层”</p>
<ul>
<li>PizzaStore是个高层组件，因为它的行为是由披萨定义的；PizzaStore创建所有不同的披萨对象，准备、烘烤、切片、装盒；</li>
<li>而披萨本身属于低层组件</li>
</ul>
</li>
<li><p>应用工厂方法后的依赖关系图</p>
<ul>
<li>如下图所示，在应用工厂方法后，高层组件(PizzaStore)和低层组件(披萨)都依赖Pizza抽象。<!-- ![19.应用工厂方法后的依赖关系图.png](./img/19.应用工厂方法后的依赖关系图.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/19.%E5%BA%94%E7%94%A8%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%90%8E%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E5%9B%BE.png" class="" title="19.应用工厂方法后的依赖关系图.png"></li>
</ul>
</li>
<li><p>想要遵循依赖倒置原则，工厂方法并非是唯一的技巧，但却是最有威力的技巧之一。</p>
</li>
<li><p>几个指导方针帮助你遵循此原则</p>
<ol>
<li>变量不可以持有具体类的引用<ul>
<li>如果使用new,就会持有具体类的引用，可以用工厂来避免这样的做法</li>
</ul>
</li>
<li>不要让类派生自具体类<ul>
<li>如果派生自具体类，你就会依赖具体类，请派生自一个抽象(接口抽象类，用C++就是virtual)</li>
</ul>
</li>
<li>不要覆盖类中已实现的方法<ul>
<li>如股票覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享</li>
</ul>
</li>
</ol>
<ul>
<li>要完全遵守这些指导方针几乎不可能，要尽量遵守</li>
</ul>
</li>
</ul>
<h3 id="7-定义抽象工厂模式"><a href="#7-定义抽象工厂模式" class="headerlink" title="7. 定义抽象工厂模式"></a>7. 定义抽象工厂模式</h3><ul>
<li><p>抽象工厂模式</p>
<ul>
<li>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类</li>
</ul>
</li>
<li><p>抽象工厂类图</p>
<!-- ![14.抽象工厂类图.png](./img/14.抽象工厂类图.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/14.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E7%B1%BB%E5%9B%BE.png" class="" title="14.抽象工厂类图.png"></li>
<li><p>从PizzaStore来看类图</p>
<!-- ![15.从PizzaStore来看类图.png](./img/15.从PizzaStore来看类图.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/15.%E4%BB%8EPizzaStore%E6%9D%A5%E7%9C%8B%E7%B1%BB%E5%9B%BE.png" class="" title="15.从PizzaStore来看类图.png">
</li>
<li><p>都做哪些改变</p>
<ol>
<li>引入新类型的工厂，也就是抽象工厂，来创建披萨原料家族</li>
<li>我们的代码将从实际工厂解耦，以便在不同上下文中实现各式各样的工厂，制造出不同的产品。例如，不同的区域，不同的外观</li>
<li>可以替换不同的工厂来取得不停的行为</li>
</ol>
</li>
</ul>
<h3 id="8-比较工厂方法和抽象工厂"><a href="#8-比较工厂方法和抽象工厂" class="headerlink" title="8. 比较工厂方法和抽象工厂"></a>8. 比较工厂方法和抽象工厂</h3><ul>
<li>二者都是负责创建对象，但工厂方法使用的是继承，抽象工厂使用的是组合</li>
<li>抽象工厂的一个优点是可以把一群相关的产品集合起来<!-- ![16.比较工厂和抽象工厂.png](./img/16.比较工厂和抽象工厂.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/16.%E6%AF%94%E8%BE%83%E5%B7%A5%E5%8E%82%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.png" class="" title="16.比较工厂和抽象工厂.png">
<!-- ![17.比较工厂和抽象工厂2.png](./img/17.比较工厂和抽象工厂2.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/17.%E6%AF%94%E8%BE%83%E5%B7%A5%E5%8E%82%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%822.png" class="" title="17.比较工厂和抽象工厂2.png">

</li>
</ul>
<h3 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h3><ul>
<li>OO基础<ol>
<li>抽象</li>
<li>封装</li>
<li>多态</li>
<li>继承</li>
</ol>
</li>
<li>OO原则<ol>
<li>封装变化。</li>
<li>多用组合,少用继承。</li>
<li>针对接口编程，不针对实现编程。</li>
<li>为交互对象之间的松耦合设计而努力</li>
<li>对扩展开放，对修改关闭</li>
<li>依赖抽象，不要依赖具体类</li>
</ol>
</li>
<li>OO模式<ul>
<li>工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂模式让类把实例化推迟到子类。</li>
</ul>
</li>
</ul>
<h3 id="10-要点"><a href="#10-要点" class="headerlink" title="10. 要点"></a>10. 要点</h3><ol>
<li>所有的工厂都是用来封装对象的创建</li>
<li>简单工厂，虽然不是真正的设计模式，但扔不失为一个简单的方法，可以将客户程序从具体类解耦</li>
<li>工厂方法使用继承，把对象的创建委托给子类，子类实现工厂方法来创建对象</li>
<li>抽象工厂使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。</li>
<li>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合</li>
<li>工厂方法允许将实例化延迟到子类进行</li>
<li>抽象工厂创建相关的对象家族，而不需要依赖它们的具体类</li>
<li>依赖倒置原则，知道我们避免依赖具体类型，而要尽量依赖抽象</li>
<li>工厂是很有威力的技巧，帮助我们针对抽象编程，而不是针对具体类编程</li>
</ol>
<h1 id="五、单件模式，独一无二的对象"><a href="#五、单件模式，独一无二的对象" class="headerlink" title="五、单件模式，独一无二的对象"></a>五、单件模式，独一无二的对象</h1><h3 id="1-定义单件模式-单实例模式"><a href="#1-定义单件模式-单实例模式" class="headerlink" title="1. 定义单件模式(单实例模式)"></a>1. 定义单件模式(单实例模式)</h3><ul>
<li>确保一个类只有一个实例，并提供一个全局访问点</li>
<li>经典例子<!-- ![20.简单单实例](./img/20.简单单实例.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/20.%E7%AE%80%E5%8D%95%E5%8D%95%E5%AE%9E%E4%BE%8B.png" class="" title="20.简单单实例.png">

</li>
</ul>
<h3 id="2-处理多线程"><a href="#2-处理多线程" class="headerlink" title="2. 处理多线程"></a>2. 处理多线程</h3><ul>
<li>若是多线程创建单实例对象还是有可能创建多个对象</li>
<li>把getInstance()变成同步(synchronized)方法,在java中加上synchronized关键字<ul>
<li>这样不会有两个线程同时进入这个方法</li>
<li>同步会降低性能，而且，只有第一次执行此方法时，也就是还没创建对象时才需要同步，对象创建以后异步访问也没问题，之后的同步就是累赘</li>
</ul>
</li>
<li>改善多线程<ol>
<li>如果getInstance()的性能对应用程序不是很关键，就什么都别做，在getInstance()使用不频繁的情况下可以这样</li>
<li>使用“急切”创建实例，而不用延迟实例化的做法 <!-- ![21.急切创建实例.png](./img/21.急切创建实例.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/21.%E6%80%A5%E5%88%87%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B.png" class="" title="21.急切创建实例.png">
<ul>
<li>如果应用程序总是创建并使用单实例，或者在创建和运行时方面的负担不太繁重，可以用这种办法</li>
</ul>
</li>
<li>用“双重检查加锁”，在getInstance()中减少使用同步 <!-- ![22.双重加锁](./img/22.双重加锁.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/22.%E5%8F%8C%E9%87%8D%E5%8A%A0%E9%94%81.png" class="" title="22.双重加锁.png">
<ul>
<li>这样只有第一次会同步</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul>
<li>OO基础<ol>
<li>抽象</li>
<li>封装</li>
<li>多态</li>
<li>继承</li>
</ol>
</li>
<li>OO原则<ol>
<li>封装变化。</li>
<li>多用组合,少用继承。</li>
<li>针对接口编程，不针对实现编程。</li>
<li>为交互对象之间的松耦合设计而努力</li>
<li>对扩展开放，对修改关闭</li>
<li>依赖抽象，不要依赖具体类</li>
</ol>
</li>
<li>OO模式<ul>
<li>单件模式：确保一个类只有一个实例，并提供一个全局访问点</li>
</ul>
</li>
</ul>
<h3 id="4-要点"><a href="#4-要点" class="headerlink" title="4. 要点"></a>4. 要点</h3><ol>
<li>单件模式确保程序中一个类最多只有一个实例</li>
<li>单件模式也提供访问这个实例的全局点</li>
<li>在java中实现单件模式需要私有的构造器，一个静态方法和一个静态变量</li>
<li>确定在性能和资源上的限制，然后小心的选择适当的方案来实现单件，以解决多线程问题(我们必须认定所有的程序都是多线程的)</li>
<li>java低版本(1.5以下)使用双重加锁单实例有一些问题</li>
</ol>
<h1 id="六、命令模式，封装调用"><a href="#六、命令模式，封装调用" class="headerlink" title="六、命令模式，封装调用"></a>六、命令模式，封装调用</h1><h3 id="1-命令模式简单介绍–餐厅"><a href="#1-命令模式简单介绍–餐厅" class="headerlink" title="1. 命令模式简单介绍–餐厅"></a>1. 命令模式简单介绍–餐厅</h3><ul>
<li><p>餐厅的交互过程</p>
  <!-- ![24.餐厅交互过程](./img/24.餐厅交互过程.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/24.%E9%A4%90%E5%8E%85%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B.png" class="" title="24.餐厅交互过程.png">
</li>
<li><p>从餐厅到命令模式</p>
  <!-- ![25.餐厅的命令模式](./img/25.餐厅的命令模式.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/25.%E9%A4%90%E5%8E%85%E7%9A%84%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.png" class="" title="25.餐厅的命令模式.png">
</li>
<li><p>餐厅角色</p>
  <!-- ![26.餐厅角色](./img/26.餐厅角色.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/26.%E9%A4%90%E5%8E%85%E8%A7%92%E8%89%B2.png" class="" title="26.餐厅角色.png">
</li>
<li><p>java代码例子</p>
<ol>
<li>实现命令接口 <!-- ![27.实现命令接口](./img/27.实现命令接口.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/27.%E5%AE%9E%E7%8E%B0%E5%91%BD%E4%BB%A4%E6%8E%A5%E5%8F%A3.png" class="" title="27.实现命令接口.png"></li>
<li>实现点灯打开命令 <!-- ![28.电灯打开命令](./img/28.电灯打开命令.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/28.%E7%94%B5%E7%81%AF%E6%89%93%E5%BC%80%E5%91%BD%E4%BB%A4.png" class="" title="28.电灯打开命令.png"></li>
<li>在控制器中使用命令对象 <!-- ![29.控制器中使用命令对象](./img/29.控制器中使用命令对象.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/29.%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AF%B9%E8%B1%A1.png" class="" title="29.控制器中使用命令对象.png"></li>
<li>测试控制器的使用 <!-- ![30.控制器测试](./img/30.控制器测试.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/30.%E6%8E%A7%E5%88%B6%E5%99%A8%E6%B5%8B%E8%AF%95.png" class="" title="30.控制器测试.png">

</li>
</ol>
</li>
</ul>
<h3 id="2-定义命令模式"><a href="#2-定义命令模式" class="headerlink" title="2. 定义命令模式"></a>2. 定义命令模式</h3><ul>
<li>命令模式：将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象，命令模式也支持可撤销的操作</li>
<li>类图  <!-- ![23.命令者模式类图.png](./img/23.命令者模式类图.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/23.%E5%91%BD%E4%BB%A4%E8%80%85%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" class="" title="23.命令者模式类图.png">

</li>
</ul>
<h3 id="3-遥控器例子"><a href="#3-遥控器例子" class="headerlink" title="3. 遥控器例子"></a>3. 遥控器例子</h3><ol>
<li>将命令指定到插槽<ul>
<li>将遥控器的每个插槽对应到一个命令，这样就让遥控器变成“调用者”。当按下按钮，相应命令对象的execute()方法就会被调用，其结果就是，接收者(如电灯，电扇)的动作被调用<!-- ![31.遥控器插槽](./img/31.遥控器插槽.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/31.%E9%81%A5%E6%8E%A7%E5%99%A8%E6%8F%92%E6%A7%BD.png" class="" title="31.遥控器插槽.png"></li>
</ul>
</li>
<li>实现遥控器 <!-- ![32.实现遥控器](./img/32.实现遥控器.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/32.%E5%AE%9E%E7%8E%B0%E9%81%A5%E6%8E%A7%E5%99%A8.png" class="" title="32.实现遥控器.png"></li>
<li>实现命令<ul>
<li>打开音响  <!-- ![33.打开音响命令](./img/33.打开音响命令.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/33.%E6%89%93%E5%BC%80%E9%9F%B3%E5%93%8D%E5%91%BD%E4%BB%A4.png" class="" title="33.打开音响命令.png"></li>
<li>其他类似</li>
</ul>
</li>
<li>测试遥控器类 <!-- ![34.测试遥控器类](./img/34.测试遥控器类.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/34.%E6%B5%8B%E8%AF%95%E9%81%A5%E6%8E%A7%E5%99%A8%E7%B1%BB.png" class="" title="34.测试遥控器类.png">
 <!-- ![35.测试遥控器类2](./img/35.测试遥控器类2.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/35.%E6%B5%8B%E8%AF%95%E9%81%A5%E6%8E%A7%E5%99%A8%E7%B1%BB2.png" class="" title="35.测试遥控器类2.png">
<ul>
<li>上述有一些插槽为nocommand,有些插槽可能没有加载命令，我们用如下方法解决<!-- ![36.不做事命令](./img/36.不做事命令.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/36.%E4%B8%8D%E5%81%9A%E4%BA%8B%E5%91%BD%E4%BB%A4.png" class="" title="36.不做事命令.png"></li>
</ul>
</li>
<li>遥控器API <!-- ![37.遥控器API](./img/37.遥控器API.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/37.%E9%81%A5%E6%8E%A7%E5%99%A8API.png" class="" title="37.遥控器API.png"></li>
<li>加入撤销功能<ol>
<li>在command接口中加入undo()方法 <!-- ![38.撤销1.png](./img/38.撤销1.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/38.%E6%92%A4%E9%94%801.png" class="" title="38.撤销1.png"></li>
<li>undo是每个命令execute()的逆过程 <!-- ![39.撤销2.png](./img/39.撤销2.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/39.%E6%92%A4%E9%94%802.png" class="" title="39.撤销2.png"></li>
<li>在遥控器中加入一个记录上一条命令的变量(这里有一个问题，只能撤销一次，若想撤销多次，可以用栈把命令压栈，每次撤销栈顶命令并弹出) <!-- ![40.撤销3.png](./img/40.撤销3.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/40.%E6%92%A4%E9%94%803.png" class="" title="40.撤销3.png"></li>
<li>对某些状态的撤销，如对电风扇速度的调整，需要在电风扇命令类里保存上次状态，并在undo()里做相应处理，这个不细说了</li>
</ol>
</li>
<li>宏命令<ul>
<li>就是一个命令类执行多条单个命令，在类里用个数组存储多个命令类，没什么可说的</li>
</ul>
</li>
</ol>
<h3 id="4-命令模式的更多用途：队列请求"><a href="#4-命令模式的更多用途：队列请求" class="headerlink" title="4. 命令模式的更多用途：队列请求"></a>4. 命令模式的更多用途：队列请求</h3><ol>
<li>运用命令模式，即使命令对象被创建许久之后，运算依然课被调用。事实上，它甚至可以在不同的线程中被调用。我们可以利用这样的特性衍生出一些应用，如：日程安排(Scheduler),线程池，工作队列等。</li>
<li>工作队列<ul>
<li>在一端添加命令</li>
<li>线程在另一端取出命令，调用它的execute()方法，等待这个调用完成，然后将此命令对象丢弃，再取出下一个命令……</li>
</ul>
</li>
<li>工作队列类和进行计算的对象之间完全是解耦的。此刻线程可能在进行财务计算，下一刻却在读取网络数据。工作队列对象不在乎到底做些什么，它们只知道取出命令对象，就可以放入队列里，当线程可用时，就调用此对象的execute()方法。</li>
</ol>
<h3 id="5-命令模式的更多用途：日志请求"><a href="#5-命令模式的更多用途：日志请求" class="headerlink" title="5. 命令模式的更多用途：日志请求"></a>5. 命令模式的更多用途：日志请求</h3><ul>
<li>将所有的动作记录在日志中，并能在系统死机后，重新调用这些动作恢复到之前的状态。</li>
<li>通过新增两个方法(store(),load())，命令模式能够支持这一点。  <!-- ![41.日志](./img/41.日志.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/41.%E6%97%A5%E5%BF%97.png" class="" title="41.日志.png"></li>
<li>我们可以将上次检查点(checkpoint)之后的所有操作记录下来，如果系统出状况，从检查点开始应用这些操作  <!-- ![42.日志恢复](./img/42.日志恢复.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/42.%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D.png" class="" title="42.日志恢复.png">

</li>
</ul>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><ul>
<li>OO基础<ol>
<li>抽象</li>
<li>封装</li>
<li>多态</li>
<li>继承</li>
</ol>
</li>
<li>OO原则<ol>
<li>封装变化。</li>
<li>多用组合,少用继承。</li>
<li>针对接口编程，不针对实现编程。</li>
<li>为交互对象之间的松耦合设计而努力</li>
<li>对扩展开放，对修改关闭</li>
<li>依赖抽象，不要依赖具体类</li>
</ol>
</li>
<li>OO模式<ul>
<li>命令模式：将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象，命令模式也支持可撤销的操作</li>
</ul>
</li>
</ul>
<h3 id="7-要点"><a href="#7-要点" class="headerlink" title="7. 要点"></a>7. 要点</h3><ol>
<li>命令模式将发出请求的对象和执行请求的对象解耦</li>
<li>在被解耦的两者之间是通过命令对象进行沟通的。命令和对象封装了接收者和一个或一组动作</li>
<li>调用者通过调用命令对象的execute()发出请求，这会使得接收者的动作被调用</li>
<li>调用者可以接受命令当做参数，甚至在运行时动态的进行</li>
<li>命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行前的状态</li>
<li>宏命令是命令的一种简单的延伸,允许调用多个命令。宏方法也可以支持撤销</li>
<li>实际操作时，很常见使用“聪明”命令对象，也就是直接实现了请求，而不是将工作委托给接收者</li>
<li>命令也可以用来实现日志和事务系统</li>
</ol>
<h1 id="七、适配器与外观模式，随遇而安"><a href="#七、适配器与外观模式，随遇而安" class="headerlink" title="七、适配器与外观模式，随遇而安"></a>七、适配器与外观模式，随遇而安</h1><h3 id="1-面向对象适配器"><a href="#1-面向对象适配器" class="headerlink" title="1. 面向对象适配器"></a>1. 面向对象适配器</h3><ol>
<li>图解 <!-- ![43.面向对象适配器.png](./img/43.面向对象适配器.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/43.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8.png" class="" title="43.面向对象适配器.png"></li>
<li>鸭子例子<ol>
<li>鸭子接口 <!-- ![45.鸭子接口.png](./img/45.鸭子接口.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/45.%E9%B8%AD%E5%AD%90%E6%8E%A5%E5%8F%A3.png" class="" title="45.鸭子接口.png"></li>
<li>用火鸡冒充鸭子 <!-- ![46.火鸡.png](./img/46.火鸡.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/46.%E7%81%AB%E9%B8%A1.png" class="" title="46.火鸡.png"></li>
<li>测试适配器 <!-- ![47.测试.png](./img/47.测试.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/47.%E6%B5%8B%E8%AF%95.png" class="" title="47.测试.png">

</li>
</ol>
</li>
</ol>
<h3 id="2-定义适配器模式"><a href="#2-定义适配器模式" class="headerlink" title="2. 定义适配器模式"></a>2. 定义适配器模式</h3><ol>
<li>适配器模式<ul>
<li>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</li>
</ul>
</li>
<li>适配器模式解析<ol>
<li>客户通过目标接口调用适配器的方法对适配器发出请求</li>
<li>适配器使用被适配者接口把请求转换城被适配者的一个或多个调用接口。</li>
<li>客户接收到调用的结果，但并未察觉这一切是适配器在起转换作用<!-- ![44.适配器解析.png](./img/44.适配器解析.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/44.%E9%80%82%E9%85%8D%E5%99%A8%E8%A7%A3%E6%9E%90.png" class="" title="44.适配器解析.png"></li>
</ol>
</li>
<li>类图<ol>
<li>对象适配器,使用组合，上述例子就是用的这个<!-- ![48.适配器类图.png](./img/48.适配器类图.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/48.%E9%80%82%E9%85%8D%E5%99%A8%E7%B1%BB%E5%9B%BE.png" class="" title="48.适配器类图.png"></li>
<li>类适配器，这个要用到多继承，而java没有多继承，所以没法在java中用<!-- ![49.类适配器.png](./img/49.类适配器.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/49.%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8.png" class="" title="49.类适配器.png"></li>
</ol>
</li>
<li>鸭子例子对应的类图 <!-- ![50.鸭子适配器.png](./img/50.鸭子适配器.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/50.%E9%B8%AD%E5%AD%90%E9%80%82%E9%85%8D%E5%99%A8.png" class="" title="50.鸭子适配器.png">

</li>
</ol>
<h3 id="3-真实世界的适配器"><a href="#3-真实世界的适配器" class="headerlink" title="3. 真实世界的适配器"></a>3. 真实世界的适配器</h3><ol>
<li>一个java中的例子 <!-- ![51.java适配器例子.png](./img/51.java适配器例子.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/51.java%E9%80%82%E9%85%8D%E5%99%A8%E4%BE%8B%E5%AD%90.png" class="" title="51.java适配器例子.png"></li>
<li>类图 <!-- ![52.java类图.png](./img/52.java类图.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/52.java%E7%B1%BB%E5%9B%BE.png" class="" title="52.java类图.png"></li>
<li>Emi,eratorIterator适配器 <!-- ![53.java适配器代码.png](./img/53.java适配器代码.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/53.java%E9%80%82%E9%85%8D%E5%99%A8%E4%BB%A3%E7%A0%81.png" class="" title="53.java适配器代码.png">

</li>
</ol>
<h3 id="4-定义外观模式"><a href="#4-定义外观模式" class="headerlink" title="4. 定义外观模式"></a>4. 定义外观模式</h3><ol>
<li>外观模式<ul>
<li>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用</li>
</ul>
</li>
<li>类图 <!-- ![54.外观模式类图.png](./img/54.外观模式类图.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/54.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" class="" title="54.外观模式类图.png"></li>
<li>观看电影的例子<ul>
<li>电影院外观  <!-- ![57.电影院外观.png](./img/57.电影院外观.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/57.%E7%94%B5%E5%BD%B1%E9%99%A2%E5%A4%96%E8%A7%82.png" class="" title="57.电影院外观.png"></li>
<li>实现简化的接口  <!-- ![56.实现简化的接口.png](./img/56.实现简化的接口.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/56.%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8C%96%E7%9A%84%E6%8E%A5%E5%8F%A3.png" class="" title="56.实现简化的接口.png"></li>
<li>更轻松的调用观赏电影接口  <!-- ![58.观赏电影.png](./img/58.观赏电影.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/58.%E8%A7%82%E8%B5%8F%E7%94%B5%E5%BD%B1.png" class="" title="58.观赏电影.png">

</li>
</ul>
</li>
</ol>
<h3 id="5-“最少知识”原则"><a href="#5-“最少知识”原则" class="headerlink" title="5. “最少知识”原则"></a>5. “最少知识”原则</h3><ol>
<li>最少知识原则：只和你的密友交谈，减少对象之间的交互</li>
<li>如何不要赢得太多的朋友和影响太多的对象？就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：<ol>
<li>该对象本身</li>
<li>被当做方法参数而传递进来的对象</li>
<li>此方法锁创建或实例化的任何对象</li>
<li>对象的任何组件(has-a)</li>
</ol>
<ul>
<li>若某对象是调用其他方法的返回结果，不要调用该对象的方法<!-- ![55.最少知识.png](./img/55.最少知识.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/55.%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86.png" class="" title="55.最少知识.png"></li>
</ul>
</li>
<li>将方法调用保持在界限内 <!-- ![59.将方法调用保持在界限内.png](./img/59.将方法调用保持在界限内.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/59.%E5%B0%86%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%BF%9D%E6%8C%81%E5%9C%A8%E7%95%8C%E9%99%90%E5%86%85.png" class="" title="59.将方法调用保持在界限内.png"></li>
<li>外观和最少知识原则 <!-- ![60.外观和最少知识.png](./img/60.外观和最少知识.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/60.%E5%A4%96%E8%A7%82%E5%92%8C%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86.png" class="" title="60.外观和最少知识.png">

</li>
</ol>
<h3 id="6-三种模式对比"><a href="#6-三种模式对比" class="headerlink" title="6. 三种模式对比"></a>6. 三种模式对比</h3><ol>
<li>装饰者：不改变接口，但加入责任</li>
<li>适配器：将一个接口转换成另一个接口</li>
<li>外观：让接口更简单</li>
</ol>
<h3 id="7-总结-2"><a href="#7-总结-2" class="headerlink" title="7. 总结"></a>7. 总结</h3><ul>
<li>OO基础<ol>
<li>抽象</li>
<li>封装</li>
<li>多态</li>
<li>继承</li>
</ol>
</li>
<li>OO原则<ol>
<li>封装变化。</li>
<li>多用组合,少用继承。</li>
<li>针对接口编程，不针对实现编程。</li>
<li>为交互对象之间的松耦合设计而努力</li>
<li>对扩展开放，对修改关闭</li>
<li>依赖抽象，不要依赖具体类</li>
<li>只和朋友交流</li>
</ol>
</li>
<li>OO模式<ul>
<li>适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</li>
<li>外观模式：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用</li>
</ul>
</li>
</ul>
<h3 id="8-要点-2"><a href="#8-要点-2" class="headerlink" title="8. 要点"></a>8. 要点</h3><ol>
<li>当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器</li>
<li>当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观</li>
<li>适配器改变接口以符合客户的期望</li>
<li>外观将客户从一个复杂的子系统中解耦</li>
<li>实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小和复杂度而定</li>
<li>实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行</li>
<li>适配器模式有两种形式：对象适配器和类适配器。类适配器需要用到多重继承</li>
<li>你可以为一个子系统实现一个以上的外观</li>
<li>适配器将一个对象包装起来以改变其接口，装饰者将一个对象包装起来以增加新的行为和责任，而外观将一群对象“包装”起来以简化其接口</li>
</ol>
<h1 id="八、模板方法模式，封装算法"><a href="#八、模板方法模式，封装算法" class="headerlink" title="八、模板方法模式，封装算法"></a>八、模板方法模式，封装算法</h1><h3 id="1-定义模板方法"><a href="#1-定义模板方法" class="headerlink" title="1. 定义模板方法"></a>1. 定义模板方法</h3><ol>
<li>模板方法模式<ul>
<li>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类在不改变算法结构的情况下，重新定义算法中的某些步骤。</li>
</ul>
</li>
<li>类图 <!-- ![61.模板方法类图.png](./img/61.模板方法类图.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/61.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9B%BE.png" class="" title="61.模板方法类图.png"></li>
<li>咖啡与茶的实例<ul>
<li>咖啡因饮料基类  <!-- ![64.咖啡因饮料基类.png](./img/64.咖啡因饮料基类.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/64.%E5%92%96%E5%95%A1%E5%9B%A0%E9%A5%AE%E6%96%99%E5%9F%BA%E7%B1%BB.png" class="" title="64.咖啡因饮料基类.png"></li>
<li>咖啡和茶子类  <!-- ![65.咖啡和茶子类.png](./img/65.咖啡和茶子类.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/65.%E5%92%96%E5%95%A1%E5%92%8C%E8%8C%B6%E5%AD%90%E7%B1%BB.png" class="" title="65.咖啡和茶子类.png">
<h3 id="2-对模板方法进行挂钩"><a href="#2-对模板方法进行挂钩" class="headerlink" title="2. 对模板方法进行挂钩"></a>2. 对模板方法进行挂钩</h3></li>
</ul>
</li>
<li>钩子是一种被声明在抽象类中的方法，但只有空的或者默认的实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。要不要挂钩，由子类自行决定。</li>
<li>钩子的一种用途<ul>
<li>基类的钩子<!-- ![62.钩子用法1.png](./img/62.钩子用法1.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/62.%E9%92%A9%E5%AD%90%E7%94%A8%E6%B3%951.png" class="" title="62.钩子用法1.png"></li>
<li>子类覆盖钩子(也可以不覆盖，用基类默认的)<!-- ![63.钩子子类.png](./img/63.钩子子类.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/63.%E9%92%A9%E5%AD%90%E5%AD%90%E7%B1%BB.png" class="" title="63.钩子子类.png">

</li>
</ul>
</li>
</ol>
<h3 id="3-好莱坞原则"><a href="#3-好莱坞原则" class="headerlink" title="3. 好莱坞原则"></a>3. 好莱坞原则</h3><ol>
<li>好莱坞原则<ul>
<li>别调用(打电话给)我们，我们会调用(打电话给)你。</li>
</ul>
</li>
<li>好莱坞可以防止“依赖腐败”<ul>
<li>当高层组件依赖低层组件，而低层组件又依赖高层组件，而高层组件又依赖边侧组件，边侧组件又依赖低层组件时，依赖腐败就发生了。</li>
<li>在这种情况下，没有人可以轻易地搞懂系统是如何设计的。</li>
</ul>
</li>
<li>在好莱坞原则之下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。换句话说，高层组件对待低层组件的方式是“别调用我们，我们会调用你”。 <!-- ![66.好莱坞依赖.png](./img/66.好莱坞依赖.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/66.%E5%A5%BD%E8%8E%B1%E5%9D%9E%E4%BE%9D%E8%B5%96.png" class="" title="66.好莱坞依赖.png">
<h3 id="4-好莱坞原则和模板方法"><a href="#4-好莱坞原则和模板方法" class="headerlink" title="4. 好莱坞原则和模板方法"></a>4. 好莱坞原则和模板方法</h3></li>
<li>当我们设计模板方法模式时，我们告诉子类，“不要调用我们，我们会调用你”。 <!-- ![67.好莱坞模板.png](./img/67.好莱坞模板.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/67.%E5%A5%BD%E8%8E%B1%E5%9D%9E%E6%A8%A1%E6%9D%BF.png" class="" title="67.好莱坞模板.png">

</li>
</ol>
<h3 id="5-三种模板的区别"><a href="#5-三种模板的区别" class="headerlink" title="5. 三种模板的区别"></a>5. 三种模板的区别</h3><ol>
<li>模板方法：子类决定如何实现算法中的某些步骤</li>
<li>策略：封装可互换的行为，然后使用委托来决定要采用哪一个行为</li>
<li>工厂方法：由子类决定实例化哪个具体类</li>
</ol>
<h3 id="6-java中模板方法的使用"><a href="#6-java中模板方法的使用" class="headerlink" title="6. java中模板方法的使用"></a>6. java中模板方法的使用</h3><ol>
<li>排序 <ul>
<li>java对对象排序，可以实现compareTo()函数，让Array.sort()知道怎么排。(这么方便)</li>
</ul>
</li>
<li>Swing<ul>
<li>paint()钩子函数  <!-- ![68.swing钩子.png](./img/68.swing钩子.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/68.swing%E9%92%A9%E5%AD%90.png" class="" title="68.swing钩子.png"></li>
</ul>
</li>
<li>Applet<ul>
<li>applet就是一个能够在网页上面执行的小程序。任何applet都必须继承自Applet类，而Applet类中提供了好些钩子，以下是其中几个。  <!-- ![69.applet钩子.png](./img/69.applet钩子.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/69.applet%E9%92%A9%E5%AD%90.png" class="" title="69.applet钩子.png">

</li>
</ul>
</li>
</ol>
<h3 id="7-策略和模板的区别"><a href="#7-策略和模板的区别" class="headerlink" title="7. 策略和模板的区别"></a>7. 策略和模板的区别</h3><ol>
<li>策略模式<ul>
<li>定义了一个算法家族，并让这些算法可以互换。</li>
<li>使用组合，所以更有弹性</li>
</ul>
</li>
<li>模板方法模式<ul>
<li>定义一个算法的大纲，在子类中定义其中某些步骤的内容</li>
<li>使用继承，所以重复代码更少，效率稍微高一点</li>
</ul>
</li>
</ol>
<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><ul>
<li>OO基础<ol>
<li>抽象</li>
<li>封装</li>
<li>多态</li>
<li>继承</li>
</ol>
</li>
<li>OO原则<ol>
<li>封装变化。</li>
<li>多用组合,少用继承。</li>
<li>针对接口编程，不针对实现编程。</li>
<li>为交互对象之间的松耦合设计而努力</li>
<li>对扩展开放，对修改关闭</li>
<li>依赖抽象，不要依赖具体类</li>
<li>只和朋友交流</li>
<li>别找我，我会找你</li>
</ol>
</li>
<li>OO模式<ul>
<li>模板方法模式：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类在不改变算法结构的情况下，重新定义算法中的某些步骤。</li>
</ul>
</li>
</ul>
<h3 id="9-要点"><a href="#9-要点" class="headerlink" title="9. 要点"></a>9. 要点</h3><ol>
<li>模板方法 定义了算法的步骤，把这些步骤的实现延迟到子类</li>
<li>模板方法模式为我们提供了一种代码复用的重要技巧</li>
<li>模板方法的抽象类可以定义具体方法、抽象方法和钩子</li>
<li>抽象方法由子类实现</li>
<li>钩子是一种方法，它在抽象类中不做事，或者只做默认的事，子类可以选择要不要取覆盖它</li>
<li>为了防止子类改变模板方法中的算法，可以将模板方法声明为final</li>
<li>好莱坞原则告诉我们，将决策权放在高层模块中，一遍决定如何以及何时调用低层模块</li>
<li>你将在真实世界代码中看到模板方法模式的许多变体，不要期待他们全部是一眼就可以被认出的</li>
<li>策略模式和模板方法模式都封装算法，一个用组合，一个用继承</li>
<li>工厂方法是模板方法的一个特殊版本</li>
</ol>
<h1 id="九、迭代器与组合模式，管理良好的集合"><a href="#九、迭代器与组合模式，管理良好的集合" class="headerlink" title="九、迭代器与组合模式，管理良好的集合"></a>九、迭代器与组合模式，管理良好的集合</h1><h3 id="1-定义迭代器模式"><a href="#1-定义迭代器模式" class="headerlink" title="1. 定义迭代器模式"></a>1. 定义迭代器模式</h3><ol>
<li><p>迭代器模式</p>
<ul>
<li>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示</li>
<li>把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。</li>
</ul>
</li>
<li><p>迭代器类图</p>
 <!-- ![70.迭代器类图.png](./img/70.迭代器类图.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/70.%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9B%BE.png" class="" title="70.迭代器类图.png"></li>
<li><p>餐厅例子</p>
<ul>
<li><p>餐厅类图</p>
  <!-- ![71.餐厅例子.png](./img/71.餐厅例子.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/71.%E9%A4%90%E5%8E%85%E4%BE%8B%E5%AD%90.png" class="" title="71.餐厅例子.png"></li>
<li><p>菜单接口和服务员代码</p>
  <!-- ![74.菜单接口和服务员.png](./img/74.菜单接口和服务员.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/74.%E8%8F%9C%E5%8D%95%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%91%98.png" class="" title="74.菜单接口和服务员.png"></li>
<li><p>具体菜单代码</p>
  <!-- ![72.具体菜单.png](./img/72.具体菜单.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/72.%E5%85%B7%E4%BD%93%E8%8F%9C%E5%8D%95.png" class="" title="72.具体菜单.png">
</li>
<li><p>迭代器代码</p>
  <!-- ![73.迭代器代码.png](./img/73.迭代器代码.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/73.%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%A3%E7%A0%81.png" class="" title="73.迭代器代码.png">

</li>
</ul>
</li>
</ol>
<h3 id="2-单一责任"><a href="#2-单一责任" class="headerlink" title="2. 单一责任"></a>2. 单一责任</h3><ul>
<li>若果我们在聚合内部实现相关的操作和遍历的方法，也就是不用迭代器，在集合内部写next()方法，会如何？<ul>
<li>这样我们运行一个类不但要完成自己的事情(管理某种聚合)，还要负担更多的责任(例如遍历)时，我们就给这个类两个变化的原因。</li>
<li>如果这个集合改变的话，这个类也必须改变，如果我们遍历的方式改变的话，这个类也必须跟着改变。所以，“改变”又成了我们设计原则的中心</li>
</ul>
</li>
<li>设计原则：一个类应该只有一个引起变化的原因<ul>
<li>我们要避免类内的改变，因为修改代码很容易造成许多潜在的错误。</li>
</ul>
</li>
<li>内聚<ul>
<li>它用来度量一个类或模块紧密地达到单一目的或责任</li>
<li>当一个模块或一个类被设计成只支持一组相关的功能时，我们说它具有高内聚</li>
</ul>
</li>
</ul>
<h3 id="3-定义组合模式"><a href="#3-定义组合模式" class="headerlink" title="3. 定义组合模式"></a>3. 定义组合模式</h3><ol>
<li><p>组合模式</p>
<ul>
<li>允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合</li>
<li>使用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个体对象之间的差别。</li>
</ul>
</li>
<li><p>组合模式类图</p>
 <!-- ![75.组合模式类图.png](./img/75.组合模式类图.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/75.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" class="" title="75.组合模式类图.png"></li>
<li><p>利用组合设计菜单</p>
 <!-- ![76.组合菜单.png](./img/76.组合菜单.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/76.%E7%BB%84%E5%90%88%E8%8F%9C%E5%8D%95.png" class="" title="76.组合菜单.png"></li>
<li><p>实现菜单组件</p>
 <!-- ![77.实现菜单组件.png](./img/77.实现菜单组件.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/77.%E5%AE%9E%E7%8E%B0%E8%8F%9C%E5%8D%95%E7%BB%84%E4%BB%B6.png" class="" title="77.实现菜单组件.png"></li>
<li><p>实现菜单项</p>
 <!-- ![78.实现菜单项.png](./img/78.实现菜单项.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/78.%E5%AE%9E%E7%8E%B0%E8%8F%9C%E5%8D%95%E9%A1%B9.png" class="" title="78.实现菜单项.png"></li>
<li><p>实现组合菜单</p>
 <!-- ![79.实现组合菜单.png](./img/79.实现组合菜单.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/79.%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E8%8F%9C%E5%8D%95.png" class="" title="79.实现组合菜单.png"></li>
<li><p>修改print</p>
 <!-- ![80.修改print.png](./img/80.修改print.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/80.%E4%BF%AE%E6%94%B9print.png" class="" title="80.修改print.png"></li>
<li><p>服务员</p>
 <!-- ![81.服务员.png](./img/81.服务员.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/81.%E6%9C%8D%E5%8A%A1%E5%91%98.png" class="" title="81.服务员.png"></li>
<li><p>菜单结构</p>
 <!-- ![82.菜单结构.png](./img/82.菜单结构.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/82.%E8%8F%9C%E5%8D%95%E7%BB%93%E6%9E%84.png" class="" title="82.菜单结构.png"></li>
<li><p>测试</p>
<!-- ![83.菜单测试.png](./img/83.菜单测试.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/83.%E8%8F%9C%E5%8D%95%E6%B5%8B%E8%AF%95.png" class="" title="83.菜单测试.png">
<!-- ![84.执行结果.png](./img/84.执行结果.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/84.%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png" class="" title="84.执行结果.png"></li>
<li><p>透明性</p>
<ul>
<li>组合模式以单一责任设计原则换取透明性(transparency)</li>
<li>透明性：通过让组件接口同时包含一些管理子节点和叶节点的操作，客户可以将组合和叶节点一视同仁。也就是说一个元素究竟是组合还是叶节点，对客户是透明的。</li>
</ul>
</li>
<li><p>为组合创建迭代器</p>
<!-- ![85.组合迭代器.png](./img/85.组合迭代器.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/85.%E7%BB%84%E5%90%88%E8%BF%AD%E4%BB%A3%E5%99%A8.png" class="" title="85.组合迭代器.png"></li>
<li><p>组合迭代器-递归</p>
<!-- ![86.递归迭代器.png](./img/86.递归迭代器.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/86.%E9%80%92%E5%BD%92%E8%BF%AD%E4%BB%A3%E5%99%A8.png" class="" title="86.递归迭代器.png"></li>
<li><p>空迭代器</p>
<ul>
<li>在上述例子中，菜单项没有什么可以遍历的，那如何实现菜单项的createIterator()方法？有两种办法<ol>
<li>返会null,但这么做，就需要在客户代码中用条件语句判断是否为null</li>
<li>返回一个迭代器，而这个迭代器的hasNext()永远为false,这就是空迭代器<!-- ![87.空迭代器.png](./img/87.空迭代器.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/87.%E7%A9%BA%E8%BF%AD%E4%BB%A3%E5%99%A8.png" class="" title="87.空迭代器.png"></li>
</ol>
</li>
</ul>
</li>
<li><p>组合迭代器测试-返回素食菜单</p>
<!-- ![88.返回素食菜单.png](./img/88.返回素食菜单.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/88.%E8%BF%94%E5%9B%9E%E7%B4%A0%E9%A3%9F%E8%8F%9C%E5%8D%95.png" class="" title="88.返回素食菜单.png"></li>
<li><p>异常处理菜单没有isVegetarian方法(菜单项有)</p>
<!-- ![89.异常处理菜单.png](./img/89.异常处理菜单.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/89.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%8F%9C%E5%8D%95.png" class="" title="89.异常处理菜单.png">

</li>
</ol>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li>OO基础<ol>
<li>抽象</li>
<li>封装</li>
<li>多态</li>
<li>继承</li>
</ol>
</li>
<li>OO原则<ol>
<li>封装变化。</li>
<li>多用组合,少用继承。</li>
<li>针对接口编程，不针对实现编程。</li>
<li>为交互对象之间的松耦合设计而努力</li>
<li>对扩展开放，对修改关闭</li>
<li>依赖抽象，不要依赖具体类</li>
<li>只和朋友交流</li>
<li>别找我，我会找你</li>
<li>类应该只有一个改变的理由</li>
</ol>
</li>
<li>OO模式<ul>
<li>迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示</li>
<li>组合模式：允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合</li>
</ul>
</li>
</ul>
<h3 id="5-要点"><a href="#5-要点" class="headerlink" title="5. 要点"></a>5. 要点</h3><ol>
<li>迭代器允许访问聚合的元素，而不需要暴露它的内部结构</li>
<li>迭代器将遍历聚合的工作封装进一个对象中</li>
<li>当使用迭代器的时候，我们依赖聚合提供遍历</li>
<li>迭代器提供了一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多态机制</li>
<li>我们应该努力让一个类只分配一个责任</li>
<li>组合模式提供一个结构，可同时包容个别对象和组合对象</li>
<li>组合模式允许客户对个别对象以及组合对象一视同仁</li>
<li>组合结构内的任意对象称为组件，组件可以使组合，也可以是叶节点</li>
<li>在实现组合模式时，有许多设计上的这种。要根据需要平衡安全性和透明性</li>
</ol>
<h1 id="十、状态模式，事物的状态"><a href="#十、状态模式，事物的状态" class="headerlink" title="十、状态模式，事物的状态"></a>十、状态模式，事物的状态</h1><h3 id="1-定义状态模式"><a href="#1-定义状态模式" class="headerlink" title="1. 定义状态模式"></a>1. 定义状态模式</h3><ol>
<li>状态模式<ul>
<li>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类</li>
</ul>
</li>
<li>类图 <!-- ![90.状态模式类图.png](./img/90.状态模式类图.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/90.%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" class="" title="90.状态模式类图.png"></li>
<li>策略模式的类图和这个一样<ul>
<li>对于状态模式：context的客户对与状态对象了解不多，甚至根本是浑然不觉。</li>
<li>对于策略模式：客户通常主动指定Context所要组合的策略对象是哪一个。通常只有一个最适当的策略对象，而状态模式的对象经常改变</li>
</ul>
</li>
</ol>
<h3 id="2-糖果例子"><a href="#2-糖果例子" class="headerlink" title="2. 糖果例子"></a>2. 糖果例子</h3><ol>
<li>状态转换图 <!-- ![91.糖果状态转换图.png](./img/91.糖果状态转换图.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/91.%E7%B3%96%E6%9E%9C%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" class="" title="91.糖果状态转换图.png"></li>
<li>定义状态接口和类 <!-- ![92.状态接口和类.png](./img/92.状态接口和类.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/92.%E7%8A%B6%E6%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB.png" class="" title="92.状态接口和类.png"></li>
<li>未投币状态 <!-- ![93.未投币状态.png](./img/93.未投币状态.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/93.%E6%9C%AA%E6%8A%95%E5%B8%81%E7%8A%B6%E6%80%81.png" class="" title="93.未投币状态.png"></li>
<li>完整的糖果机类 <!-- ![94.糖果机类.png](./img/94.糖果机类.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/94.%E7%B3%96%E6%9E%9C%E6%9C%BA%E7%B1%BB.png" class="" title="94.糖果机类.png"></li>
<li>加入奖励机制，有10%概率弹出两个糖果<ul>
<li>加入winnerState状态  <!-- ![95.加入winner.png](./img/95.加入winner.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/95.%E5%8A%A0%E5%85%A5winner.png" class="" title="95.加入winner.png"></li>
<li>实现winnerState  <!-- ![96.实现winner.png](./img/96.实现winner.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/96.%E5%AE%9E%E7%8E%B0winner.png" class="" title="96.实现winner.png"></li>
<li>在转动曲柄状态中实现随机数  <!-- ![97.加入随机数.png](./img/97.加入随机数.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/97.%E5%8A%A0%E5%85%A5%E9%9A%8F%E6%9C%BA%E6%95%B0.png" class="" title="97.加入随机数.png"></li>
</ul>
</li>
<li>测试 <!-- ![98.测试.png](./img/98.测试.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/98.%E6%B5%8B%E8%AF%95.png" class="" title="98.测试.png">

</li>
</ol>
<h3 id="3-模式对比"><a href="#3-模式对比" class="headerlink" title="3. 模式对比"></a>3. 模式对比</h3><ol>
<li>状态：封装基于状态的行为，并将行为委托到当前状态</li>
<li>策略：将可以互换的行为封装起来，然后使用委托的方法，决定使用哪一个行为</li>
<li>模板方法：由子类决定如何实现算法中的某些步骤</li>
</ol>
<h3 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li>OO基础<ol>
<li>抽象</li>
<li>封装</li>
<li>多态</li>
<li>继承</li>
</ol>
</li>
<li>OO原则<ol>
<li>封装变化。</li>
<li>多用组合,少用继承。</li>
<li>针对接口编程，不针对实现编程。</li>
<li>为交互对象之间的松耦合设计而努力</li>
<li>对扩展开放，对修改关闭</li>
<li>依赖抽象，不要依赖具体类</li>
<li>只和朋友交流</li>
<li>别找我，我会找你</li>
<li>类应该只有一个改变的理由</li>
</ol>
</li>
<li>OO模式<ul>
<li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类</li>
</ul>
</li>
</ul>
<h3 id="5-要点-1"><a href="#5-要点-1" class="headerlink" title="5. 要点"></a>5. 要点</h3><ol>
<li>状态模式允许一个对象基于内部状态而拥有不同的行为</li>
<li>和程序状态机(PSM)不同，状态模式用类代表状态</li>
<li>Context会将行为委托给当前状态对象</li>
<li>通过将每个状态封装进一个类，我们把以后需要做的任何改变局部化了</li>
<li>状态模式和策略模式有相同的类图，但是他们的意图不同</li>
<li>策略模式通常会用行为或算法来配置Context类</li>
<li>状态模式允许Context随着状态的改变而改变行为</li>
<li>状态转换可以由State类或Context类控制</li>
<li>使用状态模式通常会导致设计中类的数目大量增加</li>
<li>状态类可以被多个Context实例共享</li>
</ol>
<h1 id="十一、代理模式，控制对象访问"><a href="#十一、代理模式，控制对象访问" class="headerlink" title="十一、代理模式，控制对象访问"></a>十一、代理模式，控制对象访问</h1><h3 id="1-远程代理角色"><a href="#1-远程代理角色" class="headerlink" title="1. 远程代理角色"></a>1. 远程代理角色</h3><ol>
<li>糖果机的远程代理 <!-- ![99.糖果机远程代理.png](./img/99.糖果机远程代理.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/99.%E7%B3%96%E6%9E%9C%E6%9C%BA%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%90%86.png" class="" title="99.糖果机远程代理.png"></li>
<li>客户对象所做的就像是在做远程方法调用，但其实只是调用本地堆中的“代理”对象上的 方法，再由代理处理所有网络通信的低层细节。</li>
</ol>
<h3 id="2-定义代理模式"><a href="#2-定义代理模式" class="headerlink" title="2. 定义代理模式"></a>2. 定义代理模式</h3><ol>
<li>代理模式<ul>
<li>为另一个对象提供一个替身或占位符以控制对这个对象的访问</li>
<li>被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象</li>
</ul>
</li>
<li>几种代理控制访问的方式<ol>
<li>远程代理控制访问远程对象</li>
<li>虚拟代理控制访问创建开销大的资源</li>
<li>保护代理基于权限控制对资源的访问</li>
</ol>
</li>
<li>类图 <!-- ![101.类图.png](./img/101.类图.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/101.%E7%B1%BB%E5%9B%BE.png" class="" title="101.类图.png">

</li>
</ol>
<h3 id="3-java-RMI-远程代理"><a href="#3-java-RMI-远程代理" class="headerlink" title="3. java RMI(远程代理)"></a>3. java RMI(远程代理)</h3><ol>
<li>远程代理可以作为另一个JVM上对象的本地代表。调用代理的方法，会被代理利用网络转发到远程执行，并且结果会通过网络返回给代理，再由代理将结果转给客户。</li>
<li>远程方法 <!-- ![100.远程方法.png](./img/100.远程方法.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/100.%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95.png" class="" title="100.远程方法.png"></li>
<li>方法调用过程<ol>
<li>客户对象调用客户辅助对象的doThing()方法</li>
<li>客户辅助对象打包调用信息(变量、方法名称等)，然后通过网络将它运给服务辅助对象</li>
<li>服务辅助对象把来自客户辅助对象的信息解包，找出被调用的方法(以及在哪个对象内)，然后调用真正的服务对象上的真正方法。</li>
<li>服务对象上的方法被调用，将结果返回给服务辅助对象</li>
<li>服务辅助对象把调用的返回信息打包，然后通过网络运回给客户辅助对象</li>
<li>客户辅助对象把返回值解包，返回给客户对象。对于客户来说，这是完全透明的。</li>
</ol>
</li>
<li>java RMI概观<ul>
<li>RMI提供了客户辅助对象和服务辅助对象，好处是不必亲自写任何网络或IO代码。客户程序调用远程方法(即真正的服务所在)就和在运行在客户自己的本地JVM上对对象进行正常方法调用一样</li>
<li>RMI将客户辅助对象称为stub(桩)，服务辅助对象称为skeleton(骨架)  <!-- ![110.RMI.png](./img/110.RMI.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/110.RMI.png" class="" title="110.RMI.png"></li>
</ul>
</li>
<li>制作远程服务步骤<ol>
<li>制作远程接口(myserver.java) <!-- ![111.步骤1.png](./img/111.步骤1.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/111.%E6%AD%A5%E9%AA%A41.png" class="" title="111.步骤1.png"></li>
<li>制作远程实现(MyServiceImp1.java),就是实现方法 <!-- ![112.步骤2.png](./img/112.步骤2.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/112.%E6%AD%A5%E9%AA%A42.png" class="" title="112.步骤2.png"></li>
<li>利用rmic产生的stub和skeleton(java5以后不用显式声明skeleton)<ul>
<li>rmic MyServiceImp1    ,rmic是一个工具<!-- ![113.步骤3.png](./img/113.步骤3.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/113.%E6%AD%A5%E9%AA%A43.png" class="" title="113.步骤3.png"></li>
</ul>
</li>
<li>启动RMI registry(rmiregistry)<ul>
<li>remireistry就像是电话簿，客户可以从中查到代理的位置(也就是客户的stub helper对象)<!-- ![114.步骤4.png](./img/114.步骤4.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/114.%E6%AD%A5%E9%AA%A44.png" class="" title="114.步骤4.png"></li>
</ul>
</li>
<li>开始远程服务<ul>
<li>java MyServiceImp1<!-- ![115.步骤5.png](./img/115.步骤5.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/115.%E6%AD%A5%E9%AA%A45.png" class="" title="115.步骤5.png"></li>
</ul>
</li>
</ol>
</li>
<li>服务器端完整代码<ul>
<li>远程接口  <!-- ![116.远程接口.png](./img/116.远程接口.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/116.%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3.png" class="" title="116.远程接口.png"></li>
<li>远程服务(实现):  <!-- ![117.远程实现.png](./img/117.远程实现.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/117.%E8%BF%9C%E7%A8%8B%E5%AE%9E%E7%8E%B0.png" class="" title="117.远程实现.png"></li>
</ul>
</li>
<li>客户端完整代码 <!-- ![118.客户端完整代码.png](./img/118.客户端完整代码.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/118.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81.png" class="" title="118.客户端完整代码.png"></li>
<li>使用RMI常犯的错误<ol>
<li>忘了在启动服务之前先启动rmiregistry(要用Name.rebind()注册服务，rmiregistry必须是运行的)。</li>
<li>忘了让变量和返回值的类型成为可序列化的类型(这种错误无法在编译期发现，只会在运行时发现)</li>
<li>忘了给客户提供stub类</li>
</ol>
</li>
</ol>
<h3 id="4-虚拟代理-Virtual-Proxy"><a href="#4-虚拟代理-Virtual-Proxy" class="headerlink" title="4. 虚拟代理(Virtual Proxy)"></a>4. 虚拟代理(Virtual Proxy)</h3><ol>
<li>虚拟代理作为创建开销大的对象的代表。虚拟代理经常直到我们真正需要你个对象的时候才创建它。当对象在创建前和创建中时，由虚拟代理来扮演对象的替身。对象创建后，代理就会将请求直接委托给对象。 <!-- ![102.虚拟代理.png](./img/102.虚拟代理.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/102.%E8%99%9A%E6%8B%9F%E4%BB%A3%E7%90%86.png" class="" title="102.虚拟代理.png"></li>
<li>显示CD封面的例子<ul>
<li>在加载图像的时候，先由代理提示，等图像加载完再显示图像</li>
<li>设计CD封面虚拟代理  <!-- ![103.CD封面.png](./img/103.CD封面.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/103.CD%E5%B0%81%E9%9D%A2.png" class="" title="103.CD封面.png"></li>
<li>ImageProxy工作流程  <!-- ![104.工作流程.png](./img/104.工作流程.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/104.%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="" title="104.工作流程.png"></li>
<li>编写ImageProxy  <!-- ![105.编写img.png](./img/105.编写img.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/105.%E7%BC%96%E5%86%99img.png" class="" title="105.编写img.png">
  <!-- ![106.paint.png](./img/106.paint.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/106.paint.png" class="" title="106.paint.png">
  <!-- ![107.细节.png](./img/107.细节.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/107.%E7%BB%86%E8%8A%82.png" class="" title="107.细节.png"></li>
</ul>
</li>
<li>测试 <!-- ![108.测试.png](./img/108.测试.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/108.%E6%B5%8B%E8%AF%95.png" class="" title="108.测试.png">

</li>
</ol>
<h3 id="5-保护代理"><a href="#5-保护代理" class="headerlink" title="5. 保护代理"></a>5. 保护代理</h3><ol>
<li>动态代理<ul>
<li>Java在java.lang.reflect包中有自己的代理支持，利用这个包可以在运行时动态地创建一个代理类，实现一个或多个接口，并将方法的调用转发到你所指定的类。因为实际的代理类是在运行时创建的，我们称这个Java技术为:动态代理。  <!-- ![109.动态代理.png](./img/109.动态代理.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/109.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png" class="" title="109.动态代理.png"></li>
<li>因为Java已经为你创建了Proxy类，所以你需要有办法来告诉Proxy类你要做什么。你不能像以前一样把代码放在Proxy类中，因为Proxy不是你直接实现的。代码要放在InvocationHandler中。InvocationHandler的工作是相应代理的任何调用。</li>
</ul>
</li>
<li>使用java包</li>
</ol>
<h3 id="6-模式对比"><a href="#6-模式对比" class="headerlink" title="6. 模式对比"></a>6. 模式对比</h3><ol>
<li>装饰者<ul>
<li>包装另一个对象，并提供额外的行为</li>
</ul>
</li>
<li>外观<ul>
<li>包装许多对象以简化它们的接口</li>
</ul>
</li>
<li>代理<ul>
<li>包装另一个对象，并控制对它的访问</li>
</ul>
</li>
<li>适配器<ul>
<li>包装另一个对象，并提供不同的接口</li>
</ul>
</li>
</ol>
<h3 id="7-其他代理"><a href="#7-其他代理" class="headerlink" title="7. 其他代理"></a>7. 其他代理</h3><ol>
<li>防火墙代理(Firewall Proxy)<ul>
<li>控制网站资源的访问、保护主题免于“坏客户”的侵害</li>
<li>常出没于公司的防火墙系统</li>
</ul>
</li>
<li>智能引用代理(Smart Reference Proxy)<ul>
<li>当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数</li>
</ul>
</li>
<li>缓存代理(Caching Proxy)<ul>
<li>为开销大的运算结果提供暂时存储，以减少计算或网络延迟</li>
<li>常出没于Web服务器代理，以及内容管理和出版系统</li>
</ul>
</li>
<li>同步代理(Synchronization Proxy)<ul>
<li>在多线程的情况下为主题提供安全的访问</li>
<li>出没于JavaSpaces，为分散式环境内的潜在对象集合提供同步访问控制</li>
</ul>
</li>
<li>复杂隐藏代理(Complexity Hiding Proxy)<ul>
<li>用来隐藏一个类的复杂集合的复杂度，并进行访问控制。有时候也称为外观代理(Facade Proxy),这并不难理解。复杂隐藏代理和外观模式是不一样的，因为代理控制访问，而外观模式只提供另一组接口。</li>
</ul>
</li>
<li>写入时复制代理(Copy-On-Write Proxy)<ul>
<li>用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止。这是虚拟代理的变体。</li>
<li>例子如java5的CopyOnWriteArraylist</li>
</ul>
</li>
</ol>
<h3 id="8-总结-1"><a href="#8-总结-1" class="headerlink" title="8. 总结"></a>8. 总结</h3><ul>
<li>OO基础<ol>
<li>抽象</li>
<li>封装</li>
<li>多态</li>
<li>继承</li>
</ol>
</li>
<li>OO原则<ol>
<li>封装变化。</li>
<li>多用组合,少用继承。</li>
<li>针对接口编程，不针对实现编程。</li>
<li>为交互对象之间的松耦合设计而努力</li>
<li>对扩展开放，对修改关闭</li>
<li>依赖抽象，不要依赖具体类</li>
<li>只和朋友交流</li>
<li>别找我，我会找你</li>
<li>类应该只有一个改变的理由</li>
</ol>
</li>
<li>OO模式<ul>
<li>代理模式：为另一个对象提供一个替身或占位符以控制对这个对象的访问</li>
</ul>
</li>
</ul>
<h3 id="9-要点-1"><a href="#9-要点-1" class="headerlink" title="9. 要点"></a>9. 要点</h3><ol>
<li>代理模式为另一个对象提供代表，以便控制客户对对象的访问，管理访问的方式有许多种</li>
<li>远程道理管理客户和远程对象之间的交互</li>
<li>虚拟代理控制访问实例化开销大的对象</li>
<li>保护代理基于调用者控制对象方法的访问</li>
<li>代理模式有许多变体，例如：缓存代理、同步带利、防火墙代理和写入时复制代理</li>
<li>代理在结构上类似装饰者，但是目的不同</li>
<li>装饰者模式为对象加上行为，而代理则是控制访问</li>
<li>Java内置的代理支持，可以根据需要建立动态代理，并将所有调用分配到所选的处理器</li>
<li>就和其他的包装者(wrapper)一样，代理会造成你的设计中类的数目增加</li>
</ol>
<h1 id="十二、复合模式，模式中的模式"><a href="#十二、复合模式，模式中的模式" class="headerlink" title="十二、复合模式，模式中的模式"></a>十二、复合模式，模式中的模式</h1><h3 id="1-定义复合模式"><a href="#1-定义复合模式" class="headerlink" title="1. 定义复合模式"></a>1. 定义复合模式</h3><ol>
<li>复合模式<ul>
<li>结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题</li>
</ul>
</li>
</ol>
<h3 id="2-鸭子例子"><a href="#2-鸭子例子" class="headerlink" title="2. 鸭子例子"></a>2. 鸭子例子</h3><ol>
<li>都做什么 <!-- ![119.复合例子.png](./img/119.复合例子.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/119.%E5%A4%8D%E5%90%88%E4%BE%8B%E5%AD%90.png" class="" title="119.复合例子.png"></li>
<li>类图 <!-- ![120.复合类图1.png](./img/120.复合类图1.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/120.%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9B%BE1.png" class="" title="120.复合类图1.png">
 <!-- ![121.复合类图2.png](./img/121.复合类图2.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/121.%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9B%BE2.png" class="" title="121.复合类图2.png">

</li>
</ol>
<h3 id="3-复合模式之王-MVC"><a href="#3-复合模式之王-MVC" class="headerlink" title="3. 复合模式之王-MVC"></a>3. 复合模式之王-MVC</h3><ol>
<li>认识MVC <!-- ![122.认识MVC.png](./img/122.认识MVC.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/122.%E8%AE%A4%E8%AF%86MVC.png" class="" title="122.认识MVC.png"></li>
<li>MVC的模式 <!-- ![123.MVC模式.png](./img/123.MVC模式.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/123.MVC%E6%A8%A1%E5%BC%8F.png" class="" title="123.MVC模式.png"></li>
<li>观察者 <!-- ![124.观察者.png](./img/124.观察者.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/124.%E8%A7%82%E5%AF%9F%E8%80%85.png" class="" title="124.观察者.png"></li>
<li>策略 <!-- ![125.策略.png](./img/125.策略.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/125.%E7%AD%96%E7%95%A5.png" class="" title="125.策略.png"></li>
<li>组合 <!-- ![126.组合.png](./img/126.组合.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/126.%E7%BB%84%E5%90%88.png" class="" title="126.组合.png">

</li>
</ol>
<h3 id="4-一个控制节拍的例子"><a href="#4-一个控制节拍的例子" class="headerlink" title="4. 一个控制节拍的例子"></a>4. 一个控制节拍的例子</h3><ol>
<li><p>设计</p>
 <!-- ![127.设计.png](./img/127.设计.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/127.%E8%AE%BE%E8%AE%A1.png" class="" title="127.设计.png"></li>
<li><p>MVC</p>
 <!-- ![128.MVC.png](./img/128.MVC.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/128.MVC.png" class="" title="128.MVC.png"></li>
<li><p>Model</p>
<ul>
<li>Model接口  <!-- ![129.Model接口.png](./img/129.Model接口.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/129.Model%E6%8E%A5%E5%8F%A3.png" class="" title="129.Model接口.png"></li>
<li>Model  <!-- ![130.Model.png](./img/130.Model.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/130.Model.png" class="" title="130.Model.png"></li>
</ul>
</li>
<li><p>视图</p>
<ul>
<li>视图分为两部分  <!-- ![131.视图.png](./img/131.视图.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/131.%E8%A7%86%E5%9B%BE.png" class="" title="131.视图.png"></li>
<li>状态视图代码  <!-- ![132.状态视图.png](./img/132.状态视图.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/132.%E7%8A%B6%E6%80%81%E8%A7%86%E5%9B%BE.png" class="" title="132.状态视图.png"></li>
<li>控制视图代码  <!-- ![133.控制视图.png](./img/133.控制视图.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/133.%E6%8E%A7%E5%88%B6%E8%A7%86%E5%9B%BE.png" class="" title="133.控制视图.png"></li>
<li>这虽然是两个不同的界面，但在一个类中</li>
</ul>
</li>
<li><p>控制器</p>
<ul>
<li>接口  <!-- ![134.控制器接口.png](./img/134.控制器接口.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/134.%E6%8E%A7%E5%88%B6%E5%99%A8%E6%8E%A5%E5%8F%A3.png" class="" title="134.控制器接口.png"></li>
<li>实现  <!-- ![135.控制器实现.png](./img/135.控制器实现.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/135.%E6%8E%A7%E5%88%B6%E5%99%A8%E5%AE%9E%E7%8E%B0.png" class="" title="135.控制器实现.png"></li>
</ul>
</li>
<li><p>运行</p>
 <!-- ![136.运行.png](./img/136.运行.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/136.%E8%BF%90%E8%A1%8C.png" class="" title="136.运行.png">
</li>
<li><p>适配心跳检测</p>
<ol>
<li>写适配器 <!-- ![137.心跳适配.png](./img/137.心跳适配.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/137.%E5%BF%83%E8%B7%B3%E9%80%82%E9%85%8D.png" class="" title="137.心跳适配.png"></li>
<li>心跳控制器 <!-- ![138.心跳控制.png](./img/138.心跳控制.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/138.%E5%BF%83%E8%B7%B3%E6%8E%A7%E5%88%B6.png" class="" title="138.心跳控制.png"></li>
<li>测试 <!-- ![139.测试.png](./img/139.测试.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/139.%E6%B5%8B%E8%AF%95.png" class="" title="139.测试.png">

</li>
</ol>
</li>
</ol>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul>
<li>OO基础<ol>
<li>抽象</li>
<li>封装</li>
<li>多态</li>
<li>继承</li>
</ol>
</li>
<li>OO原则<ol>
<li>封装变化。</li>
<li>多用组合,少用继承。</li>
<li>针对接口编程，不针对实现编程。</li>
<li>为交互对象之间的松耦合设计而努力</li>
<li>对扩展开放，对修改关闭</li>
<li>依赖抽象，不要依赖具体类</li>
<li>只和朋友交流</li>
<li>别找我，我会找你</li>
<li>类应该只有一个改变的理由</li>
</ol>
</li>
<li>OO模式<ul>
<li>复合模式：结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题</li>
</ul>
</li>
</ul>
<h3 id="6-要点"><a href="#6-要点" class="headerlink" title="6. 要点"></a>6. 要点</h3><ol>
<li>MVC是复合模式，结合了观察者模式、策略模式和组合模式</li>
<li>模型使用观察者模式，以便观察者更新，同时保持两者之间解耦</li>
<li>控制器是视图的策略，视图可以使用不同的控制器实现，得到不同的行为</li>
<li>视图使用组合模式实现用户界面，用户界面通常组合了嵌套的组件，像面板、框架和按钮</li>
<li>这些模式携手合作，把MVC模型的三层解耦，这样可以保持设计干净又有弹性</li>
<li>适配器模式用来将新的模型适配成已有的视图和控制器</li>
<li>Model2是MVC在Web上的应用</li>
<li>在Model2中，控制器实现成Servlet，而JSP/HTML实现视图</li>
</ol>
<h1 id="十三、与设计模式相处，真实世界中的模式"><a href="#十三、与设计模式相处，真实世界中的模式" class="headerlink" title="十三、与设计模式相处，真实世界中的模式"></a>十三、与设计模式相处，真实世界中的模式</h1><h3 id="1-定义设计模式"><a href="#1-定义设计模式" class="headerlink" title="1. 定义设计模式"></a>1. 定义设计模式</h3><ol>
<li>模式是在某情境(context)下，针对某问题的某种解决方案</li>
</ol>
<h3 id="2-模式总结"><a href="#2-模式总结" class="headerlink" title="2. 模式总结"></a>2. 模式总结</h3><ol>
<li>策略:封装可以互换的行为，并用委托来决定要使用哪个</li>
<li>状态：封装基于状态的行为，并用委托在行为之间切换</li>
<li>装饰者：包装一个对象，以提供新的行为</li>
<li>外观：简化一群类的接口</li>
<li>迭代器：在对象的集合之中游走，而不暴露集合的实现</li>
<li>适配器：封装对象，并提供不同的接口</li>
<li>代理：包装对象，以控制对对象的访问</li>
<li>观察者：让对象能够在状态改变时被通知</li>
<li>工厂方法：由子类决定要创建的具体类是哪一个</li>
<li>抽象工厂：允许客户创建对象的家族，而无需指定他们的具体类</li>
<li>组合：客户用一致的方式处理对象集合和单个对象</li>
<li>单件：确保有且只有一个对象被创建</li>
<li>命令：封装请求成为对象</li>
<li>模板方法：由子类决定如何实现一个算法中的步骤</li>
</ol>
<h3 id="3-模式分类"><a href="#3-模式分类" class="headerlink" title="3. 模式分类"></a>3. 模式分类</h3><ol>
<li><p>创建型</p>
</li>
<li><p>行为型</p>
</li>
<li><p>结构型</p>
 <!-- ![140.模式分类.png](./img/140.模式分类.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/140.%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB.png" class="" title="140.模式分类.png">
</li>
<li><p>模式所处理的是类还是对象</p>
 <!-- ![141.类与对象.png](./img/141.类与对象.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/141.%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1.png" class="" title="141.类与对象.png">

</li>
</ol>
<h3 id="4-用模式思考"><a href="#4-用模式思考" class="headerlink" title="4. 用模式思考"></a>4. 用模式思考</h3><ol>
<li>保持简单</li>
<li>设计模式并非万能</li>
<li>需要知道何时需要模式</li>
<li>重构的时间就是模式的时间</li>
<li>去掉不需要的设计模式</li>
<li>如果现在不需要，就别做</li>
</ol>
<h3 id="5-其他模式"><a href="#5-其他模式" class="headerlink" title="5. 其他模式"></a>5. 其他模式</h3><ol>
<li>架构模式<ul>
<li>用来简历生机勃勃的建筑、城镇和城市的架构。这也正是模式开始的地方</li>
<li>例子：从所居住、参观的建筑物中，可以发现它的踪迹</li>
</ul>
</li>
<li>应用模式<ul>
<li>是建立系统级架构的模式。许多多层的架构都属于这一类目</li>
<li>出现在三层架构、客户/服务器系统、及Web中</li>
<li>MVC可算是其中的一种</li>
</ul>
</li>
<li>领域特定模式<ul>
<li>关注特定领域的问题，如并发系统或实时系统</li>
</ul>
</li>
<li>业务流程模式<ul>
<li>描述业务、客户和数据之间的交互，此模式能处理如“如何有效决策并沟通决策”之类的问题</li>
<li>出现在公司的会议室以及项目管理会议中</li>
</ul>
</li>
<li>组织模式<ul>
<li>，描述了人类组织的结构以及实践</li>
</ul>
</li>
<li>用户界面设计模式<ul>
<li>致力于解决设计交互式软件时的问题</li>
<li>被发现在视频游戏设计者、GUJ构造者和制作者附近</li>
</ul>
</li>
</ol>
<h3 id="6-反模式"><a href="#6-反模式" class="headerlink" title="6. 反模式"></a>6. 反模式</h3><ol>
<li>反模式告诉你如何采用一个不好的解决方案解决一个问题</li>
<li>例子：黄金榔头 <!-- ![142.黄金榔头.png](./img/142.黄金榔头.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/142.%E9%BB%84%E9%87%91%E6%A6%94%E5%A4%B4.png" class="" title="142.黄金榔头.png">

</li>
</ol>
<h1 id="十四、剩下的模式"><a href="#十四、剩下的模式" class="headerlink" title="十四、剩下的模式"></a>十四、剩下的模式</h1><h3 id="1-桥接模式-Bridge-Pattern"><a href="#1-桥接模式-Bridge-Pattern" class="headerlink" title="1. 桥接模式(Bridge Pattern)"></a>1. 桥接模式(Bridge Pattern)</h3><ol>
<li>使用桥接模式不只改变你的实现，也改变你的抽象</li>
<li>场景 <!-- ![143.桥接.png](./img/143.桥接.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/143.%E6%A1%A5%E6%8E%A5.png" class="" title="143.桥接.png"></li>
<li>桥接模式类图 <!-- ![144.桥接类图.png](./img/144.桥接类图.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/144.%E6%A1%A5%E6%8E%A5%E7%B1%BB%E5%9B%BE.png" class="" title="144.桥接类图.png">
<ul>
<li>现在有了两个层次结构，有了桥接的存在，就可以独立地改变这两个层次</li>
</ul>
</li>
<li>桥接的优点<ol>
<li>将实现解耦，让它和界面之间不再永久绑定</li>
<li>抽象和实现可以独立扩展，不会影响到对方</li>
<li>对于”具体的抽象类”所做的改变，不会影响到客户</li>
</ol>
</li>
<li>桥接的用途和缺点<ol>
<li>适合使用在需要跨多个平台的图形和窗口系统上</li>
<li>当需要用不同的方式改变接口和实现时，你会发现桥接模式很好用</li>
<li>桥接模式的缺点是增加了复杂度</li>
</ol>
</li>
</ol>
<h3 id="2-生成器模式-Builder-Pattern"><a href="#2-生成器模式-Builder-Pattern" class="headerlink" title="2. 生成器模式(Builder Pattern)"></a>2. 生成器模式(Builder Pattern)</h3><ol>
<li>使用生成器封装一个产品的构造过程，并允许按步骤构造</li>
<li>场景 <!-- ![145.生成器主题.png](./img/145.生成器主题.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/145.%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%BB%E9%A2%98.png" class="" title="145.生成器主题.png">
<ul>
<li>需要有弹性的设计  <!-- ![146.有弹性.png](./img/146.有弹性.png) -->
  <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/146.%E6%9C%89%E5%BC%B9%E6%80%A7.png" class="" title="146.有弹性.png"></li>
</ul>
</li>
<li>生成器类图 <!-- ![147.生成器类图.png](./img/147.生成器类图.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/147.%E7%94%9F%E6%88%90%E5%99%A8%E7%B1%BB%E5%9B%BE.png" class="" title="147.生成器类图.png"></li>
<li>生成器的优点<ol>
<li>讲一个复杂对象的创建过程封装起来</li>
<li>允许对象通过多个步骤来创建，并且可以改变过程(这和只有一个步骤的工厂模式不同)</li>
<li>向客户隐藏产品内部的表现</li>
<li>产品的实现可以被替换，因为客户只看到一个抽象的接口</li>
</ol>
</li>
<li>生成器的用途和缺点<ol>
<li>经常被用来创建组合结构</li>
<li>与工厂模式相比，采用生成器模式创建对象的客户，需要具备更多的领域知识</li>
</ol>
</li>
</ol>
<h3 id="3-责任链模式-Chain-of-Responsibility-Pattern"><a href="#3-责任链模式-Chain-of-Responsibility-Pattern" class="headerlink" title="3. 责任链模式(Chain of Responsibility Pattern)"></a>3. 责任链模式(Chain of Responsibility Pattern)</h3><ol>
<li><p>当你想要让一个以上的对象有机会能够处理某个请求的时候，就是用责任链模式</p>
</li>
<li><p>场景</p>
 <!-- ![148.场景.png](./img/148.场景.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/148.%E5%9C%BA%E6%99%AF.png" class="" title="148.场景.png"></li>
<li><p>类图</p>
<ul>
<li>通过责任链模式，可以为某个请求创建一个对象链。每个对象依序检查此请求，并对其进行处理，或者将它传给链中的下一个对象<!-- ![149.责任链.png](./img/149.责任链.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/149.%E8%B4%A3%E4%BB%BB%E9%93%BE.png" class="" title="149.责任链.png"></li>
</ul>
</li>
<li><p>责任链优点</p>
<ol>
<li>将请求的发送者和接收者解耦</li>
<li>可以简化你的对象，因为他不需要知道链的结构</li>
<li>通过改变链内的成员或调动它们的次序，允许你动态地新增或者删除责任</li>
</ol>
</li>
<li><p>责任链的用途和缺点</p>
<ol>
<li>经常被使用在窗口系统中，处理鼠标和键盘之类的事件</li>
<li>并不保证请求一定会被执行；如果没有任何对象处理它的话，他可能会落到链尾之外(这可以是有点也可以是缺点)</li>
<li>可能不容易观察运行时的特征，有碍于除错</li>
</ol>
</li>
</ol>
<h3 id="4-蝇量模式-Flyweight-Pattern"><a href="#4-蝇量模式-Flyweight-Pattern" class="headerlink" title="4. 蝇量模式(Flyweight Pattern)"></a>4. 蝇量模式(Flyweight Pattern)</h3><ol>
<li><p>如想让某个类的一个实例能用来提供许多”虚拟实例”，就使用蝇量模式</p>
</li>
<li><p>场景</p>
 <!-- ![150.场景.png](./img/150.场景.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/150.%E5%9C%BA%E6%99%AF.png" class="" title="150.场景.png"></li>
<li><p>类图</p>
<ul>
<li>不用上述做法，只用一个树实例和一个客户对象来维护”所有”树的状态。这就是蝇量模式<!-- ![151.蝇量.png](./img/151.蝇量.png) -->
<img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/151.%E8%9D%87%E9%87%8F.png" class="" title="151.蝇量.png"></li>
</ul>
</li>
<li><p>优点</p>
<ol>
<li>减少运行时对象实例的个数，节省内存</li>
<li>将许多”虚拟”对象的状态集中管理</li>
</ol>
</li>
<li><p>用途和缺点<br> 1.当一个类有许多的实例，而这些实例能被同一方法控制的时候，我们就可以使用蝇量模式</p>
<ol start="2">
<li>蝇量模式的缺点在于，一旦你实现了它，那么单个的逻辑实例将无法拥有独立而不同的行为 </li>
</ol>
</li>
</ol>
<h3 id="5-解释器模式-Interpreter-Pattern"><a href="#5-解释器模式-Interpreter-Pattern" class="headerlink" title="5. 解释器模式(Interpreter Pattern)"></a>5. 解释器模式(Interpreter Pattern)</h3><ol>
<li>使用解释器模式为语言创建解释器</li>
<li>场景 <!-- ![152.解释器.png](./img/152.解释器.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/152.%E8%A7%A3%E9%87%8A%E5%99%A8.png" class="" title="152.解释器.png"></li>
<li>类图 <!-- ![153.类图.png](./img/153.类图.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/153.%E7%B1%BB%E5%9B%BE.png" class="" title="153.类图.png"></li>
<li>优点<ol>
<li>将每一个语法规则表示成一个类，方便于实现语言</li>
<li>因为语法由许多类表示，所以你可以轻易地改变或扩展此语言</li>
<li>通过在类结构中加入新的方法，可以在解释的同时增加新的行为，例如打印格式的美化或者进行复杂的程序验证</li>
</ol>
</li>
<li>用途和缺点<ol>
<li>当你需要实现一个简单的语言时，使用解释器</li>
<li>当你有一个简单的语法，而且简单比效率更重要时，使用解释器</li>
<li>可以处理脚本语言和编程语言</li>
<li>当语法规则的数目太大时，这个模式可能会变得非常繁杂。在这种情况下，使用解析器/编译器的产生器可能更合适</li>
</ol>
</li>
</ol>
<h3 id="6-中介者模式-Mediator-Pattern"><a href="#6-中介者模式-Mediator-Pattern" class="headerlink" title="6. 中介者模式(Mediator Pattern)"></a>6. 中介者模式(Mediator Pattern)</h3><ol>
<li>集中相关对象之间复杂的沟通和控制方式</li>
<li>场景 <!-- ![154.场景.png](./img/154.场景.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/154.%E5%9C%BA%E6%99%AF.png" class="" title="154.场景.png"></li>
<li>类图 <!-- ![155.中介.png](./img/155.中介.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/155.%E4%B8%AD%E4%BB%8B.png" class="" title="155.中介.png"></li>
<li>优点<ol>
<li>通过将对象彼此解耦，可以增加对象的复用性</li>
<li>通过将控制逻辑集中，可以简化系统维护</li>
<li>可以让对象之间所传递的消息变得简单而且大幅减少</li>
</ol>
</li>
<li>用途和缺点<ol>
<li>中介者常常被用来协调相关的GUI组件</li>
<li>中介者模式的缺点是，如果设计不当，中介者对象本身会变得过于复杂</li>
</ol>
</li>
</ol>
<h3 id="7-备忘录模式-Mementor-Pattern"><a href="#7-备忘录模式-Mementor-Pattern" class="headerlink" title="7. 备忘录模式(Mementor Pattern)"></a>7. 备忘录模式(Mementor Pattern)</h3><ol>
<li><p>当你需要让对象返回之前的状态时(例如“撤销”)，就使用备忘录模式</p>
</li>
<li><p>场景</p>
 <!-- ![156.场景.png](./img/156.场景.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/156.%E5%9C%BA%E6%99%AF.png" class="" title="156.场景.png"></li>
<li><p>类图</p>
 <!-- ![157.类图.png](./img/157.类图.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/157.%E7%B1%BB%E5%9B%BE.png" class="" title="157.类图.png">
</li>
<li><p>优点</p>
<ol>
<li>将被存储的状态放在外面，不要和关键对象混在一起，这可以帮助维护内聚</li>
<li>保持关键对象的数据封装</li>
<li>提供了容易实现的回复能力</li>
</ol>
</li>
<li><p>用途和缺点</p>
<ol>
<li>备忘录用于存储状态</li>
<li>使用备忘录的缺点；存储和恢复状态的过程可能相当耗时</li>
<li>在Java系统中，其实可以考虑使用序列化机制存系统的状态</li>
</ol>
</li>
</ol>
<h3 id="8-原型模式-Prototype-Pattern"><a href="#8-原型模式-Prototype-Pattern" class="headerlink" title="8. 原型模式(Prototype Pattern)"></a>8. 原型模式(Prototype Pattern)</h3><ol>
<li>当创建给定类的实例的过程很昂贵或很复杂时，就使用原型模式</li>
<li>场景 <!-- ![158.场景.png](./img/158.场景.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/158.%E5%9C%BA%E6%99%AF.png" class="" title="158.场景.png"></li>
<li>类图 <!-- ![159.原型.png](./img/159.原型.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/159.%E5%8E%9F%E5%9E%8B.png" class="" title="159.原型.png"></li>
<li>优点<ol>
<li>向客户隐藏制造新实例的复杂性</li>
<li>提供让客户能够产生未知类型对象的选项</li>
<li>在某些环境下，复制对象比创建新对象更有效</li>
</ol>
</li>
<li>用途和缺点<ol>
<li>在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象时，可以考虑原型。</li>
<li>使用原型模式的缺点：对象的复制有时相当复杂</li>
</ol>
</li>
</ol>
<h3 id="9-访问者模式-Visitor-Pattern"><a href="#9-访问者模式-Visitor-Pattern" class="headerlink" title="9. 访问者模式(Visitor Pattern)"></a>9. 访问者模式(Visitor Pattern)</h3><ol>
<li>当你想要为一个对象的组合增加新的能力，且封装并不重要时，就使用访问者模式</li>
<li>场景 <!-- ![160.场景.png](./img/160.场景.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/160.%E5%9C%BA%E6%99%AF.png" class="" title="160.场景.png"></li>
<li>类图 <!-- ![161.访问者.png](./img/161.访问者.png) -->
 <img src="/%E3%80%8Ahead-first%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/161.%E8%AE%BF%E9%97%AE%E8%80%85.png" class="" title="161.访问者.png"></li>
<li>优点<ol>
<li>允许你对组合结构加入新的操作，而无需改变结构本身</li>
<li>想要加入新的操作，相对容易</li>
<li>访问者所进行的操作，其代码是集中在一起的。</li>
</ol>
</li>
<li>缺点<ol>
<li>当采用访问者模式的时候，就会打破组合类的封装</li>
<li>因为游走的功能牵涉其中，所以对组合结构的改变就更加困难</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>服务端</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《精通Django》</title>
    <url>/%E3%80%8A%E7%B2%BE%E9%80%9ADjango%E3%80%8B/</url>
    <content><![CDATA[<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ul>
<li>之前有用Django2.1做过个小项目，有点经验，可惜这本书是1.8的，之前的没整理笔记很多细节都忘了，做了个思维导图还是在Windows上，在另一个硬盘里也不知道丢哪了，唉</li>
</ul>
<a id="more"></a>

<h1 id="第一章：新手入门"><a href="#第一章：新手入门" class="headerlink" title="第一章：新手入门"></a>第一章：新手入门</h1><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><ul>
<li>python</li>
<li>django</li>
<li>python虚拟环境<ul>
<li>virtualenv</li>
<li>这个非必须</li>
</ul>
</li>
<li>数据库</li>
<li>具体怎么安装就不说了</li>
</ul>
<h3 id="2-新建项目"><a href="#2-新建项目" class="headerlink" title="2. 新建项目"></a>2. 新建项目</h3><ul>
<li><p>新建</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在当前目录新建名为mysite的项目</span><br><span class="line">django-admin startproject mysite</span><br></pre></td></tr></table></figure>
</li>
<li><p>目录结构</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysite&#x2F;     &#x2F;&#x2F;项目的容器。这个目录的名称对 Django 没什么作用,你可以根据喜好重命名</span><br><span class="line">    manage.py   &#x2F;&#x2F;命令行实用脚本,可以通过不同的方式与 Django 项目交互</span><br><span class="line">    mysite&#x2F;     &#x2F;&#x2F;项目的 Python 包。导入这里面的内容要使用目录的名称(如mysite.urls )</span><br><span class="line">        __init__.py &#x2F;&#x2F;空文件,目的是让 Python 把这个目录识别为 Python 包。</span><br><span class="line">        settings.py &#x2F;&#x2F;Django 项目的设置&#x2F;配置</span><br><span class="line">        urls.py &#x2F;&#x2F;URL 声明</span><br><span class="line">        wsgi.py &#x2F;&#x2F;兼容 WSGI 的 Web 服务器的入口点,用于伺服项目</span><br></pre></td></tr></table></figure>
<h3 id="3-Django-的设置"><a href="#3-Django-的设置" class="headerlink" title="3. Django 的设置"></a>3. Django 的设置</h3></li>
<li><p>编辑 mysite/settings.py</p>
</li>
<li><p>TIME_ZONE</p>
<ul>
<li>设置时区</li>
<li>‘Asia/Shanghai’ 上海时间</li>
<li>‘UTC’ 世界标准时间</li>
</ul>
</li>
<li><p>LANGUAGE_CODE</p>
<ul>
<li>设置语言</li>
<li>‘zh-Hans’ 汉语</li>
<li>‘en-us’ 英语</li>
</ul>
</li>
<li><p>ROOT_URLCONF = ‘mysite.urls’</p>
<ul>
<li>设置URL解析的文件</li>
</ul>
</li>
<li><p>INSTALLED_APPS</p>
<ul>
<li>其值是这个 Django 实例中激活的全部 Django 应用</li>
<li>一个应用可以在多个项目中使用,而且应用可以打包,供其他项目使用</li>
<li>默认包含<ul>
<li>django.contrib.admin :管理后台</li>
<li>django.contrib.auth :身份验证系统</li>
<li>django.contrib.contenttypes :内容类型框架</li>
<li>django.contrib.sessions :会话框架</li>
<li>django.contrib.messages :消息框架</li>
<li>django.contrib.staticfiles :管理静态文件的框架</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-开发服务器"><a href="#4-开发服务器" class="headerlink" title="4. 开发服务器"></a>4. 开发服务器</h3><ul>
<li>运行自带的服务器  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure></li>
<li>注意,别在任何生产环境中使用这个服务器,它只能在开发过程中使用。</li>
</ul>
<h3 id="5-模型-视图-控制器设计模式"><a href="#5-模型-视图-控制器设计模式" class="headerlink" title="5. 模型-视图-控制器设计模式"></a>5. 模型-视图-控制器设计模式</h3><ul>
<li>Django 严格遵守 MVC 模式,但是有自己的实现逻辑。“C”部分由框架处理,多数时候,我们的工作在模型、模板和视图中,因此 Django 经常被称为 MTV 框架。在 MTV 开发模式中:</li>
<li>M 表示“模型”,即数据访问层。这一层包含所有与数据相关的功能:访问数据的方式、验证数据的方式、数据的行为、数据之间的关系。第 4 章将深入探讨 Django 的模型。</li>
<li>T 表示“模板”,即表现层。这一层包含表现相关的决策:在网页或其他文档类型中如何显示某个东西。第 3 章将探讨 Django 的模板。</li>
<li>V 表示“视图”,即业务逻辑层。这一层包含访问模型和选择合适模板的逻辑。你可以把视图看做模型和模板之间的桥梁。下一章将讨论 Django 的视图。</li>
</ul>
<h1 id="第二章：视图和-URL-配置"><a href="#第二章：视图和-URL-配置" class="headerlink" title="第二章：视图和 URL 配置"></a>第二章：视图和 URL 配置</h1><h3 id="1-Django-驱动的页面"><a href="#1-Django-驱动的页面" class="headerlink" title="1. Django 驱动的页面"></a>1. Django 驱动的页面</h3><ul>
<li>编写视图<ul>
<li>在前一章创建的 mysite 目录中新建一个空文件,名为 views.py  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line">def hello(request):</span><br><span class="line">    return HttpResponse(&quot;Hello world&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>URL 配置<ul>
<li>修改urls.py  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, include(admin.site.urls)),</span><br><span class="line">    url(r&#39;^hello&#x2F;$&#39;, hello),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>流程  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 请求 &#x2F;hello&#x2F; 。</span><br><span class="line">2. Django 查看 ROOT_URLCONF 设置,找到根 URL 配置。</span><br><span class="line">3. Django 比较 URL 配置中的各个 URL 模式,找到与 &#x2F;hello&#x2F; 匹配的那个。</span><br><span class="line">4. 如果找到匹配的模式,调用对应的视图函数。</span><br><span class="line">5. 视图函数返回一个 HttpResponse 对象。</span><br><span class="line">6. Django 把 HttpResponse 对象转换成正确的 HTTP 响应,得到网页。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-第二个视图：动态内容"><a href="#2-第二个视图：动态内容" class="headerlink" title="2. 第二个视图：动态内容"></a>2. 第二个视图：动态内容</h3><ul>
<li>动态获取时间  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">def hello(request):</span><br><span class="line">    return HttpResponse(&quot;Hello world&quot;)</span><br><span class="line">def current_datetime(request):</span><br><span class="line">    now &#x3D; datetime.datetime.now()</span><br><span class="line">    html &#x3D; &quot;It is now %s.&quot; % now</span><br><span class="line">    return HttpResponse(html)</span><br></pre></td></tr></table></figure>
<h3 id="3-URL-配置和松耦合"><a href="#3-URL-配置和松耦合" class="headerlink" title="3. URL 配置和松耦合"></a>3. URL 配置和松耦合</h3></li>
<li>URL 配置和视图之间就是松耦合的  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;如果想把这个功能对应的 URL 从 &#x2F;time&#x2F; 移到 &#x2F;current-time&#x2F; ,只需修改URL 配置,视图则不用动</span><br><span class="line">&#x2F;&#x2F;还可以多个URL指向同一个视图</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, include(admin.site.urls)),</span><br><span class="line">    url(r&#39;^hello&#x2F;$&#39;, hello),</span><br><span class="line">    url(r&#39;^time&#x2F;$&#39;, current_datetime),</span><br><span class="line">    url(r&#39;^another-time-page&#x2F;$&#39;, current_datetime),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="4-第三个视图-动态-URL"><a href="#4-第三个视图-动态-URL" class="headerlink" title="4. 第三个视图:动态 URL"></a>4. 第三个视图:动态 URL</h3></li>
<li>处理url带参数的情况</li>
<li>以一定的偏移量显示当前日期和时间。我们的目标是让 /time/plus/1/ 页面显示一小时之后的日期和时间,让 /time/plus/2/ 页面显示两小时之后的日期和时间,以此类推。<ul>
<li>url  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url(r&#39;^time&#x2F;plus&#x2F;(\d&#123;1,2&#125;)&#x2F;$&#39;, hours_ahead),</span><br></pre></td></tr></table></figure></li>
<li>视图  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.http import Http404, HttpResponse</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">def hours_ahead(request, offset):</span><br><span class="line">    try:</span><br><span class="line">        offset &#x3D; int(offset)</span><br><span class="line">    except ValueError:</span><br><span class="line">        raise Http404()</span><br><span class="line">    dt &#x3D; datetime.datetime.now() + datetime.timedelta(hours&#x3D;offset)</span><br><span class="line">    html &#x3D; &quot;In %s hour(s), it will be %s.&quot; % (offset, dt)</span><br><span class="line">    return HttpResponse(html)</span><br></pre></td></tr></table></figure></li>
<li>每个视图的第一个参数都是 HttpRequest 对象。</li>
<li>offset 是 URL 模式中那对圆括号捕获的字符串。</li>
</ul>
</li>
<li>这个url写法是1.8，要用正则表达式，貌似2.1有更好写的，不用正则表达式的写法。<ul>
<li>系统的urls.py里，在1.X的时候，都是采用的url方式。如下  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url(r&#39;^&#39;, include(&quot;test1.urls&quot;)),</span><br></pre></td></tr></table></figure></li>
<li>在2.0中，它推荐使用的是path模块，所以这里就改写一下。引包from django.urls import path  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path(&#39;&#39;, include(&quot;test1.urls&quot;)),</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>自己项目的urls.py里，我们也使用path<ul>
<li>1.x里面的写法是  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url(r’^page&#x3D;(\d+)&amp;key&#x3D;(\w+)$’, views.detail, name&#x3D;”detail”), </span><br></pre></td></tr></table></figure></li>
<li>现在的写法  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">re_path(&#39;page&#x3D;(?P&lt;page&gt;\d+)&amp;key&#x3D;(?P&lt;key&gt;\w+)&#39;, views.detail, name&#x3D;&quot;detail&quot;),</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="第三章：Django-模板"><a href="#第三章：Django-模板" class="headerlink" title="第三章：Django 模板"></a>第三章：Django 模板</h1><h3 id="1-模板基础"><a href="#1-模板基础" class="headerlink" title="1. 模板基础"></a>1. 模板基础</h3><ul>
<li>作用<ul>
<li>Django 模板是一些文本字符串,作用是把文档的表现与数据区分开。模板定义一些占位符和基本的逻辑(模板标签),规定如何显示文档。通常,模板用于生成 HTML,不过 Django 模板可以生成任何基于文本的格式。</li>
</ul>
</li>
<li>变量<ul>
<li>两对花括号包围的文本<code>(如 &#123;&#123; person_name &#125;&#125; )</code>是变量,意思是“把指定变量的值插入这里”。如何指定变量的值呢?稍后说明。</li>
</ul>
</li>
<li>条件判断<ul>
<li>一对花括号和百分号包围的文本<code>(如 &#123;% if ordered_warranty %&#125; )`是模板标签。标签的定义相当宽泛:只要能让模板系统“做些事”的就是标签。
- 循环
    - 这个示例模板中有一个 for 标签`( &#123;% for item in item_list %&#125; )`和一个 if 标签`( &#123;% if or-dered_warranty %&#125; )`。 for 标签的作用与 Python 中的 for 语句很像,用于迭代序列中的各个元素。与你预期的一样, if 标签的作用是编写逻辑判断语句。这里, if 标签检查 ordered_warranty 变量的求值结果是不是 True 。如果是,模板系统将显示 `&#123;% ifordered_warranty %&#125;` 和 `&#123;% else %&#125;` 之间的内容;如果不是,模板系统将显示 `&#123;% else %&#125;` 和 `&#123;% endif%&#125;</code> 之间的内容。注意, <code>&#123;% else %&#125;</code> 是可选的。</li>
</ul>
</li>
<li>过滤器<ul>
<li>最后,这个模板的第二段包含一个过滤器,这是调整变量格式最为便利的方式。对这个示例中的 <code>&#123;&#123;ship_date|date:"F j, Y" &#125;&#125;</code> 来说,我们把 ship_date 变量传给 date 过滤器,并且为 date 过滤器指定”F j, Y” 参数。 date 过滤器使用参数指定的格式格式化日期。过滤器使用管道符号<code>|</code>依附,类似于 Unix 管道。</li>
</ul>
</li>
</ul>
<h3 id="2-使用模板系统"><a href="#2-使用模板系统" class="headerlink" title="2. 使用模板系统"></a>2. 使用模板系统</h3><h5 id="创建template对象"><a href="#创建template对象" class="headerlink" title="创建template对象"></a>创建template对象</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.template import Template</span><br><span class="line">t &#x3D; Template(&#39;My name is &#123;&#123; name &#125;&#125;.&#39;)</span><br><span class="line">print (t)  </span><br><span class="line">&#x2F;&#x2F;输出：&lt;django.template.base.Template object at 0x030396B0&gt;</span><br></pre></td></tr></table></figure></code></pre>
<h5 id="渲染模板"><a href="#渲染模板" class="headerlink" title="渲染模板"></a>渲染模板</h5><ul>
<li>有了 Template 对象之后,可以为其提供上下文,把数据传给它。上下文就是一系列模板变量和相应的值。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.template import Context, Template</span><br><span class="line">t &#x3D; Template(&#39;My name is &#123;&#123; name &#125;&#125;.&#39;)</span><br><span class="line">c &#x3D; Context(&#123;&#39;name&#39;: &#39;Stephane&#39;&#125;)</span><br><span class="line">t.render(c)</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">&#39;My name is Stephane.&#39;</span><br></pre></td></tr></table></figure>
<h5 id="Django-模板系统的基本用法"><a href="#Django-模板系统的基本用法" class="headerlink" title="Django 模板系统的基本用法"></a>Django 模板系统的基本用法</h5></li>
<li>编写模板字符串</li>
<li>创建 Template 对象</li>
<li>创建 Context 对象</li>
<li>调用 render() 方法。</li>
</ul>
<h3 id="3-字典和上下文"><a href="#3-字典和上下文" class="headerlink" title="3. 字典和上下文"></a>3. 字典和上下文</h3><ul>
<li>Python 字典是键和值的映射。 Context 对象类似于字典,但是它有额外的功能<h5 id="多个上下文-同一个模板"><a href="#多个上下文-同一个模板" class="headerlink" title="多个上下文,同一个模板"></a>多个上下文,同一个模板</h5>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; Template(&#39;Hello, &#123;&#123; name &#125;&#125;&#39;)</span><br><span class="line">for name in (&#39;John&#39;, &#39;Julie&#39;, &#39;Pat&#39;):</span><br><span class="line">    print (t.render(Context(&#123;&#39;name&#39;: name&#125;)))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="上下文变量查找"><a href="#上下文变量查找" class="headerlink" title="上下文变量查找"></a>上下文变量查找</h5><ul>
<li>模板系统遇到变量名中的点号时会按照下述顺序尝试查找:<ul>
<li>字典查找(如 foo[“bar”] )</li>
<li>属性查找(如 foo.bar )</li>
<li>方法调用(如 foo.bar() )</li>
<li>列表索引查找(如 foo[2] )</li>
</ul>
</li>
<li>下述示例使用的  ,相当于一个字典查找( person[‘name’] )加上一个方法调用( upper() ):  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from django.template import Template, Context</span><br><span class="line">&gt;&gt;&gt; person &#x3D; &#123;&#39;name&#39;: &#39;Sally&#39;, &#39;age&#39;: &#39;43&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; t &#x3D; Template(&#39;&#123;&#123; person.name.upper &#125;&#125; is &#123;&#123; person.age &#125;&#125; years old.&#39;)</span><br><span class="line">&gt;&gt;&gt; c &#x3D; Context(&#123;&#39;person&#39;: person&#125;)</span><br><span class="line">&gt;&gt;&gt; t.render(c)</span><br><span class="line">&#39;SALLY is 43 years old.&#39;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="方法调用的行为"><a href="#方法调用的行为" class="headerlink" title="方法调用的行为"></a>方法调用的行为</h5><ul>
<li>在方法查找的过程中,如果方法抛出异常,异常会向上冒泡,除非异常有 silent_variable_failure 属性,而且值为 True 。如果异常确实有 silent_variable_failure 属性,使用引擎的 string_if_invalid配置选项(默认为一个空字符串)渲染变量。</li>
<li>方法不能有必须的参数。否则,模板系统向后移动到下一种查询类型(列表索引查询)。</li>
<li>按照设计,Django 限制了在模板中可以处理的逻辑量,因此在模板中不能给方法传递参数。数据应该在视图中计算之后再传给模板显示。</li>
<li>显然,有些方法有副作用,如果允许模板系统访问这样的方法,那就愚蠢之极,甚至还可能埋下安全漏洞。</li>
<li>假如有个 BankAccount 对象,它有个 delete() 方法。如果模板中有  这样的内容,其中 account 是 BankAccount 对象,那么渲染模板时会把 account 删除。为了避免这种行为,在方法上设定函数属性 alters_data</li>
</ul>
<h5 id="如何处理无效变量"><a href="#如何处理无效变量" class="headerlink" title="如何处理无效变量"></a>如何处理无效变量</h5><ul>
<li>如果变量不存在,模板系统在变量处插入引擎的 string_if_invalid 配置选项。这个选项的默认值为一个空字符串。</li>
<li>例如  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from django.template import Template, Context</span><br><span class="line">&gt;&gt;&gt; t &#x3D; Template(&#39;Your name is &#123;&#123; name &#125;&#125;.&#39;)</span><br><span class="line">&gt;&gt;&gt; t.render(Context())</span><br><span class="line">&#39;Your name is .&#39;</span><br><span class="line">&gt;&gt;&gt; t.render(Context(&#123;&#39;var&#39;: &#39;hello&#39;&#125;))</span><br><span class="line">&#39;Your name is .&#39;</span><br></pre></td></tr></table></figure>
<h3 id="4-基本的模板标签和过滤器"><a href="#4-基本的模板标签和过滤器" class="headerlink" title="4. 基本的模板标签和过滤器"></a>4. 基本的模板标签和过滤器</h3></li>
</ul>
<h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><ul>
<li>if/elif/else/endif  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if athlete_list %&#125;</span><br><span class="line">Number of athletes: &#123;&#123; athlete_list|length &#125;&#125;</span><br><span class="line">&#123;% elif athlete_in_locker_room_list %&#125;</span><br><span class="line">&lt;p&gt;Athletes should be out of the locker room soon! &lt;&#x2F;p&gt;</span><br><span class="line">&#123;% elif ...</span><br><span class="line">...</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">&lt;p&gt;No athletes. &lt;&#x2F;p&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&#123;% if %&#125;</code> 支持使用 and 、 or 或 not 测试多个变量,或者取反指定的变量。</li>
<li>在同一个标签中可以同时使用 and 和 or ,此时, and 的优先级比 or 高。</li>
<li>在 if 标签中使用括号是无效的句法。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if athlete_list and coach_list or cheerleader_list %&#125;</span><br><span class="line">&#x2F;&#x2F;像下面这样解释:但不能像下面这样写</span><br><span class="line">if (athlete_list and coach_list) or cheerleader_list</span><br></pre></td></tr></table></figure></li>
<li>如果需要通过括号指明优先级,应该使用嵌套的 if 标签。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if athlete_list %&#125;</span><br><span class="line">    &#123;% if coach_list or cheerleader_list %&#125;</span><br><span class="line">        &lt;p&gt;We have athletes, and either coaches or cheerleaders! &lt;&#x2F;p&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>for  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for athlete in athlete_list %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; athlete.name &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% empty %&#125;</span><br><span class="line">    &lt;p&gt;There are no athletes. Only computer programmers.&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>&#123;% for %&#125;</code> 循环内部,可以访问一个名为 forloop 的模板变量。这个变量有几个属性,通过它们可以获知循环进程的一些信息:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for item in todo_list %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; forloop.counter &#125;&#125;: &#123;&#123; item &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>forloop.counter 的值是一个整数,表示循环的次数。这个属性的值从 1 开始,因此第一次循环时,forloop.counter 等于 1 。</li>
<li>forloop.counter0 与 forloop.counter 类似,不过是从零开始的。第一次循环时,其值为 0 。</li>
<li>forloop.revcounter 的值是一个整数,表示循环中剩余的元素数量。第一次循环时, for-loop.revcounter 的值是序列中要遍历的元素总数。最后一次循环时, forloop.revcounter 的值为 1 。</li>
<li>forloop.revcounter0 与 forloop.revcounter 类似,不过索引是基于零的。第一次循环时, for-loop.revcounter0 的值是序列中元素数量减去一。最后一次循环时, forloop.revcounter0 的值为 0 。</li>
<li>forloop.first 是个布尔值,第一次循环时为 True 。需要特殊处理第一个元素时很方便:</li>
<li>forloop.last 是个布尔值,最后一次循环时为 True 。经常用它在一组链接之间放置管道符号:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for link in links %&#125;</span><br><span class="line">    &#123;&#123; link &#125;&#125;</span><br><span class="line">    &#123;% if not forloop.last %&#125; </span><br><span class="line">    ， </span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#x2F;&#x2F;结果</span><br><span class="line">Link1 ， Link2 ， Link3 ， Link4</span><br></pre></td></tr></table></figure></li>
<li>在嵌套的循环中, forloop.parentloop 引用父级循环的 forloop 对象。  </li>
</ul>
</li>
</ul>
</li>
<li>ifequal/ifnotequal  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% ifequal section &#39;sitenews&#39; %&#125;</span><br><span class="line">    &lt;h1&gt;Site News&lt;&#x2F;h1&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    &lt;h1&gt;No News Here&lt;&#x2F;h1&gt;</span><br><span class="line">&#123;% endifequal %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以下都合法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% ifequal variable True %&#125;</span><br><span class="line">&#123;% ifequal variable [1, 2, 3] %&#125;</span><br><span class="line">&#123;% ifequal variable &#123;&#39;key&#39;: &#39;value&#39;&#125; %&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>注释  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# This is a comment #&#125;</span><br><span class="line">&#123;% comment %&#125;</span><br><span class="line">This is a</span><br><span class="line">multi-line comment.</span><br><span class="line">&#123;% endcomment %&#125;</span><br></pre></td></tr></table></figure>
<h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5></li>
<li>获取列表中的第一个元素,然后将其转换成大写:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; my_list|first|upper &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li>显示 bio 变量的前 30 个词。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; bio|truncatewords:&quot;30&quot; &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li>几个重要过滤器<ul>
<li>addslashes :在反斜线、单引号和双引号前面添加一个反斜线。可用于转义字符串。例如: <code>&#123;&#123; val-ue|addslashes &#125;&#125;</code> 。</li>
<li>date :根据参数中的格式字符串格式化 date 或 datetime 对象。例如: <code>&#123;&#123; pub_date|date:"F j, Y"&#125;&#125;</code> 。格式字符串在附录 E 中说明。</li>
<li>length :返回值的长度。对列表来说,返回元素的数量。对字符串来说,返回字符的数量。如果变量未定义,返回 0 。</li>
</ul>
</li>
</ul>
<h3 id="5-理念和局限"><a href="#5-理念和局限" class="headerlink" title="5. 理念和局限"></a>5. 理念和局限</h3><h5 id="Django-的核心理念"><a href="#Django-的核心理念" class="headerlink" title="Django 的核心理念"></a>Django 的核心理念</h5><ol>
<li>表现与逻辑分离<ul>
<li>模板系统用于控制表现及与其相关的逻辑,仅此而已。超出这一基本目标的功能都不应该支持。</li>
</ul>
</li>
<li>避免重复<ul>
<li>大多数动态网站都使用某种全站通用的设计,例如通用的页头、页脚、导航栏,等等。Django 模板系统应该为此提供便利的方式,把这些元素存储在一个位置,减少重复的代码。模板继承背后就是这个理念。</li>
</ul>
</li>
<li>与 HTML 解耦<ul>
<li>模板系统不应该只能输出 HTML,还要能够生成其他基于文本的格式(也就是纯文本)。</li>
</ul>
</li>
<li>XML 不应该作为模板语言<ul>
<li>如果使用 XML 引擎解析模板,编辑模板时可能引入大量人为错误,而且处理模板有很多额外消耗。 </li>
</ul>
</li>
<li>不要求具备设计能力<ul>
<li>模板系统不应该必须在 WYSIWYG 编辑器(如 Dreamweaver)中才能写出。这样有太多局限,句法不够灵活。</li>
<li>Django 的目标是让模板编写人员能直接编辑 HTML。</li>
</ul>
</li>
<li>透明处理空格<ul>
<li>模板系统不应该特殊处理空格。模板中的空格就是空格,要像文本那样显示出来。不在模板标签中的空格都应该显示。</li>
</ul>
</li>
<li>不重造一门编程语言<ul>
<li>模板系统一定不能允许:<br>  ◦ 为变量赋值<br>  ◦ 编写高级的逻辑</li>
<li>也就是不能重造一门编程语言。模板系统的目标是提供适量的编程功能,例如分支和循环,足够做表现相关的判断就行。</li>
<li>Django 模板系统知道模板最常由设计师编写,而不是程序员,因此不要求具备 Python 知识。</li>
</ul>
</li>
<li>确保安全有保障<ul>
<li>模板系统默认应该禁止包含恶意代码,例如删除数据库记录的命令。这是模板系统不允许随意使用Python 代码的另一个原因。</li>
</ul>
</li>
<li>可扩展<ul>
<li>模板系统应该认识到,高级模板编写人员可能想扩展功能。这是自定义模板标签和过滤器背后的理念。</li>
</ul>
</li>
</ol>
<h3 id="6-在视图中使用模板"><a href="#6-在视图中使用模板" class="headerlink" title="6. 在视图中使用模板"></a>6. 在视图中使用模板</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.template import Template, Context</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line">import datetime</span><br><span class="line">def current_datetime(request):</span><br><span class="line">now &#x3D; datetime.datetime.now()</span><br><span class="line"># 使用文件系统中模板的简单方式</span><br><span class="line"># 这样做不好,因为没有考虑缺少文件的情况</span><br><span class="line">fp &#x3D; open(&#39;&#x2F;home&#x2F;djangouser&#x2F;templates&#x2F;mytemplate.html&#39;)</span><br><span class="line">t &#x3D; Template(fp.read())</span><br><span class="line">fp.close()</span><br><span class="line">html &#x3D; t.render(Context(&#123;&#39;current_date&#39;: now&#125;))</span><br><span class="line">return HttpResponse(html)</span><br></pre></td></tr></table></figure>
<ul>
<li>这么做不够优雅,原因如下:<ol>
<li>没有处理缺少文件的情况。如果 mytemplate.html 文件不存在或不可读, open() 调用会抛出 IOError异常。</li>
<li>模板位置是硬编码的。如果每个视图函数都这么做,要重复编写模板的位置。更别提要输入很多内容了!</li>
<li>有大量乏味的样板代码。生活如此美好,为何每次加载模板时要浪费时间编写 open() 、 fp.read() 和fp.close() 调用。</li>
</ol>
</li>
</ul>
<h3 id="7-模板加载机制"><a href="#7-模板加载机制" class="headerlink" title="7. 模板加载机制"></a>7. 模板加载机制</h3><ol>
<li>为了从文件系统中加载模板,Django 提供了便利而强大的 API,力求去掉模板加载调用和模板自身的冗余</li>
<li>若想使用这个模板加载 API,首先要告诉框架模板的存储位置。这个位置在设置文件中配置。</li>
<li>打开 settings..py 文件,找到 TEMPLATES 设置。它的值是一个列表,分别针对各个模板引擎: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TEMPLATES &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,</span><br><span class="line">        &#39;DIRS&#39;: [],</span><br><span class="line">        &#39;APP_DIRS&#39;: True,</span><br><span class="line">        &#39;OPTIONS&#39;: &#123;</span><br><span class="line">            &#39;context_processors&#39;: [</span><br><span class="line">                &#39;django.template.context_processors.debug&#39;,</span><br><span class="line">                &#39;django.template.context_processors.request&#39;,</span><br><span class="line">                &#39;django.contrib.auth.context_processors.auth&#39;,</span><br><span class="line">                &#39;django.contrib.messages.context_processors.messages&#39;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>BACKEND 的值是一个点分 Python 路径,指向实现 Django 模板后端 API 的模板引擎类。</li>
<li>内置的后端有 <ul>
<li>djan-go.template.backends.django.DjangoTemplates</li>
<li>django.template.backends.jinja2.Jinja2 。</li>
</ul>
</li>
<li>因为多数引擎从文件中加载模板,所以各个引擎的顶层配置包含三个通用的设置:<ul>
<li>DIRS 定义一个目录列表,模板引擎按顺序在里面查找模板源文件。</li>
<li>APP_DIRS 设定是否在安装的应用中查找模板。按约定, APPS_DIRS 设为 True 时, DjangoTemplates 会在INSTALLED_APPS 中的各个应用里查找名为“templates”的子目录。这样,即使 DIRS 为空,模板引擎还能查找应用模板。</li>
<li>OPTIONS 是一些针对后端的设置。</li>
</ul>
</li>
<li>注意<ul>
<li>如果不是构建没有应用的极简程序,最好留空 DIRS 。设置文件默认把 APP_DIRS 设为 True ,因此最好在 Django 应用中放一个“templates”子目录。</li>
<li>如果想在项目根目录中放一些主模板(例如在 mysite/templates 目录中),需要像这样设定 DIRS :  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>代码 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.template.loader import get_template</span><br><span class="line">from django.template import Context</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">def current_datetime(request):</span><br><span class="line">    now &#x3D; datetime.datetime.now()</span><br><span class="line">    t &#x3D; get_template(&#39;current_datetime.html&#39;)</span><br><span class="line">    html &#x3D; t.render(Context(&#123;&#39;current_date&#39;: now&#125;))</span><br><span class="line">    return HttpResponse(html)</span><br></pre></td></tr></table></figure>
<h3 id="8-render"><a href="#8-render" class="headerlink" title="8. render()"></a>8. render()</h3></li>
<li>使用 render() 重写的 current_datetime 视图 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">def current_datetime(request):</span><br><span class="line">    now &#x3D; datetime.datetime.now()</span><br><span class="line">    return render(request, &#39;current_datetime.html&#39;, &#123;&#39;current_date&#39;: now&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="9-模板子目录"><a href="#9-模板子目录" class="headerlink" title="9. 模板子目录"></a>9. 模板子目录</h3><ul>
<li><p>如果把所有模板存放在一个目录中,很快就会变得不灵便。你可能想把模板存储在模板目录的子目录里,这么做很好。</p>
</li>
<li><p>把模板放到模板目录的子目录中不是难事。调用 get_template() 时,只需在模板名称前面加上子目录的名称和一条斜线,如下所示:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; get_template(&#39;dateapp&#x2F;current_datetime.html&#39;)</span><br><span class="line">&#x2F;&#x2F;或者用render</span><br><span class="line">return render(request, &#39;dateapp&#x2F;current_datetime.html&#39;, &#123;&#39;current_date&#39;: now&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="10-include-模板标签"><a href="#10-include-模板标签" class="headerlink" title="10. include 模板标签"></a>10. include 模板标签</h3></li>
<li><p>只要想在多个模板中使用相同的代码,就可以考虑使用 <code>&#123;% include %&#125;</code> ,去除重复。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &#39;nav.html&#39; %&#125;</span><br><span class="line">&#123;% include &quot;nav.html&quot; %&#125;</span><br><span class="line">&#123;% include &#39;includes&#x2F;nav.html&#39; %&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mypage.html</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#123;% include &quot;includes&#x2F;nav.html&quot; %&#125;</span><br><span class="line">&lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line"># includes&#x2F;nav.html</span><br><span class="line">&lt;div id&#x3D;&quot;nav&quot;&gt;</span><br><span class="line">You are in: &#123;&#123; current_section &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>如果 <code>&#123;% include %&#125;</code> 标签的参数指定的模板不存在,Django 会做下面两件事中的一件:</p>
<ul>
<li>DEBUG 为 True 时,渲染 Django 错误页面,显示 TemplateDoesNotExist 异常。</li>
<li>DEBUG 为 False 时,静默,那个标签的位置什么也不显示。</li>
</ul>
</li>
</ul>
<h3 id="11-模板继承"><a href="#11-模板继承" class="headerlink" title="11. 模板继承"></a>11. 模板继承</h3><ul>
<li><p>模板继承是指创建一个基底“骨架”模板,包含网站的所有通用部分,并且定义一些“块”,让子模板覆盖。</p>
</li>
<li><p>基模板base.html</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01&#x2F;&#x2F;EN&quot;&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;My helpful timestamp site&lt;&#x2F;h1&gt;</span><br><span class="line">        &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">        &#123;% block footer %&#125;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &lt;p&gt;Thanks for visiting my site.&lt;&#x2F;p&gt;</span><br><span class="line">        &#123;% endblock %&#125;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>继承基类的current_datetime.html</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;The current time&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">&lt;p&gt;It is now &#123;&#123; current_date &#125;&#125;.&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>继承不影响模板的上下文。也就是说,继承树中的任何模板都能访问上下文中的每一个模板变量。</p>
</li>
<li><p>继承经常使用下述三层结构:</p>
<ol>
<li>创建 base.html 模板,定义网站的整体外观。这个模板的内容很少变化。</li>
<li>为网站中的各个“区域”创建 base_SECTION.html 模板(如 base_photos.html 和 base_forum.html )。这些模板扩展 base.html ,包含各区域专属的样式和设计。</li>
<li>为各种页面创建单独的模板,例如论坛页面或相册。这些模板扩展相应的区域模板。</li>
</ol>
</li>
<li><p>使用模板继承的一些指导方针:</p>
<ol>
<li>如果模板中有 <code>&#123;% extends %&#125;</code> ,必须是模板中的第一个标签。否则,模板继承不起作用。</li>
<li>一般来说,基模板中的 <code>&#123;% block %&#125;</code> 标签越多越好。记住,子模板无需定义父模板中的全部块,因此可以为一些块定义合理的默认内容,只在子模板中覆盖需要的块。钩子多总是好的。</li>
<li>如果发现要在多个模板中重复编写相同的代码,或许说明应该把那些代码移到父模板中的一个 <code>&#123;%block %&#125;</code> 标签里。</li>
<li>如果需要从父模板中的块里获取内容,使用 <code>&#123;&#123; block.super &#125;&#125;</code> ,这是一个“魔法”变量,提供父模板中渲染后的文本。向块中添加内容,而不是完全覆盖时就可以这么做。</li>
<li>在同一个模板中不能为多个 <code>&#123;% block %&#125;</code> 标签定义相同的名称。之所以有这个限制,是因为 block 标签是双向的。即, block 标签不仅标识供填充的空位,还用于定义填充父模板中空位的内容。如果一个模板中有两个同名的块,那么父模板就不知道使用哪个块里的内容。</li>
<li>传给 <code>&#123;% extends %&#125;</code> 的模板名称使用与 get_template() 相同的方法加载。即,模板在 DIRS 设置定义的目录中,或者在当前 Django 应用的“templates”目录里。</li>
<li>多数情况下, <code>&#123;% extends %&#125;</code> 的参数是字符串,不过如果直到运行时才知道父模板的名称,也可以用变量。通过这一点可以做些动态判断。</li>
</ol>
</li>
</ul>
<h1 id="第四章：Django模型"><a href="#第四章：Django模型" class="headerlink" title="第四章：Django模型"></a>第四章：Django模型</h1><h3 id="1-在视图中执行数据库查询的“愚蠢”方式"><a href="#1-在视图中执行数据库查询的“愚蠢”方式" class="headerlink" title="1. 在视图中执行数据库查询的“愚蠢”方式"></a>1. 在视图中执行数据库查询的“愚蠢”方式</h3><ul>
<li>通过MySQLdb连接  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render</span><br><span class="line">import MySQLdb</span><br><span class="line"></span><br><span class="line">def book_list(request):</span><br><span class="line">    db &#x3D; MySQLdb.connect(user&#x3D;&#39;me&#39;, db&#x3D;&#39;mydb&#39;, passwd&#x3D;&#39;secret&#39;, host&#x3D;&#39;localhost&#39;)</span><br><span class="line">    cursor &#x3D; db.cursor()</span><br><span class="line">    cursor.execute(&#39;SELECT name FROM books ORDER BY name&#39;)</span><br><span class="line">    names &#x3D; [row[0] for row in cursor.fetchall()]</span><br><span class="line">    db.close()</span><br><span class="line">    return render(request, &#39;book_list.html&#39;, &#123;&#39;names&#39;: names&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-配置数据库"><a href="#2-配置数据库" class="headerlink" title="2. 配置数据库"></a>2. 配置数据库</h3><ul>
<li>在 settings.py 文件中添加的初始配置  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DATABASES &#x3D; &#123;</span><br><span class="line">    &#39;default&#39;: &#123;</span><br><span class="line">        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,</span><br><span class="line">        &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ENGINE 告诉 Django 使用哪个数据库引擎。默认sqlite3</li>
<li>NAME 告诉 Django 数据库的名称。例如: ‘NAME’: ‘mydb’, 。</li>
<li>一个连接mysql的示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DATABASES &#x3D; &#123;</span><br><span class="line">    &#39;default&#39;: &#123;</span><br><span class="line">    &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,</span><br><span class="line">    &#39;NAME&#39;: &#39;schemename&#39;,</span><br><span class="line">    &#39;USER&#39;: &#39;root&#39;,</span><br><span class="line">    &#39;PASSWORD&#39;:&#39;...&#39;,</span><br><span class="line">    &#39;HOST&#39;:&#39;localhost&#39;,</span><br><span class="line">    &#39;PORT&#39;:&#39;3306&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-第一个应用"><a href="#3-第一个应用" class="headerlink" title="3. 第一个应用"></a>3. 第一个应用</h3></li>
</ul>
</li>
<li>项目与应用之间有什么区别呢?<ol>
<li>区别是一个是配置,一个是代码。</li>
<li>一个项目是一系列 Django 应用的实例,外加那些应用的配置。严格来说,一个项目唯一需要的是一个设定文件,定义数据库连接信息、安装的应用列表、 DIRS ,等等。</li>
<li>一个应用是一系列便携的 Django 功能,通常包含模型和视图。打包在一个 Python 包里。Django 自带了一些应用,例如管理后台。这些应用的独特之处是便携,可以在多个项目中复用。</li>
<li>编写的代码在这二者之间游走,没有严格的界限。如果构建的是简单的网站,可能只会使用一个应用;如果构建复杂的网站,有几个不相关的部分,如电商系统和留言板,可能想把各部分放在单独的应用中,这样以后可以复用。</li>
<li>如果使用 Django 的数据库层(模型),必须创建 Django 应用。模型必须保存在应用中。因此,编写模型之前,要新建一个应用。</li>
</ol>
</li>
<li>创建应用  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py startapp books </span><br></pre></td></tr></table></figure></li>
<li>应用目录结构  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">books&#x2F;</span><br><span class="line">    &#x2F;migrations</span><br><span class="line">    __init__.py</span><br><span class="line">    admin.py</span><br><span class="line">    models.py</span><br><span class="line">    tests.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-使用-Python-定义模型"><a href="#4-使用-Python-定义模型" class="headerlink" title="4. 使用 Python 定义模型"></a>4. 使用 Python 定义模型</h3><ul>
<li>Django 模型是使用 Python 代码对数据库中数据的描述,是数据的结构,等效于 SQL 中的 CREATE TABLE 语句,不过是用 Python 代码而非 SQL 表述的,而且不仅包含数据库列的定义。</li>
<li>“使用 Python 代替 SQL 定义数据模型是不是多此一举?”Django 之所以这么做有几个原因:<ul>
<li>内省(introspection)有开销,而且不完美。为了提供便利的数据访问 API,Django 需要以某种方式知晓数据库布局,而这一需求有两种实现方式。第一种是使用 Python 明确描述数据,第二种是在运行时内省数据库,推知数据模型。第二种方式在一个地方存储表的元数据,看似更简单,其实会导致几个问题。首先,运行时内省数据库肯定有消耗。如果每次执行请求,或者只是初始化 Web 服务器都要内省数据库,那带来的消耗是无法接受的。其次,有些数据库,尤其是旧版 MySQL,存储的元数据不足以完成内省。</li>
<li>Python 编写起来让人心情舒畅,而且使用 Python 编写所有代码无需频繁让大脑切换情境。</li>
<li>把数据模型保存在代码中比保存在数据库中易于做版本控制,易于跟踪数据布局的变化。</li>
<li>SQL 对数据布局的元数据只有部分支持。例如,多数数据库系统没有提供专门表示电子邮件地址或URL 的数据类型。而 Django 模型有。高层级的数据结构有助于提升效率,让代码更便于复用。</li>
<li>不同数据库平台使用的 SQL 不一致。</li>
</ul>
</li>
<li>缺点:<ul>
<li>模型的 Python 代码可能与数据库的真正结构脱节。如果修改了 Django 模型,还要在数据库中做相同的改动,让数据库与模型保持一致。本章后面讨论迁移(migration)时会说明如何处理这个问题。</li>
</ul>
</li>
</ul>
<h5 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h5><ul>
<li><p>在models.py文件中</p>
</li>
<li><p>图书-作者-出版社</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class Publisher(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    address &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    city &#x3D; models.CharField(max_length&#x3D;60)</span><br><span class="line">    state_province &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    country &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    website &#x3D; models.URLField()</span><br><span class="line"></span><br><span class="line">class Author(models.Model):</span><br><span class="line">    first_name &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    last_name &#x3D; models.CharField(max_length&#x3D;40)</span><br><span class="line">    email &#x3D; models.EmailField()</span><br><span class="line"></span><br><span class="line">class Book(models.Model):</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;100)</span><br><span class="line">    authors &#x3D; models.ManyToManyField(Author)</span><br><span class="line">    publisher &#x3D; models.ForeignKey(Publisher)</span><br><span class="line">    publication_date &#x3D; models.DateField()</span><br></pre></td></tr></table></figure>
<h5 id="安装模型"><a href="#安装模型" class="headerlink" title="安装模型"></a>安装模型</h5></li>
<li><p>编写好代码之后,要在数据库中创建表。为此,第一步是在 Django 项目中激活那些模型。激活的方法是把books 应用添加到设置文件中“安装的应用”列表中。</p>
</li>
<li><p>打开 settings.py 文件,找到 INSTALLED_APPS 设置。它的作用是告诉 Django,当前项目激活了哪些应用。</p>
</li>
<li><p>为了注册我们开发的“books”应用,要把 ‘books’ (指代我们正在开发的“books”应用)添加到 INSTALLED_APPS中,得到下述设置:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS &#x3D; [</span><br><span class="line">    &#39;django.contrib.admin&#39;,</span><br><span class="line">    &#39;django.contrib.auth&#39;,</span><br><span class="line">    &#39;django.contrib.contenttypes&#39;,</span><br><span class="line">    &#39;django.contrib.sessions&#39;,</span><br><span class="line">    &#39;django.contrib.messages&#39;,</span><br><span class="line">    &#39;django.contrib.staticfiles&#39;,</span><br><span class="line">    &#39;books&#39;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>首先,运行下述命令,验证模型:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py check</span><br></pre></td></tr></table></figure>
<ul>
<li>check 命令运行 Django 系统检查框架,即验证 Django 项目的一系列静态检查。如果一切正常,你将看到这个消息: System check identified no issues (0 silenced) 。如若不然,请确保你输入的模型代码是正确的。错误消息应该会告诉你代码哪里出错了。</li>
<li>只要觉得模型有问题,就可以运行 python manage.py check ,它能捕获全部常见的模型问题。</li>
</ul>
</li>
<li><p>告诉 Django ，对模型做了修改(第一次运行是新建了模型):</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations books   </span><br><span class="line">&#x2F;&#x2F;books是应用名</span><br></pre></td></tr></table></figure>
<ul>
<li>Django 把对模型(也就是数据库模式)的改动存储在迁移中,迁移就是磁盘中的文件。</li>
<li>运行上述命令后,books 应用的 migrations 文件夹里会出现一个名为 0001_initial.py 的文件。</li>
<li>migrate 命令会查看最新的迁移文件,自动更新数据库模式</li>
<li>查看将运行的 SQL。 sqlmigrate 命令的参数是迁移名称,输出的结果是对应的 SQL:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py sqlmigrate books 0001</span><br></pre></td></tr></table></figure></li>
<li>你应该看到类似下面的输出(为了便于阅读,重新做了排版):  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">CREATE TABLE &quot;books_author&quot; (</span><br><span class="line">    &quot;id&quot; integer NOT NULL PRIMARY KEY AUTOINCREMENT,</span><br><span class="line">    &quot;first_name&quot; varchar(30) NOT NULL,</span><br><span class="line">    &quot;last_name&quot; varchar(40) NOT NULL,</span><br><span class="line">    &quot;email&quot; varchar(254) NOT NULL</span><br><span class="line">);</span><br><span class="line">......&#x2F;&#x2F;省略</span><br></pre></td></tr></table></figure></li>
<li>sqlmigrate 命令并不创建表,其实它根本不接触数据库,而是在屏幕上输出 Django 将执行的 SQL。如果愿意,可以把输出的 SQL 复制粘贴到数据库客户端里</li>
</ul>
</li>
<li><p>提交SQL</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>
<ul>
<li>迁移是 Django 把模型改动(添加字段、删除模型,等等)应用到数据库模式的方式。大多数情况下,迁移能自动完成工作,然而也有一些不足。</li>
</ul>
</li>
</ul>
<h3 id="5-基本的数据访问"><a href="#5-基本的数据访问" class="headerlink" title="5. 基本的数据访问"></a>5. 基本的数据访问</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from books.models import Publisher</span><br><span class="line">&gt;&gt;&gt; p1 &#x3D; Publisher(name&#x3D;&#39;Apress&#39;, address&#x3D;&#39;2855 Telegraph Avenue&#39;,</span><br><span class="line">...</span><br><span class="line">city&#x3D;&#39;Berkeley&#39;, state_province&#x3D;&#39;CA&#39;, country&#x3D;&#39;U.S.A.&#39;,</span><br><span class="line">...</span><br><span class="line">website&#x3D;&#39;http:&#x2F;&#x2F;www.apress.com&#x2F;&#39;)</span><br><span class="line">&gt;&gt;&gt; p1.save()</span><br><span class="line">&gt;&gt;&gt; p2 &#x3D; Publisher(name&#x3D;&quot;O&#39;Reilly&quot;, address&#x3D;&#39;10 Fawcett St.&#39;,</span><br><span class="line">...</span><br><span class="line">city&#x3D;&#39;Cambridge&#39;, state_province&#x3D;&#39;MA&#39;, country&#x3D;&#39;U.S.A.&#39;,</span><br><span class="line">...</span><br><span class="line">website&#x3D;&#39;http:&#x2F;&#x2F;www.oreilly.com&#x2F;&#39;)</span><br><span class="line">&gt;&gt;&gt; p2.save()</span><br><span class="line">&gt;&gt;&gt; publisher_list &#x3D; Publisher.objects.all()</span><br><span class="line">&gt;&gt;&gt; publisher_list</span><br><span class="line">[&lt;Publisher: Publisher object&gt;, &lt;Publisher: Publisher object&gt;]</span><br></pre></td></tr></table></figure>
<ul>
<li>这几行代码完成的工作<ul>
<li>首先,导入 Publisher 模型类,以便与保存出版社的数据库表交互。</li>
<li>提供各个字段的值, name 、 address ,等等,实例化一个 Publisher 对象。</li>
<li>为了把对象保存到数据库中,调用 save() 方法。Django 在背后执行 SQL INSERT 语句。</li>
<li>为了从数据库中检索出版社,使用 Publisher.objects 属性,你可以把它的值理解为全部出版社。使用 Publisher.objects.all() 获取数据库中的所有 Publisher 对象。Django 在背后执行 SQL SELECT 语句。</li>
</ul>
</li>
<li>使用 Django 模型 API 创建的对象不会自动保存,只能自己动手调用 save() 方法</li>
</ul>
<h5 id="添加模型的字符串表示形式"><a href="#添加模型的字符串表示形式" class="headerlink" title="添加模型的字符串表示形式"></a>添加模型的字符串表示形式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; publisher_list</span><br><span class="line">[&lt;Publisher: Publisher object&gt;, &lt;Publisher: Publisher object&gt;]</span><br></pre></td></tr></table></figure>
<ul>
<li>上例得到的输出,不易区分各个 Publisher 对象，这个问题易于修正,为 Publisher 类添加一个名为 <strong>str</strong>() 的方法即可。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Publisher(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    address &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    city &#x3D; models.CharField(max_length&#x3D;60)</span><br><span class="line">    state_province &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    country &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    website &#x3D; models.URLField()</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br></pre></td></tr></table></figure></li>
<li>新的输出<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; publisher_list</span><br><span class="line">[&lt;Publisher: Apress&gt;, &lt;Publisher: O&#39;Reilly&gt;]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="插入和更新数据"><a href="#插入和更新数据" class="headerlink" title="插入和更新数据"></a>插入和更新数据</h5><ul>
<li>插入如上例中的，创建对象p,p.save();</li>
<li>更新就是更改p,例如  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p.name&#x3D;&quot;newname&quot;</span><br><span class="line">p.save()    &#x2F;&#x2F;还要调用这一步，而且是全部更新，并不是只更新修改的，这在某些逻辑中可能导致条件竞争。</span><br></pre></td></tr></table></figure>
<h5 id="选择对象"><a href="#选择对象" class="headerlink" title="选择对象"></a>选择对象</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.all()</span><br><span class="line">[&lt;Publisher: Apress&gt;, &lt;Publisher: O&#39;Reilly&gt;]</span><br><span class="line">&#x2F;&#x2F;这基本上相当于下述 SQL 语句:</span><br><span class="line">SELECT id, name, address, city, state_province, country, website</span><br><span class="line">FROM books_publisher;</span><br></pre></td></tr></table></figure></li>
<li>分析 Publisher.objects.all() 这行代码:<ul>
<li>首先, Publisher 是我们定义的模型。这没什么可意外的,想查找数据就应该使用相应的模型。</li>
<li>然后,访问 objects 属性。这叫管理器(manager),在第 9 章详述。现在,你只需知道,管理器负责<br>所有“表层”数据操作,包括(最重要的)数据查询。所有模型都自动获得一个 objects 管理器,需要查询模型实例时都要使用它。</li>
<li>最后,调用 all() 方法。这是 objects 管理器的一个方法,返回数据库中的所有行。虽然返回的对象看似一个列表,但其实是一个查询集合(QuerySet)——表示数据库中一系列行的对象。附录 C 将详细说明查询集合。本章都将把它视作它所模仿的列表。</li>
</ul>
</li>
</ul>
<h5 id="过滤数据-filter"><a href="#过滤数据-filter" class="headerlink" title="过滤数据,filter()"></a>过滤数据,filter()</h5><ul>
<li>我们很少需要一次性从数据库中选择所有数据。多数情况下,我们只想处理数据的子集。</li>
<li>可以使用 filter() 方法过滤数据:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.filter(name&#x3D;&#39;Apress&#39;)</span><br><span class="line">[&lt;Publisher: Apress&gt;]</span><br></pre></td></tr></table></figure></li>
<li>与 Python 一样,Django 使用双下划线表示“魔法”操作。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.filter(name__contains&#x3D;&quot;press&quot;)</span><br><span class="line">[&lt;Publisher: Apress&gt;]</span><br><span class="line">&#x2F;&#x2F;Django 把 __contains 部分转换成 SQL LIKE 语句:</span><br><span class="line">SELECT id, name, address, city, state_province, country, website</span><br><span class="line">FROM books_publisher</span><br><span class="line">WHERE name LIKE &#39;%press%&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li>支持的其他查找类型有: icontains (不区分大小写的 LIKE ), startswith 和 endswith ,以及 range (SQLBETWEEN 语句)<h5 id="检索单个对象-get"><a href="#检索单个对象-get" class="headerlink" title="检索单个对象,get()"></a>检索单个对象,get()</h5></li>
</ul>
</li>
<li>上述 filter() 示例都返回一个查询集合(可视作列表)。有时,较之列表,更适合获取单个对象。此时应该使用 get() 方法:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.get(name&#x3D;&quot;Apress&quot;)</span><br><span class="line">&lt;Publisher: Apress&gt;</span><br></pre></td></tr></table></figure></li>
<li>返回多个对象和不返回对象都会导致异常</li>
</ul>
<h5 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.order_by(&quot;name&quot;)</span><br><span class="line">[&lt;Publisher: Apress&gt;, &lt;Publisher: O&#39;Reilly&gt;]</span><br></pre></td></tr></table></figure>
<ul>
<li>逆序，加减号-<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.order_by(&quot;-name&quot;)</span><br><span class="line">[&lt;Publisher: O&#39;Reilly&gt;, &lt;Publisher: Apress&gt;]</span><br></pre></td></tr></table></figure></li>
<li>可以在模型中指定排序  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Publisher(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    address &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    city &#x3D; models.CharField(max_length&#x3D;60)</span><br><span class="line">    state_province &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    country &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    website &#x3D; models.URLField()</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        ordering &#x3D; [&#39;name&#39;]</span><br></pre></td></tr></table></figure>
<h5 id="链式查找"><a href="#链式查找" class="headerlink" title="链式查找"></a>链式查找</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.filter(country&#x3D;&quot;U.S.A.&quot;).order_by(&quot;-name&quot;)</span><br><span class="line">[&lt;Publisher: O&#39;Reilly&gt;, &lt;Publisher: Apress&gt;]</span><br></pre></td></tr></table></figure>
<h5 id="切片数据"><a href="#切片数据" class="headerlink" title="切片数据"></a>切片数据</h5></li>
<li>返回第一个  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.order_by(&#39;name&#39;)[0]   &#x2F;&#x2F;注意,不支持使用负数:</span><br><span class="line">&lt;Publisher: Apress&gt;</span><br></pre></td></tr></table></figure></li>
<li>检索数据子集:得到的是两个对象  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Publisher.objects.order_by(&#39;name&#39;)[0:2]</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">SELECT id, name, address, city, state_province, country, website</span><br><span class="line">FROM books_publisher</span><br><span class="line">ORDER BY name</span><br><span class="line">OFFSET 0 LIMIT 2;</span><br></pre></td></tr></table></figure>
<h5 id="在一个语句中更新多个对象"><a href="#在一个语句中更新多个对象" class="headerlink" title="在一个语句中更新多个对象"></a>在一个语句中更新多个对象</h5></li>
<li>这种办法会导致竞争条件  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; p &#x3D; Publisher.objects.get(name&#x3D;&#39;Apress&#39;)</span><br><span class="line">&gt;&gt;&gt; p.name &#x3D; &#39;Apress Publishing&#39;</span><br><span class="line">&gt;&gt;&gt; p.save()</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">SELECT id, name, address, city, state_province, country, website</span><br><span class="line">FROM books_publisher</span><br><span class="line">WHERE name &#x3D; &#39;Apress&#39;;</span><br><span class="line"></span><br><span class="line">UPDATE books_publisher SET</span><br><span class="line">    name &#x3D; &#39;Apress Publishing&#39;,</span><br><span class="line">    address &#x3D; &#39;2855 Telegraph Ave.&#39;,</span><br><span class="line">    city &#x3D; &#39;Berkeley&#39;,</span><br><span class="line">    state_province &#x3D; &#39;CA&#39;,</span><br><span class="line">    country &#x3D; &#39;U.S.A.&#39;,</span><br><span class="line">    website &#x3D; &#39;http:&#x2F;&#x2F;www.apress.com&#39;</span><br><span class="line">WHERE id &#x3D; 52;</span><br></pre></td></tr></table></figure></li>
<li>更高效,而且不会导致条件竞争的办法  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Publisher.objects.filter(id&#x3D;52).update(name&#x3D;&#39;Apress Publishing&#39;)</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">UPDATE books_publisher</span><br><span class="line">SET name &#x3D; &#39;Apress Publishing&#39;</span><br><span class="line">WHERE id &#x3D; 52;</span><br></pre></td></tr></table></figure></li>
<li>update() 方法可以在任何 QuerySet 对象上调用,这意味着可以通过它批量编辑多个记录。下述代码把每个Publisher 记录的 country 列都由 ‘U.S.A.’ 改为 ‘USA’ :  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.all().update(country&#x3D;&#39;USA&#39;)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<ul>
<li>update() 方法有返回值,是一个整数,表示修改的记录数量。在上述示例中,返回值是 2 。</li>
</ul>
</li>
</ul>
<h5 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;method 1</span><br><span class="line">&gt;&gt;&gt; p &#x3D; Publisher.objects.get(name&#x3D;&quot;O&#39;Reilly&quot;)</span><br><span class="line">&gt;&gt;&gt; p.delete()</span><br><span class="line">&gt;&gt;&gt; Publisher.objects.all()</span><br><span class="line">[&lt;Publisher: Apress Publishing&gt;]</span><br><span class="line">&#x2F;&#x2F;way 2</span><br><span class="line">&gt;&gt;&gt; Publisher.objects.filter(country&#x3D;&#39;USA&#39;).delete()</span><br><span class="line">&gt;&gt;&gt; Publisher.objects.all().delete()</span><br></pre></td></tr></table></figure>

<h1 id="第五章：Django-管理后台"><a href="#第五章：Django-管理后台" class="headerlink" title="第五章：Django 管理后台"></a>第五章：Django 管理后台</h1><h3 id="1-使用-Django-管理后台"><a href="#1-使用-Django-管理后台" class="headerlink" title="1. 使用 Django 管理后台"></a>1. 使用 Django 管理后台</h3><ul>
<li>运行 django-admin startproject mysite 时,Django 为我们创建并配置了默认的管理后台。我们只需创建一个管理员用户(超级用户),就可以登录管理后台。<h5 id="创建管理员用户"><a href="#创建管理员用户" class="headerlink" title="创建管理员用户"></a>创建管理员用户</h5>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br><span class="line">Username: admin</span><br><span class="line">Email address: admin@example.com</span><br><span class="line">Password: **********</span><br><span class="line">Password (again): *********</span><br><span class="line">Superuser created successfully.</span><br></pre></td></tr></table></figure>
<h5 id="登录后台"><a href="#登录后台" class="headerlink" title="登录后台"></a>登录后台</h5></li>
<li>/admin</li>
<li>input the username and password</li>
</ul>
<h3 id="2-把模型添加到-Django-管理后台中"><a href="#2-把模型添加到-Django-管理后台中" class="headerlink" title="2. 把模型添加到 Django 管理后台中"></a>2. 把模型添加到 Django 管理后台中</h3><ul>
<li>在应用文件夹下有个admin.py文件，如果没有自己创建  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from .models import Publisher, Author, Book</span><br><span class="line"></span><br><span class="line">admin.site.register(Publisher)</span><br><span class="line">admin.site.register(Author)</span><br><span class="line">admin.site.register(Book)</span><br></pre></td></tr></table></figure>
<h3 id="3-把字段设为可选的"><a href="#3-把字段设为可选的" class="headerlink" title="3. 把字段设为可选的"></a>3. 把字段设为可选的</h3></li>
<li>即数据库中表的某些字段可以为空，要修改模型，加上blank=True  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Author(models.Model):</span><br><span class="line">    first_name &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    last_name &#x3D; models.CharField(max_length&#x3D;40)</span><br><span class="line">    email &#x3D; models.EmailField(blank&#x3D;True)</span><br></pre></td></tr></table></figure>
<h5 id="把日期和数值字段设为可选的"><a href="#把日期和数值字段设为可选的" class="headerlink" title="把日期和数值字段设为可选的"></a>把日期和数值字段设为可选的</h5></li>
<li>若是字符串,可以不设置blank=true，如果不输入，默认为””,注意NULL和空字符串不一样</li>
<li>如果想让日期字段(如 DateField 、TimeField 、DateTimeField )或数值字段(如IntegerField 、DecimalField 、FloatField )接受空值,要同时添加 null=True 和 blank=True 。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;100)</span><br><span class="line">    authors &#x3D; models.ManyToManyField(Author)</span><br><span class="line">    publisher &#x3D; models.ForeignKey(Publisher)</span><br><span class="line">    publication_date &#x3D; models.DateField(blank&#x3D;True, null&#x3D;True)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-自定义字段的标注"><a href="#4-自定义字段的标注" class="headerlink" title="4. 自定义字段的标注"></a>4. 自定义字段的标注</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Author(models.Model):</span><br><span class="line">    first_name &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    last_name &#x3D; models.CharField(max_length&#x3D;40)</span><br><span class="line">    email &#x3D; models.EmailField(blank&#x3D;True, verbose_name&#x3D;&#39;e-mail&#39;)</span><br><span class="line">    &#x2F;&#x2F;使用e-mail作为名字</span><br></pre></td></tr></table></figure>

<h3 id="5-自定义-ModelAdmin-类"><a href="#5-自定义-ModelAdmin-类" class="headerlink" title="5. 自定义 ModelAdmin 类"></a>5. 自定义 ModelAdmin 类</h3><h5 id="自定义修改列表"><a href="#自定义修改列表" class="headerlink" title="自定义修改列表"></a>自定义修改列表</h5><ul>
<li>默认情况下,修改列表显示的是各个对象的 __str__() 方法返回的结果。</li>
<li>我们可以改进这种默认行为,在修改列表中添加几个其他字段。比如说,可以在列表中显示作者的电子邮件地址;另外,如果能按照名字和姓排序就好了。</li>
<li>为此,要为 Author 模型定义一个 ModelAdmin 子类。这个类是定制管理后台的关键,其中最基本的一件事是指定修改列表页面显示的字段。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;修改 admin.py 文件</span><br><span class="line">from django.contrib import admin</span><br><span class="line">from mysite.books.models import Publisher, Author, Book</span><br><span class="line"></span><br><span class="line">class AuthorAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display &#x3D; (&#39;first_name&#39;, &#39;last_name&#39;, &#39;email&#39;)</span><br><span class="line">    search_fields &#x3D; (&#39;first_name&#39;, &#39;last_name&#39;)</span><br><span class="line"></span><br><span class="line">class BookAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display &#x3D; (&#39;title&#39;, &#39;publisher&#39;, &#39;publication_date&#39;)</span><br><span class="line">    list_filter &#x3D; (&#39;publication_date&#39;,)</span><br><span class="line">    date_hierarchy &#x3D; &#39;publication_date&#39;</span><br><span class="line">    ordering &#x3D; (&#39;-publication_date&#39;,)</span><br><span class="line"></span><br><span class="line">admin.site.register(Publisher)</span><br><span class="line">admin.site.register(Author, AuthorAdmin)</span><br><span class="line">admin.site.register(Book)</span><br></pre></td></tr></table></figure>
<ul>
<li>list_display是显示哪些内容</li>
<li>search_fields 是可以按照这些字段搜索</li>
<li>list_filter 是添加过滤，比如：今天，近7天，近1个月。list_filter 也能处理其他类型的字段,而非 DateField 一个。(比如说,可以试试 BooleanField 和 For-eignKey 字段。)只要有超过两个值供选择,过滤器就会显示。</li>
<li>提供日期过滤器的另一种方法是使用date_hierarchy 选项，添加这个选项之后,修改列表上边会显示一个日期层级导航栏</li>
<li>ordering，让修改列表页面的图书始终以出版日期倒序排列</li>
</ul>
</li>
</ul>
<h5 id="自定义编辑表单"><a href="#自定义编辑表单" class="headerlink" title="自定义编辑表单"></a>自定义编辑表单</h5><ul>
<li>我们可以在 ModelAdmin 子类中使用 fields 选项修改排序:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display &#x3D; (&#39;title&#39;, &#39;publisher&#39;, &#39;publication_date&#39;)</span><br><span class="line">    list_filter &#x3D; (&#39;publication_date&#39;,)</span><br><span class="line">    date_hierarchy &#x3D; &#39;publication_date&#39;</span><br><span class="line">    ordering &#x3D; (&#39;-publication_date&#39;,)</span><br><span class="line">    fields &#x3D; (&#39;title&#39;, &#39;authors&#39;, &#39;publisher&#39;, &#39;publication_date&#39;)</span><br><span class="line">    filter_horizontal &#x3D; (&#39;authors&#39;,)</span><br><span class="line">    raw_id_fields &#x3D; (&#39;publisher&#39;,)</span><br></pre></td></tr></table></figure>
<ul>
<li>filter_horizontal,用于多对多的字段</li>
<li>raw_id_fields 用于一对多的字段</li>
</ul>
</li>
<li>fields 选项还有一个作用:排除特定的字段,禁止编辑。只需去掉想排除的字段即可。</li>
</ul>
<h3 id="6-用户、分组和权限"><a href="#6-用户、分组和权限" class="headerlink" title="6. 用户、分组和权限"></a>6. 用户、分组和权限</h3><ul>
<li>有一些字段用于定义允许用户在管理界面中做什么<ul>
<li>“Active”控制是否激活用户。如果未勾选,即便用户使用有效的密码也无法登录。</li>
<li>“Staff status”控制是否允许用户登录管理界面(即是否把用户当做组织中的一员)。因为这个用户系统也用于控制面向公众的网站(即前台,参见第 11 章),所以这个旗标对公开用户和管理员是有区别的。</li>
<li>“Superuser status”为用户赋予所有权限,可以在管理界面中添加、编辑和删除任何对象。如果勾选,用户的常规权限(即使没有)不再考虑。</li>
</ul>
</li>
<li>“普通的”管理员,即已激活且不是超级用户,所具有的管理权限是一项项赋予的。</li>
</ul>
<h3 id="7-何时以及为何使用管理界面"><a href="#7-何时以及为何使用管理界面" class="headerlink" title="7. 何时以及为何使用管理界面"></a>7. 何时以及为何使用管理界面</h3><ul>
<li>一个在线功能(例如市政供水水质特别报道)的开发过程通常是这样的:<ul>
<li>负责该项目的记者与一位开发者碰头,指出所需的数据。</li>
<li>开发者设计满足需求的 Django 模型,然后打开管理后台给记者看。</li>
<li>记者审查管理后台,及时指出缺少或多余的字段。开发者不断修改模型。</li>
<li>得到满意的模型之后,记者开始在管理后台中输入数据。与此同时,程序员可以集中精力开发面向公众的视图/模板(即开发过程中有趣的部分)。</li>
</ul>
</li>
<li>除了输入数据之外,管理后台还有很多用处:<ul>
<li>审查数据模型:定义几个模型之后,可以在管理界面中查看,输入一些虚拟数据。有时,在这个过程中能够发现数据建模等问题。</li>
<li>管理从别处得到的数据:对依靠外部源(例如用户或 Web 爬虫)提供数据的应用程序来说,通过管理后台便于审查或编辑数据。你可以把管理后台看做数据库命令行工具的另一个版本,虽然不那么强大,但是足够便利。</li>
<li>临时的数据管理应用:你可以使用管理后台构建一个特别轻量级的数据管理应用,例如记录花销。如果只构建给自己用的功能,而不面向公众,管理后台能节省很多时间。在这个意义上,管理后台相当于增强版关系型电子表格。</li>
</ul>
</li>
</ul>
<h1 id="第六章：Django-表单"><a href="#第六章：Django-表单" class="headerlink" title="第六章：Django 表单"></a>第六章：Django 表单</h1><h3 id="1-从请求对象中获取数据"><a href="#1-从请求对象中获取数据" class="headerlink" title="1. 从请求对象中获取数据"></a>1. 从请求对象中获取数据</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line"></span><br><span class="line">def hello(request):</span><br><span class="line">    return HttpResponse(&quot;Hello world&quot;)</span><br></pre></td></tr></table></figure></code></pre>
<h5 id="关于-URL-的信息-HttpRequest-对象的方法和属性"><a href="#关于-URL-的信息-HttpRequest-对象的方法和属性" class="headerlink" title="关于 URL 的信息: HttpRequest 对象的方法和属性"></a>关于 URL 的信息: HttpRequest 对象的方法和属性</h5><table>
<thead>
<tr>
<th>属性/方法</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>request.path</td>
<td>完整的路径,不含域名,但是包含前导斜线</td>
<td>“/hello/”</td>
</tr>
<tr>
<td>request.get_host()</td>
<td>主机名(即通常所说的“域名”)</td>
<td>“127.0.0.1:8000”或“<a href="http://www.exam-ple.com”/">www.exam-ple.com”</a></td>
</tr>
<tr>
<td>request.get_full_path()</td>
<td>包含查询字符串(如果有的话)的路径</td>
<td>“/hello/?print=true”</td>
</tr>
<tr>
<td>request.is_secure()</td>
<td>通过 HTTPS 访问时为 True ,否则为 False</td>
<td>True 或 False</td>
</tr>
</tbody></table>
<h5 id="关于请求的其他信息"><a href="#关于请求的其他信息" class="headerlink" title="关于请求的其他信息"></a>关于请求的其他信息</h5><ul>
<li>request.META 的值是一个 Python 字典,包含请求的所有 HTTP 首部,例如用户的 IP 地址和用户代理(useragent,通常是 Web 浏览器的名称和版本)。</li>
<li>注意,具体包含哪些首部取决于用户发送了什么首部,以及Web 服务器返回了什么首部。这个字典中常见的几个键有:<ul>
<li>HTTP_REFERER :入站前的 URL(可能没有)。(注意,要使用错误的拼写,即 REFERER 。)</li>
<li>HTTP_USER_AGENT :浏览器的用户代理(可能没有)。例如: “Mozilla/5.0 (X11; U; Linux i686; fr-FR; rv:1.8.1.17) Gecko/20080829 Firefox/2.0.0.17” 。</li>
<li>REMOTE_ADDR :客户端的 IP 地址,例如 “12.345.67.89” 。(如果请求经由代理,这个首部的值可能是一组 IP 地址,以逗号分隔,例如 “12.345.67.89,23.456.78.90” 。)</li>
</ul>
</li>
<li>因为 request.META 是个普通的 Python 字典,所以尝试访问不存在的键时,抛出 KeyError 异常。(HTTP 首部是外部数据,即由用户的浏览器提交,因此不能完全相信,当某个首部为空或不存在时,应该让应用程序优雅失败。)为了处理未定义的键,应该使用 try / except 子句,或者 get() 方法</li>
<li>可以编写一个简单的视图,显示 request.META 中的所有信息,以便查阅。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def display_meta(request):</span><br><span class="line">    values &#x3D; request.META.items()</span><br><span class="line">    values.sort()</span><br><span class="line">    html &#x3D; []</span><br><span class="line">    for k, v in values:</span><br><span class="line">    html.append(&#39;&lt;tr&gt;&lt;td&gt;%s&lt;&#x2F;td&gt;&lt;td&gt;%s&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&#39; % (k, v))</span><br><span class="line">    return HttpResponse(&#39;&lt;table&gt;%s&lt;&#x2F;table&gt;&#39; % &#39;\n&#39;.join(html))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="关于提交数据的信息"><a href="#关于提交数据的信息" class="headerlink" title="关于提交数据的信息"></a>关于提交数据的信息</h5><ul>
<li>除了关于请求的基本元数据之外, HttpRequest 对象还有两个属性包含用户提交的信息: request.GET 和 request.POST 。</li>
<li>这两个属性的值都是类似字典的对象,分别用于获取 GET 和 POST 数据。 POST 数据一般由 HTML表单提交,而 GET 数据既可以来自表单,也可以来自页面 URL 中的查询字符串。</li>
</ul>
<h3 id="2-一个简单的表单处理"><a href="#2-一个简单的表单处理" class="headerlink" title="2. 一个简单的表单处理"></a>2. 一个简单的表单处理</h3><ul>
<li>创建一个简单的视图,让用户通过书名搜索数据库中的图书。</li>
<li>表单分为两部分:用户界面 HTML 和处理提交数据的后端视图代码。<ul>
<li>视图  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line"></span><br><span class="line">def search_form(request):</span><br><span class="line">    return render(request, &#39;search_form.html&#39;)</span><br><span class="line"></span><br><span class="line">def search(request):</span><br><span class="line">    if &#39;q&#39; in request.GET:</span><br><span class="line">    message &#x3D; &#39;You searched for: %r&#39; % request.GET[&#39;q&#39;]</span><br><span class="line">    else:</span><br><span class="line">    message &#x3D; &#39;You submitted an empty form.&#39;</span><br><span class="line">    return HttpResponse(message)</span><br></pre></td></tr></table></figure></li>
<li>search_form.html  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Search&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;&#x2F;search&#x2F;&quot; method&#x3D;&quot;get&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;q&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Search&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h5><ul>
<li>GET 数据通过查询字符串传递(例如 /search/?q=django ),因此可以使用 request.GET 获取查询字符串参数。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line">from django.shortcuts import render</span><br><span class="line">from books.models import Book</span><br><span class="line"></span><br><span class="line">def search(request):</span><br><span class="line">    if &#39;q&#39; in request.GET and request.GET[&#39;q&#39;]:</span><br><span class="line">        q &#x3D; request.GET[&#39;q&#39;]</span><br><span class="line">        books &#x3D; Book.objects.filter(title__icontains&#x3D;q)</span><br><span class="line">        return render(request, &#39;search_results.html&#39;,&#123;&#39;books&#39;: books, &#39;query&#39;: q&#125;)</span><br><span class="line">    else:</span><br><span class="line">        return HttpResponse(&#39;Please submit a search term.&#39;)</span><br></pre></td></tr></table></figure>
<ul>
<li>不建议在大型生产数据库中使用 icontains 查询,因为速度可能很慢。(在实际运用中,你可能想使用某种自定义的搜索系统。你可以搜索一下开源的全文搜索引擎。)</li>
</ul>
</li>
</ul>
<h3 id="3-改进这个简单的表单处理示例"><a href="#3-改进这个简单的表单处理示例" class="headerlink" title="3. 改进这个简单的表单处理示例"></a>3. 改进这个简单的表单处理示例</h3><ul>
<li><p>search() 视图对空查询的处理不完美,我们只是显示“Please submit a search term.”消息,用户必须点击浏览器的后退按钮。</p>
</li>
<li><p>这样做不友好,而且显得不专业,这样的实现会再次经由 Django 处理。遇到这种情况时,重新显示表单,并且在上部显示错误更好,这样用户可以立即再试一次。为此,最简单的方法是再次渲染模板,如下所示:</p>
<ul>
<li>视图<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line">from django.shortcuts import render</span><br><span class="line">from books.models import Book</span><br><span class="line"></span><br><span class="line">def search(request):</span><br><span class="line">    if &#39;q&#39; in request.GET and request.GET[&#39;q&#39;]:</span><br><span class="line">        q &#x3D; request.GET[&#39;q&#39;]</span><br><span class="line">        books &#x3D; Book.objects.filter(title__icontains&#x3D;q)</span><br><span class="line">        return render(request, &#39;search_results.html&#39;,&#123;&#39;books&#39;: books, &#39;query&#39;: q&#125;)</span><br><span class="line">    else:</span><br><span class="line">        return render(request, &#39;search_form.html&#39;,&#123;&#39;error&#39;: True&#125;)</span><br></pre></td></tr></table></figure></li>
<li>search_form.html<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Search&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;% if error %&#125;</span><br><span class="line">        &lt;p style&#x3D;&quot;color: red;&quot;&gt;Please submit a search term.&lt;&#x2F;p&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    &lt;form action&#x3D;&quot;&#x2F;search&#x2F;&quot; method&#x3D;&quot;get&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;q&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Search&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>不需要search_form视图了</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def search(request):</span><br><span class="line">    error &#x3D; False</span><br><span class="line">    if &#39;q&#39; in request.GET:</span><br><span class="line">        q &#x3D; request.GET[&#39;q&#39;]</span><br><span class="line">        if not q:</span><br><span class="line">            error &#x3D; True</span><br><span class="line">    else:</span><br><span class="line">        books &#x3D; Book.objects.filter(title__icontains&#x3D;q)</span><br><span class="line">        return render(request, &#39;search_results.html&#39;,&#123;&#39;books&#39;: books, &#39;query&#39;: q&#125;)</span><br><span class="line">    return render(request, &#39;search_form.html&#39;,&#123;&#39;error&#39;: error&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>那么 search_form.html 中的 HTML &lt;form&gt; 不再需要硬编码 URL</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;&#x2F;search&#x2F;&quot; method&#x3D;&quot;get&quot;&gt;</span><br><span class="line">把上面改为</span><br><span class="line">&lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;get&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;action&#x3D;&quot;&quot; 的意思是,“把表单提交到与当前页面相同的 URL”。</span><br><span class="line">&#x2F;&#x2F;这样修改之后,如果想把 search() 视图放到别的 URL 上,不用再修改 action 属性。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-简单的验证"><a href="#4-简单的验证" class="headerlink" title="4. 简单的验证"></a>4. 简单的验证</h3><ul>
<li><p>验证输入信息的准确性，如长度不能超过20</p>
<ul>
<li>视图<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def search(request):</span><br><span class="line">    errors &#x3D; []</span><br><span class="line">    if &#39;q&#39; in request.GET:</span><br><span class="line">        q &#x3D; request.GET[&#39;q&#39;]</span><br><span class="line">        if not q:</span><br><span class="line">            errors.append(&#39;Enter a search term.&#39;)</span><br><span class="line">        elif len(q) &gt; 20:</span><br><span class="line">            errors.append(&#39;Please enter at most 20 characters.&#39;)</span><br><span class="line">        else:</span><br><span class="line">            books &#x3D; Book.objects.filter(title__icontains&#x3D;q)</span><br><span class="line">            return render(request, &#39;search_results.html&#39;,&#123;&#39;books&#39;: books, &#39;query&#39;: q&#125;)</span><br><span class="line">    return render(request, &#39;search_form.html&#39;,&#123;&#39;errors&#39;: errors&#125;)</span><br></pre></td></tr></table></figure></li>
<li>search_form.html<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Search&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;% if error %&#125;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#123;% for error in errors %&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123; error &#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    &lt;form action&#x3D;&quot;&#x2F;search&#x2F;&quot; method&#x3D;&quot;get&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;q&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Search&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5-创建一个联系表单"><a href="#5-创建一个联系表单" class="headerlink" title="5. 创建一个联系表单"></a>5. 创建一个联系表单</h3></li>
</ul>
</li>
<li><p>Django 自带了一个表单库, django.forms ,它能处理本章所述的多数问题,从显示 HTML 表单到验证,都能胜任。</p>
</li>
<li><p>这个表单框架的主要用法是为要处理的每个 HTML 表单定义一个 Form 类。</p>
</li>
<li><p>这个类可以放在任意位置,例如直接放在 views.py 文件中,不过社区的约定是,把 Form 类放在单独的 forms.py 文件中。在 views.py 文件所在的目录( mysite )中创建这个文件。</p>
<ul>
<li>forms.py<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django import forms</span><br><span class="line"></span><br><span class="line">class ContactForm(forms.Form):</span><br><span class="line">    subject &#x3D; forms.CharField()</span><br><span class="line">    email &#x3D; forms.EmailField(required&#x3D;False)</span><br><span class="line">    message &#x3D; forms.CharField()</span><br></pre></td></tr></table></figure>
<h3 id="6-在视图中使用表单对象"><a href="#6-在视图中使用表单对象" class="headerlink" title="6. 在视图中使用表单对象"></a>6. 在视图中使用表单对象</h3></li>
</ul>
</li>
<li><p>所有通过 POST 指向内部URL 的表单都应该使用 <code>&#123;% csrf_token %&#125;</code> 模板标签,跨站请求伪造(Cross Site Request Forgery,CSRF)</p>
</li>
<li><p>就是一个利用表单提交数据，在视图里调用send_mail模块发送邮件的例子，代码太长，粘贴过来占行数，需要的时候再看吧</p>
</li>
</ul>
<h3 id="7-表单的一些设置"><a href="#7-表单的一些设置" class="headerlink" title="7. 表单的一些设置"></a>7. 表单的一些设置</h3><ul>
<li><p>message 字段显示为 &lt;input type=”text”&gt; ,而它应该为&lt;textarea&gt; 。这个问题可以通过设定字段的 widget 参数修正，还有一些其他设置如下</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django import forms</span><br><span class="line"></span><br><span class="line">class ContactForm(forms.Form):</span><br><span class="line">    subject &#x3D; forms.CharField(max_length&#x3D;100, label&#x3D;&#39;sss&#39;)   &#x2F;&#x2F;设定最大长度,label是自定义标注</span><br><span class="line">    email &#x3D; forms.EmailField(required&#x3D;False)&#x2F;&#x2F;可以为空</span><br><span class="line">    message &#x3D; forms.CharField(widget&#x3D;forms.Textarea)&#x2F;&#x2F;改变字段的渲染方式</span><br></pre></td></tr></table></figure></li>
<li><p>设定初始值</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">form &#x3D; ContactForm(</span><br><span class="line">    initial&#x3D;&#123;&#39;subject&#39;: &#39;I love your site!&#39;&#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li>
<li><p>自定义验证规则，在 Form 类中添加一个 clean_message() 方法:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django import forms</span><br><span class="line"></span><br><span class="line">class ContactForm(forms.Form):</span><br><span class="line">    subject &#x3D; forms.CharField(max_length&#x3D;100)</span><br><span class="line">    email &#x3D; forms.EmailField(required&#x3D;False)</span><br><span class="line">    message &#x3D; forms.CharField(widget&#x3D;forms.Textarea)</span><br><span class="line"></span><br><span class="line">    def clean_message(self):</span><br><span class="line">        message &#x3D; self.cleaned_data[&#39;message&#39;]</span><br><span class="line">        num_words &#x3D; len(message.split())</span><br><span class="line">        if num_words &lt; 4:</span><br><span class="line">            raise forms.ValidationError(&quot;Not enough words!&quot;)</span><br><span class="line">            return message</span><br></pre></td></tr></table></figure>
<ul>
<li>Django 的表单系统会自动查找名称以 clean_ 开头、以字段名结尾的方法。如果存在这样的方法,在验证过程中调用。</li>
<li>注意,方法的最后一定要显式返回那个字段清理后的值。如果没有 return语句,返回的是 None ,如此一来原来的值就丢失了。</li>
</ul>
</li>
<li><p>自定义表单的外观</p>
<ul>
<li>自定义表单外观最简便的方法是使用 CSS。</li>
<li>根据情况改变css类</li>
</ul>
</li>
</ul>
<h1 id="第7章：高级视图和-URL-配置"><a href="#第7章：高级视图和-URL-配置" class="headerlink" title="第7章：高级视图和 URL 配置"></a>第7章：高级视图和 URL 配置</h1><h3 id="1-URL-配置小技巧"><a href="#1-URL-配置小技巧" class="headerlink" title="1. URL 配置小技巧"></a>1. URL 配置小技巧</h3><h5 id="在调试模式下提供特殊的-URL"><a href="#在调试模式下提供特殊的-URL" class="headerlink" title="在调试模式下提供特殊的 URL"></a>在调试模式下提供特殊的 URL</h5><pre><code>- views.py文件中
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if settings.DEBUG:</span><br><span class="line">    urlpatterns +&#x3D; [url(r&#39;^debuginfo&#x2F;$&#39;, views.debug),]</span><br></pre></td></tr></table></figure></code></pre>
<h5 id="具名分组"><a href="#具名分组" class="headerlink" title="具名分组"></a>具名分组</h5><ul>
<li>以位置参数传给视图函数<ul>
<li>views..py  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url(r&#39;^reviews&#x2F;([0-9]&#123;4&#125;)&#x2F;([0-9]&#123;2&#125;)&#x2F;$&#39;, views.month_archive),</span><br></pre></td></tr></table></figure></li>
<li>对 /reviews/2005/03/ 的请求匹配上述列表中的第三个条目。Django 调用 views.month_archive(request, ‘2005’, ‘03’) 函数。在视图函数中以位置参数获得参数</li>
</ul>
</li>
<li>以关键字参数传给视图函数<ul>
<li>views..py  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url(r&#39;^reviews&#x2F;(?P&lt;year&gt;[0-9]&#123;4&#125;)&#x2F;(?P&lt;month&gt;[0-9]&#123;2&#125;)&#x2F;$&#39;,views.month_archive),</span><br></pre></td></tr></table></figure></li>
<li>在实际运用中,这样做的好处是 URL 配置的意图稍微明显一些,而且不容易出现由于参数顺序不当导致的缺陷,因为视图函数定义中的参数顺序可以调整。当然,这也牺牲了一些简洁性,有些开发者觉得具名分组句法不美观,而且太啰嗦。</li>
</ul>
</li>
<li>匹配/分组算法<ol>
<li>如果有具名分组,使用具名分组,忽略非具名分组。</li>
<li>否则,以位置参数传递所有非具名分组。</li>
</ol>
</li>
</ul>
<p>#####　URL 配置搜索的范围<br>－　对 <a href="http://www.example.com/myapp/?page=3">http://www.example.com/myapp/?page=3</a> 的请求,URL 配置只查找 myapp/ 。URL 配置不关心请求方法。<br>－　也就是说,相同URL 的所有请求方法( POST 、 GET 、 HEAD ,等等)都交由同一个视图函数处理。</p>
<h5 id="捕获的参数始终是字符串"><a href="#捕获的参数始终是字符串" class="headerlink" title="捕获的参数始终是字符串"></a>捕获的参数始终是字符串</h5><ul>
<li>虽然 [0-9]{4} 只匹配字符串中的整数,但是传给views.year_archive() 视图函数的 year 参数是字符串,需要在视图中自己处理</li>
<li>但是2.1貌似有区别</li>
</ul>
<h5 id="为视图的参数指定默认值"><a href="#为视图的参数指定默认值" class="headerlink" title="为视图的参数指定默认值"></a>为视图的参数指定默认值</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 视图(在 reviews&#x2F;views.py 文件中)</span><br><span class="line">def page(request, num&#x3D;&quot;1&quot;):</span><br><span class="line">    # 输出指定数量的书评</span><br></pre></td></tr></table></figure>

<h3 id="2-错误处理"><a href="#2-错误处理" class="headerlink" title="2. 错误处理"></a>2. 错误处理</h3><ul>
<li>找不到匹配所请求 URL 的正则表达式或有异常抛出时,Django 会调用一个错误处理视图。具体使用的视图由四个参数指定。这四个参数是:<ul>
<li>handler404<ul>
<li>没有这个页面</li>
</ul>
</li>
<li>handler500<ul>
<li>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。</li>
<li>服务器内部资源出故障</li>
</ul>
</li>
<li>handler403<ul>
<li>请求资源的访问被服务器拒绝了</li>
<li>可能没有权限</li>
</ul>
</li>
<li>handler400<ul>
<li>该状态码表示请求报文中存在语法错误。</li>
<li>服务器无法理解的请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-引入其他-URL-配置"><a href="#3-引入其他-URL-配置" class="headerlink" title="3. 引入其他 URL 配置"></a>3. 引入其他 URL 配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import include, url</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    # ...</span><br><span class="line">    url(r&#39;^community&#x2F;&#39;, include(&#39;django_website.aggregator.urls&#39;)),</span><br><span class="line">    url(r&#39;^contact&#x2F;&#39;, include(&#39;django_website.contact.urls&#39;)),</span><br><span class="line">    # ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h5 id="去除-URL-配置中的重复-在多处使用相同的模式前缀。"><a href="#去除-URL-配置中的重复-在多处使用相同的模式前缀。" class="headerlink" title="去除 URL 配置中的重复,在多处使用相同的模式前缀。"></a>去除 URL 配置中的重复,在多处使用相同的模式前缀。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^(?P&lt;page_slug&gt;\w+)-(?P&lt;page_id&gt;\w+)&#x2F;history&#x2F;$&#39;,views.history),</span><br><span class="line">    url(r&#39;^(?P&lt;page_slug&gt;\w+)-(?P&lt;page_id&gt;\w+)&#x2F;edit&#x2F;$&#39;,views.edit),</span><br><span class="line">    url(r&#39;^(?P&lt;page_slug&gt;\w+)-(?P&lt;page_id&gt;\w+)&#x2F;discuss&#x2F;$&#39;,views.discuss),</span><br><span class="line">    url(r&#39;^(?P&lt;page_slug&gt;\w+)-(?P&lt;page_id&gt;\w+)&#x2F;permissions&#x2F;$&#39;,views.permissions),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以改进这个 URL 配置,把共用的路径前缀提取出来,再把不同的部分放在其后:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import include, url</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^(?P&lt;page_slug&gt;\w+)-(?P&lt;page_id&gt;\w+)&#x2F;&#39;,</span><br><span class="line">        include([</span><br><span class="line">            url(r&#39;^history&#x2F;$&#39;, views.history),</span><br><span class="line">            url(r&#39;^edit&#x2F;$&#39;, views.edit),</span><br><span class="line">            url(r&#39;^discuss&#x2F;$&#39;, views.discuss),</span><br><span class="line">            url(r&#39;^permissions&#x2F;$&#39;, views.permissions),</span><br><span class="line">        ])</span><br><span class="line">    ),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="捕获的参数"><a href="#捕获的参数" class="headerlink" title="捕获的参数"></a>捕获的参数</h5><ul>
<li>被引入的 URL 配置会接收到父级 URL 配置捕获的参数</li>
</ul>
<h3 id="5-给视图函数传递额外参数"><a href="#5-给视图函数传递额外参数" class="headerlink" title="5. 给视图函数传递额外参数"></a>5. 给视图函数传递额外参数</h3><ul>
<li>URL 配置允许向视图函数传递额外的参数,这些参数放在一个 Python 字典中。</li>
<li>django.conf.urls.url() 函数的第三个参数是可选的,如果指定,应该是一个字典,指定要传给视图函数的额外关键字参数及其值  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^reviews&#x2F;(?P&lt;year&gt;[0-9]&#123;4&#125;)&#x2F;$&#39;,</span><br><span class="line">        views.year_archive,</span><br><span class="line">        &#123;&#39;foo&#39;: &#39;bar&#39;&#125;</span><br><span class="line">    ),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>处理冲突<ul>
<li>有可能 URL 模式捕获了具名关键字参数,又在第三个参数中传递同名的参数。此时,Django使用字典中的参数,而不是从 URL 中捕获的参数。</li>
</ul>
</li>
</ul>
</li>
<li>同样,也可以为 include() 传递额外参数。还是写第三个参数。</li>
</ul>
<h3 id="6-反向解析-URL"><a href="#6-反向解析-URL" class="headerlink" title="6. 反向解析 URL"></a>6. 反向解析 URL</h3><ul>
<li>执行 URL 反转所需的工具:<ul>
<li>在模板中,使用 url 模板标签。</li>
<li>在 Python 代码中,使用 django.core.urlresolvers.reverse() 函数。</li>
</ul>
</li>
<li>例子<ul>
<li>url配置  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    #...</span><br><span class="line">    url(r&#39;^reviews&#x2F;([0-9]&#123;4&#125;)&#x2F;$&#39;, views.year_archive,name&#x3D;&#39;reviews-year-archive&#39;),</span><br><span class="line">    #...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>html  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&#123;% url &#39;reviews-year-archive&#39; 2012 %&#125;&quot;&gt;2012 Archive&lt;&#x2F;a&gt;</span><br><span class="line">&#123;# 或者把年份存储在一个模板上下文变量中:#&#125;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% for yearvar in year_list %&#125;</span><br><span class="line">    &lt;li&gt;&lt;a href&#x3D;&quot;&#123;% url &#39;reviews-year-archive&#39; yearvar %&#125;&quot;&gt;&#123;&#123; yearvar &#125;&#125; Archive&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure></li>
<li>视图  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def redirect_to_year(request):</span><br><span class="line">    # ...</span><br><span class="line">    year &#x3D; 2012</span><br><span class="line">    # ...</span><br><span class="line">    return HttpResponseRedirect(reverse(&#39;reviews-year-archive&#39;, args&#x3D;(year,)))</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="7-URL-命名空间"><a href="#7-URL-命名空间" class="headerlink" title="7. URL 命名空间"></a>7. URL 命名空间</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url(r&#39;^reviews&#x2F;&#39;, include(&#39;reviews.urls&#39;,</span><br><span class="line">    namespace&#x3D;&#39;author-reviews&#39;,</span><br><span class="line">    app_name&#x3D;&#39;reviews&#39;)</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<h1 id="第八章：高级模板技术"><a href="#第八章：高级模板技术" class="headerlink" title="第八章：高级模板技术"></a>第八章：高级模板技术</h1><h3 id="1-RequestContext-和上下文处理器"><a href="#1-RequestContext-和上下文处理器" class="headerlink" title="1. RequestContext 和上下文处理器"></a>1. RequestContext 和上下文处理器</h3><ul>
<li><p>RequestContext 默认为模板上下文添加很多变量,例如 HttpRequest 对象或当前登录用户的信息。</p>
</li>
<li><p>Django 提供了全局上下文处理器。 context_processors 设置(在 settings.py 文件中)指明始终提供给 RequestContext 的上下文处理器。</p>
</li>
<li><p>context_processors 的默认值如下:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;context_processors&#39;: [</span><br><span class="line">    &#39;django.template.context_processors.debug&#39;,</span><br><span class="line">    &#39;django.template.context_processors.request&#39;,</span><br><span class="line">    &#39;django.contrib.auth.context_processors.auth&#39;,</span><br><span class="line">    &#39;django.contrib.messages.context_processors.messages&#39;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure></li>
<li><p>auth，django.contrib.auth.context_processors.auth</p>
<ul>
<li>启用这个处理器后, RequestContext 中将包含下述变量:<ul>
<li>user : auth.User 的实例,表示当前登录的用户(如未登录,是 AnonymousUser 实例)。</li>
<li>perms : django.contrib.auth.context_processors.PermWrapper 实例,表示当前登录用户拥有的权限。</li>
</ul>
</li>
</ul>
</li>
<li><p>debug，django.template.context_processors.debug</p>
<ul>
<li>启用这个处理器后, RequestContext 中将包含下面两个变量,但前提是 DEBUG 设置的值是 True ,而且 INTER-NAL_IPS 设置中包含请求的 IP 地址( request.META[‘REMOTE_ADDR’] ):<ul>
<li>debug : True 。可以在模板中测试是否在 DEBUG 模式中。</li>
<li>sql_queries : {‘sql’: …, ‘time’: …} 字典构成的列表,表示处理请求的过程中执行的 SQL 查询及其用时。列表中的值按查询的执行顺序排列,在访问时惰性生成。</li>
</ul>
</li>
</ul>
</li>
<li><p>i18n，django.template.context_processors.i18n</p>
<ul>
<li>启用这个处理器后, RequestContext 中将包含下面两个变量:<ul>
<li>LANGUAGES : LANGUAGES 设置的值。</li>
<li>LANGUAGE_CODE :如果 request.LANGUAGE_CODE 存在,返回它的值;否则返回 LANGUAGE_CODE 设置的值。</li>
</ul>
</li>
</ul>
</li>
<li><p>media，django.template.context_processors.media</p>
<ul>
<li>启用这个处理器后, RequestContext 中将包含 MEDIA_URL 变量,提供 MEDIA_URL 设置的值。<br>static，django.template.context_processors.static</li>
<li>启用这个处理程序后, RequestContext 中将包含 STATIC_URL 变量,提供 STATIC_URL 设置的值。</li>
</ul>
</li>
<li><p>csrf，django.template.context_processors.csrf</p>
<ul>
<li>这个处理器添加一个令牌,供 csrf_token 模板标签使用,用于防范跨站请求伪造(参见第 19 章)。</li>
</ul>
</li>
<li><p>request，django.template.context_processors.request</p>
<ul>
<li>启用这个处理器后, RequestContext 中将包含 request 变量,它的值是当前的 HttpRequest 对象。</li>
</ul>
</li>
<li><p>messages，django.contrib.messages.context_processors.messages</p>
<ul>
<li>启用这个处理器后, RequestContext 中将包含下面两个变量:<ul>
<li>messages :消息框架设定的消息列表(里面的值是字符串)。</li>
<li>DEFAULT_MESSAGE_LEVELS :消息等级名称到数字值的映射。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-自定义上下文处理器的指导方针"><a href="#2-自定义上下文处理器的指导方针" class="headerlink" title="2. 自定义上下文处理器的指导方针"></a>2. 自定义上下文处理器的指导方针</h3><ul>
<li>上下文处理器的接口十分简单,它就是普通的 Python 函数,有一个参数,是一个 HttpRequest 对象,返回一个字典,用于添加到模板上下文中。</li>
<li>自定义的上下文处理器可以放在代码基的任何位置。Django 只关心 TEMPLATES 设置中的 ‘con-text_processors’ 选项或者 Engine 的 context_processors 参数(直接使用 Engine 时)有没有指向你的上下文处理器。尽管如此,约定的做法是把上下文处理器保存在应用或项目中一个名为 con-text_processors.py 的文件中。</li>
</ul>
<h3 id="3-自动转义-HTML"><a href="#3-自动转义-HTML" class="headerlink" title="3. 自动转义 HTML"></a>3. 自动转义 HTML</h3><h5 id="跨站脚本攻击-Cross-Site-Scripting-XSS"><a href="#跨站脚本攻击-Cross-Site-Scripting-XSS" class="headerlink" title="跨站脚本攻击(Cross Site Scripting,XSS)"></a>跨站脚本攻击(Cross Site Scripting,XSS)</h5><ul>
<li>使用模板生成 HTML 时,变量的值可能包含特殊的字符,对得到的 HTML 产生影响。对下述模板片段来说:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello, &#123;&#123; name &#125;&#125;.</span><br></pre></td></tr></table></figure></li>
<li>乍一看这样显示用户的名字没什么危害。但是,如果用户输入的名字是这样的呢:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(&#39;hello&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li>此时,渲染模板后得到的结果是:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello, &lt;script&gt;alert(&#39;hello&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li>因此,浏览器会弹出一个对话框。同样,如果名字中包含 ‘&lt;’ 符号呢:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;username</span><br></pre></td></tr></table></figure></li>
<li>此时,渲染模板后得到的结果是:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello, &lt;b&gt;username</span><br></pre></td></tr></table></figure></li>
<li>这样,网页中的后续内容都会显示为粗体。</li>
<li>显然,用户提交的数据不该盲目信任,不能直接插入网页,因为恶意用户可以利用这种漏洞做些坏事。这种安全漏洞称为跨站脚本攻击</li>
<li>为了避免这种漏洞,有两个选择:<ol>
<li>每个不信任的变量都传给 escape 过滤器,把有潜在危害的 HTML 字符转换成无危害的。Django 起初的几年默认采用这种方案,它的问题是把责任强加到开发者或模板编写者身上了,你要确保转义一切。但是,忘记转义数据是常事。</li>
<li>利用 Django 的自动转义 HTML 特性。本节余下的内容说明自动转义的工作方式。</li>
</ol>
</li>
<li>Django 默认转义模板中的每个变量标签。具体而言,转义的是下面五个字符:<br>  • &lt; 转换成 &amp;lt;<br>  • &gt; 转换成 &amp;gt;<br>  • ‘ (单引号)转换成 &amp;#39;<br>  • “ (双引号)转换成 &amp;quot;<br>  • &amp; 转换成 &amp;amp;</li>
</ul>
<h5 id="如何禁用"><a href="#如何禁用" class="headerlink" title="如何禁用"></a>如何禁用</h5><ul>
<li><p>自动转义可以在整站禁用、在模板层禁用或在变量层禁用。为什么要禁用呢?因为有时候想把模板变量包含的数据渲染成原始 HTML,无需转义。</p>
</li>
<li><p>在单个变量中禁用</p>
<ul>
<li>使用 safe 过滤器:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This will be escaped: &#123;&#123; data &#125;&#125;</span><br><span class="line">This will not be escaped: &#123;&#123; data|safe &#125;&#125;</span><br><span class="line">&#x2F;&#x2F;结果</span><br><span class="line">This will be escaped: &lt;b&gt;</span><br><span class="line">This will not be escaped: &lt;b&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在模板中的块里禁用</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% autoescape off %&#125;</span><br><span class="line">Hello &#123;&#123; name &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br></pre></td></tr></table></figure>
<h5 id="自动转义过滤器参数中的字符串字面量"><a href="#自动转义过滤器参数中的字符串字面量" class="headerlink" title="自动转义过滤器参数中的字符串字面量"></a>自动转义过滤器参数中的字符串字面量</h5></li>
<li><p>字符串字面量插入模板时不会自动转义,就像是经过 safe 过滤器处理过了一样。</p>
</li>
<li><p>应该编写:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; data|default:&quot;3 &lt; 2&quot; &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>而不是:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; data|default:&quot;3 &lt; 2&quot; &#125;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-模板加载内部机制"><a href="#4-模板加载内部机制" class="headerlink" title="4. 模板加载内部机制"></a>4. 模板加载内部机制</h3><h5 id="1-DIRS-选项"><a href="#1-DIRS-选项" class="headerlink" title="1. DIRS 选项"></a>1. DIRS 选项</h5><ul>
<li><p>settings.py里的TEMPLATES的DIRS填写template文件的搜索目录</p>
<h5 id="2-加载器的类型"><a href="#2-加载器的类型" class="headerlink" title="2. 加载器的类型"></a>2. 加载器的类型</h5></li>
<li><p>文件系统加载器</p>
<ul>
<li>filesystem.Loader</li>
<li>根据 DIRS 的值,从文件系统中加载模板。这是默认启用的加载器。然而,如果不设定 DIRS 选项,这个加载器找不到任何模板。</li>
</ul>
</li>
<li><p>应用目录加载器</p>
<ul>
<li>app_directories.Loader</li>
<li>从文件系统中的 Django 应用里加载模板。这个加载器在 INSTALLED_APPS 列出的各个应用中查找 templates 子目录。如果找到,Django 在其中查找模板。这意味着,应用可以自带模板。通过这一行为,便于分发带默认模板的 Django 应用。例如,对下面的设置来说:<br>INSTALLED_APPS = [‘myproject.reviews’, ‘myproject.music’]<br>get_template(‘foo.html’) 会按顺序在下述目录中查找 foo.html :<br>• /path/to/myproject/reviews/templates/<br>• /path/to/myproject/music/templates/</li>
<li>只需把 APP_DIRS 选项设为 True 即可启用这个加载器:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TEMPLATES &#x3D; [&#123;</span><br><span class="line">    &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,</span><br><span class="line">    &#39;APP_DIRS&#39;: True,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>其他加载器</p>
<ul>
<li>以在 TEMPLATES 设置中为 DjangoTemplates 后端添加 ‘loaders’ 选项,或者把loaders 参数传给 Engine 启用。这些高级加载器的详细说明,以及构建自定义加载器的方法参见 Django 项目的网站。</li>
</ul>
</li>
</ul>
<h3 id="5-扩展模板系统"><a href="#5-扩展模板系统" class="headerlink" title="5. 扩展模板系统"></a>5. 扩展模板系统</h3><h5 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h5><ul>
<li>自定义的模板标签和过滤器必须放在一个 Django 应用中。如果与现有应用有关,可以放在现有应用中;否则,应该专门创建一个应用存放。</li>
<li>应用中应该有个 templatetags 目录,与 models.py 、 views.py 等文件放在同一级。如果没有这个目录,创建一个,别忘了 <strong>init</strong>.py 文件,这样才能保证所在目录是一个 Python包。</li>
<li>自定义的标签和过滤器在 templatetags 目录里的一个模块中。</li>
<li>假如自定义的标签(过滤器)放在 review_extras.py 文件中,应用的布局可能是下面这样:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reviews&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    models.py</span><br><span class="line">    templatetags&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">        review_extras.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure></li>
<li>在模板中则这样使用:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% load review_extras %&#125;</span><br></pre></td></tr></table></figure></li>
<li>包含自定义标签的应用必须在 INSTALLED_APPS 中列出,这样 <code>&#123;% load %&#125;</code> 标签才能起作用。</li>
</ul>
<h5 id="创建模板库"><a href="#创建模板库" class="headerlink" title="创建模板库"></a>创建模板库</h5><ul>
<li><p>首先,如果应用是使用 manage.py startapp 创建的,可以把模板库放在那里;如若不然,可以专门创建一个应用,用于存放模板库。</p>
</li>
<li><p>其次,在 Django 应用中合适的包里创建 templatetags 目录。这个目录应该与 models.py 、 views.py 等文件放在同一级。</p>
<ul>
<li>在 templatetags 目录中创建两个空文件: <strong>init</strong>.py (告诉 Python 这是包含 Python 代码的包)和存放自定义标签(过滤器)的文件。后者的名称是加载标签所用的名称。如上面的例子</li>
</ul>
</li>
<li><p>一个有效的标签库必须有一个名为 register 的模块层变量,其值是 template.Library 的实例。标签和过滤器都通过这种方式注册。因此,在模块顶部要插入下述代码:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django import template</span><br><span class="line">register &#x3D; template.Library()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-自定义模板标签和过滤器"><a href="#6-自定义模板标签和过滤器" class="headerlink" title="6. 自定义模板标签和过滤器"></a>6. 自定义模板标签和过滤器</h3><h5 id="自定义模板过滤器"><a href="#自定义模板过滤器" class="headerlink" title="自定义模板过滤器"></a>自定义模板过滤器</h5><ul>
<li><p>自定义的过滤器其实就是普通的 Python 函数,接受一个或多个参数:</p>
<ol>
<li>变量的值(输入),不一定是字符串。</li>
<li>参数的值,可以有默认值,也可以留空。</li>
</ol>
</li>
<li><p>例如,对 <code>&#123;&#123; var|foo:"bar" &#125;&#125;</code> 来说,传给 foo 过滤器的变量是 var ,参数是 “bar” 。</p>
</li>
<li><p>一个示例过滤器的定义:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def cut(value, arg):</span><br><span class="line">    &quot;&quot;&quot;Removes all values of arg from the given string&quot;&quot;&quot;</span><br><span class="line">    return value.replace(arg, &#39;&#39;)</span><br></pre></td></tr></table></figure>
<ul>
<li>用法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; somevariable|cut:&quot;0&quot; &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li>多数过滤器没有参数。此时,在函数中留空参数即可。</li>
</ul>
</li>
<li><p>注册自定义的过滤器</p>
<ul>
<li>定义好过滤器之后,要使用 Library 实例注册,让 Django 的模板语言知道它的存在:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">register.filter(&#39;cut&#39;, cut)</span><br><span class="line">register.filter(&#39;lower&#39;, lower)</span><br></pre></td></tr></table></figure></li>
<li>Library.filter() 有两个参数:<ol>
<li>过滤器的名称,一个字符串。</li>
<li>负责处理过滤器的函数,一个 Python 函数(不是函数名称的字符串形式)。</li>
</ol>
</li>
<li>register.filter() 也可以作为装饰器使用:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@register.filter(name&#x3D;&#39;cut&#39;)</span><br><span class="line">def cut(value, arg):</span><br><span class="line">    return value.replace(arg, &#39;&#39;)</span><br><span class="line"></span><br><span class="line">@register.filter    &#x2F;&#x2F;不带name参数，默认函数名为name</span><br><span class="line">def cut(value, arg):</span><br><span class="line">    return value.replace(arg, &#39;&#39;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>期待字符串的模板过滤器</p>
<ul>
<li>如果模板过滤器期望第一个参数是字符串,应该使用 stringfilter 装饰器。这样,对象在传给过滤器之前会先转换成字符串值。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django import template</span><br><span class="line">from django.template.defaultfilters import stringfilter</span><br><span class="line"></span><br><span class="line">register &#x3D; template.Library()</span><br><span class="line"></span><br><span class="line">@register.filter</span><br><span class="line">@stringfilter</span><br><span class="line">def lower(value):</span><br><span class="line">    return value.lower()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>过滤器和自动转义</p>
<ul>
<li>自定义过滤器时,应该想想 Django 的自动转义行为对过滤器有什么影响。</li>
<li>模板代码中存在三种字符串:<ul>
<li>原始字符串是原生的 Python str 或 unicode 类型。输出时,如果启用了自动转义就转义,否则原封不动呈现出来。</li>
<li>安全字符串是标记为安全的字符串,输出时不会转义,因为已经做了必要的转义。</li>
<li>标记为“需要转义”的字符串是在输出时始终应该转义的字符串,不管在不在 autoescape 块中都是如此。然而,即使启用了自动转义,这种字符串也只转义一次。</li>
</ul>
</li>
<li>模板过滤器分属两种情况:<ol>
<li>不在尚未呈现的结果中引入对 HTML 不安全的字符( &lt; 、 &gt; 、 ‘ 、 “ 或 &amp; )。在注册过滤器函数时把 is_safe 旗标设为True <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@register.filter(is_safe&#x3D;True)</span><br><span class="line">def myfilter(value):</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure></li>
<li>过滤器代码自行负责做必要的转义。在结果中引入新的 HTML 标记时必须这么做。</li>
</ol>
</li>
</ul>
</li>
<li><p>过滤器和时区</p>
<ul>
<li>自定义处理 datetime 对象的过滤器时,注册时通常要把 expects_localtime 旗标设为 True :  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@register.filter(expects_localtime&#x3D;True)</span><br><span class="line">def businesshours(value):</span><br><span class="line">    try:</span><br><span class="line">        return 9 &lt;&#x3D; value.hour &lt; 17</span><br><span class="line">    except AttributeError:</span><br><span class="line">        return &#39;&#39;</span><br></pre></td></tr></table></figure></li>
<li>这样设定之后,如果过滤器的第一个参数是涉及时区的日期时间,根据模板中的时区转换规则,必要时Django 会先把它转换成当前时区,然后再传给过滤器。</li>
</ul>
</li>
</ul>
<h5 id="自定义模板标签"><a href="#自定义模板标签" class="headerlink" title="自定义模板标签"></a>自定义模板标签</h5><ul>
<li>就是 <code>&#123;% if xxx %&#125;</code> 自定义个类似if的标签，可以在模板中使用</li>
<li>具体用法再说吧，和自定义过滤器异曲同工</li>
</ul>
<p>#第九章：Django 模型的高级用法</p>
<h3 id="1-相关的对象"><a href="#1-相关的对象" class="headerlink" title="1. 相关的对象"></a>1. 相关的对象</h3><h5 id="访问外键值"><a href="#访问外键值" class="headerlink" title="访问外键值"></a>访问外键值</h5><ul>
<li>访问 ForeignKey 类型的字段时,得到的是相关的模型对象。例如:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b &#x3D; Book.objects.get(id&#x3D;50)</span><br><span class="line">&gt;&gt;&gt; b.publisher</span><br><span class="line">&lt;Publisher: Apress Publishing&gt;</span><br><span class="line">&gt;&gt;&gt; b.publisher.website</span><br><span class="line">&#39;http:&#x2F;&#x2F;www.apress.com&#x2F;&#39;</span><br></pre></td></tr></table></figure></li>
<li>ForeignKey 字段也能反向使用,不过因为关系是不对称的,行为稍有不同。若想获取指定出版社出版的所有图书,要使用 publisher.book_set.all() ,如下所示:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; p &#x3D; Publisher.objects.get(name&#x3D;&#39;Apress Publishing&#39;)</span><br><span class="line">&gt;&gt;&gt; p.book_set.all()</span><br><span class="line">[&lt;Book: The Django Book&gt;, &lt;Book: Dive Into Python&gt;, ...]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="访问多对多值"><a href="#访问多对多值" class="headerlink" title="访问多对多值"></a>访问多对多值</h5><ul>
<li>多对多值与外键值的获取方式类似,不过处理的是 QuerySet 值,而非模型实例。例如,查看一本的的作者要这么做:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b &#x3D; Book.objects.get(id&#x3D;50)</span><br><span class="line">&gt;&gt;&gt; b.authors.all()</span><br><span class="line">[&lt;Author: Adrian Holovaty&gt;, &lt;Author: Jacob Kaplan-Moss&gt;]</span><br><span class="line">&gt;&gt;&gt; b.authors.filter(first_name&#x3D;&#39;Adrian&#39;)</span><br><span class="line">[&lt;Author: Adrian Holovaty&gt;]</span><br><span class="line">&gt;&gt;&gt; b.authors.filter(first_name&#x3D;&#39;Adam&#39;)</span><br><span class="line">[]</span><br></pre></td></tr></table></figure></li>
<li>反过来也可以。如果想查看一位作者撰写的所有图书,使用 author.book_set ,如下所示:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; Author.objects.get(first_name&#x3D;&#39;Adrian&#39;,</span><br><span class="line">last_name&#x3D;&#39;Holovaty&#39;)</span><br><span class="line">&gt;&gt;&gt; a.book_set.all()</span><br><span class="line">[&lt;Book: The Django Book&gt;, &lt;Book: Adrian&#39;s Other Book&gt;]</span><br></pre></td></tr></table></figure></li>
<li>与 ForeignKey 字段一样,这里的 book_set 也是生成的:把模型名的小写形式与 _set 连在一起。</li>
</ul>
<h3 id="2-管理器"><a href="#2-管理器" class="headerlink" title="2. 管理器"></a>2. 管理器</h3><ul>
<li>自定义管理器可能出于两方面的原因:<ol>
<li>添加额外的管理器方法</li>
<li>修改管理器返回的 QuerySet 。</li>
</ol>
</li>
</ul>
<h5 id="添加额外的管理器方法"><a href="#添加额外的管理器方法" class="headerlink" title="添加额外的管理器方法"></a>添加额外的管理器方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># models.py</span><br><span class="line">from django.db import models</span><br><span class="line"># ... Author 和 Publisher 模型省略了 ...</span><br><span class="line"></span><br><span class="line">class BookManager(models.Manager):</span><br><span class="line">    def title_count(self, keyword):</span><br><span class="line">        return self.filter(title__icontains&#x3D;keyword).count()</span><br><span class="line"></span><br><span class="line">class Book(models.Model):</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;100)</span><br><span class="line">    authors &#x3D; models.ManyToManyField(Author)</span><br><span class="line">    publisher &#x3D; models.ForeignKey(Publisher)</span><br><span class="line">    publication_date &#x3D; models.DateField()</span><br><span class="line">    num_pages &#x3D; models.IntegerField(blank&#x3D;True, null&#x3D;True)</span><br><span class="line">    objects &#x3D; BookManager()</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br></pre></td></tr></table></figure>
<ul>
<li>创建好管理器之后,可以像下面这样使用  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Book.objects.title_count(&#39;django&#39;)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; Book.objects.title_count(&#39;python&#39;)</span><br><span class="line">18</span><br></pre></td></tr></table></figure></li>
<li>为什么想要添加 title_count() 这样的方法呢?为的是封装经常执行的查询,以免代码重复。</li>
</ul>
<h5 id="修改管理器返回的查询集合"><a href="#修改管理器返回的查询集合" class="headerlink" title="修改管理器返回的查询集合"></a>修改管理器返回的查询集合</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MaleManager(models.Manager):</span><br><span class="line">    def get_queryset(self):</span><br><span class="line">        return super(MaleManager, self).get_queryset().filter(sex&#x3D;&#39;M&#39;)</span><br><span class="line">class FemaleManager(models.Manager):</span><br><span class="line">    def get_queryset(self):</span><br><span class="line">        return super(FemaleManager, self).get_queryset().filter(sex&#x3D;&#39;F&#39;)</span><br><span class="line">class Person(models.Model):</span><br><span class="line">    first_name &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    last_name &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    sex &#x3D; models.CharField(max_length&#x3D;1,</span><br><span class="line">                        choices&#x3D;(</span><br><span class="line">                                    (&#39;M&#39;, &#39;Male&#39;),</span><br><span class="line">                                    (&#39;F&#39;, &#39;Female&#39;)</span><br><span class="line">                                )</span><br><span class="line">                            )</span><br><span class="line">    people &#x3D; models.Manager()</span><br><span class="line">    men &#x3D; MaleManager()</span><br><span class="line">    women &#x3D; FemaleManager()</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义 Manager 对象时要注意,Django 遇到的第一个管理器(按照在模型中定义的顺序)有特殊的状态。Django 把它解释的第一个管理器定义为“默认的”管理器,而且 Django 在很多地方(管理后台不在此列)只使用那个管理器。</li>
</ul>
<h3 id="3-模型方法"><a href="#3-模型方法" class="headerlink" title="3. 模型方法"></a>3. 模型方法</h3><ul>
<li><p>管理器的作用是执行数据表层的操作,而模型方法处理的是具体的模型实例。这个技术的价值很大,能把业务逻辑统一放在一个地方,即模型中。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">class Person(models.Model):</span><br><span class="line">    first_name &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    last_name &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    birth_date &#x3D; models.DateField()</span><br><span class="line"></span><br><span class="line">    def baby_boomer_status(self):</span><br><span class="line">        # 返回一个人的出生日期与婴儿潮的关系</span><br><span class="line">        import datetime</span><br><span class="line">        if self.birth_date &lt; datetime.date(1945, 8, 1):</span><br><span class="line">            return &quot;Pre-boomer&quot;</span><br><span class="line">        elif self.birth_date &lt; datetime.date(1965, 1, 1):</span><br><span class="line">            return &quot;Baby boomer&quot;</span><br><span class="line">        else:</span><br><span class="line">            return &quot;Post-boomer&quot;</span><br><span class="line"></span><br><span class="line">    def _get_full_name(self):</span><br><span class="line">        # 返回一个人的全名</span><br><span class="line">        return &#39;%s %s&#39; % (self.first_name, self.last_name)</span><br><span class="line">    full_name &#x3D; property(_get_full_name)</span><br></pre></td></tr></table></figure></li>
<li><p>覆盖预定义的模型方法</p>
<ul>
<li>如<strong>str</strong>(),get_absolute_url(),save()</li>
</ul>
</li>
</ul>
<h3 id="4-执行原始-SQL"><a href="#4-执行原始-SQL" class="headerlink" title="4. 执行原始 SQL"></a>4. 执行原始 SQL</h3><ul>
<li>Django 为执行原始 SQL 查询提供了两种方式:<ul>
<li>使用 Manag-er.raw() 执行,返回模型实例集合;</li>
<li>或者完全不用模型层,直接执行自定义的 SQL。</li>
</ul>
</li>
</ul>
<h3 id="5-执行原始查询"><a href="#5-执行原始查询" class="headerlink" title="5. 执行原始查询"></a>5. 执行原始查询</h3><ul>
<li>管理器的 raw() 方法用于执行原始的 SQL 查询,其返回结果是模型实例集合:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Manager.raw(raw_query, params&#x3D;None, translations&#x3D;None)</span><br></pre></td></tr></table></figure></li>
<li>SQL查询  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for p in Person.objects.raw(&#39;SELECT * FROM myapp_person&#39;):</span><br><span class="line">...</span><br><span class="line">print(p)</span><br><span class="line">John Smith</span><br><span class="line">Jane Jones</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-直接执行自定义的-SQL"><a href="#6-直接执行自定义的-SQL" class="headerlink" title="6. 直接执行自定义的 SQL"></a>6. 直接执行自定义的 SQL</h3><ul>
<li>django.db.connection 对象表示默认的数据库连接。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import connection</span><br><span class="line"></span><br><span class="line">def my_custom_sql(self):</span><br><span class="line">    cursor &#x3D; connection.cursor()</span><br><span class="line">    cursor.execute(&quot;UPDATE bar SET foo &#x3D; 1 WHERE baz &#x3D; %s&quot;, [self.baz])</span><br><span class="line">    cursor.execute(&quot;SELECT foo FROM bar WHERE baz &#x3D; %s&quot;, [self.baz])</span><br><span class="line">    row &#x3D; cursor.fetchone()</span><br><span class="line">    return row</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第十章：通用视图"><a href="#第十章：通用视图" class="headerlink" title="第十章：通用视图"></a>第十章：通用视图</h1><ul>
<li>有点没太理解这个是干嘛的，好像是自己写视图函数的话得自己提取数据库中的数据，用这个通用视图能直接返回整个模型</li>
</ul>
<h3 id="1-视图的使用"><a href="#1-视图的使用" class="headerlink" title="1. 视图的使用"></a>1. 视图的使用</h3><ul>
<li>views..py  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.views.generic import ListView</span><br><span class="line">from books.models import Publisher</span><br><span class="line"></span><br><span class="line">class PublisherList(ListView):</span><br><span class="line">    model &#x3D; Publisher   &#x2F;&#x2F;指定视图操作的数据库模型</span><br></pre></td></tr></table></figure></li>
<li>urls..py  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from books.views import PublisherList</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^publishers&#x2F;$&#39;, PublisherList.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>模板  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">&lt;h2&gt;Publishers&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% for publisher in object_list %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; publisher.name &#125;&#125;&lt;&#x2F;li&gt;    </span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>渲染这个模板时,上下文中有个名为 object_list 的变量,它的值是所有出版社对象</li>
<li>可以为视图添加一个 template_name 属性,明确指明使用哪个模板;如果没明确指定,Django 将从对象的名称中推知。这里,推知的模板是 books/publisher_list.html  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;或者添加一个 template_name 属性</span><br><span class="line">template_name &#x3D; &#39;books&#x2F;publisher_list.html&#39;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>model 属性。指定视图操作的数据库模型</li>
</ul>
<h3 id="2-提供“友好的”模板上下文"><a href="#2-提供“友好的”模板上下文" class="headerlink" title="2. 提供“友好的”模板上下文"></a>2. 提供“友好的”模板上下文</h3><ul>
<li>就是把 object_list 换个名字</li>
<li>例子  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.views.generic import ListView</span><br><span class="line">from books.models import Publisher</span><br><span class="line"></span><br><span class="line">class PublisherList(ListView):</span><br><span class="line">    model &#x3D; Publisher   </span><br><span class="line">    context_object_name &#x3D; &#39;my_favorite_publishers&#39;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-提供额外的上下文变量"><a href="#3-提供额外的上下文变量" class="headerlink" title="3. 提供额外的上下文变量"></a>3. 提供额外的上下文变量</h3><ul>
<li>DetailView 通用视图在上下文中提供了出版社信息,但是如何在模板中获取额外的信息呢?答案是扩展 DetailView ,自己实现 get_context_data 方法。</li>
<li>例子  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.views.generic import DetailView</span><br><span class="line">from books.models import Publisher, Book</span><br><span class="line"></span><br><span class="line">class PublisherDetail(DetailView):</span><br><span class="line">    model &#x3D; Publisher</span><br><span class="line"></span><br><span class="line">    def get_context_data(self, **kwargs):</span><br><span class="line">        # 先调用原来的实现,获取上下文</span><br><span class="line">        context &#x3D; super(PublisherDetail, self).get_context_data(**kwargs)</span><br><span class="line">        # 把所有图书构成的查询集合添加到上下文中</span><br><span class="line">        context[&#39;book_list&#39;] &#x3D; Book.objects.all()</span><br><span class="line">        return context</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-显示对象子集"><a href="#4-显示对象子集" class="headerlink" title="4. 显示对象子集"></a>4. 显示对象子集</h3><ul>
<li>model 属性指定视图操作的数据库模型</li>
<li>这不是指定视图操作哪些对象的唯一方式,此外还可以使用 queryset 属性指定一组对象:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.views.generic import ListView</span><br><span class="line">from books.models import Book</span><br><span class="line"></span><br><span class="line">class AcmeBookList(ListView):</span><br><span class="line">    context_object_name &#x3D; &#39;book_list&#39;</span><br><span class="line">    queryset &#x3D; Book.objects.filter(publisher__name&#x3D;&#39;Acme Publishing&#39;)</span><br><span class="line">    template_name &#x3D; &#39;books&#x2F;acme_list.html&#39;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-动态过滤"><a href="#5-动态过滤" class="headerlink" title="5. 动态过滤"></a>5. 动态过滤</h3><ul>
<li>根据 URL 中指定的键过滤列表页面中的对象</li>
<li>编写一个视图显示随意一家出版社旗下的所有图书呢?这也很方便,我们可以覆盖 ListView 的 get_queryset() 方法。它的默认实现是返回 queryset 属性的值,不过我们可以添加更多逻辑。</li>
<li>调用基于类的视图时,很多有用的东西存储到 self 中了</li>
<li>URL 配置  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url(r&#39;^books&#x2F;([\w-]+)&#x2F;$&#39;, PublisherBookList.as_view()),</span><br></pre></td></tr></table></figure></li>
<li>views..py  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import get_object_or_404</span><br><span class="line">from django.views.generic import ListView</span><br><span class="line">from books.models import Book, Publisher</span><br><span class="line"></span><br><span class="line">class PublisherBookList(ListView):</span><br><span class="line">    template_name &#x3D; &#39;books&#x2F;books_by_publisher.html&#39;</span><br><span class="line">    def get_queryset(self):</span><br><span class="line">        self.publisher &#x3D; get_object_or_404(Publisher, name&#x3D;self.args[0])</span><br><span class="line">        return Book.objects.filter(publisher&#x3D;self.publisher)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第十一章-在-Django-中验证用户的身份"><a href="#第十一章-在-Django-中验证用户的身份" class="headerlink" title="第十一章;在 Django 中验证用户的身份"></a>第十一章;在 Django 中验证用户的身份</h1><ul>
<li>Django 自带了一套系统,能管理用户的账户、分组和权限,并且实现了基于 cookie 的用户会话。</li>
</ul>
<h3 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h3><ul>
<li><p>Django 的身份验证系统包括:</p>
<ul>
<li>用户</li>
<li>权限:二元(是或否)旗标,指明用户是否能执行特定的任务</li>
<li>分组:把标注和权限赋予多个用户的通用方式</li>
<li>可配置的密码哈希系统</li>
<li>管理身份验证和权限核准的表单</li>
<li>登录用户或限制内容的视图工具</li>
<li>可更换的后端系统</li>
</ul>
</li>
<li><p>Django 的身份验证系统十分通用,没有提供 Web 身份验证系统中某些常用的功能。某些常用功能通过第三方包实现:</p>
<ul>
<li>密码强度检查</li>
<li>登录尝试次数限制</li>
<li>通过第三方验证身份(如 OAuth)</li>
</ul>
</li>
</ul>
<h3 id="2-User-对象"><a href="#2-User-对象" class="headerlink" title="2. User 对象"></a>2. User 对象</h3><ul>
<li>在 Django 的身份验证框架中,只有一个用户类存在,因此 superusers或管理后台的 staff 用户只是设定了特殊属性的用户对象,而不是分属不同类的用户对象。</li>
<li>默认用户主要有下面几个属性:<ul>
<li>username</li>
<li>password</li>
<li>email</li>
<li>first_name</li>
<li>last_name</li>
</ul>
</li>
</ul>
<h5 id="创建超级用户"><a href="#创建超级用户" class="headerlink" title="创建超级用户"></a>创建超级用户</h5><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser --username&#x3D;joe --email&#x3D;joe@example.com</span><br></pre></td></tr></table></figure></code></pre>
<h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><ul>
<li>创建和管理用户最简单、最不易出错的方式是使用 Django 管理后台。</li>
<li>Django 还内置了登录、退出和修改密码的视图和表单。</li>
<li>创建用户最直接的方式是使用 create_user() 辅助函数:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from django.contrib.auth.models import User</span><br><span class="line">&gt;&gt;&gt; user &#x3D; User.objects.create_user(&#39;john&#39;, &#39;lennon@thebeatles.com&#39;,</span><br><span class="line">&#39;johnpassword&#39;)</span><br><span class="line"># 此时,user 是一个 User 对象,而且已经保存到数据库中</span><br><span class="line"># 如果想修改其他字段的值,可以继续修改属性</span><br><span class="line">&gt;&gt;&gt; user.last_name &#x3D; &#39;Lennon&#39;</span><br><span class="line">&gt;&gt;&gt; user.save()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h5><ul>
<li>Django 不在用户模型中存储原始(明文)密码,只存储密码的哈希值。因此,不要试图直接处理用户的密码。正是因为这样,创建密码才要使用一个辅助函数。</li>
<li>如果想修改用户的密码,有两个选择:<ul>
<li>在命令行中使用 manage.py changepassword username 命令修改用户的密码。</li>
<li>通过编程方式,使用 set_password() 方法修改:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from django.contrib.auth.models import User</span><br><span class="line">&gt;&gt;&gt; u &#x3D; User.objects.get(username&#x3D;&#39;john&#39;)</span><br><span class="line">&gt;&gt;&gt; u.set_password(&#39;new password&#39;)</span><br><span class="line">&gt;&gt;&gt; u.save()</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="3-权限和权限核准"><a href="#3-权限和权限核准" class="headerlink" title="3. 权限和权限核准"></a>3. 权限和权限核准</h3><ul>
<li>Django 自带了一个简单的权限系统。通过它可以为指定的用户和用户组赋予权限。Django 管理后台就用到了这个系统，就是对数据的增删改查的限制</li>
</ul>
<h3 id="4-在-Web-请求中验证身份"><a href="#4-在-Web-请求中验证身份" class="headerlink" title="4. 在 Web 请求中验证身份"></a>4. 在 Web 请求中验证身份</h3><ul>
<li>Django 使用会话和中间件把身份验证系统插入 request 对象,为每个请求提供 request.user 属性,表示当前用户。如果未登陆,这个属性的值是一个 AnonymousUser 实例,否则是是一个 User 实例。这两种情况可以使用 is_authenticated() 方法区分,例如:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if request.user.is_authenticated():</span><br><span class="line">    # 处理通过身份验证的用户</span><br><span class="line">else:</span><br><span class="line">    # 处理匿名用户</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="如何登录用户"><a href="#如何登录用户" class="headerlink" title="如何登录用户"></a>如何登录用户</h5><ul>
<li>在视图中使用 login() 登录用户。</li>
<li>它的参数是一个 HttpRequest 对象和一个 User 对象。 login() 使用 Django的会话框架把用户的 ID 保存到会话中。注意,匿名期间设定的会话数据在用户登录后依然存在。</li>
<li>下述示例展示 authenticate() 和 login() 的用法:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib.auth import authenticate, login</span><br><span class="line">def my_view(request):</span><br><span class="line">    username &#x3D; request.POST[&#39;username&#39;]</span><br><span class="line">    password &#x3D; request.POST[&#39;password&#39;]</span><br><span class="line">    user &#x3D; authenticate(username&#x3D;username, password&#x3D;password)</span><br><span class="line">    if user is not None:</span><br><span class="line">        if user.is_active:</span><br><span class="line">            login(request, user)</span><br><span class="line">            # 重定向到成功登录页面</span><br><span class="line">        else:</span><br><span class="line">            # 返回“账户未激活”错误消息</span><br><span class="line">    else:</span><br><span class="line">        # 返回“无效登录”错误消息</span><br></pre></td></tr></table></figure>
<ul>
<li>先调用 authenticate()<ul>
<li>自己动手登录用户时,必须在 login() 之前调用 authenticate() 。 authenticate() 在 User 对象上设定一个属性,指明成功验证用户身份的是哪个身份验证后端,而登录过程中需要使用这个信息。如果直接登录从数据库中检索的用户对象,Django 报错。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="如何退出用户"><a href="#如何退出用户" class="headerlink" title="如何退出用户"></a>如何退出用户</h5><ul>
<li>在视图中退出通过 login() 登录的用户使用 logout() 。</li>
<li>这个函数的参数是一个 HttpRequest 对象,而且没有返回值。例如:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib.auth import logout</span><br><span class="line">def logout_view(request):</span><br><span class="line">    logout(request)</span><br><span class="line">    # 重定向到成功退出页面</span><br></pre></td></tr></table></figure></li>
<li>如果用户未登录, logout() 函数不报错。调用 logout() 函数后,当前请求的会话数据完全清除,所有数据将被删除。这样能避免其他人在登录的 Web 浏览器中访问用户之前的会话数据。</li>
</ul>
<h5 id="限制已登录用户的访问"><a href="#限制已登录用户的访问" class="headerlink" title="限制已登录用户的访问"></a>限制已登录用户的访问</h5><ul>
<li><p>直接方式</p>
<ul>
<li>限制访问页面简单直接的方式是检查 request.user.is_authenticated() ,如果未通过,可以重定向到登录页面:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import redirect</span><br><span class="line"></span><br><span class="line">def my_view(request):</span><br><span class="line">    if not request.user.is_authenticated():</span><br><span class="line">        return redirect(&#39;&#x2F;login&#x2F;?next&#x3D;%s&#39; % request.path)</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure></li>
<li>login_required装饰器</li>
</ul>
</li>
<li><p>根据测试条件限制访问</p>
<ul>
<li>下述示例检查用户的电子邮件是否由指定域名提供:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def my_view(request):</span><br><span class="line">    if not request.user.email.endswith(&#39;@example.com&#39;):</span><br><span class="line">        return HttpResponse(&quot;You can&#39;t leave a review for this book.&quot;)</span><br><span class="line">    &#x2F;&#x2F; others</span><br></pre></td></tr></table></figure></li>
<li>user_passes_test装饰器  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def email_check(user):</span><br><span class="line">    return user.email.endswith(&#39;@example.com&#39;)</span><br><span class="line"></span><br><span class="line">@user_passes_test(email_check)</span><br><span class="line">def my_view(request):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li>
<li>permission_required 装饰器<ul>
<li>检查用户有没有特定权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@permission_required(&#39;reviews.can_vote&#39;)</span><br><span class="line">def my_view(request):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>修改密码后作废会话</p>
<ul>
<li>如果启用了 SessionAuthenticationMiddleware ,Django 会验证随各个请求发送的哈希值是否与服务器端计算的匹配。这样,修改密码后,用户的所有会话都会失效,从而退出。</li>
</ul>
</li>
</ul>
<h3 id="5-身份验证视图"><a href="#5-身份验证视图" class="headerlink" title="5. 身份验证视图"></a>5. 身份验证视图</h3><ul>
<li>Django 为登录、退出和密码管理提供了视图。这些视图使用 auth 包中内置的表单,不过也可以传入自己编写的视图。</li>
<li>简单也是最常见的做法  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">urlpatterns &#x3D; [url(&#39;^&#39;, include(&#39;django.contrib.auth.urls&#39;))]</span><br></pre></td></tr></table></figure></li>
<li>这样,各个视图在默认的 URL 上</li>
</ul>
<h5 id="默认的URL"><a href="#默认的URL" class="headerlink" title="默认的URL"></a>默认的URL</h5><table>
<thead>
<tr>
<th>视图</th>
<th>默认url</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>login 视图</td>
<td>/login/</td>
<td>登录用户。</td>
</tr>
<tr>
<td>logout 视图</td>
<td>/logout/</td>
<td>退出用户</td>
</tr>
<tr>
<td>logout_then_login 视图</td>
<td>未提供</td>
<td>退出用户,然后重定向到登录页面。</td>
</tr>
</tbody></table>
<ul>
<li>还有一些默认URL没写，每个URL都有可选参数和上下文，需要的时候再查</li>
</ul>
<h3 id="6-模板中的身份验证数据"><a href="#6-模板中的身份验证数据" class="headerlink" title="6. 模板中的身份验证数据"></a>6. 模板中的身份验证数据</h3><ul>
<li>使用 RequestContext 时,当前登录用户及其权限可通过模板上下文访问。</li>
<li>渲染模板的 RequestContext 时,当前登录用户,不管是 User 实例还是 AnonymousUser 实例,都存储在模板变量  中</li>
<li>当前登录用户的权限存储在模板变量  中</li>
</ul>
<h3 id="7-在管理后台中管理用户"><a href="#7-在管理后台中管理用户" class="headerlink" title="7. 在管理后台中管理用户"></a>7. 在管理后台中管理用户</h3><ul>
<li>图形化操作</li>
</ul>
<h3 id="8-密码管理"><a href="#8-密码管理" class="headerlink" title="8. 密码管理"></a>8. 密码管理</h3><ul>
<li>如非必要,不要重新实现密码管理功能,Django 提供的功能足够安全和灵活。</li>
<li>其他的一些改变密码加密算法之类的操作，需要的时候再看</li>
</ul>
<h3 id="9-自定义身份验证"><a href="#9-自定义身份验证" class="headerlink" title="9. 自定义身份验证"></a>9. 自定义身份验证</h3><ul>
<li>可以自己编写后端验证代码，覆盖Django自带的</li>
</ul>
<h3 id="10-扩展现有的-User-模型"><a href="#10-扩展现有的-User-模型" class="headerlink" title="10. 扩展现有的 User 模型"></a>10. 扩展现有的 User 模型</h3><ul>
<li><p>如果想存储关于用户的额外信息,可以与另一个模型建立一对一关系,把信息存储在那个模型的字段中。这种通过一对一关系连接的模型通常称为个人资料模型(profile model),因为它可能存储着与身份验证无关的信息。</p>
</li>
<li><p>比如说,可以创建下述 Employee 模型:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib.auth.models import User</span><br><span class="line"></span><br><span class="line">class Employee(models.Model):</span><br><span class="line">    user &#x3D; models.OneToOneField(User)</span><br><span class="line">    department &#x3D; models.CharField(max_length&#x3D;100)</span><br></pre></td></tr></table></figure></li>
<li><p>假如员工 Fred Smith 既属于 User 模型,也属于 Employee 模型,可以使用 Django 标准的相关模型约定访问额外的信息:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; u &#x3D; User.objects.get(username&#x3D;&#39;fsmith&#39;)</span><br><span class="line">&gt;&gt;&gt; freds_department &#x3D; u.employee.department</span><br></pre></td></tr></table></figure></li>
<li><p>若想把个人资料模型中的字段添加到管理后台中的用户页面中,在应用的 admin.py 文件中定义一个 InlineModelAdmin 类(这里使用的是 StackedInline ),然后把它添加到 UserAdmin 类中,再注册到 User 类上:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.contrib.auth.admin import UserAdmin</span><br><span class="line">from django.contrib.auth.models import User</span><br><span class="line">from my_user_profile_app.models import Employee</span><br><span class="line"></span><br><span class="line"># 它的行为有点像单例</span><br><span class="line">class EmployeeInline(admin.StackedInline):</span><br><span class="line">    model &#x3D; Employee</span><br><span class="line">    can_delete &#x3D; False</span><br><span class="line">    verbose_name_plural &#x3D; &#39;employee&#39;</span><br><span class="line"></span><br><span class="line"># 定义一个 UserAdmin 的子类</span><br><span class="line">class UserAdmin(UserAdmin):</span><br><span class="line">    inlines &#x3D; (EmployeeInline, )</span><br><span class="line"></span><br><span class="line"># 重新注册 UserAdmin</span><br><span class="line">admin.site.unregister(User)</span><br><span class="line">admin.site.register(User, UserAdmin)</span><br></pre></td></tr></table></figure></li>
<li><p>个人资料模型没什么特殊的,就是普通的 Django 模型,只是碰巧与 User 模型有一对一关系。因此,创建用户时不会自动创建对应的个人资料,不过可以通过 django.db.models.signals.post_save 信号创建或更新相关的模型。</p>
</li>
<li><p>通过相关的模型检索数据时有额外的查询或联结,某些情况下替换 User 模型或添加额外的字段可能更好。然而,项目中的应用对默认 User 模型的现有链接可能会调整额外的数据库负载。</p>
</li>
</ul>
<h3 id="11-替换成自定义的-User-模型"><a href="#11-替换成自定义的-User-模型" class="headerlink" title="11. 替换成自定义的 User 模型"></a>11. 替换成自定义的 User 模型</h3><ul>
<li><p>Django 允许覆盖默认的 User 模型,方法是把 AUTH_USER_MODEL 设置的值设为自定义的模型:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AUTH_USER_MODEL &#x3D; &#39;books.MyUser&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>提醒</p>
<ul>
<li>修改 AUTH_USER_MODEL 设置对 Django 项目有重大的影响,尤其是数据库结构。如果在运行迁移之后修改 AUTH_USER_MODEL ,必须自己动手更新数据库,因为很多数据库表的关系受到了影响。除非有特别好的理由,否则不要修改 AUTH_USER_MODEL 。</li>
</ul>
</li>
<li><p>如何自定义用户模型的全面说明,参见 <a href=" https://docs.djangoproject.com/en/1.8/topics/auth/customizing/#a-full-example">Django Project 网站。</a></p>
</li>
</ul>
<h1 id="第十二章：测试-Django-应用程序"><a href="#第十二章：测试-Django-应用程序" class="headerlink" title="第十二章：测试 Django 应用程序"></a>第十二章：测试 Django 应用程序</h1><h3 id="1-测试简介"><a href="#1-测试简介" class="headerlink" title="1. 测试简介"></a>1. 测试简介</h3><ul>
<li>Django 也内置了单元测试功能。单元测试是一种软件测试过程,测试的是软件应用程序的独立单元,确保能做预期中的事情。</li>
<li>单元测试分为不同的层级,可以测试单个方法,看它能不能返回正确的值以及能否处理正确的数据,也可以测试整个方法组件,确保一系列用户输入能得到所需的结果。</li>
<li>在单元测试背后,有四个基本的概念:<ol>
<li>测试固件(test fixture),执行测试所需的设置。包含数据库、示例数据集合服务器搭建。测试固件可能还包括测试完毕后执行的清理操作。</li>
<li>测试用例(test case),测试的基本单元。测试用例检查指定的输入是否能得到预期的结果。</li>
<li>测试组件(test suite),一系列测试用例或其他测试组件,作为一个整体执行。</li>
<li>测试运行程序(test runner),负责执行测试并把结果反馈给用户的软件程序。</li>
</ol>
</li>
</ul>
<h3 id="2-基本的测试策略"><a href="#2-基本的测试策略" class="headerlink" title="2. 基本的测试策略"></a>2. 基本的测试策略</h3><ul>
<li>测试驱动开发(Test-Driven Development,TDD)的准则<ul>
<li>先写测试后写代码</li>
</ul>
</li>
</ul>
<h3 id="这测试。。。跳过吧"><a href="#这测试。。。跳过吧" class="headerlink" title="这测试。。。跳过吧"></a>这测试。。。跳过吧</h3><h1 id="第十三章：部署-Django-应用程序"><a href="#第十三章：部署-Django-应用程序" class="headerlink" title="第十三章：部署 Django 应用程序"></a>第十三章：部署 Django 应用程序</h1><h3 id="1-为上线做好准备"><a href="#1-为上线做好准备" class="headerlink" title="1. 为上线做好准备"></a>1. 为上线做好准备</h3><ul>
<li>部署点检表，部署 Django 项目之前,应该花点时间审查设置,考虑安全、性能和运维。</li>
<li>点检表涉及以下几方面的设置:<ul>
<li>必须正确设置,以便提供预期的安全级别</li>
<li>在各个环境中本该不同</li>
<li>启用可选的安全措施</li>
<li>启用性能优化</li>
<li>提供错误报告</li>
</ul>
</li>
</ul>
<h3 id="2-关键设置"><a href="#2-关键设置" class="headerlink" title="2. 关键设置"></a>2. 关键设置</h3><h5 id="SECRET-KEY"><a href="#SECRET-KEY" class="headerlink" title="SECRET_KEY"></a>SECRET_KEY</h5><ul>
<li>密钥必须是一长串随机值,而且必须保密。</li>
<li>别在设置模块中硬编码密钥,应该考虑从环境变量中加载:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">SECRET_KEY &#x3D; os.environ[&#39;SECRET_KEY&#39;]</span><br></pre></td></tr></table></figure></li>
<li>或者从文件中加载:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;&#x2F;etc&#x2F;secret_key.txt&#39;) as f:</span><br><span class="line">    SECRET_KEY &#x3D; f.read().strip()</span><br></pre></td></tr></table></figure>
<h5 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h5></li>
<li>一定不能在生产环境启用调试模式。</li>
<li>开发环境下 settings.py 文件把 DEBUG 设为 True 。生产环境下应该把 DEBUG 设为 False 。</li>
<li>假如把 DEBUG 设为 True 了,那么:<ul>
<li>所有数据库查询以 django.db.connection.queries 对象的形式存储在内存中。可以想象,这样很耗内存!</li>
<li>404 错误使用 Django 特殊的 404 页面渲染(参见第 3 章),而不是返回 404 响应。那个页面可能包含敏感信息,因此不应该公开在互联网中显示。</li>
<li>Django 应用程序中任何未捕获的异常(从基本的 Python 句法错误、数据库错误,到模板句法错误)都使用 Django 精美的错误页面渲染。这个页面包含的敏感信息比404 页面还多,决不能公开显示。</li>
</ul>
</li>
</ul>
<h3 id="3-各环境专用的设置"><a href="#3-各环境专用的设置" class="headerlink" title="3. 各环境专用的设置"></a>3. 各环境专用的设置</h3><h5 id="ALLOWED-HOSTS"><a href="#ALLOWED-HOSTS" class="headerlink" title="ALLOWED_HOSTS"></a>ALLOWED_HOSTS</h5><ul>
<li>设定 DEBUG = False 之后,如果不为 ALLOWED_HOSTS 设定合适的值,Django 根本无法运转。</li>
<li>这个设置的作用是防范某些 CSRF 攻击,因此必须设定。如果使用泛域名,必须自行验证 HTTP Host 首部,或者确保没有这方面的漏洞。</li>
</ul>
<h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><ul>
<li>如果使用缓存,开发环境和生产环境使用的连接参数可能不同。</li>
<li>缓存服务器往往不严格验证身份,因此要确保只接受来自应用服务器的连接。</li>
<li>如果使用 Memcached,请考虑缓存会话,以提升性能。</li>
</ul>
<h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><ul>
<li>数据库连接参数在开发环境和生产环境中可能不同。数据库密码是敏感信息,应该像 SECRET_KEY 那样保护起来。为了最大限度的增强安全,确保数据库服务器只接受来自应用服务器的连接。</li>
<li>做好数据库备份</li>
</ul>
<p>#####　EMAIL_BACKEND 和相关的设置</p>
<ul>
<li>如果你的网站要发送电子邮件,下述设置要正确设置。</li>
<li>默认情况下,Django 发送的邮件使用的发件人是 webmaster@localhost 和 root@localhost,但是有些邮件提供商拒收这两个地址发送的邮件。如果想使用其他发件地址,修改 DEFAULT_FROM_EMAIL 和 SERVER_EMAIL 设置</li>
</ul>
<h5 id="STATIC-ROOT-和-STATIC-URL"><a href="#STATIC-ROOT-和-STATIC-URL" class="headerlink" title="STATIC_ROOT 和 STATIC_URL"></a>STATIC_ROOT 和 STATIC_URL</h5><ul>
<li>开发服务器自动伺服静态文件。但是在生产环境中必须定义 STATIC_ROOT 目录, collectstatic 命令会自动复制那个目录中的静态文件。</li>
</ul>
<h5 id="MEDIA-ROOT-和-MEDIA-URL"><a href="#MEDIA-ROOT-和-MEDIA-URL" class="headerlink" title="MEDIA_ROOT 和 MEDIA_URL"></a>MEDIA_ROOT 和 MEDIA_URL</h5><ul>
<li>媒体文件由用户上传,是不能信任的</li>
<li>Web 服务器一定不能去解释用户上传的媒体文件</li>
<li>例如,Web 服务器不应该执行用户上传的 .php 文件。现在是检查媒体文件备份策略的好时机。</li>
</ul>
<h3 id="4-HTTPS"><a href="#4-HTTPS" class="headerlink" title="4. HTTPS"></a>4. HTTPS</h3><ul>
<li>允许用户登录的网站都应该强制全站使用 HTTPS,以防明文传输访问令牌。</li>
<li>设置好 HTTPS 后,启用下述设置。<ul>
<li>CSRF_COOKIE_SECURE，设为 True ,以防不小心通过 HTTP 传输 CSRF cookie。</li>
<li>SESSION_COOKIE_SECURE，设为 True ,以防不小心通过 HTTP 传输会话 cookie。</li>
</ul>
</li>
</ul>
<h3 id="5-性能优化"><a href="#5-性能优化" class="headerlink" title="5. 性能优化"></a>5. 性能优化</h3><ul>
<li>设定 DEBUG = False 后,禁用了几个只在开发中有用的功能。此外,可以调整下述几个设置。</li>
</ul>
<h5 id="CONN-MAX-AGE"><a href="#CONN-MAX-AGE" class="headerlink" title="CONN_MAX_AGE"></a>CONN_MAX_AGE</h5><ul>
<li>如果处理请求时连接数据库所用的时间占据相当一部分,可以启用持久数据库连接,有效减少这一部分的耗时。</li>
<li>在网络性能受限的虚拟主机中这么做效果明显。</li>
</ul>
<h5 id="TEMPLATES"><a href="#TEMPLATES" class="headerlink" title="TEMPLATES"></a>TEMPLATES</h5><ul>
<li>缓存模板加载器通常能极大地提升性能,因为无需每次渲染都编译模板。详情参见<a href="https://docs.djangoproject.com/en/1.8/howto/deployment/checklist/#performance-optimizations">模板加载器的文档</a>。</li>
</ul>
<h3 id="6-错误报告"><a href="#6-错误报告" class="headerlink" title="6. 错误报告"></a>6. 错误报告</h3><h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><ul>
<li>网站上线之前要检查日志配置,而且要确保在有一定流量之后能按预期工作。</li>
</ul>
<h5 id="ADMINS-和-MANAGERS"><a href="#ADMINS-和-MANAGERS" class="headerlink" title="ADMINS 和 MANAGERS"></a>ADMINS 和 MANAGERS</h5><ul>
<li>出现 500 错误时,会通过邮件通知 ADMINS 。出现 404 错误时,会通过邮件通知 MANAGERS 。 IGNORABLE_404_URLS 可以防止误报。</li>
<li>通过电子邮件报告错误不太便利。在收件箱没被报告淹没之前考虑使用错误监控系统吧,例如 Sentry。Sentry还能聚合日志。</li>
</ul>
<h5 id="自定义默认的错误视图"><a href="#自定义默认的错误视图" class="headerlink" title="自定义默认的错误视图"></a>自定义默认的错误视图</h5><ul>
<li>Django 为几个 HTTP 错误码提供了默认的视图和模板。你可以在根模板目录中创建这几个模板覆盖默认的模板: 404.html 、 500.html 、 403.html 和 400.html 。99% 的 Web 应用使用默认视图即可,但是如果你想自定义,请看<a href="https://docs.djangoproject.com/en/1.8/topics/http/views/#customizing-error-views">这里的说明</a>。那份文档还详细说明了下述默认模板:<br>  • http_not_found_view<br>  • http_internal_server_error_view<br>  • http_forbidden_view<br>  • http_bad_request_view</li>
</ul>
<h3 id="7-使用虚拟环境"><a href="#7-使用虚拟环境" class="headerlink" title="7. 使用虚拟环境"></a>7. 使用虚拟环境</h3><ul>
<li>如果你把项目的 Python 依赖安装到一个虚拟环境中,还要把虚拟环境中的 site-packages 目录添加到 Python路径中。</li>
<li>就是用来virtualenv</li>
</ul>
<h3 id="8-在生产环境中使用不同的设置"><a href="#8-在生产环境中使用不同的设置" class="headerlink" title="8. 在生产环境中使用不同的设置"></a>8. 在生产环境中使用不同的设置</h3><ul>
<li>目前只使用一个设置文件,即 django-admin startproject 命令生成的 settings.py 。</li>
<li>可能需要使用多个设置文件,把开发环境和生产环境区分开。<ul>
<li>使用两个完全独立的设置文件。</li>
</ul>
</li>
</ul>
<h3 id="9-把-Django-应用程序部署到生产服务器"><a href="#9-把-Django-应用程序部署到生产服务器" class="headerlink" title="9. 把 Django 应用程序部署到生产服务器"></a>9. 把 Django 应用程序部署到生产服务器</h3><ul>
<li>如果你真想部署一个线上网站,明智的做法只有一个:找一个明确支持 Django 的主机。</li>
<li>这样的主机不仅自带媒体服务器(通常是 Nginx),还会为你做好一些设置,比如配置好 Apache,以及定期重启 Python 进程的定时任务(cron job,避免网站停机)。有些优秀主机可能还会提供某种形式的“一键”部署功能。</li>
</ul>
<h3 id="10-使用-Apache-和-mod-wsgi-部署-Django-应用程序"><a href="#10-使用-Apache-和-mod-wsgi-部署-Django-应用程序" class="headerlink" title="10. 使用 Apache 和 mod_wsgi 部署 Django 应用程序"></a>10. 使用 Apache 和 mod_wsgi 部署 Django 应用程序</h3><ul>
<li>后面全是部署相关的，不好说，不好说，部署的时候再实践吧，晕乎乎，晕乎乎。</li>
</ul>
<h1 id="第十四章：生成非-HTML-内容"><a href="#第十四章：生成非-HTML-内容" class="headerlink" title="第十四章：生成非 HTML 内容"></a>第十四章：生成非 HTML 内容</h1><ul>
<li>如题，视图返回的不是HTML，而是其他的，如CSV，图片，地图等，有些需要第三方库，具体情况具体分析吧。</li>
</ul>
<h1 id="第十五章：Django-会话"><a href="#第十五章：Django-会话" class="headerlink" title="第十五章：Django 会话"></a>第十五章：Django 会话</h1><ul>
<li>会话是位于浏览器和 Web 服务器之间的半永久性双向通信。大多数情况下,访问现代的网站时,Web 服务器会使用匿名会话记录与访问有关的数据。这种会话之所以是匿名的,原因在于 Web 服务器只能记录你做了什么,却无法得知你是谁。</li>
<li>Django 完全支持匿名会话。通过会话框架可以针对网站的每个访客存储和检索任意的数据。Django 把会话数据存储在服务器端,而且对发送和接收 cookie 的过程做了抽象。cookie 中存储的是会话 ID,而不是数据本身(除非使用基于 cookie 的后端)——这样实现更安全。</li>
</ul>
<h3 id="1-启用会话"><a href="#1-启用会话" class="headerlink" title="1. 启用会话"></a>1. 启用会话</h3><h3 id="2-配置会话引擎"><a href="#2-配置会话引擎" class="headerlink" title="2. 配置会话引擎"></a>2. 配置会话引擎</h3><h3 id="3-在视图中使用会话"><a href="#3-在视图中使用会话" class="headerlink" title="3. 在视图中使用会话"></a>3. 在视图中使用会话</h3><ul>
<li>以上是基本的三个功能，还有其他的，和细节，需要时再看</li>
</ul>
<h1 id="第十六章：Django-的缓存框架"><a href="#第十六章：Django-的缓存框架" class="headerlink" title="第十六章：Django 的缓存框架"></a>第十六章：Django 的缓存框架</h1><ul>
<li>配置缓存的一些东西，目前只是了解一个做网站的框架做个小项目，以后若是真的用Django做大项目的时候在了解这些吧。</li>
</ul>
<h1 id="第十七章：Django-中间件"><a href="#第十七章：Django-中间件" class="headerlink" title="第十七章：Django 中间件"></a>第十七章：Django 中间件</h1><ul>
<li>中间件是插在 Django 的请求和响应过程之中的框架。这是一种轻量级的低层插件系统,用于全局调整 Django 的输入或输出。</li>
<li>一个中间件组件专注于做一件特定的事。例如,Django 使用 AuthenticationMiddleware 这个中间件组件处理带会话的请求。</li>
<li>本章说明中间件的工作方式、如何激活中间件,以及如何自己动手编写中间件。Django 自带了一些中间件,拿来即用。</li>
</ul>
<h3 id="1-激活中间件"><a href="#1-激活中间件" class="headerlink" title="1. 激活中间件"></a>1. 激活中间件</h3><ul>
<li>若想激活一个中间件组件,把它添加到 Django 设置文件中的 MIDDLEWARE_CLASSES 列表里。</li>
<li>默认值:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES &#x3D; [</span><br><span class="line">    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.common.CommonMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>没有任何中间件是必须的,如果愿意, MIDDLEWARE_CLASSES 列表可以为空,但是强烈建议至少要使用 CommonMiddleware 。</li>
<li>MIDDLEWARE_CLASSES 要按照一定顺序罗列中间件,因为中间件之间可能彼此依赖。例如, AuthenticationMiddleware 在会话中存储通过身份验证的用户,因此必须列在SessionMiddleware 后面。</li>
</ul>
<h3 id="2-钩子和应用中间件的顺序"><a href="#2-钩子和应用中间件的顺序" class="headerlink" title="2. 钩子和应用中间件的顺序"></a>2. 钩子和应用中间件的顺序</h3><ul>
<li>处理请求时,在调用视图之前,Django 按照 MIDDLEWARE_CLASSES 列出的顺序从上到下应用各个中间件。这期间有两个钩子可用:<ul>
<li>process_request()</li>
<li>process_view()</li>
</ul>
</li>
<li>处理响应时,在调用视图之后,Django 按照相反的顺序从下到上应用各个中间件。这期间有三个钩子可用:<ul>
<li>process_exception()</li>
<li>process_template_response()</li>
<li>process_response()</li>
</ul>
</li>
</ul>
<h3 id="3-自己动手编写中间件"><a href="#3-自己动手编写中间件" class="headerlink" title="3. 自己动手编写中间件"></a>3. 自己动手编写中间件</h3><ul>
<li>自己编写中间件不难。一个中间件组件就是一个 Python 类,其中定义一个或多个下述方法。<ul>
<li>就是上面的5个钩子方法</li>
<li>再加<strong>init</strong>()<ul>
<li>多数中间件类不需要定义初始化方法,因为中间件类基本上只需实现各个 process_* 方法。但是,如果需要某种全局状态,可以实现<strong>init</strong> 。</li>
<li>Django 初始化中间件时不传入任何参数,因此你定义的 <strong>init</strong> 方法不能有参数。</li>
<li>process_* 方法每次请求调用一次,而 <strong>init</strong> 只在 Web 服务器响应第一个请求时调用一次。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-可用的中间件-和中间件的顺序"><a href="#4-可用的中间件-和中间件的顺序" class="headerlink" title="4. 可用的中间件,和中间件的顺序"></a>4. 可用的中间件,和中间件的顺序</h3><ul>
<li>一堆，需要再看</li>
</ul>
<h1 id="第十八章：国际化"><a href="#第十八章：国际化" class="headerlink" title="第十八章：国际化"></a>第十八章：国际化</h1><ul>
<li>Django 对国际化的支持。</li>
</ul>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><ul>
<li>国际化<ul>
<li>指为任何区域设置提供支持的程序设计过程。这个过程通常由软件开发者处理。国际化包括标记可翻译的文本(例如 UI 元素和错误消息);抽象日期和时间的显示方式,兼顾不同的区域标准;支持不同的时区;以及在代码中不对用户的区域位置做任何假设。国际化经常缩写为 I18N</li>
</ul>
</li>
<li>本地化<ul>
<li>指把国际化的程序翻译成特定区域的语言。这个过程通常由翻译人员处理。本地化有时缩写为 L10N。</li>
</ul>
</li>
</ul>
<h1 id="之后章节：安全和数据库"><a href="#之后章节：安全和数据库" class="headerlink" title="之后章节：安全和数据库"></a>之后章节：安全和数据库</h1><ul>
<li>暂时没必要看</li>
</ul>
<h1 id="附录A-模型定义参考"><a href="#附录A-模型定义参考" class="headerlink" title="附录A:模型定义参考"></a>附录A:模型定义参考</h1><h3 id="1-Django-模型字段类"><a href="#1-Django-模型字段类" class="headerlink" title="1. Django 模型字段类"></a>1. Django 模型字段类</h3><table>
<thead>
<tr>
<th>字段类</th>
<th>默认小组件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AutoField</td>
<td>N/A</td>
<td>根据 ID 自动递增的 IntegerField 。</td>
</tr>
<tr>
<td>BigIntegerField</td>
<td>NumberInput</td>
<td>64 位整数,与 IntegerField 很像,但取值范围是-9223372036854775808 到 9223372036854775807 。</td>
</tr>
<tr>
<td>BinaryField</td>
<td>N/A</td>
<td>存储原始二进制数据的字段。只支持 bytes 类型。注意,这个字段的功能有限。</td>
</tr>
<tr>
<td>BooleanField</td>
<td>CheckboxInput</td>
<td>真假值字段。如果想接受 null 值,使用NullBooleanField 。</td>
</tr>
<tr>
<td>CharField</td>
<td>TextInput</td>
<td>字符串字段,针对长度较小的字符串。大量文本应该使用 TextField 。有个额外的必须参数:max_length ,即字段的最大长度(字符个数)。</td>
</tr>
<tr>
<td>DateField</td>
<td>DateInput</td>
<td>日期,在 Python 中使用 datetime.date 实例表示。有两个额外的可选参数: auto_now ,每次保存对象时自动设为当前日期; auto_now_add ,创建对象时自动设为当前日期。</td>
</tr>
<tr>
<td>DateTimeField</td>
<td>DateTimeInput</td>
<td>日期和时间,在 Python 中使用 datetime.datetime实例表示。与 DateField 具有相同的额外参数。</td>
</tr>
<tr>
<td>DecimalField</td>
<td>TextInput</td>
<td>固定精度的小数,在 Python 中使用 Decimal 实例表示。有两个必须的参数: max_digits 和decimal_places 。</td>
</tr>
<tr>
<td>DurationField</td>
<td>TextInput</td>
<td>存储时间跨度,在 Python 中使用 timedelta 表示。</td>
</tr>
<tr>
<td>EmailField</td>
<td>TextInput</td>
<td>一种 CharField ,使用 EmailValidator 验证输入。max_length 的默认值为 254 。</td>
</tr>
<tr>
<td>FileField</td>
<td>ClearableFileInput</td>
<td>文件上传字段。详情参见下一节。</td>
</tr>
<tr>
<td>FilePathField</td>
<td>Select</td>
<td>一种 CharField ,限定只能在文件系统中的特定目录里选择文件。</td>
</tr>
<tr>
<td>FloatField</td>
<td>NumberInput</td>
<td>浮点数,在 Python 中使用 float 实例表示。注意, field.localize 的值为 False 时,默认的小组件是 TextInput 。</td>
</tr>
<tr>
<td>ImageField</td>
<td>ClearableFileInput</td>
<td>所有属性和方法都继承自 FileField ,此外验证上传的对象是不是有效的图像。增加了 height 和width 两个属性。需要 Pillow 库支持。</td>
</tr>
<tr>
<td>IntegerField</td>
<td>NumberInput</td>
<td>整数。取值范围是 -2147483648 到 2147483647 ,在Django 支持的所有数据库中可放心使用。</td>
</tr>
<tr>
<td>GenericIPAddressField</td>
<td>TextInput</td>
<td>IPv4 或 IPv6 地址,字符串形式(如 192.0.2.30 、</td>
</tr>
<tr>
<td>NullBooleanField</td>
<td>NullBooleanSelect</td>
<td>类似于 BooleanField ,但是 NULL 可作为其中一个选项。</td>
</tr>
<tr>
<td>PositiveIntegerField</td>
<td>NumberInput</td>
<td>整数。取值范围是 0 到 2147483647 ,在 Django 支持的所有数据库中可放心使用。</td>
</tr>
<tr>
<td>SlugField</td>
<td>TextInput</td>
<td>别名(slug)是报业术语,是某个事物的简短标注,只包含字母、数字、下划线或连字符。</td>
</tr>
<tr>
<td>SmallIntegerField</td>
<td>NumberInput</td>
<td>类似于 IntegerField ,但是对值有限制。取值范围是 -32768 到 32767 ,在 Django 支持的所有数据库中可放心使用。</td>
</tr>
<tr>
<td>TextField</td>
<td>Textarea</td>
<td>大段文本字段。如果指定了 max_length 选项,这一限制在自动生成的表单字段中会体现出来。</td>
</tr>
<tr>
<td>TimeField</td>
<td>TextInput</td>
<td>时间,在 Python 中使用 datetime.time 实例表示。</td>
</tr>
<tr>
<td>URLField</td>
<td>URLInput</td>
<td>用于输入 URL 的 CharField 。可选 max_length 选项。</td>
</tr>
<tr>
<td>UUIDField</td>
<td>TextInput</td>
<td>用于存储通用唯一标识码。使用 Python 的 UUID类</td>
</tr>
</tbody></table>
<h3 id="2-内置标签和过滤器"><a href="#2-内置标签和过滤器" class="headerlink" title="2. 内置标签和过滤器"></a>2. 内置标签和过滤器</h3><ul>
<li>看官网吧</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>《TCPIP详解》</title>
    <url>/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/</url>
    <content><![CDATA[<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ol>
<li>这本书略看了一下，学习的时候主要学的《计算机网络(谢希仁)》，这个笔记是根据“即时通讯网”上的资料整理的。获益良多。</li>
<li>关于TCP,嗯还有很多要学的。<a id="more"></a>

</li>
</ol>
<h1 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h1><h3 id="网络常识"><a href="#网络常识" class="headerlink" title="网络常识"></a>网络常识</h3><ul>
<li><ol>
<li>互联网地址(ip地址)</li>
</ol>
<ul>
<li>网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。现在，通常使用的IP地址是一个32bit的数字，也就是我们常说的IPv4 标准，这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址。具体的 分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合</li>
</ul>
</li>
<li><ol start="2">
<li>域名系统</li>
</ol>
<ul>
<li>域名系统是一个分布的数据库，它提供将主机名（就是网址）转换成IP地址的服务。</li>
</ul>
</li>
<li><ol start="3">
<li>RFC</li>
</ol>
<ul>
<li>RFC是什么？RFC就是tcp/ip协议的标准文档，在这里我们可以看到RFC那长长的定义列表，现在它一共有4000多个协议的定义，当然，我们所要学习的，也就是那么十几个协议而已。</li>
</ul>
</li>
<li><ol start="4">
<li>端口号(port)</li>
</ol>
<ul>
<li>注意，这个号码是用在TCP，UDP上的一个逻辑号码，并不是一个硬件端口，我们平时说把某某端口封掉了，也只是在IP层次把带有这个号码的IP包给过滤掉了而已。</li>
</ul>
</li>
<li><ol start="5">
<li>应用编程接口</li>
</ol>
<ul>
<li>现在常用的编程接口有socket和TLI。而前面的有时候也叫做“Berkeley socket”，可见Berkeley对于网络的发展有多大的贡献。</li>
</ul>
</li>
</ul>
<h1 id="二：链路层"><a href="#二：链路层" class="headerlink" title="二：链路层"></a>二：链路层</h1><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li><p>链路层主要有三个目的</p>
<ol>
<li>为IP模块发送和接收IP数据报；</li>
<li>为ARP模块发送ARP请求和接收ARP应答；</li>
<li>为RARP发送RARP请求和接收RARP应答。</li>
</ol>
</li>
<li><p>TCP/IP支持多种不同的链路层协议，这取决于网络所使用的硬件，如以太网、令牌环网、FDDI（光纤分布式数据接口）及RS-232串行线路等。</p>
</li>
<li><p>本章讨论内容</p>
<ol>
<li>详细讨论以太网链路层协议</li>
<li>两个串行接口链路层协议（SLIP和PPP），以及大多数实现都包含的环回（loopback）驱动程序。</li>
<li>以太网和SLIP是本书中大多数例子使用的链路层。</li>
<li>对MTU（最大传输单元）进行了介绍</li>
<li>如何为串行线路选择MTU。</li>
</ol>
</li>
</ul>
<h3 id="2-以太网和IEEE-802封装"><a href="#2-以太网和IEEE-802封装" class="headerlink" title="2. 以太网和IEEE 802封装"></a>2. 以太网和IEEE 802封装</h3><ul>
<li>以太网是当今TCP/IP采用的主要的局域网技术。它采用一种称作CSMA/CD的媒体接入方法，其意思是带冲突检测的载波侦听多路接入（Carrier Sense, Multiple Access with Collision Detection）。它的速率为10 Mb/s，地址为48 bit。</li>
<li>几年后，IEEE（电子电气工程师协会）802委员会公布了一个稍有不同的标准集，其中802.3针对整个CSMA/CD网络，802.4针对令牌总线网络，802.5针对令牌环网络。这三者的共同特性由802.2标准来定义，那就是802网络共有的逻辑链路控制（LLC）。不幸的是，802.2和802.3定义了一个与以太网不同的帧格式。</li>
</ul>
<h3 id="3-SLIP：串行线路IP"><a href="#3-SLIP：串行线路IP" class="headerlink" title="3. SLIP：串行线路IP"></a>3. SLIP：串行线路IP</h3><ul>
<li>SLIP的全称是Serial Line IP。它是一种在串行线路上对IP数据报进行封装的简单形式</li>
<li>压缩的SLIP，CSLIP</li>
<li>常用于低速的串行链路</li>
</ul>
<h3 id="4-PPP：点对点协议"><a href="#4-PPP：点对点协议" class="headerlink" title="4. PPP：点对点协议"></a>4. PPP：点对点协议</h3><ul>
<li>点对点协议修改了SLIP协议中的所有缺陷</li>
<li>PPP数据帧的格式。  <!-- ![1.ppp.png](./img/1.ppp.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/1.ppp.png" class="" title="1.ppp.png">
<ul>
<li>每一帧都以标志字符0x7e开始和结束。</li>
<li>紧接着是一个地址字节，值始终是0xff</li>
<li>然后是一个值为0x03的控制字节。</li>
<li>接下来是协议字段，类似于以太网中类型字段的功能。当它的值为0x0021时，表示信息字段是一个IP数据报；值为0xc021时，表示信息字段是链路控制数据；值为0x8021时，表示信息字段是网络控制数据。</li>
<li>CRC字段（或FCS，帧检验序列）是一个循环冗余检验码，以检测数据帧中的错误。</li>
<li>0x7e结束</li>
</ul>
</li>
<li>由于标志字符的值是0x7e，因此当该字符出现在信息字段中时，PPP需要对它进行转义。</li>
<li>与SLIP类似，由于PPP经常用于低速的串行链路</li>
<li>PPP比SLIP具有下面这些优点：<br>  (1)PPP支持在单根串行线路上运行多种协议，不只是IP协议；<br>  (2)每一帧都有循环冗余检验；<br>  (3)通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；<br>  (4)与CSLIP类似，对TCP和IP报文首部进行压缩；<br>  (5)链路控制协议可以对多个数据链路选项进行设置。为这些优点付出的代价是在每一帧的首部增加3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</li>
</ul>
<h3 id="5-环回接口"><a href="#5-环回接口" class="headerlink" title="5. 环回接口"></a>5. 环回接口</h3><ul>
<li>作用：允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信。</li>
<li>A类网络号127就是为环回接口预留的。根据惯例，大多数系统把IP地址127.0.0.1分配给这个接口，并命名为localhost。一个传给环回接口的IP数据报不能在任何网络上出现。</li>
<li>用ifconfig显示的lo就是loopback接口</li>
</ul>
<h3 id="6-最大传输单元MTU"><a href="#6-最大传输单元MTU" class="headerlink" title="6. 最大传输单元MTU"></a>6. 最大传输单元MTU</h3><ul>
<li>以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。链路层的这个特性称作MTU ,最大传输单元。</li>
<li>如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大,那么IP层就需要进行分片（fragmentation），把数据报分成若干片，这样每一片都小于MTU。</li>
<li>netstat -in看MTU值</li>
</ul>
<h3 id="7-路径MTU"><a href="#7-路径MTU" class="headerlink" title="7. 路径MTU"></a>7. 路径MTU</h3><ul>
<li>当在同一个网络上的两台主机互相进行通信时，该网络的MTU是非常重要的。但是如果两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的MTU。重要的不是两台主机所在网络的MTU的值，重要的是两台通信主机路径中的最小MTU。它被称作路径MTU。</li>
<li>两台主机之间的路径MTU不一定是个常数。它取决于当时所选择的路由。而选路不一定是对称的（从A到B的路由可能与从B到A的路由不同），因此路径MTU在两个方向上不一定是一致的。</li>
</ul>
<h3 id="8-串行线路吞吐量计算-如何为串行线路选择MTU"><a href="#8-串行线路吞吐量计算-如何为串行线路选择MTU" class="headerlink" title="8. 串行线路吞吐量计算(如何为串行线路选择MTU)"></a>8. 串行线路吞吐量计算(如何为串行线路选择MTU)</h3><ul>
<li>如果线路速率是9600 b/s，而一个字节有8bit，加上一个起始比特和一个停止比特，那么线路的速率就是960 B/s（字节/秒）。以这个速率传输一个1024字节的分组需要1066 ms。如果用SLIP链接运行一个交互式应用程序，同时还运行另一个应用程序如FTP发送或接收1024字节的数据，那么一般来说就必须等待一半的时间（533 ms）才能把交互式应用程序的分组数据发送出去。</li>
<li>对于交互应用来说，等待533 ms是不能接受的。关于人的有关研究表明，交互响应时间超过100～200 ms就被认为是不好的</li>
<li>把SLIP的MTU缩短到256就意味着链路传输一帧最长需要266 ms，它的一半是133 ms（这是一般需要等待的时间）。这样情况会好一些，但仍然不完美。我们选择它的原因（与64或128相比）是因为大块数据提供良好的线路利用率（如大文件传输）。</li>
<li>假设CSLIP的报文首部是5个字节，数据帧总长为261个字节，256个字节的数据使线路的利用率为98.1%，帧头占了1.9%，这样的利用率是很不错的。如果把MTU降到256以下，那么将降低传输大块数据的最大吞吐量。</li>
</ul>
<h1 id="三：IP-网际协议"><a href="#三：IP-网际协议" class="headerlink" title="三：IP:网际协议"></a>三：IP:网际协议</h1><h3 id="1-引言-1"><a href="#1-引言-1" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输</li>
<li>不可靠unreliable<ul>
<li>意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）。</li>
</ul>
</li>
<li>无连接connectionless<ul>
<li>意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明，IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达。</li>
</ul>
</li>
<li>本章讨论的内容<ul>
<li><ol>
<li>IP首部中的各个字段</li>
</ol>
</li>
<li><ol start="2">
<li>讨论IP路由选择和子网的有关内容</li>
</ol>
</li>
<li><ol start="3">
<li>介绍两个有用的命令：ifconfig和netstat。</li>
</ol>
</li>
<li><ol start="4">
<li>关于IP首部中一些字段的细节，将留在以后使用这些字段的时候再进行讨论。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="2-IP首部"><a href="#2-IP首部" class="headerlink" title="2. IP首部"></a>2. IP首部</h3><!-- ![2.IP首部.png](./img/2.IP首部.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/2.IP%E9%A6%96%E9%83%A8.png" class="" title="2.IP首部.png">
<ul>
<li>首部长度<ul>
<li>首部长度指的是首部占32 bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部最长为60个字节。在第8章中，我们将看到这种限制使某些选项如路由记录选项在当今已没有什么用处。普通IP数据报（没有任何选择项）字段的值是5。</li>
</ul>
</li>
<li>服务类型<ul>
<li>服务类型（TOS）字段包括一个3bit的优先权子字段（现在已被忽略），4bit的TOS子字段和1bit未用位但必须置0。4bit的TO S分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。4bit中只能置其中1bit。如果所有4bit均为0，那么就意味着是一般服务。</li>
</ul>
</li>
<li>总长度字段<ul>
<li>是指整个IP数据报的长度，以字节为单位。利用首部长度字段和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16比特，所以IP数据报最长可达65535字节（超级通道的MTU为65535。它的意思其实不是一个真正的MTU—它使用了最长的IP数据报）。当数据报被分片时，该字段的值也随着变化。</li>
<li>尽管可以传送一个长达65535字节的IP数据报，但是大多数的链路层都会对它进行分片。而且，主机也要求不能接收超过576字节的数据报。</li>
<li>由于TCP把用户数据分成若干片，因此一般来说这个限制不会影响TCP。</li>
<li>大量使用UDP的应用（RIP，TFTP，BOOTP，DNS，以及SNMP），它们都限制用户数据报长度为512字节，小于576字节。但是，事实上现在大多数的实现（特别是那些支持网络文件系统NFS的实现）允许超过8192字节的IP数据报。</li>
</ul>
</li>
<li>标识字段<ul>
<li>唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。</li>
<li>在讨论分片时再来分析标志字段和片偏移字段。</li>
</ul>
</li>
<li>TTL<ul>
<li>生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。</li>
</ul>
</li>
<li>协议字段<ul>
<li>根据它可以识别是哪个协议向IP传送数据。(TCP or UDP?)</li>
</ul>
</li>
<li>首部检验和字段<ul>
<li>是根据IP首部计算的检验和码。它不对首部后面的数据进行计算。ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。</li>
</ul>
</li>
<li>源IP地址和目的IP地址<ul>
<li>它们都是32 bit的值。</li>
</ul>
</li>
<li>任选项<ul>
<li>这些选项很少被使用，并非所有的主机和路由器都支持这些选项。</li>
</ul>
</li>
</ul>
<h3 id="3-IP路由选择"><a href="#3-IP路由选择" class="headerlink" title="3. IP路由选择"></a>3. IP路由选择</h3><ul>
<li>当今的大多数多用户系统，包括几乎所有的Unix系统，都可以配置成一个路由器。我们可以为它指定主机和路由器都可以使用的简单路由算法。本质上的区别在于主机从不把数据报从一个接口转发到另一个接口，而路由器则要转发数据报。内含路由器功能的主机应该从不转发数据报，除非它被设置成那样。</li>
<li>在一般的体制中，IP可以从TCP、UDP、ICMP和IGMP接收数据报（即在本地生成的数据报）并进行发送，或者从一个网络接口接收数据报（待转发的数据报）并进行发送。</li>
<li>IP层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次。<ul>
<li>当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样，数据报就被送到由IP首部协议字段所指定的协议模块进行处理。</li>
<li>如果数据报的目的不是这些地址，那么（1）如果IP层被设置为路由器的功能，那么就对数据报进行转发（也就是说，像下面对待发出的数据报一样处理）；否则（2）数据报被丢弃。</li>
</ul>
</li>
<li>路由表中的每一项都包含下面这些信息：<ul>
<li>目的IP地址</li>
<li>下一跳路由器IP地址</li>
<li>标志</li>
<li>为数据报的传输指定一个网络接口</li>
</ul>
</li>
<li>IP路由选择</li>
<li>为一个网络指定一个路由器，而不必为每个主机指定一个路由器，这是IP路由选择机制的另一个基本特性。这样做可以极大地缩小路由表的规模</li>
</ul>
<h3 id="4-子网寻址和子网掩码"><a href="#4-子网寻址和子网掩码" class="headerlink" title="4. 子网寻址和子网掩码"></a>4. 子网寻址和子网掩码</h3><ul>
<li>先比较是否是同类地址(A?B?C?),然后用子网掩码看是否在同一个子网，然后再看主机号</li>
<li>主机号全1表示是该子网的广播地址</li>
<li>255.255.255.255是受限的广播(永远不被转发)</li>
</ul>
<h3 id="5-ifconfig和netstat"><a href="#5-ifconfig和netstat" class="headerlink" title="5. ifconfig和netstat"></a>5. ifconfig和netstat</h3><ul>
<li>查看/设置网卡信息</li>
<li>查看TCP等连接情况，接口信息等</li>
</ul>
<h1 id="四：ARP-地址解析协议"><a href="#四：ARP-地址解析协议" class="headerlink" title="四：ARP:地址解析协议"></a>四：ARP:地址解析协议</h1><h3 id="1-引言-2"><a href="#1-引言-2" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>数据链路如以太网或令牌环网都有自己的寻址机制（常常为48 bit地址），这是使用数据链路的任何网络层都必须遵从的。</li>
<li>一个网络如以太网可以同时被不同的网络层使用。例如，一组使用TCP/IP协议的主机和另一组使用某种PC网络软件的主机可以共享相同的电缆。</li>
<li>ARP<ul>
<li>为IP地址到对应的硬件地址之间提供动态映射。我们之所以用动态这个词是因为这个过程是自动完成的，一般应用程序用户或系统管理员不必关心。</li>
</ul>
</li>
<li>RARP<ul>
<li>是被那些没有磁盘驱动器的系统使用（一般是无盘工作站或X终端），它需要系统管理员进行手工设置。</li>
</ul>
</li>
</ul>
<h3 id="2-一个例子"><a href="#2-一个例子" class="headerlink" title="2. 一个例子"></a>2. 一个例子</h3><ul>
<li>使用 ftp <a href="http://www.xxx.com/">www.xxx.com</a> 过程<ul>
<li><ol>
<li>应用程序FTP客户端调用函数gethostbyname(3)把主机名（bsdi）转换成32 bit的IP地址。这个函数在DNS（域名系统）中称作解析器，我们将在第14章对它进行介绍。这个转换过程或者使用DNS，或者在较小网络中使用一个静态的主机文件（/etc/hosts）。</li>
</ol>
</li>
<li><ol start="2">
<li>FTP客户端请求TCP用得到的IP地址建立连接。</li>
</ol>
</li>
<li><ol start="3">
<li>TCP发送一个连接请求分段到远端的主机，即用上述IP地址发送一份IP数据报（在第18章我们将讨论完成这个过程的细节）。</li>
</ol>
</li>
<li><ol start="4">
<li>如果目的主机在本地网络上（如以太网、令牌环网或点对点链接的另一端），那么IP数据报可以直接送到目的主机上。如果目的主机在一个远程网络上，那么就通过IP选路函数来确定位于本地网络上的下一站路由器地址，并让它转发IP数据报。在这两种情况下，IP数据报都是被送到位于本地网络上的一台主机或路由器。</li>
</ol>
</li>
<li><ol start="5">
<li>假定是一个以太网，那么发送端主机必须把32 bit的IP地址变换成48 bit的以太网地址。从逻辑Internet地址到对应的物理硬件地址需要进行翻译。这就是ARP的功能。ARP本来是用于广播网络的，有许多主机或路由器连在同一个网络上。</li>
</ol>
</li>
<li><ol start="6">
<li>ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机。这个过程称作广播，如图4-2中的虚线所示。ARP请求数据帧中包含目的主机的IP地址（主机名为bsdi），其意思是“如果你是这个IP地址的拥有者，请回答你的硬件地址。”</li>
</ol>
</li>
<li><ol start="7">
<li>目的主机的ARP层收到这份广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址。</li>
</ol>
</li>
<li><ol start="8">
<li>收到ARP应答后，使ARP进行请求—应答交换的IP数据报现在就可以传送了。</li>
</ol>
</li>
<li><ol start="9">
<li>发送IP数据报到目的主机。<!-- ![3.ftpARP.png](./img/3.ftpARP.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/3.ftpARP.png" class="" title="3.ftpARP.png"></li>
</ol>
</li>
</ul>
</li>
<li>在ARP背后有一个基本概念，那就是网络接口有一个硬件地址（一个48 bit的值，标识不同的以太网或令牌环网络接口）。</li>
<li>点对点链路不使用ARP。当设置这些链路时（一般在引导过程进行），必须告知内核链路每一端的IP地址。像以太网地址这样的硬件地址并不涉及。</li>
</ul>
<h3 id="3-ARP高速缓存"><a href="#3-ARP高速缓存" class="headerlink" title="3. ARP高速缓存"></a>3. ARP高速缓存</h3><ul>
<li>ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了最近Internet地址到硬件地址之间的映射记录。</li>
<li>高速缓存中每一项的生存时间一般为20分钟，起始时间从被创建时开始算起。</li>
<li>arp -a 查看缓存表</li>
</ul>
<h3 id="4-ARP的分组格式"><a href="#4-ARP的分组格式" class="headerlink" title="4. ARP的分组格式"></a>4. ARP的分组格式</h3><!-- ![4.ARP.png](./img/4.ARP.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/4.ARP.png" class="" title="4.ARP.png">
<ul>
<li>以太网首部14字节</li>
<li>ARP请求/应答28字节</li>
</ul>
<h3 id="5-ARP代理"><a href="#5-ARP代理" class="headerlink" title="5. ARP代理"></a>5. ARP代理</h3><ul>
<li>如果ARP请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作委托ARP或ARP代理(Proxy ARP)。</li>
</ul>
<h3 id="6-免费ARP"><a href="#6-免费ARP" class="headerlink" title="6. 免费ARP"></a>6. 免费ARP</h3><ul>
<li>免费ARP(gratuitous ARP)。它是指主机发送ARP查找自己的IP地址。通常，它发生在系统引导期间进行接口配置的时候。</li>
<li>免费ARP可以有两个方面的作用：<ul>
<li><ol>
<li>一个主机可以通过它来确定另一个主机是否设置了相同的IP地址。主机bsdi并不希望对此请求有一个回答。但是，如果收到一个回答，那么就会在终端日志上产生一个错误消息“以太网地址：a:b:c:d:e:f发送来重复的IP地址”。这样就可以警告系统管理员，某个系统有不正确的设置。</li>
</ol>
</li>
<li><ol start="2">
<li>如果发送免费ARP的主机正好改变了硬件地址（很可能是主机关机了，并换了一块接口卡，然后重新启动），那么这个分组就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。</li>
</ol>
</li>
<li>一个比较著名的ARP协议事实[Plummer 1982]是，如果主机收到某个IP地址的ARP请求，而且它已经在接收者的高速缓存中，那么就要用ARP请求中的发送端硬件地址（如以太网地址）对高速缓存中相应的内容进行更新。主机接收到任何ARP请求都要完成这个操作（ARP请求是在网上广播的，因此每次发送ARP请求时网络上的所有主机都要这样做）。</li>
</ul>
</li>
</ul>
<h1 id="五-RARP-逆地址解析协议"><a href="#五-RARP-逆地址解析协议" class="headerlink" title="五 RARP:逆地址解析协议"></a>五 RARP:逆地址解析协议</h1><h3 id="1-引言-3"><a href="#1-引言-3" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li><p>具有本地磁盘的系统引导时，一般是从磁盘上的配置文件中读取IP地址。但是无盘机，如X终端或无盘工作站，则需要采用其他方法来获得IP地址。</p>
</li>
<li><p>网络上的每个系统都具有唯一的硬件地址，它是由网络接口生产厂家配置的。无盘系统的RARP实现过程是从接口卡上读取唯一的硬件地址，然后发送一份RARP请求（一帧在网络上广播的数据），请求某个主机响应该无盘系统的IP地址（在RARP应答中）。</p>
</li>
<li><p>RARP分组的格式与ARP分组基本一致</p>
</li>
<li><p>ARP服务器很简单，通常是TCP/IP在内核中实现的一部分。由于内核知道IP地址和硬件地址，因此当它收到一个询问IP地址的ARP请求时，只需用相应的硬件地址来提供应答就可以了。</p>
</li>
<li><p>但是一个RARP服务器的设计与系统相关而且比较复杂。</p>
</li>
<li><p>虽然RARP在概念上很简单，但是RARP服务器的实现却与系统相关。因此，并不是所有的TCP/IP实现都提供RARP服务器。</p>
</li>
</ul>
<h1 id="六-ICMP-Internet控制报文协议"><a href="#六-ICMP-Internet控制报文协议" class="headerlink" title="六 ICMP:Internet控制报文协议"></a>六 ICMP:Internet控制报文协议</h1><h3 id="1-引言-4"><a href="#1-引言-4" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li><p>IP数据包</p>
<table>
<thead>
<tr>
<th>IP首部</th>
<th>ICMP报文</th>
</tr>
</thead>
<tbody><tr>
<td>20字节</td>
<td>不确定字节</td>
</tr>
<tr>
<td><!-- ![5.ICMP-IP.png](./img/5.ICMP-IP.png) --></td>
<td></td>
</tr>
<tr>
<td><img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/5.ICMP-IP.png" class="" title="5.ICMP-IP.png"></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>ICMP</p>
<table>
<thead>
<tr>
<th>8位类型</th>
<th>8位代码</th>
<th>16位校验和</th>
</tr>
</thead>
<tbody><tr>
<td>其他内容</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><!-- ![6.ICMP.png](./img/6.ICMP.png) --></td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/6.ICMP.png" class="" title="6.ICMP.png"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>本章内容</p>
<ul>
<li><ol>
<li>讨论ICMP报文</li>
</ol>
</li>
<li><ol start="2">
<li>详解地址掩码请求和应答、时间戳请求和应答以及不可达端口。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="2-ICMP报文类型"><a href="#2-ICMP报文类型" class="headerlink" title="2. ICMP报文类型"></a>2. ICMP报文类型</h3><!-- ![7.ICMP报文类型.png](./img/7.ICMP报文类型.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/7.ICMP%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B.png" class="" title="7.ICMP报文类型.png">
<ul>
<li><p>图中的最后两列表明ICMP报文是一份查询报文还是一份差错报文。因为对ICMP差错报文有时需要作特殊处理，因此我们需要对它们进行区分。</p>
<ul>
<li>例如，在对ICMP差错报文进行响应时，永远不会生成另一份ICMP差错报文（如果没有这个限制规则，可能会遇到一个差错产生另一个差错的情况，而差错再产生差错，这样会无休止地循环下去）。</li>
</ul>
</li>
<li><p>当发送一份ICMP差错报文时，报文始终包含IP的首部和产生ICMP差错报文的IP数据报的前8个字节。这样，接收ICMP差错报文的模块就会把它与某个特定的协议（根据IP数据报首部中的协议字段来判断）和用户进程（根据包含在IP数据报前8个字节中的TCP或UDP报文首部中的TCP或UDP端口号来判断）联系起来。</p>
</li>
<li><p>下面各种情况都不会导致产生ICMP差错报文：</p>
<ol>
<li>ICMP差错报文（但是，ICMP查询报文可能会产生ICMP差错报文）。</li>
<li>目的地址是广播地址或多播地址的IP数据报。</li>
<li>作为链路层广播的数据报。</li>
<li>不是IP分片的第一片（将在11.5节介绍分片）。</li>
<li>源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地址或多播地址。</li>
</ol>
<ul>
<li>这些规则是为了防止过去允许ICMP差错报文对广播分组响应所带来的广播风暴。</li>
</ul>
</li>
</ul>
<h3 id="3-ICMP地址掩码请求与应答"><a href="#3-ICMP地址掩码请求与应答" class="headerlink" title="3. ICMP地址掩码请求与应答"></a>3. ICMP地址掩码请求与应答</h3><ul>
<li>ICMP地址掩码请求用于无盘系统在引导过程中获取自己的子网掩码</li>
<li>ICMP地址掩码请求和应答报文共12字节<!-- ![8.ICMP请求掩码.png](./img/8.ICMP请求掩码.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/8.ICMP%E8%AF%B7%E6%B1%82%E6%8E%A9%E7%A0%81.png" class="" title="8.ICMP请求掩码.png">

</li>
</ul>
<h3 id="4-ICMP时间戳请求与应答"><a href="#4-ICMP时间戳请求与应答" class="headerlink" title="4. ICMP时间戳请求与应答"></a>4. ICMP时间戳请求与应答</h3><ul>
<li>ICMP时间戳请求允许系统向另一个系统查询当前的时间。</li>
<li>报文有20字节<!-- ![9.ICMP时间戳.png](./img/9.ICMP时间戳.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/9.ICMP%E6%97%B6%E9%97%B4%E6%88%B3.png" class="" title="9.ICMP时间戳.png">

</li>
</ul>
<h3 id="5-ICMP端口不可达差错"><a href="#5-ICMP端口不可达差错" class="headerlink" title="5. ICMP端口不可达差错"></a>5. ICMP端口不可达差错</h3><ul>
<li><p>端口不可达报文，它是ICMP目的不可到达报文中的一种，以此来看一看ICMP差错报文中所附加的信息。使用UDP（见第11章）来查看它。</p>
</li>
<li><p>UDP的规则之一是，如果收到一份UDP数据报而目的端口与某个正在使用的进程不相符，那么UDP返回一个ICMP不可达报文。可以用TFTP来强制生成一个端口不可达报文（TFTP将在第15章描述）。</p>
</li>
<li><p>有16种不同类型的ICMP不可达报文，代码分别从0到15。</p>
</li>
<li><p>netstat -s 查看每个协议统计数据</p>
</li>
<li><p>ICMP不可达报文</p>
  <!-- ![10.ICMP不可达报文.png](./img/10.ICMP不可达报文.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/10.ICMP%E4%B8%8D%E5%8F%AF%E8%BE%BE%E6%8A%A5%E6%96%87.png" class="" title="10.ICMP不可达报文.png">

</li>
</ul>
<h1 id="七-Ping程序"><a href="#七-Ping程序" class="headerlink" title="七 Ping程序"></a>七 Ping程序</h1><h3 id="1-引言-5"><a href="#1-引言-5" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>一般来说，如果不能Ping到某台主机，那么就不能Telnet或者FTP到那台主机。反过来，如果不能Telnet到某台主机，那么通常可以用Ping程序来确定问题出在哪里。</li>
<li>Ping程序还能测出到这台主机的往返时间，以表明该主机离我们有“多远”。</li>
</ul>
<h3 id="2-Ping程序"><a href="#2-Ping程序" class="headerlink" title="2. Ping程序"></a>2. Ping程序</h3><ul>
<li><p>大多数的TCP/IP实现都在内核中直接支持Ping服务器—这种服务器不是一个用户进程</p>
  <!-- ![11.ICMP回显.png](./img/11.ICMP回显.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/11.ICMP%E5%9B%9E%E6%98%BE.png" class="" title="11.ICMP回显.png"></li>
<li><p>Unix系统在实现ping程序时是把ICMP报文中的标识符字段置成发送进程的ID号。这样即使在同一台主机上同时运行了多个ping程序实例，ping程序也可以识别出返回的信息。</p>
</li>
<li><p>运行在不同的环境下结果不一样</p>
<ul>
<li>LAN</li>
<li>WAN</li>
<li>线路SLIP链接</li>
<li>拨号SLIP链路</li>
</ul>
</li>
</ul>
<h3 id="3-IP记录路由选项"><a href="#3-IP记录路由选项" class="headerlink" title="3. IP记录路由选项"></a>3. IP记录路由选项</h3><ul>
<li>ping程序为我们提供了查看IP记录路由（RR）选项的机会。</li>
<li>发送出去的IP数据报中设置IPRR选项（该IP数据报包含ICMP回显请求报文）。这样，每个处理该数据报的路由器都把它的IP地址放入选项字段中。</li>
<li>只能存放9个IP地址。</li>
</ul>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul>
<li>Ping服务器一般在内核中实现ICMP的功能。</li>
<li>只利用ICMP回显请求(类型8)和回显应答报文(类型0)，而不用经过传输层（TCP/UDP）。</li>
</ul>
<h1 id="八-Traceroute程序"><a href="#八-Traceroute程序" class="headerlink" title="八 Traceroute程序"></a>八 Traceroute程序</h1><h3 id="1-引言-6"><a href="#1-引言-6" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>Traceroute程序可以让我们看到IP数据报从一台主机传到另一台主机所经过的路由。</li>
<li>IP记录路由选项（RR）。为什么不使用这个选项而另外开发一个新的应用程序？有三个方面的原因。<ul>
<li>首先，原先并不是所有的路由器都支持记录路由选项，因此该选项在某些路径上不能使用（Traceroute程序不需要中间路由器具备任何特殊的或可选的功能）。</li>
<li>其次，记录路由一般是单向的选项。发送端设置了该选项，那么接收端不得不从收到的IP首部中提取出所有的信息，然后全部返回给发送端。</li>
<li>最后一个原因也是最主要的原因是，IP首部中留给选项的空间有限，不能存放当前大多数的路径。在IP首部选项字段中最多只能存放9个IP地址。在原先的ARPANET中这是足够的，但是对现在来说是远远不够的。</li>
</ul>
</li>
</ul>
<h3 id="2-Traceroute程序的操作"><a href="#2-Traceroute程序的操作" class="headerlink" title="2. Traceroute程序的操作"></a>2. Traceroute程序的操作</h3><ul>
<li>Traceroute程序使用ICMP报文和IP首部中的TTL字段（生存周期）。</li>
<li>TTL字段的目的是防止数据报在选路时无休止地在网络中流动。</li>
<li>Traceroute程序的操作过程。<ul>
<li>它发送一份TTL字段为1的IP数据报给目的主机。处理这份数据报的第一个路由器将TTL值减1，丢弃该数据报，并发回一份超时ICMP报文。这样就得到了该路径中的第一个路由器的地址。然后Traceroute程序发送一份TTL值为2的数据报，这样我们就可以得到第二个路由器的地址。继续这个过程直至该数据报到达目的主机。但是目的主机哪怕接收到TTL值为1的IP数据报，也不会丢弃该数据报并产生一份超时ICMP报文，这是因为数据报已经到达其最终目的地。那么我们该如何判断是否已经到达目的主机了呢？</li>
<li>Traceroute程序发送一份UDP数据报给目的主机，但它选择一个不可能的值作为UDP端口号（大于30 000），使目的主机的任何一个应用程序都不可能使用该端口。因为，当该数据报到达时，将使目的主机的UDP模块产生一份“端口不可达”错误（见6.5节）的ICMP报文。这样，Traceroute程序所要做的就是区分接收到的ICMP报文是超时还是端口不可达，以判断什么时候结束。</li>
</ul>
</li>
<li>UDP or ICMP<ul>
<li>windows使用的是ICMP，最终使用ICMP seq识别</li>
<li>UNIX使用的UDP+ICMP,最终用一个大于30000的端口号来返回ICMP端口不可达</li>
</ul>
</li>
</ul>
<h1 id="九-IP选路"><a href="#九-IP选路" class="headerlink" title="九 IP选路"></a>九 IP选路</h1><h3 id="1-引言-7"><a href="#1-引言-7" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>需要进行选路的数据报可以由本地主机产生，也可以由其他主机产生。在后一种情况下，主机必须配置成一个路由器，否则通过网络接口接收到的数据报，如果目的地址不是本机就要被丢弃</li>
<li>netstat -r 查看路由表 -n 以数字格式打印出IP地址</li>
<li>IP层工作流程  <!-- ![12.IP层工作流程.png](./img/12.IP层工作流程.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/12.IP%E5%B1%82%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="" title="12.IP层工作流程.png">

</li>
</ul>
<h3 id="2-选路的原理"><a href="#2-选路的原理" class="headerlink" title="2. 选路的原理"></a>2. 选路的原理</h3><ul>
<li><p>首先要理解内核是如何维护路由表的。路由表中包含的信息决定了IP层所做的所有决策。IP搜索路由表的几个步骤：</p>
<ul>
<li>搜索匹配的主机地址；</li>
<li>搜索匹配的网络地址；</li>
<li>搜索默认表项（默认表项一般在路由表中被指定为一个网络表项，其网络号为0）。</li>
</ul>
</li>
<li><p>IP层进行的选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。</p>
</li>
<li><p>路由表的五种标志</p>
<ul>
<li>U 该路由可以使用。</li>
<li>G 该路由是到一个网关（路由器）。如果没有设置该标志，说明目的地是直接相连的。</li>
<li>H 该路由是到一个主机，也就是说，目的地址是一个完整的主机地址。如果没有设置该标志，说明该路由是到一个网络，而目的地址是一个网络地址：一个网络号，或者网络号与子网号的组合。</li>
<li>D 该路由是由重定向报文创建的（9.5节）。</li>
<li>M 该路由已被重定向报文修改（9.5节）。</li>
</ul>
</li>
<li><p>初始化路由表</p>
<ul>
<li>每当初始化一个接口时（通常是用ifconfig命令设置接口地址），就为接口自动创建一个直接路由。</li>
<li>初始化路由表的其他方法是运行路由守护程序（第10章）或者用较新的路由器发现协议（9.6节）。</li>
</ul>
</li>
<li><p>没有到达目的地的路由</p>
<ul>
<li>如果路由表中没有默认项，而又没有找到匹配项，结果取决于该IP数据报是由主机产生的还是被转发的（例如，我们就充当一个路由器）。如果数据报是由本地主机产生的，那么就给发送该数据报的应用程序返回一个差错，或者是“主机不可达差错”或者是“网络不可达差错”。如果是被转发的数据报，那么就给原始发送端发送一份ICMP主机不可达的差错报文。</li>
</ul>
</li>
</ul>
<h3 id="3-ICMP主机与网络不可达差错"><a href="#3-ICMP主机与网络不可达差错" class="headerlink" title="3. ICMP主机与网络不可达差错"></a>3. ICMP主机与网络不可达差错</h3><ul>
<li>当路由器收到一份IP数据报但又不能转发时，就要发送一份ICMP“主机不可达”差错报文</li>
</ul>
<h3 id="4-转发或不转发"><a href="#4-转发或不转发" class="headerlink" title="4. 转发或不转发"></a>4. 转发或不转发</h3><ul>
<li>一般都假定主机不转发IP数据报，除非对它们进行特殊配置而作为路由器使用。</li>
</ul>
<h3 id="5-ICMP重定向差错"><a href="#5-ICMP重定向差错" class="headerlink" title="5. ICMP重定向差错"></a>5. ICMP重定向差错</h3><ul>
<li>当IP数据报应该被发送到另一个路由器时，收到数据报的路由器就要发送ICMP重定向差错报文给IP数据报的发送端。</li>
<li>步骤<ol>
<li>我们假定主机发送一份IP数据报给R1。这种选路决策经常发生，因为R1是该主机的默认路由。</li>
<li>R1收到数据报并且检查它的路由表，发现R2是发送该数据报的下一站。当它把数据报发送给R2时，R1检测到它正在发送的接口与数据报到达接口是相同的（即主机和两个路由器所在的LAN）。这样就给路由器发送重定向报文给原始发送端提供了线索。</li>
<li>R1发送一份ICMP重定向报文给主机，告诉它以后把数据报发送给R2而不是R1。    </li>
</ol>
</li>
<li>ICMP重定向例子  <!-- ![13.ICMP重定向.png](./img/13.ICMP重定向.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/13.ICMP%E9%87%8D%E5%AE%9A%E5%90%91.png" class="" title="13.ICMP重定向.png"></li>
<li>重定向一般用来让具有很少选路信息的主机逐渐建立更完善的路由表。</li>
</ul>
<h3 id="6-ICMP路由器发现报文"><a href="#6-ICMP路由器发现报文" class="headerlink" title="6. ICMP路由器发现报文"></a>6. ICMP路由器发现报文</h3><ul>
<li><p>前面已提到过一种初始化路由表的方法，即在配置文件中指定静态路由。这种方法经常用来设置默认路由。另一种新的方法是利用ICMP路由器通告和请求报文。</p>
</li>
<li><p>一般认为，主机在引导以后要广播或多播传送一份路由器请求报文。一台或更多台路由器响应一份路由器通告报文。另外，路由器定期地广播或多播传送它们的路由器通告报文，允许每个正在监听的主机相应地更新它们的路由表。</p>
</li>
<li><p>路由器操作</p>
<ul>
<li>当路由器启动时，它定期在所有广播或多播传送接口上发送通告报文。准确地说，这些通告报文不是定期发送的，而是随机传送的，以减小与子网上其他路由器发生冲突的概率。一般每两次通告间隔450秒和600秒。一份给定的通告报文默认生命周期是30分钟。</li>
<li>除了定期发送主动提供的通告报文以外，路由器还要监听来自主机的请求报文，并发送路由器通告报文以响应这些请求报文。</li>
</ul>
</li>
<li><p>主机操作</p>
<ul>
<li>主机在引导期间一般发送三份路由器请求报文，每三秒钟发送一次。一旦接收到一个有效的通告报文，就停止发送请求报文。</li>
<li>主机也监听来自相邻路由器的请求报文。这些通告报文可以改变主机的默认路由器。另外，如果没有接收到来自当前默认路由器的通告报文，那么默认路由器会超时。</li>
</ul>
</li>
<li><p>实现</p>
<ul>
<li>路由器发现报文一般由用户进程（守护程序）创建和处理。</li>
</ul>
</li>
</ul>
<h1 id="十-动态选路协议"><a href="#十-动态选路协议" class="headerlink" title="十 动态选路协议"></a>十 动态选路协议</h1><h3 id="1-引言-8"><a href="#1-引言-8" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>动态选路协议，它用于路由器间的通信。</li>
<li>本章内容<ul>
<li>主要讨论RIP，即选路信息协议(Routing Infromation Protocol)，大多数TCP/IP实现都提供这个应用广泛的协议。</li>
<li>然后讨论两种新的选路协议，OSPF和BGP。</li>
<li>最后研究一种名叫无分类域间选路的新的选路技术，现在Internet上正在开始采用该协议以保持B类网络的数量。</li>
</ul>
</li>
</ul>
<h3 id="2-动态选路"><a href="#2-动态选路" class="headerlink" title="2. 动态选路"></a>2. 动态选路</h3><ul>
<li><p>当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时就出现了动态选路。</p>
</li>
<li><p>路由器上有一个进程称为路由守护程序（routing daemon），它运行选路协议，并与其相邻的一些路由器进行通信。</p>
</li>
<li><p>在像Internet这样的系统中，目前采用了许多不同的选路协议。Internet是以一组自治系统(AS，Autonomous System)的方式组织的，每个自治系统通常由单个实体管理。常常将一个公司或大学校园定义为一个自治系统。NSFNET的Internet骨干网形成一个自治系统，这是因为骨干网中的所有路由器都在单个的管理控制之下。</p>
</li>
<li><p>每个自治系统可以选择该自治系统中各个路由器之间的选路协议。这种协议我们称之为内部网关协议IGP（Interior Gateway Protocol）或域内选路协议（intradomain routing protocol）。最常用的IGP是选路信息协议RIP。一种新的IGP是开放最短路径优先OSPF（Open Shortest Path First）协议。它意在取代RIP。另一种1986年在原来NSFNET骨干网上使用的较早的IGP协议——HELLO，现在已经不用了。</p>
</li>
<li><p>外部网关协议EGP（Exterier Gateway Protocol）或域内选路协议的分隔选路协议用于不同自治系统之间的路由器。在历史上，（令人容易混淆）改进的EGP有着一个与它名称相同的协议：EGP。新EGP是当前在NSFNET骨干网和一些连接到骨干网的区域性网络上使用的是边界网关协议BGP（Border Gateway Protocol）。BGP意在取代EGP。</p>
</li>
</ul>
<h3 id="3-Unix选路守护进程"><a href="#3-Unix选路守护进程" class="headerlink" title="3. Unix选路守护进程"></a>3. Unix选路守护进程</h3><ul>
<li>Unix系统上常常运行名为routed路由守护程序。几乎在所有的TCP/IP实现中都提供该程序。该程序只使用RIP进行通信</li>
<li>另一个程序是gated。IGP和EGP都支持它。[Fedor 1998]描述了早期开发的gated。</li>
</ul>
<h3 id="4-RIP：选路信息协议"><a href="#4-RIP：选路信息协议" class="headerlink" title="4. RIP：选路信息协议"></a>4. RIP：选路信息协议</h3><h5 id="1-报文格式"><a href="#1-报文格式" class="headerlink" title="1. 报文格式"></a>1. 报文格式</h5><ul>
<li>RIP报文包含中在UDP数据报中</li>
</ul>
<table>
<thead>
<tr>
<th>IP首部</th>
<th>UDP首部</th>
<th>RIP报文</th>
</tr>
</thead>
</table>
<ul>
<li>RIP报文格式  <!-- ![14.RIP.png](./img/14.RIP.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/14.RIP.png" class="" title="14.RIP.png">

</li>
</ul>
<h5 id="2-正常运行"><a href="#2-正常运行" class="headerlink" title="2. 正常运行"></a>2. 正常运行</h5><ul>
<li>让我们来看一下采用RIP协议的routed程序正常运行的结果。RIP常用的UDP端口号是520。</li>
</ul>
<ol>
<li>初始化：在启动一个路由守护程序时，它先判断启动了哪些接口，并在每个接口上发送一个请求报文，要求其他路由器发送完整路由表。在点对点链路中，该请求是发送给其他终点的。如果网络支持广播的话，这种请求是以广播形式发送的。目的UDP端口号是520（这是其他路由器的路由守护程序端口号）。 这种请求报文的命令字段为1，但地址系列字段设置为0，而度量字段设置为16。这是一种要求另一端完整路由表的特殊请求报文。</li>
<li>接收到请求。如果这个请求是刚才提到的特殊请求，那么路由器就将完整的路由表发送给请求者。否则，就处理请求中的每一个表项：如果有连接到指明地址的路由，则将度量设置成我们的值，否则将度量置为16（度量为16是一种称为“无穷大”的特殊值，它意味着没有到达目的的路由）。然后发回响应。</li>
<li>接收到响应。使响应生效，可能会更新路由表。可能会增加新表项，对已有的表项进行修改，或是将已有表项删除。</li>
<li>定期选路更新。每过30秒，所有或部分路由器会将其完整路由表发送给相邻路由器。发送路由表可以是广播形式的（如在以太网上），或是发送给点对点链路的其他终点的。</li>
<li>触发更新。每当一条路由的度量发生变化时，就对它进行更新。不需要发送完整路由表，而只需要发送那些发生变化的表项。</li>
</ol>
<ul>
<li>每条路由都有与之相关的定时器。如果运行RIP的系统发现一条路由在3分钟内未更新，就将该路由的度量设置成无穷大（16），并标注为删除。这意味着已经在6个30秒更新时间里没收到通告该路由的路由器的更新了。再过60秒，将从本地路由表中删除该路由，以保证该路由的失效已被传播开。</li>
</ul>
<h5 id="3-RIP版本2"><a href="#3-RIP版本2" class="headerlink" title="3. RIP版本2"></a>3. RIP版本2</h5><ul>
<li>RFC 1388 [Malkin 1993a]中对RIP定义进行了扩充，通常称其结果为RIP-2。</li>
<li>RIP2报文格式  <!-- ![15.RIP2.png](./img/15.RIP2.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/15.RIP2.png" class="" title="15.RIP2.png">

</li>
</ul>
<h3 id="5-OSPF：开放最短路径优先"><a href="#5-OSPF：开放最短路径优先" class="headerlink" title="5. OSPF：开放最短路径优先"></a>5. OSPF：开放最短路径优先</h3><ul>
<li>OSPF是除RIP外的另一个内部网关协议。它克服了RIP的所有限制。RFC 1247[Moy 1991]中对第2版OSPF进行了描述。</li>
<li>与采用距离向量的RIP协议不同的是，OSPF是一个链路状态协议。距离向量的意思是，RIP发送的报文包含一个距离向量（跳数）。每个路由器都根据它所接收到邻站的这些距离向量来更新自己的路由表。</li>
<li>二者的不同点是链路状态协议总是比距离向量协议收敛更快。收敛的意思是在路由发生变化后，例如在路由器关闭或链路出故障后，可以稳定下来。</li>
<li>OSPF与RIP（以及其他选路协议）的不同点在于，OSPF直接使用IP。也就是说，它并不使用UDP或TCP。对于IP首部的protocol字段，OSPF有其自己的值</li>
</ul>
<h3 id="6-BGP：边界网关协议"><a href="#6-BGP：边界网关协议" class="headerlink" title="6. BGP：边界网关协议"></a>6. BGP：边界网关协议</h3><ul>
<li>BGP是一种不同自治系统的路由器之间进行通信的外部网关协议。</li>
<li>BGP与RIP和OSPF的不同之处在于BGP使用TCP作为其传输层协议。两个运行BGP的系统之间建立一条TCP连接，然后交换整个BGP路由表。从这个时候开始，在路由表发生变化时，再发送更新信号。</li>
<li>BGP是一个距离向量协议，但是与（通告到目的地址跳数的）RIP不同的是，BGP列举了到每个目的地址的路由（自治系统到达目的地址的序列号）。这样就排除了一些距离向量协议的问题。采用16 bit数字表示自治系统标识。</li>
</ul>
<h3 id="7-CIDR：无类型域间选路"><a href="#7-CIDR：无类型域间选路" class="headerlink" title="7. CIDR：无类型域间选路"></a>7. CIDR：无类型域间选路</h3><ul>
<li>无类型域间选路（CIDR）是一个防止Internet路由表膨胀的方法，它也称为超网（supernetting）。</li>
<li>CIDR同时还使用一种技术，使最佳匹配总是最长的匹配：即在32 bit掩码中，它具有最大值。</li>
<li>“无类型”的意思是现在的选路决策是基于整个32 bit IP地址的掩码操作，而不管其IP地址是A类、B类或是C类，都没有什么区别。</li>
</ul>
<h1 id="十一-UDP-用户数据报协议"><a href="#十一-UDP-用户数据报协议" class="headerlink" title="十一 UDP:用户数据报协议"></a>十一 UDP:用户数据报协议</h1><h3 id="1-引言-9"><a href="#1-引言-9" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>UDP是一个简单的面向数据报的运输层协议<ul>
<li>进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。这与面向流字符的协议不同，如TCP，应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系。</li>
</ul>
</li>
<li>UDP不提供可靠性<ul>
<li>它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的地。由于缺乏可靠性，我们似乎觉得要避免使用UDP而使用一种可靠协议如TCP。我们在第17章讨论完TCP后将再回到这个话题，看看什么样的应用程序可以使用UDP。</li>
</ul>
</li>
<li>应用程序必须关心IP数据报的长度。<ul>
<li>如果它超过网络的MTU（2.8节），那么就要对IP数据报进行分片。如果需要，源端到目的端之间的每个网络都要进行分片，并不只是发送端主机连接第一个网络才这样做（我们在2.9节中已定义了路径MTU的概念）。在11.5节中，我们将讨论IP分片机制。</li>
</ul>
</li>
</ul>
<h3 id="2-UDP首部"><a href="#2-UDP首部" class="headerlink" title="2. UDP首部"></a>2. UDP首部</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|   16位源端口  |   16位目的端口    |</span><br><span class="line">|   16位UDP长度 |   16位UDP校验和  |</span><br><span class="line">|           数据（如果有）         |</span><br></pre></td></tr></table></figure>
<!-- ![16.UDP数据报.png](./img/16.UDP数据报.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/16.UDP%E6%95%B0%E6%8D%AE%E6%8A%A5.png" class="" title="16.UDP数据报.png">
<ul>
<li><p>端口号表示发送进程和接收进程。TCP端口号由TCP来查看，而UDP端口号由UDP来查看。TCP端口号与UDP端口号是相互独立的。</p>
</li>
<li><p>UDP长度字段指的是UDP首部和UDP数据的字节长度。16位，最小值为8字节，也就是没有数据。</p>
</li>
</ul>
<h3 id="3-UDP检验和"><a href="#3-UDP检验和" class="headerlink" title="3. UDP检验和"></a>3. UDP检验和</h3><!-- ![17.UDP校验和.png](./img/17.UDP校验和.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/17.UDP%E6%A0%A1%E9%AA%8C%E5%92%8C.png" class="" title="17.UDP校验和.png">
<ul>
<li>UDP检验和覆盖UDP首部和UDP数据。回想IP首部的检验和，它只覆盖IP的首部—并不覆盖IP数据报中的任何数据。</li>
<li>UDP和TCP在首部中都有覆盖它们首部和数据的检验和。UDP的检验和是可选的，而TCP的检验和是必需的。</li>
<li>UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。伪首部包含IP首部一些字段(源IP/目的IP地址)。其目的是让UDP两次检查数据是否已经正确到达目的地。</li>
<li>UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动。</li>
</ul>
<h3 id="4-IP分片"><a href="#4-IP分片" class="headerlink" title="4. IP分片"></a>4. IP分片</h3><ul>
<li>物理网络层一般要限制每次发送数据帧的最大长度。任何时候IP层接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据（选路），并查询该接口获得其MTU。IP把MTU与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。</li>
<li>把一份IP数据报分片以后，只有到达目的地才进行重新组装（这里的重新组装与其他网络协议不同，它们要求在下一站就进行进行重新组装，而不是在最终的目的地）。重新组装由目的端的IP层来完成，其目的是使分片和重新组装过程对运输层（TCP和UDP）是透明的</li>
<li>回忆IP首部，下面这些字段用于分片过程。对于发送端发送的每份IP数据报来说，其标识字段都包含一个唯一值。该值在数据报分片时被复制到每个片中（我们现在已经看到这个字段的用途）。标志字段用其中一个比特来表示“更多的片”。除了最后一片外，其他每个组成数据报的片都要把该比特置1。片偏移字段指的是该片偏移原始数据报开始处的位置。另外，当数据报被分片后，每个片的总长度值要改为该片的长度值。</li>
<li>IP标志字段中有一个比特称作“不分片”位。如果将这一比特置1，IP将不对数据报进行分片。相反把数据报丢弃并发送一个ICMP差错报文（“需要进行分片但设置了不分片比特”，见图6-3）给起始端。</li>
<li>尽管IP分片过程看起来是透明的，但有一点让人不想使用它：即使只丢失一片数据也要重传整个数据报。为什么会发生这种情况呢？因为IP层本身没有超时重传的机制——由更高层来负责超时和重传（TCP有超时和重传机制，但UDP没有。一些UDP应用程序本身也执行超时和重传）。</li>
<li>解释几个术语：<ul>
<li>IP数据报是指IP层端到端的传输单元（在分片之前和重新组装之后）</li>
<li>分组是指在IP层和链路层之间传送的数据单元。一个分组可以是一个完整的IP数据报，也可以是IP数据报的一个分片。</li>
</ul>
</li>
</ul>
<h3 id="5-ICMP不可达差错（需要分片）"><a href="#5-ICMP不可达差错（需要分片）" class="headerlink" title="5. ICMP不可达差错（需要分片）"></a>5. ICMP不可达差错（需要分片）</h3><ul>
<li>发生ICMP不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在IP首部又设置了不分片（DF）的标志比特。如果某个程序需要判断到达目的端的路途中最小MTU是多少—称作路径MTU发现机制（2.9节），那么这个差错就可以被该程序使用。<!-- ![18.ICMP不可达差错.png](./img/18.ICMP不可达差错.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/18.ICMP%E4%B8%8D%E5%8F%AF%E8%BE%BE%E5%B7%AE%E9%94%99.png" class="" title="18.ICMP不可达差错.png">

</li>
</ul>
<h3 id="6-用Traceroute确定路径MTU"><a href="#6-用Traceroute确定路径MTU" class="headerlink" title="6. 用Traceroute确定路径MTU"></a>6. 用Traceroute确定路径MTU</h3><ul>
<li>尽管大多数的系统不支持路径MTU发现功能，但可以很容易地修改traceroute程序，用它来确定路径MTU。</li>
<li>要做的是发送分组，并设置“不分片”标志比特。发送的第一个分组的长度正好与出口MTU相等，每次收到ICMP“不能分片”差错时（在上一节讨论的）就减小分组的长度。如果路由器发送的ICMP差错报文是新格式，包含出口的MTU，那么就用该MTU值来发送，否则就用下一个最小的MTU值来发送。正如RFC 1191[Mogul and Deering 1990]声明的那样，MTU值的个数是有限的，因此在我们的程序中有一些由近似值构成的表，取下一个最小MTU值来发送。</li>
</ul>
<h3 id="7-采用UDP的路径MTU发现"><a href="#7-采用UDP的路径MTU发现" class="headerlink" title="7. 采用UDP的路径MTU发现"></a>7. 采用UDP的路径MTU发现</h3><p>看书</p>
<h3 id="8-UDP和ARP之间的交互作用"><a href="#8-UDP和ARP之间的交互作用" class="headerlink" title="8. UDP和ARP之间的交互作用"></a>8. UDP和ARP之间的交互作用</h3><p>看书</p>
<h3 id="9-最大UDP数据报长度"><a href="#9-最大UDP数据报长度" class="headerlink" title="9. 最大UDP数据报长度"></a>9. 最大UDP数据报长度</h3><ul>
<li>理论上，IP数据报的最大长度是65535字节，这是由IP首部16比特总长度字段所限制的。去除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最长长度为65507字节。但是，大多数实现所提供的长度比这个最大值小。</li>
<li>两个限制因素。<ul>
<li>第一，应用程序可能会受到其程序接口的限制。socket API提供了一个可供应用程序调用的函数，以设置接收和发送缓存的长度。对于UDP socket，这个长度与应用程序可以读写的最大UDP数据报的长度直接相关。现在的大部分系统都默认提供了可读写大于8192字节的UDP数据报（使用这个默认值是因为8192是NFS读写用户数据数的默认值）。</li>
<li>第二个限制来自于TCP/IP的内核实现。可能存在一些实现特性（或差错），使IP数据报长度小于65535字节。</li>
</ul>
</li>
</ul>
<h3 id="10-UDP服务器的设计"><a href="#10-UDP服务器的设计" class="headerlink" title="10. UDP服务器的设计"></a>10. UDP服务器的设计</h3><ol>
<li>客户IP地址及端口号<ul>
<li>当一个应用程序接收到UDP数据报时，操作系统必须告诉它是谁发送了这份消息，即源IP地址和端口号。</li>
<li>这个特性允许一个交互UDP服务器对多个客户进行处理。给每个发送请求的客户发回应答。</li>
</ul>
</li>
<li>目的IP地址<ul>
<li>一些应用程序需要知道数据报是发送给谁的，即目的IP地址。</li>
</ul>
</li>
<li>UDP输入队列<ul>
<li>大多数UDP服务器是交互服务器。这意味着，单个服务器进程对单个UDP端口上（服务器上的名知端口）的所有客户请求进行处理。</li>
</ul>
</li>
<li>限制本地IP地址</li>
<li>限制远端IP地址</li>
<li>每个端口有多个接收者</li>
</ol>
<h1 id="十二-广播和多播"><a href="#十二-广播和多播" class="headerlink" title="十二 广播和多播"></a>十二 广播和多播</h1><h3 id="1-引言-10"><a href="#1-引言-10" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>有三种IP地址：单播地址、广播地址和多播地址。</li>
<li>广播和多播仅应用于UDP，它们对需将报文同时传往多个接收者的应用来说十分重要。TCP是一个面向连接的协议，它意味着分别运行于两主机（由IP地址确定）内的两进程（由端口号确定）间存在一条连接。</li>
<li>单播<ul>
<li>通常每个以太网帧仅发往单个目的主机，目的地址指明单个接收接口，因而称为单播(unicast)。在这种方式下，任意两个主机的通信不会干扰网内其他主机（可能引起争夺共享信道的情况除外）。</li>
</ul>
</li>
<li>广播<ul>
<li>有时一个主机要向网上的所有其他主机发送帧，这就是广播。</li>
</ul>
</li>
<li>多播(multicast)<ul>
<li>处于单播和广播之间：帧仅传送给属于多播组的多个主机。</li>
</ul>
</li>
</ul>
<h3 id="2-广播"><a href="#2-广播" class="headerlink" title="2. 广播"></a>2. 广播</h3><ol>
<li>受限的广播<ul>
<li>受限的广播地址是255.255.255.255。</li>
<li>在任何情况下，路由器都不转发目的地址为受限的广播地址的数据报，这样的数据报仅出现在本地网络中。</li>
</ul>
</li>
<li>指向网络的广播<ul>
<li>指向网络的广播地址是主机号为全1的地址。</li>
<li>A类网络广播地址为netid.255.255.255，其中netid为A类网络的网络号。</li>
</ul>
</li>
<li>指向子网的广播<ul>
<li>指向子网的广播地址为主机号为全1且有特定子网号的地址。</li>
<li>例如，如果路由器收到发往128.1.2.255的数据报，当B类网络128.1的子网掩码为255.255.255.0时，该地址就是指向子网的广播地址；但如果该子网的掩码为255.255.254.0，该地址就不是指向子网的广播地址。</li>
</ul>
</li>
<li>指向所有子网的广播<ul>
<li>指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开。</li>
<li>指向所有子网的广播地址的子网号及主机号为全1。</li>
<li>例如，如果目的子网掩码为255.255.255.0，那么IP地址128.1.255.255是一个指向所有子网的广播地址。然而，如果网络没有划分子网，这就是一个指向网络的广播。</li>
<li>当前的看法[Almquist 1993]是这种广播是陈旧过时的，更好的方式是使用多播而不是对所有子网的广播。</li>
</ul>
</li>
</ol>
<h3 id="3-ping-255-255-255-255"><a href="#3-ping-255-255-255-255" class="headerlink" title="3. ping 255.255.255.255"></a>3. ping 255.255.255.255</h3><ul>
<li>ping 把点分十进制IP转换成二进制的函数是 inet_addr(),这个函数对255.255.255.255返回-1，即出错</li>
</ul>
<p>###　4. 多播</p>
<ol>
<li>IP多播提供两类服务：<ul>
<li>向多个目的地址传送数据。有许多向多个接收者传送信息的应用：例如交互式会议系统和向多个接收者分发邮件或新闻。如果不采用多播，目前这些应用大多采用TCP来完成（向每个目的地址传送一个单独的数据复制）。然而，即使使用多播，某些应用可能继续采用TCP来保证它的可靠性。</li>
<li>客户对服务器的请求。例如，无盘工作站需要确定启动引导服务器。目前，这项服务是通过广播来提供的（正如第16章的BOOTP），但是使用多播可降低不提供这项服务主机的负担。</li>
</ul>
</li>
<li>多播组地址<ul>
<li>一些多播组地址被IANA确定为知名地址。它们也被当作永久主机组，这和TCP及UDP中的熟知端口相似。</li>
<li>例如，224.0.0.1代表“该子网内的所有系统组”，224.0.0.2代表“该子网内的所有路由器组”。多播地址224.0.1.1用作网络时间协议NTP，224.0.0.9用作RIP-2(见10.5节)，224.0.1.2用作SGI公司的dogfight应用。</li>
<li>D类IP地址被称为多播组地址。通过将其低位23 bit映射到相应以太网地址中便可实现多播组地址到以太网地址的转换。由于地址映射是不唯一的，因此需要其他的协议实现额外的数据报过滤。</li>
</ul>
</li>
</ol>
<h1 id="十三-IGMP-Internet组管理协议"><a href="#十三-IGMP-Internet组管理协议" class="headerlink" title="十三 IGMP:Internet组管理协议"></a>十三 IGMP:Internet组管理协议</h1><h3 id="1-引言-11"><a href="#1-引言-11" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>Internet组管理协议（IGMP）。它让一个物理网络上的所有系统知道主机当前所在的多播组。多播路由器需要这些信息以便知道多播数据报应该向哪些接口转发。</li>
<li>正如ICMP一样，IGMP也被当作IP层的一部分。IGMP报文通过IP数据报进行传输。不像我们已经见到的其他协议，IGMP有固定的报文长度，没有可选数据。</li>
<li>多播是一种将报文发往多个接收者的通信方式。在许多应用中，它比广播更好，因为多播降低了不参与通信的主机的负担。简单的主机成员报告协议(IGMP)是多播的基本模块。</li>
<li>多播还未解决的一个问题是在广域网内的多播。</li>
</ul>
<h3 id="2-IGMP报文"><a href="#2-IGMP报文" class="headerlink" title="2. IGMP报文"></a>2. IGMP报文</h3><ul>
<li><p>格式</p>
  <!-- ![19.IGMP报文.png](./img/19.IGMP报文.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/19.IGMP%E6%8A%A5%E6%96%87.png" class="" title="19.IGMP报文.png"></li>
<li><p>IGMP类型为1说明是由多播路由器发出的查询报文，为2说明是主机发出的报告报文。检验和的计算和ICMP协议相同。</p>
</li>
<li><p>组地址为D类IP地址。</p>
</li>
<li><p>这个需要的时候再看书吧，很多概念有点抽象</p>
</li>
</ul>
<h1 id="十四-DNS-域名系统"><a href="#十四-DNS-域名系统" class="headerlink" title="十四 DNS:域名系统"></a>十四 DNS:域名系统</h1><h3 id="1-引言-12"><a href="#1-引言-12" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>域名系统（DNS）是一种用于TCP/IP应用程序的分布式数据库，它提供主机名字和IP地址之间的转换及有关电子邮件的选路信息。</li>
<li>这里提到的分布式是指在Internet上的单个站点不能拥有所有的信息。每个站点（如大学中的系、校园、公司或公司中的部门）保留它自己的信息数据库，并运行一个服务器程序供Internet上的其他系统（客户程序）查询。</li>
<li>DNS提供了允许服务器和客户程序相互通信的协议。</li>
<li>从应用的角度上看，对DNS的访问是通过一个地址解析器（resolver）来完成的。在Unix主机中，该解析器主要是通过两个库函数gethostbyname(3)和gethostbyaddr(3)来访问的，它们在编译应用程序时与应用程序连接在一起。</li>
</ul>
<h3 id="2-DNS基础"><a href="#2-DNS基础" class="headerlink" title="2. DNS基础"></a>2. DNS基础</h3><ul>
<li>DNS的名字空间和Unix的文件系统相似，也具有树型层次结构。  <!-- ![20.DNS层次结构.png](./img/20.DNS层次结构.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/20.DNS%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" class="" title="20.DNS层次结构.png"></li>
<li>DNS的一个基本特性是使用超高速缓存。即当一个名字服务器收到有关映射的信息（主机名字到IP地址）时，它会将该信息存放在高速缓存中。这样若以后遇到相同的映射请求，就能直接使用缓存中的结果而无需通过其他服务器查询。</li>
<li>7个普通域  <!-- ![21.普通域.png](./img/21.普通域.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/21.%E6%99%AE%E9%80%9A%E5%9F%9F.png" class="" title="21.普通域.png">

</li>
</ul>
<h3 id="3-DNS的报文格式"><a href="#3-DNS的报文格式" class="headerlink" title="3. DNS的报文格式"></a>3. DNS的报文格式</h3><ul>
<li>这个报文由12字节长的首部和4个长度可变的字段组成。  <!-- ![22.DNS报文.png](./img/22.DNS报文.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/22.DNS%E6%8A%A5%E6%96%87.png" class="" title="22.DNS报文.png"></li>
<li>DNS查询报文问题部分  <!-- ![23.DNS问题.png](./img/23.DNS问题.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/23.DNS%E9%97%AE%E9%A2%98.png" class="" title="23.DNS问题.png">
<ol>
<li>如何存储查询名 <!-- ![24.域名.png](./img/24.域名.png) -->
 <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/24.%E5%9F%9F%E5%90%8D.png" class="" title="24.域名.png"></li>
<li>查询类型 <!-- ![25.查询类型.png](./img/25.查询类型.png) -->
 <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/25.%E6%9F%A5%E8%AF%A2%E7%B1%BB%E5%9E%8B.png" class="" title="25.查询类型.png"></li>
<li>查询类通常是1，指互联网地址（某些站点也支持其他非IP地址）。</li>
</ol>
</li>
<li>所有的DNS查询和响应都有相同的报文格式。这个报文格式中包含查询请求和可能的回答资源记录、授权资源记录和附加资源记录。</li>
</ul>
<h3 id="4-名字解析器的配置文件-etc-resolv-conf"><a href="#4-名字解析器的配置文件-etc-resolv-conf" class="headerlink" title="4. 名字解析器的配置文件/etc/resolv.conf"></a>4. 名字解析器的配置文件/etc/resolv.conf</h3><h3 id="5-DNS的优化措施"><a href="#5-DNS的优化措施" class="headerlink" title="5. DNS的优化措施"></a>5. DNS的优化措施</h3><ul>
<li>指向域名的指针（减少报文的长度）、查询结果的高速缓存、in-addr.arpa域（查找IP地址对应的域名）以及返回的附加资源记录（避免主机重发同一查询请求）。</li>
</ul>
<h3 id="6-用-UDP-还是-TCP"><a href="#6-用-UDP-还是-TCP" class="headerlink" title="6. 用 UDP 还是 TCP"></a>6. 用 UDP 还是 TCP</h3><ul>
<li>DNS 服务器支持 TCP 和 UDP 两种协议的查询方式,而且端口都是53。而大多数的查询都是 UDP 查询的</li>
<li>一般需要 TCP 查询的 有两种情况:<ol>
<li>当查询数据多大以至于产生了数据截断(TC标志为1),这时,需要利用TCP的分片能力来进行数据传输(看TCP的相关章节)。</li>
<li>当主(master)服务器和辅(slave)服务器之间通信,辅服务器要拿到主服务器的 zone 信息的时候。</li>
</ol>
</li>
</ul>
<h1 id="十五-TFTP-简单文件传送协议"><a href="#十五-TFTP-简单文件传送协议" class="headerlink" title="十五 TFTP:简单文件传送协议"></a>十五 TFTP:简单文件传送协议</h1><h3 id="1-引言-13"><a href="#1-引言-13" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>TFTP(Trivial File Transfer Protocol)即简单文件传送协议，最初打算用于引导无盘系统（通常是工作站或X终端）。</li>
<li>和将在第27章介绍的使用TCP的文件传送协议（FTP）不同，为了保持简单和短小，TFTP将使用UDP。</li>
<li>TFTP的代码（和它所需要的UDP、IP和设备驱动程序）都能适合只读存储器。</li>
</ul>
<h3 id="2-协议"><a href="#2-协议" class="headerlink" title="2. 协议"></a>2. 协议</h3><ul>
<li>操作码|文件名|0|模式|0</li>
<li>TFTP报文的头两个字节表示操作码。对于读请求和写请求（WRQ）</li>
<li>文件名字段说明客户要读或写的位于服务器上的文件。这个文件字段以0字节作为结束</li>
<li>模式字段是一个ASCII码串netascii或octet（可大小写任意组合），同样以0字节结束。</li>
<li>停止等待协议<ul>
<li>以读一个文件作为例子，TFTP客户需要发送一个读请求说明要读的文件名和文件模式(mode)。如果这个文件能被这个客户读取，TFTP服务器就返回一个块编号为1的数据分组。TFTP客户又发送一个块编号为1的ACK。TFTP服务器随后发送块编号为2的数据。TFTP客户发回块编号为2的ACK。重复这个过程直到这个文件传送完。除了最后一个数据分组可含有不足512字节的数据，其他每个数据分组均含有512字节的数据。当TFTP客户收到一个不足512字节的数据分组，就知道它收到最后一个数据分组。</li>
<li>在写请求的情况下，TFTP客户发送WRQ指明文件名和模式。如果该文件能被该客户写，TFTP服务器就返回块编号为0的ACK包。该客户就将文件的头512字节以块编号为1发出。服务器则返回块编号为1的ACK。</li>
<li>这种类型的数据传输称为停止等待协议。它只用在一些简单的协议如TFTP中。</li>
</ul>
</li>
</ul>
<h3 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3. 安全性"></a>3. 安全性</h3><ul>
<li>在TFTP分组中并不提供用户名和口令。这是TFTP的一个特征（即“安全漏洞”）。</li>
<li>由于TFTP是设计用于系统引导进程，它不可能提供用户名和口令。</li>
<li>TFTP的这一特性被许多解密高手用于获取Unix口令文件的复制，然后来猜测用户口令。为防止这种类型的访问，目前大多数TFTP服务器提供了一个选项来限制只能访问特定目录下的文件（Unix系统中通常是/tftpboot）。这个目录中只包含无盘系统进行系统引导时所需的文件。</li>
</ul>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li>TFTP是一个简单的协议，适合于只读存储器，仅用于无盘系统进行系统引导。</li>
<li>它只使用几种报文格式，是一种停止等待协议。</li>
<li>TFTP服务器通过为每个客户提供一个新的UDP端口来提供并发。这允许不同的客户输入数据报，然后由服务器中的UDP模块根据目的端口号进行区分，而不是由服务器本身来进行区分。</li>
<li>TFTP协议没有提供安全特性。大多数执行指望TFTP服务器的系统管理员来限制客户的访问，只允许它们访问引导所必须的文件。</li>
<li>文件传输协议（FTP）是设计用于一般目的的、高吞吐量的文件传输。</li>
</ul>
<h1 id="十六-BOOTP-引导程序协议"><a href="#十六-BOOTP-引导程序协议" class="headerlink" title="十六 BOOTP:引导程序协议"></a>十六 BOOTP:引导程序协议</h1><h3 id="1-引言-14"><a href="#1-引言-14" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li><p>无盘系统，它在不知道自身IP地址的情况下，在进行系统引导时能够通过RARP来获取它的IP地址。</p>
</li>
<li><p>然而使用RARP有两个问题：</p>
<ul>
<li>（1）IP地址是返回的唯一结果；</li>
<li>（2）既然RARP使用链路层广播，RARP请求就不会被路由器转发（迫使每个实际网络设置一个RARP服务器）。</li>
</ul>
</li>
<li><p>本章将介绍一种用于无盘系统进行系统引导的替代方法，又称为引导程序协议，或BOOTP。</p>
</li>
<li><p>BOOTP使用UDP，且通常需与TFTP（参见第15章）协同工作。</p>
</li>
</ul>
<h3 id="2-BOOTP的分组格式"><a href="#2-BOOTP的分组格式" class="headerlink" title="2. BOOTP的分组格式"></a>2. BOOTP的分组格式</h3><ul>
<li>BOOTP 请求和应答均被封装在UDP数据报中，共300字节  <!-- ![26.BOOTP报文.png](./img/26.BOOTP报文.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/26.BOOTP%E6%8A%A5%E6%96%87.png" class="" title="26.BOOTP报文.png">

</li>
</ul>
<h3 id="3-BOOTP服务器的设计"><a href="#3-BOOTP服务器的设计" class="headerlink" title="3. BOOTP服务器的设计"></a>3. BOOTP服务器的设计</h3><ul>
<li>BOOTP客户通常固化在无盘系统只读存储器中</li>
<li>首先，BOOTP服务器将从它的熟知端口（67）读取UDP数据报。</li>
<li>它不同于RARP服务器，它必须读取类型字段为“RARP请求”的以太网帧。</li>
<li>BOOTP协议通过将客户的硬件地址放入BOOTP分组中，使得服务器很容易获取客户的硬件地址</li>
<li>具体再看书吧</li>
</ul>
<h3 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li>BOOTP使用UDP，它为引导无盘系统获得它的IP地址提供了除RARP外的另外一种选择。</li>
<li>BOOTP还能返回其他的信息，如路由器的IP地址、客户的子网掩码和名字服务器的IP地址。</li>
<li>既然BOOTP用于系统引导过程，一个无盘系统需要下列协议才能在只读存储器中完成：BOOTP、TFTP、UDP、IP和一个局域网的驱动程序。</li>
<li>BOOTP服务器比RARP服务器更易于实现，因为BOOTP请求和应答是在UDP数据报中，而不是特殊的数据链路层帧。一个路由器还能作为真正BOOTP服务器的代理，向位于不同网络的真正BOOTP服务器转发客户的BOOTP请求。</li>
</ul>
<h1 id="十七-TCP：传输控制协议"><a href="#十七-TCP：传输控制协议" class="headerlink" title="十七 TCP：传输控制协议"></a>十七 TCP：传输控制协议</h1><h3 id="1-引言-15"><a href="#1-引言-15" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>本章将介绍<ul>
<li>TCP为应用层提供的服务</li>
<li>TCP首部中的各个字段。</li>
</ul>
</li>
</ul>
<h3 id="2-TCP的服务"><a href="#2-TCP的服务" class="headerlink" title="2. TCP的服务"></a>2. TCP的服务</h3><ul>
<li>TCP提供一种面向连接的、可靠的字节流服务。</li>
<li>面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。</li>
<li>TCP对字节流的内容不作任何解释。TCP不知道传输的数据字节流是二进制数据，还是ASCII字符、EBCDIC字符或者其他类型数据。对字节流的解释由TCP连接双方的应用层解释。</li>
</ul>
<h3 id="3-TCP的首部"><a href="#3-TCP的首部" class="headerlink" title="3. TCP的首部"></a>3. TCP的首部</h3><!-- ![27.TCP.png](./img/27.TCP.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/27.TCP.png" class="" title="27.TCP.png">
<!-- ![28.TCP首部.png](./img/28.TCP首部.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/28.TCP%E9%A6%96%E9%83%A8.png" class="" title="28.TCP首部.png">
<ul>
<li>20字节固定加变长选项</li>
<li>16位源端口/目的端口：每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端应用进程。</li>
<li>序号：序号用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。</li>
<li>确认序号：包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加1。只有ACK标志（下面介绍）为1时确认序号字段才有效。</li>
<li>首部长度给出首部中32 bit字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占4bit，因此TCP最多有60字节的首部。</li>
<li>6位标志位  <!-- ![29.标志位.png](./img/29.标志位.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/29.%E6%A0%87%E5%BF%97%E4%BD%8D.png" class="" title="29.标志位.png"></li>
<li>TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16 bit字段，因而窗口大小最大为65535字节。</li>
<li>检验和覆盖了整个的TCP报文段：TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。TCP检验和的计算和UDP检验和的计算相似，使用如11章所述的一个伪首部。</li>
<li>只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。</li>
<li>最常见的可选字段是最长报文大小，又称为MSS(Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。</li>
<li>TCP报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有TCP首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</li>
</ul>
<h3 id="4-TCP-保证可靠性的简单工作原理"><a href="#4-TCP-保证可靠性的简单工作原理" class="headerlink" title="4. TCP 保证可靠性的简单工作原理"></a>4. TCP 保证可靠性的简单工作原理</h3><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。这和 UDP 完全不同,应用程序产生的 数据报长度将保持不变。由TCP 传递给 IP 的信息单位称为报文段或段( segment)</li>
<li>当 TCP 发出一个段后,它启动一个定时器,等待目的端确认收到这个报文段。如果不能 及时收到一个确认,将重发这个报文段。</li>
<li>当 TCP 收到发自 TCP 连接另一端的数据,它将发送一个确认。这个确认不是立即发送,通常将推迟几分之一秒,</li>
<li>TCP 将保持它首部和数据的检验和。这是一个端到端的检验和,目的是检测数据在传输 过程中的任何变化。如果收到段的检验和有差错, TCP 将丢弃这个报文段和不确认收到此报文段(希望发端超时并重发)。</li>
<li>既然 TCP 报文段作为 IP 数据报来传输,而 IP 数据报的到达可能会失序,因此 TCP 报文段 的到达也可能会失序。如果必要, TCP 将对收到的数据进行重新排序,将收到的数据以正确的顺序交给应用层。</li>
<li>TCP 还能提供流量控制。TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</li>
<li>,TCP 中保持可靠性的方式就是超时重发,这是有道理的,虽然 TCP 也可以用各种各样的 ICMP 报文来处理这些,但是这也不是可靠的,最可靠的方式就是只要不得到确认,就重新发送数据报,直到得到对方的确认为止。</li>
</ol>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul>
<li>TCP将用户数据打包构成报文段；它发送数据后启动一个定时器；另一端对收到的数据进行确认，对失序的数据重新排序，丢弃重复数据；TCP提供端到端的流量控制，并计算和验证一个强制性的端到端检验和。</li>
<li>许多流行的应用程序如Telnet、Rlogin、FTP和SMTP都使用TCP。</li>
</ul>
<h1 id="十八-TCP连接的建立与终止"><a href="#十八-TCP连接的建立与终止" class="headerlink" title="十八 TCP连接的建立与终止"></a>十八 TCP连接的建立与终止</h1><h3 id="1-连接的建立与终止"><a href="#1-连接的建立与终止" class="headerlink" title="1. 连接的建立与终止"></a>1. 连接的建立与终止</h3><ul>
<li><p>三次握手建立连接</p>
<ul>
<li>C–&gt;S:SYN</li>
<li>S–&gt;C:SYN,ACK（ACK是回应上一个SYN）</li>
<li>C–&gt;S:ACK</li>
</ul>
</li>
<li><p>四次握手终止连接</p>
<ul>
<li>C–&gt;S:FIN</li>
<li>S–&gt;C:ACK（对FIN的）</li>
<li>S–&gt;C:FIN（处理未处理完的数据后）</li>
<li>C–&gt;:ACK(对FIN)<!-- ![30.连接建立与断开例子.png](./img/30.连接建立与断开例子.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/30.%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80%E4%BE%8B%E5%AD%90.png" class="" title="30.连接建立与断开例子.png">

</li>
</ul>
</li>
</ul>
<h3 id="2-连接建立的超时"><a href="#2-连接建立的超时" class="headerlink" title="2. 连接建立的超时"></a>2. 连接建立的超时</h3><ul>
<li>在SYN无相应时，客户间隔多长时间再发送一个SYN，试图建立连接。tcpdump实验输出第2个SYN与第1个的间隔是5.8秒，而第3个与第2个的间隔是24秒。</li>
<li>大多数伯克利系统将建立一个新连接的最长时间限制为75秒。超时后就放弃连接</li>
</ul>
<h3 id="3-最大报文段长度"><a href="#3-最大报文段长度" class="headerlink" title="3. 最大报文段长度"></a>3. 最大报文段长度</h3><ul>
<li>最大报文段长度（MSS）表示TCP传往另一端的最大块数据的长度。</li>
<li>当一个连接建立时，连接的双方都要通告各自的MSS。我们已经见过MSS都是1024。这导致IP数据报通常是40字节长：20字节的TCP首部和20字节的IP首部。</li>
</ul>
<h3 id="4-TCP的半关闭"><a href="#4-TCP的半关闭" class="headerlink" title="4. TCP的半关闭"></a>4. TCP的半关闭</h3><ul>
<li>就是四次握手关闭时，服务端对FIN相应ACK后，继续把剩余的数据发送，这时服务端处于close_wait状态，客户端处于半关闭状态</li>
<li>看范例，我对半关闭的理解是：告诉服务器自己的数据传完了，服务器单向传递数据</li>
</ul>
<h3 id="5-TCP的状态变迁图"><a href="#5-TCP的状态变迁图" class="headerlink" title="5. TCP的状态变迁图"></a>5. TCP的状态变迁图</h3><!-- ![TCP状态变迁图](./img/TCP状态变迁图.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/TCP%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81%E5%9B%BE.png" class="" title="TCP状态变迁图.png">
<ul>
<li><p>初看很乱，三次握手四次握手懂了后就能看明白了</p>
</li>
<li><p>2MSL等待状态</p>
<ul>
<li>TIME_WAIT状态也称为2MSL等待状态。</li>
<li>每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime）。它是任何报文段被丢弃前在网络内的最长时间。规定为2分钟，通常为30秒</li>
<li>这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</li>
<li>只有当另一端的进程完成这个关闭，我们这端才会从FIN_WAIT_2状态进入TIME_WAIT状态。</li>
</ul>
</li>
</ul>
<h3 id="6-复位报文段"><a href="#6-复位报文段" class="headerlink" title="6. 复位报文段"></a>6. 复位报文段</h3><ul>
<li>TCP首部中的RST比特是用于“复位”的。一般说来，无论何时一个报文段发往基准的连接（referenced connection）出现错误，TCP都会发出一个复位报文段（这里提到的“基准的连接”是指由目的IP地址和目的端口号以及源IP地址和源端口号指明的连接。这就是为什么RFC 793称之为插口）。</li>
<li>到不存在的端口的连接请求<ul>
<li>产生复位的一种常见情况是当连接请求到达时，目的端口没有进程正在听。</li>
<li>对于UDP，当一个数据报到达目的端口时，该端口没在使用，它将产生一个ICMP端口不可达的信息。而TCP则使用复位。</li>
</ul>
</li>
<li>异常终止一个连接<ul>
<li>终止一个连接的正常方式是一方发送FIN。有时这也称为有序释放（orderly release），因为在所有排队数据都已发送之后才发送FIN，正常情况下没有任何数据丢失。</li>
<li>但也有可能发送一个复位报文段而不是FIN来中途释放一个连接。有时称这为异常释放（abortive release）。</li>
</ul>
</li>
<li>检测半打开连接<ul>
<li>如果一方已经关闭或异常终止连接而另一方却还不知道，我们将这样的TCP连接称为半打开（Half-Open）的。任何一端的主机异常都可能导致发生这种情况。只要不打算在半打开连接上传输数据，仍处于连接状态的一方就不会检测另一方已经出现异常。</li>
<li>半打开连接的另一个常见原因是当客户主机突然掉电而不是正常的结束客户应用程序后再关机。</li>
<li>服务器主机重启后，我们重新接上电缆，并从客户向服务器发送另一行字符。由于服务器的TCP已经重新启动，它将丢失复位前连接的所有信息，因此它不知道数据报文段中提到的连接。TCP的处理原则是接收方以复位作为应答。</li>
</ul>
</li>
</ul>
<h3 id="7-同时打开、同时关闭"><a href="#7-同时打开、同时关闭" class="headerlink" title="7. 同时打开、同时关闭"></a>7. 同时打开、同时关闭</h3><ul>
<li>两个应用程序同时彼此执行主动打开的情况是可能的，尽管发生的可能性极小。</li>
<li>TCP是特意设计为了可以处理同时打开，对于同时打开它仅建立一条连接而不是两条连接（其他的协议族，最突出的是OSI运输层，在这种情况下将建立两条连接而不是一条连接）。</li>
<li>一个同时打开的连接需要交换4个报文段，比正常的三次握手多一个。（去掉最后的ACK再乘2）</li>
<li>双方都执行主动关闭也是可能的，TCP协议也允许这样的同时关闭（simultaneous close）。</li>
</ul>
<h1 id="十九-TCP的交互数据流"><a href="#十九-TCP的交互数据流" class="headerlink" title="十九 TCP的交互数据流"></a>十九 TCP的交互数据流</h1><h3 id="1-引言-16"><a href="#1-引言-16" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>一些有关TCP通信量的研究如[Caceres et al. 1991]发现<ul>
<li>如果按照分组数量计算，约有一半的TCP报文段包含成块数据（如FTP、电子邮件和Usenet新闻），另一半则包含交互数据（如Telnet和Rlogin）。</li>
<li>如果按字节计算，则成块数据与交互数据的比例约为90%和10%。这是因为成块数据的报文段基本上都是满长度（full-sized）的（通常为512字节的用户数据），而交互数据则小得多（上述研究表明Telnet和Rlogin分组中通常约90%左右的用户数据小于10个字节）。</li>
</ul>
</li>
<li>TCP需要同时处理这两类数据，但使用的处理算法则有所不同。</li>
</ul>
<h3 id="2-交互式输入"><a href="#2-交互式输入" class="headerlink" title="2. 交互式输入"></a>2. 交互式输入</h3><!-- ![按键回显服务器](./img/按键回显服务器.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/%E6%8C%89%E9%94%AE%E5%9B%9E%E6%98%BE%E6%9C%8D%E5%8A%A1%E5%99%A8.png" class="" title="按键回显服务器.png">
<ul>
<li>这样就会产生4个报文段：<br>  （1）来自客户的交互按键；<br>  （2）来自服务器的按键确认；<br>  （3）来自服务器的按键回显；<br>  （4）来自客户的按键回显确认。</li>
<li>我们一般可以将报文段2和3进行合并—按键确认与按键回显一起发送。(经受时延的确认,捎带)</li>
<li>对于交互性要求比较高的应用,TCP 给出两个策略来提高发送效率和减低网络负担:<ol>
<li>捎带 ACK。</li>
<li>Nagle 算法(一次尽量多 的发数据)。</li>
</ol>
</li>
</ul>
<h3 id="3-经受时延的确认"><a href="#3-经受时延的确认" class="headerlink" title="3. 经受时延的确认"></a>3. 经受时延的确认</h3><ul>
<li>通常TCP在接收到数据时并不立即发送ACK；相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送（有时称这种现象为数据捎带ACK）。绝大多数实现采用的时延为200 ms，也就是说，TCP将以最大200 ms的时延等待是否有数据一起发送。</li>
<li>Host Requirements RFC声明TCP需要实现一个经受时延的ACK，但时延必须小于500 ms。</li>
</ul>
<h3 id="4-Nagle算法-一次尽量多的发数据"><a href="#4-Nagle算法-一次尽量多的发数据" class="headerlink" title="4. Nagle算法(一次尽量多的发数据)"></a>4. Nagle算法(一次尽量多的发数据)</h3><ul>
<li><p>在前一节我们看到,在一个Rlogin连接上客户一般每次发送一个字节到服务器，这就产生了一些41字节长的分组：20字节的IP首部、20字节的TCP首部和1个字节的数据。在局域网上，这些小分组（被称为微小分组（tinygram））通常不会引起麻烦，因为局域网一般不会出现拥塞。但在广域网上，这些小分组则会增加拥塞出现的可能。一种简单和好的方法就是采用RFC 896 [Nagle 1984]中所建议的Nagle算法。</p>
</li>
<li><p>形象的来说：Nagle 算法是说,当主机 A 给主机 B 发送了一个 TCP 数据报并进入等待主机 B 的 ACK 数据报的状态时,TCP 的输出缓冲区里面 只能有一个 TCP 数 据报,并且,这个数据报不断地收集后来的数据,整合成一个大的数据报,等到 B 主机的 ACK 包一到,就把这些 数据“一股脑”的发送出去。虽然这样的描述有些 不准确,但还算形象和易于理解,我们同样可以体会到这个策略对于低减网络负担的 好处。</p>
</li>
<li><p>该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。</p>
</li>
<li><p>该算法的优越之处在于它是自适应的：确认到达得越快，数据也就发送得越快。</p>
</li>
<li><p>在以太网上一个字节被发送、确认和回显的平均往返时间约为16ms。为了产生比这个速度更快的数据，我们每秒键入的字符必须多于60个。这表明在局域网环境下两个主机之间发送数据时很少使用这个算法。</p>
</li>
<li><p>在编写插口程序的时候,可以通过 TCP_NODELAY 来关闭这个算法。并且,使用这个算法看情况的,比如基于 TCP 的 X 窗口协议,如果处理鼠标事件时还是用这个算法,那么“延迟”可就非常大了。</p>
</li>
</ul>
<h3 id="5-小结-1"><a href="#5-小结-1" class="headerlink" title="5. 小结"></a>5. 小结</h3><ol>
<li>交互数据总是以小于最大报文段长度的分组发送。在Rlogin中通常只有一个字节从客户发送到服务器。Telnet允许一次发送一行输入数据，但是目前大多数实现仍然发送一个字节。</li>
<li>对于这些小的报文段，接收方使用经受时延的确认方法来判断确认是否可被推迟发送，以便与回送数据一起发送。这样通常会减少报文段的数目，尤其是对于需要回显用户输入字符的Rlogin会话。</li>
<li>在较慢的广域网环境中，通常使用Nagle算法来减少这些小报文段的数目。这个算法限制发送者任何时候只能有一个发送的小报文段未被确认。</li>
</ol>
<h1 id="二十-TCP的成块数据流"><a href="#二十-TCP的成块数据流" class="headerlink" title="二十 TCP的成块数据流"></a>二十 TCP的成块数据流</h1><h3 id="1-引言-17"><a href="#1-引言-17" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>TFTP使用了停止等待协议。数据发送方在发送下一个数据块之前需要等待接收对已发送数据的确认。</li>
<li>本章我们将介绍TCP所使用的被称为滑动窗口协议的另一种形式的流量控制方法。该协议允许发送方在停止并等待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。</li>
<li>我们还将介绍TCP的PUSH标志，该标志在前面的许多例子中都出现过。</li>
<li>此外，我们还要介绍慢启动，TCP使用该技术在一个连接上建立数据流</li>
<li>最后介绍成块数据流的吞吐量。</li>
</ul>
<h3 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2. 滑动窗口"></a>2. 滑动窗口</h3><ul>
<li>滑动窗口可视化表达  <!-- ![TCP滑动窗口](./img/TCP滑动窗口.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" class="" title="TCP滑动窗口.png">
<ul>
<li>在这个图中，我们将字节从1至11进行标号。接收方通告的窗口称为提出的窗口（offered window），它覆盖了从第4字节到第9字节的区域，表明接收方已经确认了包括第3字节在内的数据，且通告窗口大小为6。</li>
<li>窗口大小是与确认序号相对应的。发送方计算它的可用窗口，该窗口表明多少数据可以立即被发送。</li>
</ul>
</li>
<li>当接收方确认数据后，这个滑动窗口不时地向右移动。窗口两个边沿的相对运动增加或减少了窗口的大小。我们使用三个术语来描述窗口左右边沿的运动：<ul>
<li>称窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时。</li>
<li>当窗口右边沿向右移动时将允许发送更多的数据，我们称之为窗口张开。这种现象发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时。</li>
<li>当右边沿向左移动时，我们称之为窗口收缩。Host Requirements RFC强烈建议不要使用这种方式。但TCP必须能够在某一端产生这种情况时进行处理。第22.3节给出了这样的一个例子，一端希望向左移动右边沿来收缩窗口，但没能够这样做。<!-- ![窗口移动](./img/窗口移动.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/%E7%AA%97%E5%8F%A3%E7%A7%BB%E5%8A%A8.png" class="" title="窗口移动.png"></li>
<li>因为窗口的左边沿受另一端发送的确认序号的控制，因此不可能向左边移动。如果接收到一个指示窗口左边沿向左移动的ACK，则它被认为是一个重复ACK</li>
<li>如果左边沿到达右边沿，则称其为一个零窗口，此时发送方不能够发送任何数据。</li>
</ul>
</li>
<li>一个例子  <!-- ![滑动窗口例子](./img/滑动窗口例子.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%BE%8B%E5%AD%90.png" class="" title="滑动窗口例子.png">
<ol>
<li>发送方不必发送一个全窗口大小的数据。</li>
<li>来自接收方的一个报文段确认数据并把窗口向右边滑动。这是因为窗口的大小是相对于确认序号的。</li>
<li>正如从报文段7到报文段8中变化的那样，窗口的大小可以减小，但是窗口的右边沿却不能够向左移动。</li>
<li>接收方在发送一个ACK前不必等待窗口被填满。在前面我们看到许多实现每收到两个报文段就会发送一个ACK。</li>
</ol>
</li>
</ul>
<h3 id="3-窗口大小"><a href="#3-窗口大小" class="headerlink" title="3. 窗口大小"></a>3. 窗口大小</h3><ul>
<li>由接收方提供的窗口的大小通常可以由接收进程控制，这将影响TCP的性能。</li>
<li>4.2BSD默认设置发送和接受缓冲区的大小为2048个字节。在4.3BSD中双方被增加为4096个字节。SunOS 4.1.3、BSD/386和SVR4仍然使用4096字节的默认大小。其他的系统，如Solaris 2.2、4.4BSD和AIX3.2则使用更大的默认缓存大小，如8192或16384等。</li>
<li>插口API允许进程设置发送和接收缓存的大小。接收缓存的大小是该连接上所能够通告的最大窗口大小。有一些应用程序通过修改插口缓存大小来增加性能。</li>
</ul>
<h3 id="4-PUSH标志"><a href="#4-PUSH标志" class="headerlink" title="4. PUSH标志"></a>4. PUSH标志</h3><ul>
<li>发送方使用该标志通知接收方将所收到的数据全部提交给接收进程。这里的数据包括与PUSH一起传送的数据以及接收方TCP已经为接收进程收到的其他数据。</li>
<li>通过允许客户应用程序通知其TCP设置PUSH标志，客户进程通知TCP在向服务器发送一个报文段时不要因等待额外数据而使已提交数据在缓存中滞留。</li>
<li>类似地，当服务器的TCP接收到一个设置了PUSH标志的报文段时，它需要立即将这些数据递交给服务器进程而不能等待判断是否还会有额外的数据到达。</li>
<li>然而，目前大多数的API没有向应用程序提供通知其TCP设置PUSH标志的方法。的确，许多实现程序认为PUSH标志已经过时，一个好的TCP实现能够自行决定何时设置这个标志。</li>
<li>如果待发送数据将清空发送缓存，则大多数的源于伯克利的实现能够自动设置PUSH标志。这意味着我们能够观察到每个应用程序写的数据均被设置了PUSH标志，因为数据在写的时候就立即被发送。</li>
<li>由于源于伯克利的实现一般从不将接收到的数据推迟交付给应用程序，因此它们忽略所接收的PUSH标志。</li>
</ul>
<h3 id="5-慢启动"><a href="#5-慢启动" class="headerlink" title="5. 慢启动"></a>5. 慢启动</h3><ul>
<li>迄今为止，在所有的例子中，发送方一开始便向网络发送多个报文段，直至达到接收方通告的窗口大小为止。当发送方和接收方处于同一个局域网时，这种方式是可以的。但是如果在发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题。一些中间路由器必须缓存分组，并有可能耗尽存储器的空间。这种连接方式是如何严重降低了TCP连接的吞吐量的。</li>
<li>现在，TCP需要支持一种被称为“慢启动(slow start)”的算法。该算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。</li>
<li>慢启动为发送方的TCP增加了另一个窗口：拥塞窗口(congestion window)，记为cwnd。当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小）。每收到一个ACK，拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加）。发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。</li>
<li>发送方开始时发送一个报文段，然后等待ACK。当收到该ACK时，拥塞窗口从1增加为2，即可以发送两个报文段。当收到这两个报文段的ACK时，拥塞窗口就增加为4。这是一种指数增加的关系。</li>
<li>在某些点上可能达到了互联网的容量，于是中间路由器开始丢弃分组。这就通知发送方它的拥塞窗口开得过大。当我们在下一章讨论TCP的超时和重传机制时，将会看到它们是怎样对拥塞窗口起作用的。现在，我们来观察一个实际中的慢启动。  <!-- ![慢启动例子](./img/慢启动例子.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/%E6%85%A2%E5%90%AF%E5%8A%A8%E4%BE%8B%E5%AD%90.png" class="" title="慢启动例子.png">
<ul>
<li>我们观察到发送方发送一个长度为512字节的报文段，然后等待ACK。该ACK在716 ms后收到。这个时间是一个往返时间的指示。于是拥塞窗口增加了2个报文段，且又发送了两个报文段。当收到报文段5的ACK后，拥塞窗口增加为3。此时尽管可发送多达3个报文段，可是在下一个ACK收到之前，只发送了2个报文段。</li>
</ul>
</li>
</ul>
<h3 id="6-成块数据的吞吐量"><a href="#6-成块数据的吞吐量" class="headerlink" title="6. 成块数据的吞吐量"></a>6. 成块数据的吞吐量</h3><h5 id="带宽时延乘积"><a href="#带宽时延乘积" class="headerlink" title="带宽时延乘积"></a>带宽时延乘积</h5><ul>
<li>可以计算通道的容量为：<br>  capacity (bit) = bandwidth (b/s) × round-trip time (s)<ul>
<li>一般称之为带宽时延乘积。这个值依赖于网络速度和两端的RT T，可以有很大的变动。</li>
</ul>
</li>
</ul>
<h5 id="拥塞"><a href="#拥塞" class="headerlink" title="拥塞"></a>拥塞</h5><ul>
<li>当数据到达一个大的管道（如一个快速局域网）并向一个较小的管道（如一个较慢的广域网）发送时便会发生拥塞。当多个输入流到达一个路由器，而路由器的输出流小于这些输入流的总和时也会发生拥塞。</li>
</ul>
<h3 id="7-紧急方式"><a href="#7-紧急方式" class="headerlink" title="7. 紧急方式"></a>7. 紧急方式</h3><ul>
<li><p>TCP提供了“紧急方式(urgent mode)”，它使一端可以告诉另一端有些具有某种方式的“紧急数据”已经放置在普通的数据流中。另一端被通知这个紧急数据已被放置在普通数据流中，由接收方决定如何处理。</p>
</li>
<li><p>不幸的是，许多实现不正确地称TCP的紧急方式为带外数据(out-of-band data)。如果一个应用程序确实需要一个独立的带外信道，第二个TCP连接是达到这个目的的最简单的方法（许多运输层确实提供许多人认为的那种真正的带外数据：使用同一个连接的独立的逻辑数据通道作为正常的数据通道。这是TCP所没有提供的）。</p>
</li>
<li><p>TCP的紧急方式与带外数据之间的混淆，也是因为主要的编程接口（插口API）将TCP的紧急方式映射为称为带外数据的插口。</p>
</li>
<li><p>紧急方式有什么作用呢？</p>
<ul>
<li>两个最常见的例子是Telnet和Rlogin。当交互用户键入中断键时，使用紧急方式来完成这个功能。</li>
<li>另一个例子是FTP，当交互用户放弃一个文件的传输时.</li>
</ul>
</li>
<li><p>Telnet和Rlogin从服务器到客户使用紧急方式是因为在这个方向上的数据流很可能要被客户的TCP停止（也即，它通告了一个大小为0的窗口）。但是如果服务器进程进入了紧急方式，尽管它不能够发送任何数据，服务器TCP也会立即发送紧急指针和URG标志。当客户TCP接收到这个通知时就会通知客户进程，于是客户可以从服务器读取其输入、打开窗口并使数据流动。</p>
</li>
</ul>
<h1 id="二十一-TCP的超时与重传"><a href="#二十一-TCP的超时与重传" class="headerlink" title="二十一 TCP的超时与重传"></a>二十一 TCP的超时与重传</h1><h3 id="1-引言-18"><a href="#1-引言-18" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>TCP提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。<ul>
<li>但数据和确认都有可能会丢失。TCP通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据。</li>
<li>对任何实现而言，关键之处就在于超时和重传的策略，即怎样决定超时间隔和如何确定重传的频率。</li>
</ul>
</li>
<li>我们已经看到过两个超时和重传的例子：<ol>
<li>在6.5节的ICMP端口不能到达的例子中，看到TFTP客户使用UDP实现了一个简单的超时和重传机制：假定5秒是一个适当的时间间隔，并每隔5秒进行重传；</li>
<li>在向一个不存在的主机发送ARP的例子中（第4.5节），我们看到当TCP试图建立连接的时候，在每个重传之间使用一个较长的时延来重传SYN。</li>
</ol>
</li>
<li>对每个连接，TCP管理4个不同的定时器。<ol>
<li>重传定时器使用于当希望收到另一端的确认。在本章我们将详细讨论这个定时器以及一些相关的问题，如拥塞避免。</li>
<li>坚持(persist)定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。第22章将讨论这个问题。</li>
<li>保活(keepalive)定时器可检测到一个空闲连接的另一端何时崩溃或重启。第23章将描述这个定时器。</li>
<li>2MSL定时器测量一个连接处于TIME_WA IT状态的时间。我们在18.6节对该状态进行了介绍。</li>
</ol>
</li>
</ul>
<h3 id="2-超时与重传的简单例子"><a href="#2-超时与重传的简单例子" class="headerlink" title="2. 超时与重传的简单例子"></a>2. 超时与重传的简单例子</h3><!-- ![超时与重传例子](./img/超时与重传例子.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0%E4%BE%8B%E5%AD%90.png" class="" title="超时与重传例子.png">
<ul>
<li>第1、2和3行表示正常的TCP连接建立的过程，第4行是“hello,world”（12个字符加上回车和换行）的传输过程，第5行是其确认。接着我们从svr4拔掉了以太网电缆，第6行表示“and hi”将被发送。第7~18行是这个报文段的12次重传过程，而第19行则是发送方的TCP最终放弃并发送一个复位信号的过程。</li>
<li>现在检查连续重传之间不同的时间差，它们取整后分别为1、3、6、12、24、48和多个64秒。</li>
<li>这个倍乘关系被称为“指数退避(exponential backoff)”。</li>
</ul>
<h3 id="3-往返时间测量"><a href="#3-往返时间测量" class="headerlink" title="3. 往返时间测量"></a>3. 往返时间测量</h3><ul>
<li>TCP超时与重传中最重要的部分就是对一个给定连接的往返时间（RTT）的测量。由于路由器和网络流量均会变化，因此我们认为这个时间可能经常会发生变化，TCP应该跟踪这些变化并相应地改变其超时时间。</li>
<li>首先TCP必须测量在发送一个带有特别序号的字节和接收到包含该字节的确认之间的RTT。数据报文段和ACK之间通常并没有一一对应的关系。在上章的例子中，这意味着发送方可以测量到的一个RTT，是在发送报文段4（第1<del>1024字节）和接收报文段7（对1</del>1024字节的ACK）之间的时间，用M表示所测量到的RTT。</li>
</ul>
<h3 id="4-拥塞避免算法"><a href="#4-拥塞避免算法" class="headerlink" title="4. 拥塞避免算法"></a>4. 拥塞避免算法</h3><ul>
<li>在第20章介绍的慢启动算法是在一个连接上发起数据流的方法，但有时我们会达到中间路由器的极限，此时分组将被丢弃。拥塞避免算法是一种处理丢失分组的方法。</li>
<li>该算法假定由于分组受到损坏引起的丢失是非常少的（远小于1%），因此分组丢失就意味着在源主机和目的主机之间的某处网络上发生了拥塞。</li>
<li>有两种分组丢失的指示：<ul>
<li>发生超时，如果使用超时作为拥塞指示，则需要使用一个好的RTT算法，</li>
<li>接收到重复的确认</li>
</ul>
</li>
<li>拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来作到这一点。在实际中这两个算法通常在一起实现。</li>
<li>拥塞避免算法和慢启动算法需要对每个连接维持两个变量：一个拥塞窗口cwnd和一个慢启动门限ssthresh。这样得到的算法的工作过程如下：<ol>
<li>对一个给定的连接，初始化cwnd为1个报文段，ssthresh为65535个字节。</li>
<li>TCP输出例程的输出不能超过cwnd和接收方通告窗口的大小。拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估计，而后者则与接收方在该连接上的可用缓存大小有关。</li>
<li>当拥塞发生时（超时或收到重复确认），ssthresh被设置为当前窗口大小的一半（cwnd和接收方通告窗口大小的最小值，但最少为2个报文段）。此外，如果是超时引起了拥塞，则cwnd被设置为1个报文段（这就是慢启动）。</li>
<li>当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于我们是否正在进行慢启动或拥塞避免。如果cwnd小于或等于ssthresh，则正在进行慢启动，否则正在进行拥塞避免。慢启动一直持续到我们回到当拥塞发生时所处位置的半时候才停止（因为我们记录了在步骤2中给我们制造麻烦的窗口大小的一半），然后转为执行拥塞避免。</li>
</ol>
</li>
<li>慢启动算法初始设置cwnd为1个报文段，此后每收到一个确认就加1。这会使窗口按指数方式增长：发送1个报文段，然后是2个，接着是4个……。</li>
<li>拥塞避免算法要求每次收到一个确认时将cwnd增加1/cwnd。与慢启动的指数增加比起来，这是一种加性增长(additive increase)。我们希望在一个往返时间内最多为cwnd增加1个报文段（不管在这个RTT中收到了多少个ACK），然而慢启动将根据这个往返时间中所收到的确认的个数增加cwnd。</li>
<li>慢启动和拥塞避免的可视化描述  <!-- ![慢启动和拥塞避免的可视化描述](./img/慢启动和拥塞避免的可视化描述.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/%E6%85%A2%E5%90%AF%E5%8A%A8%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8F%8F%E8%BF%B0.png" class="" title="慢启动和拥塞避免的可视化描述.png">
<ul>
<li>在该图中，假定当cwnd为32个报文段时就会发生拥塞。于是设置ssthresh为16个报文段，而cwnd为1个报文段。在时刻0发送了一个报文段，并假定在时刻1接收到它的ACK，此时cwnd增加为2。接着发送了2个报文段，并假定在时刻2接收到它们的ACK，于是cwnd增加为4（对每个ACK增加1次）。这种指数增加算法一直进行到在时刻3和4之间收到8个ACK后cwnd等于ssthresh时才停止，从该时刻起，cwnd以线性方式增加，在每个往返时间内最多增加1个报文段。</li>
</ul>
</li>
</ul>
<h3 id="5-快速重传与快速恢复算法"><a href="#5-快速重传与快速恢复算法" class="headerlink" title="5. 快速重传与快速恢复算法"></a>5. 快速重传与快速恢复算法</h3><ul>
<li>在收到一个失序的报文段时，TCP立即需要产生一个ACK（一个重复的ACK）。这个重复的ACK不应该被迟延。该重复的ACK的在于让对方知道收到一个失序的报文段，并告诉对方自己希望收到的序号。</li>
<li>由于我们不知道一个重复的ACK是由一个丢失的报文段引起的，还是由于仅仅出现了几个报文段的重新排序，因此我们等待少量重复的ACK到来。假如这只是一些报文段的重新排序，则在重新排序的报文段被处理并产生一个新的ACK之前，只可能产生1~2个重复的ACK。如果一连串收到3个或3个以上的重复ACK，就非常可能是一个报文段丢失了</li>
<li>于是我们就重传丢失的数据报文段，而无需等待超时定时器溢出。这就是快速重传算法。接下来执行的不是慢启动算法而是拥塞避免算法。这就是快速恢复算法。</li>
<li>没有执行慢启动的原因是由于收到重复的ACK不仅仅告诉我们一个分组丢失了。由于接收方只有在收到另一个报文段时才会产生重复的ACK，而该报文段已经离开了网络并进入了接收方的缓存。也就是说，在收发两端之间仍然有流动的数据，而我们不想执行慢启动来突然减少数据流。</li>
<li>这个算法通常按如下过程进行实现：<ul>
<li>当收到第3个重复的ACK时，将ssthresh设置为当前拥塞窗口cwnd的一半。重传丢失的报文段。设置cwnd为ssthresh加上3倍的报文段大小。</li>
<li>每次收到另一个重复的ACK时，cwnd增加1个报文段大小并发送1个分组（如果新的cwnd允许发送）。</li>
<li>当下一个确认新数据的ACK到达时，设置cwnd为ssthresh（在第1步中设置的值）。这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认。另外，这个ACK也应该是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半。</li>
</ul>
</li>
</ul>
<h3 id="6-重新分组"><a href="#6-重新分组" class="headerlink" title="6. 重新分组"></a>6. 重新分组</h3><ul>
<li>当TCP超时并重传时，它不一定要重传同样的报文段。相反，TCP允许进行重新分组而发送一个较大的报文段，这将有助于提高性能（当然，这个较大的报文段不能够超过接收方声明的MSS）。在协议中这是允许的，因为TCP是使用字节序号而不是报文段序号来进行识别它所要发送的数据和进行确认。</li>
</ul>
<h1 id="二十二-TCP的坚持定时器"><a href="#二十二-TCP的坚持定时器" class="headerlink" title="二十二 TCP的坚持定时器"></a>二十二 TCP的坚持定时器</h1><h3 id="1-引言-19"><a href="#1-引言-19" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>我们已经看到TCP通过让接收方指明希望从发送方接收的数据字节数（即窗口大小）来进行流量控制。如果窗口大小为0会发生什么情况呢？这将有效地阻止发送方传送数据，直到窗口变为非0为止。</li>
<li>TCP不对ACK报文段进行确认，TCP只确认那些包含有数据的ACK报文段。<ul>
<li>如果一个确认丢失了，则双方就有可能因为等待对方而使连接终止：接收方等待接收数据（因为它已经向发送方通告了一个非0的窗口），而发送方在等待允许它继续发送数据的窗口更新。</li>
</ul>
</li>
<li>为防止这种死锁情况的发生，发送方使用一个坚持定时器(persist timer)来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为窗口探查(window probe)。</li>
<li>本章<ul>
<li>我们将讨论窗口探查和坚持定时器</li>
<li>还将讨论与坚持定时器有关的糊涂窗口综合症。</li>
</ul>
</li>
</ul>
<h3 id="2-窗口探查"><a href="#2-窗口探查" class="headerlink" title="2. 窗口探查"></a>2. 窗口探查</h3><ul>
<li>窗口为0，从而使客户停止发送任何其他的数据。这就引起客户设置其坚持定时器。如果在该定时器时间到时客户还没有接收到一个窗口更新，它就探查这个空的窗口以决定窗口更新是否丢失。</li>
<li>请注意客户发出的窗口探查之间的时间间隔。在收到一个大小为0的窗口通告后的第1个间隔为4.949秒，下一个间隔是4.996秒，随后的间隔分别约为6,12,24,48和60秒。</li>
<li>坚持状态与第21章中介绍的重传超时之间一个不同的特点就是TCP从不放弃发送窗口探查。这些探查每隔60秒发送一次，这个过程将持续到或者窗口被打开，或者应用进程使用的连接被终止。</li>
</ul>
<h3 id="3-糊涂窗口综合症"><a href="#3-糊涂窗口综合症" class="headerlink" title="3. 糊涂窗口综合症"></a>3. 糊涂窗口综合症</h3><ul>
<li>如果发生这种情况，则少量的数据将通过连接进行交换，而不是满长度的报文段</li>
<li>这个问题可以归结为小包的问题，就是由于发送端和接收端上的处理不一致，导致网络上产生很多的小包，之前也介绍过避免网络上产生过多小包的措施，比如Nagle算法。在滑动窗口机制下，如果发送端和接收端速率很不一致，也会产生这种比较犯傻的状态：发送方发送的数据，只要一个大大的头部，携带数据很少。</li>
<li>对于接收端来讲，如果接收很慢，一次接收1个字节或者几个字节，这个时候接收端 缓冲区很快就会被填满，然后窗口通告为0字节，这个时候发送端停止发送，应用程序收上去1个字节后，发出窗口通告为1字节，发送方收到通告之后，发出1个字节的数据，这样周而复始，传输效率会非常低。</li>
<li>该现象可发生在两端中的任何一端：接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通告），而发送方也可以发送少量的数据（而不是等待其他的数据以便发送一个大的报文段）。可以在任何一端采取措施避免出现糊涂窗口综合症的现象。<ol>
<li>接收方不通告小窗口。通常的算法是接收方不通告一个比当前窗口大的窗口（可以为0），除非窗口可以增加一个报文段大小（也就是将要接收的MSS）或者可以增加接收方缓存空间的一半，不论实际有多少。</li>
<li>发送方避免出现糊涂窗口综合症的措施是只有以下条件之一满足时才发送数据:<br> (a)可以发送一个满长度的报文段；<br> (b)可以发送至少是接收方通告窗口大小一半的报文段；<br> (c)可以发送任何数据并且不希望接收ACK（也就是说，我们没有还未被确认的数据）或者该连接上不能使用Nagle算法。</li>
</ol>
</li>
</ul>
<h1 id="二十三-TCP的保活定时器"><a href="#二十三-TCP的保活定时器" class="headerlink" title="二十三 TCP的保活定时器"></a>二十三 TCP的保活定时器</h1><h3 id="1-引言-20"><a href="#1-引言-20" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>如果TCP连接的双方都没有向对方发送数据，则在两个TCP模块之间不交换任何信息。</li>
<li>我们可以启动一个客户与服务器建立一个连接，然后离去数小时、数天、数个星期或者数月，而连接依然保持。中间路由器可以崩溃和重启，电话线可以被挂断再连通，但是只要两端的主机没有被重启，则连接依然保持建立。<ul>
<li>这意味着两个应用进程—客户进程或服务器进程—都没有使用应用级的定时器来检测非活动状态，而这种非活动状态可以导致应用进程中的任何一个终止其活动。</li>
<li>然而，许多时候一个服务器希望知道客户主机是否崩溃并关机或者崩溃又重新启动。许多实现提供的保活定时器可以提供这种能力。</li>
</ul>
</li>
<li>保活并不是TCP规范中的一部分。Host Requirements RFC提供了3个不使用保活定时器的理由：<br>  (1)在出现短暂差错的情况下，这可能会使一个非常好的连接释放掉；<br>  (2)它们耗费不必要的带宽；<br>  (3)在按分组计费的情况下会在互联网上花掉更多的钱。<ul>
<li>然而，许多实现提供了保活定时器。</li>
</ul>
</li>
<li>保活定时器是一个有争论的功能。许多人认为如果需要，这个功能不应该在TCP中提供，而应该由应用程序来完成。</li>
<li>保活功能主要是为服务器应用程序提供的。服务器应用程序希望知道客户主机是否崩溃，从而可以代表客户使用资源。许多版本的Rlogin和Telnet服务器默认使用这个选项。</li>
<li>一个说明现在需要使用保活功能的常见例子是当个人计算机用户使用TCP/IP向一个使用Telnet的主机注册时。如果在一天结束时，他们仅仅关闭了电源而没有注销，那么便会留下一个半开放的连接。一个半开放连接发送数据会导致返回一个复位，但那是在来自正在发送数据的客户端。如果客户已经消失了，使得在服务器上留下一个半开放连接，而服务器又在等待来自客户的数据，则服务器将永远等待下去。保活功能就是试图在服务器端检测到这种半开放的连接。</li>
</ul>
<h3 id="2-描述"><a href="#2-描述" class="headerlink" title="2. 描述"></a>2. 描述</h3><ul>
<li><p>通常都是服务器设置这个功能。如果双方都特别需要了解对方是否已经消失，则双方都可以使用这个选项,Telnet和Rlogin中，只有服务器设置了这个选项，而客户则没有</p>
</li>
<li><p>如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段（我们将在随后的例子中看到这个探查报文段看起来像什么）。客户主机必须处于以下4个状态之一。</p>
<ol>
<li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常工作的。服务器在两小时以后将保活定时器复位。如果在两个小时定时器到时间之前有应用程序的通信量通过此连接，则定时器在交换数据后的未来2小时再复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务器将不能够收到对探查的响应，并在75秒后超时。服务器总共发送10个这样的探查，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。</li>
<li>客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与状态2之间的区别，它所能发现的就是没有收到探查的响应。</li>
</ol>
</li>
<li><p>一个被人们不断讨论的关于保活选项的问题就是两个小时的空闲时间是否可以改变。通常他们希望该数值可以小得多，处在分钟的数量级。正如我们在附录E看到的，这个值通常可以改变，但是在该附录所描述的所有系统中，保活间隔时间是系统级的变量，因此改变它会影响到所有使用该功能的用户。</p>
</li>
</ul>
<h1 id="二十四-TCP的未来和性能"><a href="#二十四-TCP的未来和性能" class="headerlink" title="二十四 TCP的未来和性能"></a>二十四 TCP的未来和性能</h1><h3 id="1-引言-21"><a href="#1-引言-21" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>本章讨论TCP的一些修改建议，这些建议可以使TCP在高速率环境中获得最大的吞吐量。</li>
<li>首先要讨论前面已经碰到过的路径MTU发现机制，本章主要关注它如何与TCP协同工作。这个机制通常可以使TCP为非本地的连接使用大于536字节的MTU，从而增加吞吐量。</li>
<li>接着介绍长肥管道(long fat pipe)，也就是那些具有很大的带宽时延乘积的网络，以及TCP在这些网络上所具有的局限性。<ul>
<li>为处理长肥管道，我们描述两个新的TCP选项：窗口扩大选项（用来增加TCP的最大窗口，使之超过65535字节）和时间戳选项。</li>
<li>后面这个选项可以使TCP对报文段进行更加精确的RTT测量，还可以在高速率下对可能发生的序号回绕提供保护。</li>
</ul>
</li>
<li>我们还将介绍建议的T/TCP，这是为增加事务功能而对TCP进行的修改。通信的事务模式以客户的请求将被服务器应答的响应为主要特征。这是客户服务器计算的常见模型。T/TCP的目的就是减少两端交换的报文段数量，避免三次握手和使用4个报文段进行连接的关闭，从而使客户可以在一个RTT和处理请求所必需的时间内收到服务器的应答。</li>
<li>这些新选项（路径MTU发现、窗口扩大选项、时间戳选项和T/TCP）中令人印象最深刻的就是它们与现有的TCP实现能够向后兼容，即包括这些新选项的系统仍然可以与原有的旧系统进行交互。除了在一个ICMP报文中为路径MTU发现增加了一个额外字段之外，这些新的选项只需要在那些需要使用它们的端系统中进行实现。</li>
</ul>
<h3 id="2-路径MTU发现"><a href="#2-路径MTU发现" class="headerlink" title="2. 路径MTU发现"></a>2. 路径MTU发现</h3><ul>
<li><p>TCP的路径MTU发现按如下方式进行：在连接建立时，TCP使用输出接口或对端声明的MSS中的最小MTU作为起始的报文段大小。路径MTU发现不允许TCP超过对端声明的MSS。如果对端没有指定一个MSS，则默认为536。</p>
</li>
<li><p>一旦选定了起始的报文段大小，在该连接上的所有被TCP发送的IP数据报都将被设置DF比特。如果某个中间路由器需要对一个设置了DF标志的数据报进行分片，它就丢弃这个数据报</p>
<h3 id="3-长肥管道"><a href="#3-长肥管道" class="headerlink" title="3. 长肥管道"></a>3. 长肥管道</h3></li>
<li><p>在20章中，我们把一个连接的容量表示为如下，并称之为带宽时延乘积。也可称它为两端的管道大小。<br>  capacity(b) = bandwidth(b/s) × round - triptime(s)</p>
</li>
<li><p>具有大的带宽时延乘积的网络被称为长肥网络（Long Fat Network，即LFN，发音为“elefan(t)s”），而一个运行在LFN上的TCP连接被称为长肥管道。</p>
</li>
<li><p>管道可以被水平拉长（一个长的RT T），或被垂直拉高（较高的带宽），或向两个方向拉伸。使用长肥管道会遇到多种问题。</p>
</li>
<li><p>千兆比网络</p>
<ul>
<li>在千兆比速率下，时延限制占据了主要地位，而带宽不再成为限制。</li>
<li>时延主要是由光速引起的，而且不能够被减小（除非爱因斯坦是错误的）。当我们考虑到分组需要建立和终止一个连接时，这个固定时延起的作用就更糟糕了。千兆比网络会引起一些需要不同看待的连网观点。</li>
</ul>
</li>
</ul>
<h3 id="4-窗口扩大选项"><a href="#4-窗口扩大选项" class="headerlink" title="4. 窗口扩大选项"></a>4. 窗口扩大选项</h3><ul>
<li>窗口扩大选项使TCP的窗口定义从16 bit增加为32 bit。这并不是通过修改TCP首部来实现的，TCP首部仍然使用16 bit，而是通过定义一个选项实现对16 bit的扩大操作(scaling operation)来完成的。于是TCP在内部将实际的窗口大小维持为32 bit的值。</li>
</ul>
<h3 id="5-时间戳选项"><a href="#5-时间戳选项" class="headerlink" title="5. 时间戳选项"></a>5. 时间戳选项</h3><ul>
<li>时间戳选项使发送方在每个报文段中放置一个时间戳值。接收方在确认中返回这个数值，从而允许发送方为每一个收到的ACK计算RTT（我们必须说“每一个收到的ACK”而不是“每一个报文段”，是因为TCP通常用一个ACK来确认多个报文段）。我们提到过目前许多实现为每一个窗口只计算一个RTT，对于包含8个报文段的窗口而言这是正确的。然而，较大的窗口大小则需要进行更好的RTT计算。</li>
</ul>
<h3 id="6-T-TCP：为事务用的TCP扩展"><a href="#6-T-TCP：为事务用的TCP扩展" class="headerlink" title="6. T/TCP：为事务用的TCP扩展"></a>6. T/TCP：为事务用的TCP扩展</h3><ul>
<li>TCP提供的是一种虚电路方式的运输服务。一个连接的生存时间包括三个不同的阶段：建立、数据传输和终止。这种虚电路服务非常适合诸如远程注册和文件传输之类的应用。</li>
<li>但是，还有出现其他的应用进程被设计成使用事务服务。一个事务(transaction)就是符合下面这些特征的一个客户请求及其随后的服务器响应。<ol>
<li>应该避免连接建立和连接终止的开销，在可能的时候，发送一个请求分组并接收一个应答分组。</li>
<li>等待时间应当减少到等于RTT与SPT之和。其中RTT(Round-Trip Time)为往返时间，而SPT(Server Processing Time)则是服务器处理请求的时间。</li>
<li>服务器应当能够检测出重复的请求，并且当收到一个重复的请求时不重新处理事务（避免重新处理意味着服务器不必再次处理请求，而是返回保存的、与该请求对应的应答）。</li>
</ol>
</li>
<li>如今一个应用程序设计人员面对的一种选择是使用TCP还是UDP。TCP提供了过多的事务特征，而UDP提供的则不够。通常应用程序使用UDP来构造（避免TCP连接的开销），而许多需要的特征（如动态超时和重传、拥塞避免等）被放置在应用层，一遍又一遍的重新设计和实现。</li>
<li>一个较好的解决方法是提供一个能够提供足够多的事务处理功能的运输层。我们在本节所介绍的事务协议被称为T/TCP。</li>
<li>TCP为处理事务而需要进行的两个改动是避免三次握手和缩短WAIT_TIME状态。T/TCP通过使用加速打开来避免三次握手</li>
</ul>
<h1 id="二十五-SNMP-简单网络管理协议"><a href="#二十五-SNMP-简单网络管理协议" class="headerlink" title="二十五 SNMP:简单网络管理协议"></a>二十五 SNMP:简单网络管理协议</h1><h3 id="1-引言-22"><a href="#1-引言-22" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li><p>随着网络技术的飞速发展，网络的数量也越来越多。而网络中的设备来自各个不同的厂家，如何管理这些设备就变得十分重要。本章的内容就是介绍管理这些设备的标准。</p>
</li>
<li><p>基于TCP/IP的网络管理包含两个部分：</p>
<ol>
<li>网络管理站（也叫管理进程，manager）<ul>
<li><ul>
<li>管理站一般都是带有彩色监视器的工作站，可以显示所有被管设备的状态(例如连接是否掉线、各种连接上的流量状况等)。</li>
</ul>
</li>
</ul>
</li>
<li>被管的网络单元（也叫被管设备）<ul>
<li>被管设备种类繁多，例如：路由器、X终端、终端服务器和打印机等。</li>
<li>这些被管设备的共同点就是都运行TCP/IP协议。</li>
<li>被管设备端和管理相关的软件叫做代理程序(agent)或代理进程。</li>
</ul>
</li>
</ol>
</li>
<li><p>管理进程和代理进程之间的通信可以有两种方式。</p>
<ol>
<li>一种是管理进程向代理进程发出请求，询问一个具体的参数值（例如：你产生了多少个不可达的ICMP端口？）。它还可以按要求改变代理进程的参数值（例如：把默认的IP TTL值改为64）。</li>
<li>另外一种方式是代理进程主动向管理进程报告有某些重要的事件发生（例如：一个连接口掉线了）。</li>
</ol>
</li>
<li><p>基于TCP/IP的网络管理包含3个组成部分：</p>
<ol>
<li>一个管理信息库MIB（Management Information Base）。<ul>
<li>管理信息库包含所有代理进程的所有可被查询和修改的参数。</li>
</ul>
</li>
<li>关于MIB的一套公用的结构和表示符号。叫做管理信息结构SMI（Structure of Management Information）。<ul>
<li>SMI定义计数器是一个非负整数，它的计数范围是0~4294 967 295，当达到最大值时，又从0开始计数。</li>
</ul>
</li>
<li>管理进程和代理进程之间的通信协议，叫做简单网络管理协议SNMP（Simple Network Management Protocol）。<ul>
<li>尽管可以在运输层采用各种各样的协议，但是在SNMP中，用得最多的协议还是UDP。</li>
</ul>
</li>
</ol>
</li>
<li><p>本章</p>
<ul>
<li>首先介绍管理进程和代理进程之间的协议</li>
<li>然后讨论参数的数据类型。</li>
</ul>
</li>
</ul>
<h3 id="2-协议-1"><a href="#2-协议-1" class="headerlink" title="2. 协议"></a>2. 协议</h3><ul>
<li>关于管理进程和代理进程之间的交互信息，SNMP定义了5种报文：<ol>
<li>get-request操作：从代理进程处提取一个或多个参数值。</li>
<li>get-next-request操作：从代理进程处提取一个或多个参数的下一个参数值（关于“下一个（next）”的含义将在后面的章节中介绍）。</li>
<li>set-request操作：设置代理进程的一个或多个参数值。</li>
<li>get-response操作：返回的一个或多个参数值。这个操作是由代理进程发出的。它是前面3中操作的响应操作。</li>
<li>trap操作：代理进程主动发出的报文，通知管理进程有某些事情发生。</li>
</ol>
<ul>
<li>前面的3个操作是由管理进程向代理进程发出的。后面两个是代理进程发给管理进程的<!-- ![SNMP5种操作](./img/SNMP5种操作.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/SNMP5%E7%A7%8D%E6%93%8D%E4%BD%9C.png" class="" title="SNMP5种操作.png"></li>
</ul>
</li>
<li>前4种操作是简单的请求-应答方式（也就是管理进程发出请求，代理进程应答响应），而且在SNMP中往往使用UDP协议，可能发生管理进程和代理进程之间数据报丢失的情况。因此一定要有超时和重传机制。</li>
<li>管理进程发出的前面3种操作采用UDP的161端口。代理进程发出的Tr ap操作采用UDP的162端口。由于收发采用了不同的端口号，所以一个系统可以同时为管理进程和代理进程</li>
<li>封装成UDP数据报的5种操作的SNMP报文格式。  <!-- ![SNMP报文](./img/SNMP报文.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/SNMP%E6%8A%A5%E6%96%87.png" class="" title="SNMP报文.png">

</li>
</ul>
<h3 id="3-管理信息结构"><a href="#3-管理信息结构" class="headerlink" title="3. 管理信息结构"></a>3. 管理信息结构</h3><ul>
<li>SNMP中有一些自己的数据类型。有点多，有需要再看书吧。</li>
</ul>
<h3 id="4-对象标识符"><a href="#4-对象标识符" class="headerlink" title="4. 对象标识符"></a>4. 对象标识符</h3><ul>
<li>对象标识是一种数据类型，它指明一种“授权”命名的对象。“授权”的意思就是这些标识不是随便分配的，它是由一些权威机构进行管理和分配的。</li>
<li>对象标识是一个整数序列，以点（“.”）分隔。这些整数构成一个树型结构，类似于DNS或Unix的文件系统。对象标识从树的顶部开始，顶部没有标识，以root表示（这和Unix中文件系统的树遍历方向非常类似）。</li>
<li>下图显示了在SNMP中用到的这种树型结构。所有的MIB变量都从1.3.6.1.2.1这个标识开始。  <!-- ![SNMP对象标识](./img/SNMP对象标识.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/SNMP%E5%AF%B9%E8%B1%A1%E6%A0%87%E8%AF%86.png" class="" title="SNMP对象标识.png">

</li>
</ul>
<h3 id="5-管理信息库介绍"><a href="#5-管理信息库介绍" class="headerlink" title="5. 管理信息库介绍"></a>5. 管理信息库介绍</h3><ul>
<li>所谓管理信息库，或者MIB，就是所有代理进程包含的、并且能够被管理进程进行查询和设置的信息的集合。</li>
<li>如上图所示，MIB被划分为若干个组，如system、interfaces、at（地址转换）和ip组等。</li>
<li>在本节，我们仅仅讨论UDP组中的变量。这个组比较简单，它包含几个变量和一个表格。  <!-- ![SNMP之UDP组结构](./img/SNMP之UDP组结构.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/SNMP%E4%B9%8BUDP%E7%BB%84%E7%BB%93%E6%9E%84.png" class="" title="SNMP之UDP组结构.png"></li>
<li>在该组中，包含4个简单变量和1个由两个简单变量组成的表格。  <!-- ![UDP组下简单变量](./img/UDP组下简单变量.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/UDP%E7%BB%84%E4%B8%8B%E7%AE%80%E5%8D%95%E5%8F%98%E9%87%8F.png" class="" title="UDP组下简单变量.png">
  <!-- ![UDPtable中的变量](./img/UDPtable中的变量.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/UDPtable%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F.png" class="" title="UDPtable中的变量.png">

</li>
</ul>
<h3 id="6-实例标识"><a href="#6-实例标识" class="headerlink" title="6. 实例标识"></a>6. 实例标识</h3><ul>
<li>当对MIB变量进行操作，如查询和设置变量的值时，必须对MIB的每个变量进行标识。首先，只有叶子结点是可操作的。SNMP没法处理表格的一整行或一整列。mib、udp、udpTable和udpEntry就不是叶子结点。udpTable里面的数据是叶子节点。</li>
</ul>
<h1 id="二十六-Telnet和Rlogin-远程登录"><a href="#二十六-Telnet和Rlogin-远程登录" class="headerlink" title="二十六 Telnet和Rlogin:远程登录"></a>二十六 Telnet和Rlogin:远程登录</h1><h3 id="1-引言-23"><a href="#1-引言-23" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>远程登录（Remote Login）是Internet上最广泛的应用之一。我们可以先登录（即注册）到一台主机然后再通过网络远程登录到任何其他一台网络主机上去，而不需要为每一台主机连接一个硬件终端（当然必须有登录帐号）。</li>
<li>在TCP/IP网络上，有两种应用提供远程登录功能。<ol>
<li>Telnet是标准的提供远程登录功能的应用，几乎每个TCP/IP的实现都提供这个功能。它能够运行在不同操作系统的主机之间。Telnet通过客户进程和服务器进程之间的选项协商机制，从而确定通信双方可以提供的功能特性。</li>
<li>Rlogin起源于伯克利Unix，开始它只能工作在Unix系统之间，现在已经可以在其他操作系统上运行。</li>
</ol>
</li>
<li>远程登录采用客户-服务器模式。下图显示的是一个Telnet客户和服务器的典型连接图（对于Rlogin的客户和服务器连接图，我们可以画得更加简单）。  <!-- ![Telnet登录](./img/Telnet登录.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/Telnet%E7%99%BB%E5%BD%95.png" class="" title="Telnet登录.png">
<ol>
<li>Telnet客户进程同时和终端用户和TCP/IP协议模块进行交互。通常我们所键入的任何信息的传输是通过TCP连接，连接的任何返回信息都输出到终端上。</li>
<li>Telnet服务器进程经常要和一种叫做“伪终端设备”（pseudo-terminal device）打交道，至少在Unix系统下是这样的。<ul>
<li>这就使得对于登录外壳(shell)进程来讲，它是被Telnet服务器进程直接调用的，而且任何运行在登录外壳进程处的程序都感觉是直接和一个终端进行交互。</li>
<li>对于像满屏编辑器这样的应用来讲，就像直接在和终端打交道一样。</li>
<li>实际上，如何对服务器进程的登录外壳进程进行处理，使得它好像在直接和终端交互，往往是编写远程登录服务器进程程序中最困难的方面之一。</li>
</ul>
</li>
<li>仅仅使用了一条TCP连接。由于客户进程必须多次和服务器进程进行通信（反之亦然），这就必然需要某些方法，来描绘在连接上传输的命令和用户数据。我们在后面的内容中会介绍Telnet和Rlogin是如何处理这个问题的。</li>
<li>注意在上图中，我们用虚线框把终端驱动进程和伪终端驱动进程框了起来。在TCP/IP实现中，虚线框的内容一般是操作系统内核的一部分。Telnet客户进程和服务器进程一般只是属于用户应用程序。</li>
<li>把服务器进程的登录外壳进程画出来的目的是为了说明：当我们想登录到系统的时候，必须要有一个帐号，Telnet和Rlogin都是如此。</li>
</ol>
</li>
<li>现在，不断有新的Telnet选项被添加到Telnet中去，这就使得Telnet实现的源代码数量大大增加，而Rlogin依然变化不大，还是比较简单。</li>
<li>远程登录不是那种有大量数据报传输的应用。正如我们前面讲到的一样，客户进程和服务器进程交互的分组大多比较小。[Paxson 1993]发现客户进程发出的字节数（用户在终端上键入的信息）和服务器进程端发出的字节数的数量之比是 1:20。这是因为我们在终端上键入的一条短命令往往令服务器进程端产生很多输出。</li>
</ul>
<h3 id="2-Rlogin协议"><a href="#2-Rlogin协议" class="headerlink" title="2. Rlogin协议"></a>2. Rlogin协议</h3><h5 id="1-应用进程的启动"><a href="#1-应用进程的启动" class="headerlink" title="1. 应用进程的启动"></a>1. 应用进程的启动</h5><ul>
<li>Rlogin的客户进程和服务器进程使用一个TCP连接。当普通的TCP连接建立完毕之后，客户进程和服务器进程之间将发生下面所述的动作。<ul>
<li>客户进程给服务器进程发送4个字符串：<br>  （a）一个字节的0；<br>  （b）用户登录进客户进程主机的登录名，以一个字节的0结束；<br>  （c）登录服务器进程端主机的登录名，以一个字节的0结束；<br>  （d）用户终端类型名，紧跟一个正斜杠“/”，然后是终端速率，以一个字节的0结束。<ul>
<li>在这里需要两个登录名字，这是因为用户登录客户和服务器的名称有可能不一样。由于大多满屏应用程序需要知道终端类型，所以终端类型也必须发送到服务器进程。发送终端速率的原因是因为有些应用随着速率的改变，它的操作也有所变化。例如vi编辑器，当速率比较小的时候，它的工作窗口也变小。所以它不能永远保持同样大小的窗口。</li>
</ul>
</li>
<li>服务器进程返回一个字节的0。</li>
<li>服务器进程可以选择是否要求用户输入口令。这个步骤的数据交互没有什么特别的协议，而被当作是普通的数据进行传输。服务器进程给客户进程发送一个字符串（显示在客户进程的屏幕上），通常是password:。如果在一定的限定时间内（通常是60秒）客户进程没有输入口令，服务器进程将关闭该连接。</li>
<li>通常可以在服务器进程的主目录(home directory)下生成一个文件（通常叫 .rhosts），该文件的某些行记录了一个主机名和用户名。如果从该文件中已经记录的主机上用已经记录的用户名进行登录，服务器进程将不提示我们输入口令。但是很多关于安全性的文献，如[Curry 1992]，强烈建议不要采用这种方法，因为这存在安全漏洞。</li>
<li>如果提示输入口令，那么我们输入的口令将以明文的形式发送到服务器进程。我们所键入的每个字符都是以明文的格式传输的。所以某人只要能够截取网络上的原始传输的分组，他就可以截获用户口令。针对这个问题，新版本的Rlogin客户程序，例如4.4BSD版本的客户程序，第一次采用了Kerberos安全模型。Kerberos安全模型可以避免用户口令以明文的形式在网络上传输。当然，这要求服务器进程也支持Kerberos（[Curry 1992]详细描述了Kerberos安全模型）。</li>
<li>服务器进程通常要给客户进程发送请求，询问终端的窗口大小（将在后面解释）。</li>
</ul>
</li>
<li>客户进程每次给服务器进程发送一个字节的内容，并且接收服务器进程的所有返回信息。同样我们也采用了Nagle算法，该算法可以保证在速率较低的网络上，若干输入字节以单个TCP报文段传输。操作其实很简单：用户键入的所有东西被发送到服务器，服务器发送给客户的任何信息返回到用户的屏幕上。</li>
</ul>
<h5 id="2-流量控制"><a href="#2-流量控制" class="headerlink" title="2. 流量控制"></a>2. 流量控制</h5><ul>
<li>默认情况下，流量控制是由Rlogin的客户进程完成的。客户进程能够识别用户键入的STO P和STA RT的ASCII字符（Control_S和Control_Q），并且终止或启动终端的输出。</li>
<li>如果不是这样，每次我们为终止终端输出而键入的Control_S字符将沿网络传输到服务器进程，这时服务器进程将停止往网络上写数据。但是在写操作终止之前，服务器进程可能已经往网络上写了一窗口的输出数据。也就是说，在输出停止之前，成千上万的数据字节还将在屏幕上显示。  <!-- ![Rlogin流量控制](./img/Rlogin流量控制.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/Rlogin%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png" class="" title="Rlogin流量控制.png"></li>
<li>对于一个交互式用户来讲，Control_S字符的响应延时是较大的。</li>
</ul>
<h3 id="3-Telnet协议"><a href="#3-Telnet协议" class="headerlink" title="3. Telnet协议"></a>3. Telnet协议</h3><ul>
<li>Telnet协议可以工作在任何主机（例如，任何操作系统）或任何终端之间。</li>
<li>定义了一种通用字符终端叫做网络虚拟终端NVT（Network Virtual Terminal）。NVT是虚拟设备，连接的双方，即客户机和服务器，都必须把它们的物理终端和NVT进行相互转换。也就是说，不管客户进程终端是什么类型，操作系统必须把它转换为NVT格式。同时，不管服务器进程的终端是什么类型，操作系统必须能够把NVT格式转换为终端所能够支持的格式。</li>
</ul>
<!-- ![rlogin和telnet的不同特性](./img/rlogin和telnet的不同特性.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/rlogin%E5%92%8Ctelnet%E7%9A%84%E4%B8%8D%E5%90%8C%E7%89%B9%E6%80%A7.png" class="" title="rlogin和telnet的不同特性.png">

<h1 id="二十七-FTP-文件传送协议"><a href="#二十七-FTP-文件传送协议" class="headerlink" title="二十七 FTP:文件传送协议"></a>二十七 FTP:文件传送协议</h1><h3 id="1-引言-24"><a href="#1-引言-24" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>FTP是另一个常见的应用程序。它是用于文件传输的Internet标准。</li>
<li>我们必须分清文件传送（file transfer）和文件存取(file access)之间的区别，前者是FTP提供的，后者是如NFS（Sun的网络文件系统）等应用系统提供的。</li>
<li>由FTP提供的文件传送是将一个完整的文件从一个系统复制到另一个系统中。要使用FTP，就需要有登录服务器的注册帐号，或者通过允许匿名FTP的服务器来使用</li>
<li>与Telnet类似，FTP最早的设计是用于两台不同的主机，这两个主机可能运行在不同的操作系统下、使用不同的文件结构、并可能使用不同字符集。但不同的是，Telnet获得异构性是强制两端都采用同一个标准：使用7比特ASCII码的NVT。而FTP是采用另一种方法来处理不同系统间的差异。FTP支持有限数量的文件类型（ASCII，二进制，等等）和文件结构（面向字节流或记录）。</li>
</ul>
<h3 id="2-FTP协议"><a href="#2-FTP协议" class="headerlink" title="2. FTP协议"></a>2. FTP协议</h3><ul>
<li>FTP与我们已描述的另一种应用不同，它采用两个TCP连接来传输一个文件。<ul>
<li>控制连接以通常的客户服务器方式建立。服务器以被动方式打开众所周知的用于FTP的端口（21），等待客户的连接。客户则以主动方式打开TCP端口21，来建立连接。控制连接始终等待客户与服务器之间的通信。该连接将命令从客户传给服务器，并传回服务器的应答。</li>
<li>由于命令通常是由用户键入的，所以IP对控制连接的服务类型就是“最大限度地减小迟延”。</li>
<li>每当一个文件在客户与服务器之间传输时，就创建一个数据连接。（其他时间也可以创建，后面我们将说到）。</li>
<li>由于该连接用于传输目的，所以IP对数据连接的服务特点就是“最大限度提高吞吐量”。</li>
</ul>
</li>
</ul>
<h5 id="客户与服务器以及它们之间的连接情况。"><a href="#客户与服务器以及它们之间的连接情况。" class="headerlink" title="客户与服务器以及它们之间的连接情况。"></a>客户与服务器以及它们之间的连接情况。</h5><!-- ![FTP文件传输](./img/FTP文件传输.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/FTP%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" class="" title="FTP文件传输.png">
<ul>
<li>从图中可以看出，交互式用户通常不处理在控制连接中转换的命令和应答。这些细节均由两个协议解释器来完成。</li>
<li>标有“用户接口”的方框功能是按用户所需提供各种交互界面（全屏幕菜单选择，逐行输入命令，等等），并把它们转换成在控制连接上发送的FTP命令。</li>
</ul>
<h5 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h5><ul>
<li>FTP协议规范提供了控制文件传送与存储的多种选择。在以下四个方面中每一个方面都必须作出一个选择。</li>
</ul>
<ol>
<li><p>文件类型</p>
<ul>
<li>ASCII码文件类型（默认选择）文本文件以NVT ASCII码形式在数据连接中传输。这要求发方将本地文本文件转换成NVT ASCII码形式，而收方则将NVT ASCII码再还原成本地文本文件。其中，用NVT ASCII码传输的每行都带有一个回车，而后是一个换行。这意味着收方必须扫描每个字节，查找CR、LF对（我们在第15.2节见过的关于TFIP的ASCII码文件传输情况与此相同）。</li>
<li>EBCDIC文件类型该文本文件传输方式要求两端都是EBCDIC系统。</li>
<li>图像文件类型（也称为二进制文件类型）数据发送呈现为一个连续的比特流。通常用于传输二进制文件。</li>
<li>本地文件类型该方式在具有不同字节大小的主机间传输二进制文件。每一字节的比特数由发方规定。对使用8bit字节的系统来说，本地文件以8bit字节传输就等同于图像文件传输。</li>
</ul>
</li>
<li><p>格式控制，该选项只对ASCII和EBCDIC文件类型有效。</p>
<ul>
<li>非打印（默认选择）文件中不含有垂直格式信息。</li>
<li>远程登录格式控制文件含有向打印机解释的远程登录垂直格式控制。</li>
<li>Fortran回车控制每行首字符是Fortran格式控制符。</li>
</ul>
</li>
<li><p>结构</p>
<ul>
<li>文件结构（默认选择）文件被认为是一个连续的字节流。不存在内部的文件结构。</li>
<li>记录结构该结构只用于文本文件（ASCII或EBCDIC）。</li>
<li>页结构每页都带有页号发送，以便收方能随机地存储各页。该结构由TO PS-20操作系统提供（主机需求RFC不提倡采用该结构）。</li>
</ul>
</li>
<li><p>传输方式，它规定文件在数据连接中如何传输。</p>
<ul>
<li>流方式（默认选择）文件以字节流的形式传输。对于文件结构，发方在文件尾提示关闭数据连接。对于记录结构，有专用的两字节序列码标志记录结束和文件结束。</li>
<li>块方式文件以一系列块来传输，每块前面都带有一个或多个首部字节。</li>
<li>压缩方式一个简单的全长编码压缩方法，压缩连续出现的相同字节。在文本文件中常用来压缩空白串，在二进制文件中常用来压缩0字节（这种方式很少使用，也不受支持。现在有一些更好的文件压缩方法来支持FTP）。</li>
</ul>
</li>
</ol>
<ul>
<li>通常由Unix实现的FTP客户和服务器把我们的选择限制如下：<ul>
<li>类型：ASCII或图像。</li>
<li>格式控制：只允许非打印。</li>
<li>结构：只允许文件结构。</li>
<li>传输方式：只允许流方式。</li>
</ul>
</li>
</ul>
<h5 id="FTP命令"><a href="#FTP命令" class="headerlink" title="FTP命令"></a>FTP命令</h5><ul>
<li>命令和应答在客户和服务器的控制连接上以NVT ASCII码形式传送。这就要求在每行结尾都要返回CR、LF对（也就是每个命令或每个应答）。</li>
<li>常见的FTP命令  <!-- ![常见的FTP命令](./img/常见的FTP命令.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/%E5%B8%B8%E8%A7%81%E7%9A%84FTP%E5%91%BD%E4%BB%A4.png" class="" title="常见的FTP命令.png">

</li>
</ul>
<h5 id="FTP应答"><a href="#FTP应答" class="headerlink" title="FTP应答"></a>FTP应答</h5><ul>
<li>应答都是ASCII码形式的3位数字，并跟有报文选项。类似于HTTP的应答</li>
<li>应答代码第1位和第2位的含义。  <!-- ![FTP应答代码](./img/FTP应答代码.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/FTP%E5%BA%94%E7%AD%94%E4%BB%A3%E7%A0%81.png" class="" title="FTP应答代码.png"></li>
<li>第3位数字给出差错报文的附加含义。例如，这里是一些典型的应答，都带有一个可能的报文串。<ul>
<li>125   数据连接已经打开;传输开始。</li>
<li>200   就绪命令。</li>
<li>214   帮助报文(面向用户)。</li>
<li>331   用户名就绪,要求输入口令。</li>
<li>425   不能打开数据连接。</li>
<li>452   错写文件。</li>
<li>500   语法错误(未认可的命令)。</li>
<li>501   语法错误(无效参数)。</li>
<li>502   未实现的 MODE ( 方式命令 ) 类型。</li>
</ul>
</li>
</ul>
<h5 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h5><ul>
<li>数据连接有以下三大用途：<ol>
<li>从客户向服务器发送一个文件。</li>
<li>从服务器向客户发送一个文件。</li>
<li>从服务器向客户发送文件或目录列表。<!-- ![FTP连接](./img/FTP连接.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/FTP%E8%BF%9E%E6%8E%A5.png" class="" title="FTP连接.png"></li>
</ol>
</li>
<li>服务器总是执行数据连接的主动打开。通常服务器也执行数据连接的主动关闭，除非当客户向服务器发送流形式的文件时，需要客户来关闭连接（它给服务器一个文件结束的通知）。</li>
</ul>
<h1 id="二十八-SMTP-简单邮件传送协议"><a href="#二十八-SMTP-简单邮件传送协议" class="headerlink" title="二十八 SMTP:简单邮件传送协议"></a>二十八 SMTP:简单邮件传送协议</h1><h3 id="1-引言-25"><a href="#1-引言-25" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>一个用TCP/IP交换电子邮件的示意图。  <!-- ![TCPIP交换电子邮件](./img/TCPIP交换电子邮件.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/TCPIP%E4%BA%A4%E6%8D%A2%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6.png" class="" title="TCPIP交换电子邮件.png"></li>
<li>用户与用户代理（user agent）打交道，可能会有多个用户代理可供选择。常用的Unix上的用户代理包括MH，Berkeley Mail,Elm和Mush。</li>
<li>用TCP进行的邮件交换是由报文传送代理MTA（Message Transfer Agent）完成的。最普通的Unix系统中的MTA是Sendmail。用户通常不和MTA打交道，由系统管理员负责设置本地的MTA。通常，用户可以选择它们自己的用户代理。</li>
<li>本章研究在两个MTA之间如何用TCP交换邮件。我们不考虑用户代理的运行或实现。</li>
</ul>
<h3 id="2-SMTP协议"><a href="#2-SMTP协议" class="headerlink" title="2. SMTP协议"></a>2. SMTP协议</h3><ul>
<li>两个MTA之间用NVT ASCII进行通信。客户向服务器发出命令，服务器用数字应答码和可选的人可读字符串进行响应。这与上一章的FTP类似。</li>
<li>客户只能向服务器发送很少的命令：不到12个（相比较而言，FTP超过40个）。</li>
<li>电子邮件包括在两端（发送方和接收方）都有的一个用户代理以及两个或多个报文传送代理。</li>
<li>可以把一个邮件报文分成三个部分：信封、首部和正文。</li>
</ul>
<h1 id="二十九-网络文件系统"><a href="#二十九-网络文件系统" class="headerlink" title="二十九 网络文件系统"></a>二十九 网络文件系统</h1><h3 id="1-引言-26"><a href="#1-引言-26" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>NFS（网络文件系统），它为客户程序提供透明的文件访问。</li>
<li>NFS的基础是Sun RPC：远程过程调用。我们首先必须描述一下RPC。</li>
<li>客户程序使用NFS不需要做什么特别的工作，当NFS内核检测到被访问的文件位于一个NFS服务器时，就会自动产生一个访问该文件的RPC调用。</li>
<li>我们对NFS如何访问文件的细节并不感兴趣，只对它如何使用Internet的协议，尤其是UDP协议，感兴趣。</li>
</ul>
<h3 id="2-Sun远程过程调用"><a href="#2-Sun远程过程调用" class="headerlink" title="2. Sun远程过程调用"></a>2. Sun远程过程调用</h3><ul>
<li>般来说，客户发送命令给服务器，服务器向客户发送应答。目前为止，我们讨论过的所有应用程序—Ping，Traceroute，选路守护程序、以及DNS、TFTP、BOOTP、SNMP、Telnet、FTP和SMTP的客户和服务器—都是采用这种方式实现的。</li>
<li>远程过程调用RPC(Remote Procedure Call)是一种不同的网络程序设计方法。客户程序编写时只是调用了服务器程序提供的函数。这只是程序员所感觉到的，实际上发生了下面一些动作。<ol>
<li>当客户程序调用远程的过程时，它实际上只是调用了一个位于本机上的、由RPC程序包生成的函数。这个函数被称为客户残桩（stub）。客户残桩将过程的参数封装成一个网络报文，并且将这个报文发送给服务器程序。</li>
<li>服务器主机上的一个服务器残桩负责接收这个网络报文。它从网络报文中提取参数，然后调用应用程序员编写的服务器过程。</li>
<li>当服务器函数返回时，它返回到服务器残桩。服务器残桩提取返回值，把返回值封装成一个网络报文，然后将报文发送给客户残桩。</li>
<li>客户残桩从接收到的网络报文中取出返回值，将其返回给客户程序。</li>
</ol>
</li>
<li>网络程序设计是通过残桩和使用诸如插口或TLI的某个API的RPC库例程来实现的，但是用户程序—客户程序和被客户程序调用的服务器过程—不会和这个API打交道。客户应用程序只是调用服务器的过程，所有网络程序设计的细节都被RPC程序包、客户残桩和服务器残桩所隐藏。</li>
<li>一个RPC程序包提供了很多好处。<ol>
<li>程序设计更加容易，因为很少或几乎没有涉及网络编程。应用程序设计员只需要编写一个客户程序和客户程序调用的服务器过程。</li>
<li>如果使用了一个不可靠的协议，如UDP，像超时和重传等细节就由RPC程序包来处理。这就简化了用户应用程序。</li>
<li>RPC库为参数和返回值的传输提供任何需要的数据转换。例如，如果参数是由整数和浮点数组成的，RPC程序包处理整数和浮点数在客户机和服务器主机上存储的不同形式。这个功能简化了在异构环境中的客户和服务器的编码问题。</li>
</ol>
</li>
<li>下图显示的是使用UDP时，一个RPC过程调用报文的格式。  <!-- ![RPC过程调用报文](./img/RPC过程调用报文.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/RPC%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E6%8A%A5%E6%96%87.png" class="" title="RPC过程调用报文.png"></li>
<li>RPC应答报文的格式。当远程过程返回时，服务器残桩将这个报文发送给客户残桩。  <!-- ![RPC应答报文](./img/RPC应答报文.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/RPC%E5%BA%94%E7%AD%94%E6%8A%A5%E6%96%87.png" class="" title="RPC应答报文.png">

</li>
</ul>
<h3 id="3-XDR-外部数据表示"><a href="#3-XDR-外部数据表示" class="headerlink" title="3. XDR:外部数据表示"></a>3. XDR:外部数据表示</h3><ul>
<li>外部数据表示XDR(eXternal Data Representation)是一个标准，用来对RPC调用报文和应答报文中的值进行编码。这些值包括RPC首部字段（XID、程序号、接受状态等）、过程参数和过程结果。采用标准化的方法对这些值进行编码使得一个系统中的客户可以调用另一个不同架构的系统中的一个过程。</li>
<li>XDR定义了很多数据类型以及它们如何在一个RPC报文中传输的具体形式（如比特顺序，字节顺序等）。发送者必须采用XDR格式构造一个RPC报文，然后接收者将XDR格式的报文转换为本机的表示形式。</li>
</ul>
<h3 id="4-端口映射器"><a href="#4-端口映射器" class="headerlink" title="4. 端口映射器"></a>4. 端口映射器</h3><ul>
<li>包含远程过程的RPC服务器程序使用的是临时端口，而不是知名端口。这就需要某种形式的“注册”程序来跟踪哪一个RPC程序使用了哪一个临时端口。在Sun RPC中，这个注册程序被称为端口映射器(port mapper)。</li>
<li>很自然地，端口映射器本身必须有一个知名端口：UDP端口111和TCP端口111。端口映射器也就是一个RPC服务器程序。它有一个程序号（100000）、一个版本号（2）、一个TCP端口111和一个UDP端口111。服务器程序使用RPC调用向端口映射器注册自身，客户程序使用RPC调用向端口映射器查询。</li>
<li>端口映射器提供四个服务过程：<ol>
<li>PMAPPROC_SET。一个RPC服务器启动时调用这个过程，注册一个程序号、版本号和带有一个端口号的协议。</li>
<li>PMAPPROC_UNSET。RPC服务器调用此过程来删除一个已经注册的映射。</li>
<li>PMAPPROC_GETPORT。一个RPC客户启动时调用此过程。根据一个给定的程序号、版本号和协议来获得注册的端口号。</li>
<li>PMAPPROC_DUMP。返回端口映射器数据库中所有的记录（每个记录包括程序号、版本号、协议和端口号）。</li>
</ol>
</li>
</ul>
<h3 id="5-NFS协议"><a href="#5-NFS协议" class="headerlink" title="5. NFS协议"></a>5. NFS协议</h3><ul>
<li>使用NFS，客户可以透明地访问服务器上的文件和文件系统。这不同于提供文件传输的FTP</li>
<li>FTP会产生文件一个完整的副本。NFS只访问一个进程引用文件的那一部分，并且NFS的一个目的就是使得这种访问透明。这就意味着任何能够访问一个本地文件的客户程序不需要做任何修改，就应该能够访问一个NFS文件。</li>
<li>NFS是一个使用Sun RPC构造的客户服务器应用程序。NFS客户通过向一个NFS服务器发送RPC请求来访问其上的文件。</li>
<li>一个NFS客户和一个NFS服务器的典型配置  <!-- ![NFS客户服务器](./img/NFS客户服务器.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/NFS%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8.png" class="" title="NFS客户服务器.png"></li>
<li>大多数的Unix主机可以作为一个NFS客户，一个NFS服务器，或者两者都是。大多数PC机的实现（MS-DOS）只提供了NFS客户实现。大多数的IBM大型机只提供了NFS服务器功能。</li>
</ul>
<h5 id="文件句柄"><a href="#文件句柄" class="headerlink" title="文件句柄"></a>文件句柄</h5><ul>
<li>NFS中一个基本概念是文件句柄(file handle)。它是一个不透明(opaque)的对象，用来引用服务器上的一个文件或目录。</li>
<li>不透明指的是服务器创建文件句柄，把它传递给客户，然后客户访问文件时，使用对应的文件句柄。客户不会查看文件句柄的内容—它的内容只对服务器有意义。</li>
<li>每次一个客户进程打开一个实际上位于一个NFS服务器上的文件时，NFS客户就会从NFS服务器那里获得该文件的一个文件句柄。每次NFS客户为用户进程读或写文件时，文件句柄就会传给服务器以指定被访问的文件。</li>
<li>一般情况下，用户进程不会和文件句柄打交道—只有NFS客户和NFS服务器将文件句柄传来传去。</li>
</ul>
<h5 id="安装协议"><a href="#安装协议" class="headerlink" title="安装协议"></a>安装协议</h5><ul>
<li>一个NFS的安装过程。  <!-- ![NFS安装](./img/NFS安装.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/NFS%E5%AE%89%E8%A3%85.png" class="" title="NFS安装.png">

</li>
</ul>
<h5 id="UDP还是TCP"><a href="#UDP还是TCP" class="headerlink" title="UDP还是TCP"></a>UDP还是TCP</h5><ul>
<li>NFS最初是用UDP写的，所有的厂商都提供了这种实现。最新的一些实现也支持TCP。TCP支持主要用于广域网，它可以使文件操作更快。NFS已经不再局限于局域网的使用。</li>
<li>当从LAN转换到WAN时，网络的动态特征变化得非常大。往返时间（round-trip time）变动范围大，拥塞经常发生。WAN的这些特征使得我们考虑使用具有TCP属性的算法——慢启动，但是可以避免拥塞。既然UDP没有提供任何类似的东西，那么在NFS客户和服务器上加进同样的算法或者使用TCP。</li>
</ul>
<h1 id="三十-其他的TCP-IP应用程序"><a href="#三十-其他的TCP-IP应用程序" class="headerlink" title="三十 其他的TCP/IP应用程序"></a>三十 其他的TCP/IP应用程序</h1><h3 id="1-引言-27"><a href="#1-引言-27" class="headerlink" title="1. 引言"></a>1. 引言</h3><ul>
<li>本章中我们描述了另外一些很多实现都支持的TCP/IP应用程序。</li>
<li>简单的：Finger，Whois</li>
<li>复杂的：X窗口系统</li>
</ul>
<h3 id="2-Finger协议"><a href="#2-Finger协议" class="headerlink" title="2. Finger协议"></a>2. Finger协议</h3><ul>
<li>Finger协议返回一个指定主机上一个或多个用户的信息。它常被用来检查某个人是否登录了，或者搞清一个人的登录名以便给他发送邮件。</li>
<li>很多站点不支持一个Finger服务器。</li>
<li>从一个协议的角度来看，Finger服务器有一个知名的端口79。客户对这个端口做一个主动打开，然后发送一个在线的请求。服务器处理这个请求，把输出发送回去，然后关闭连接。查询和响应都是采用NVT ASCII，类似于我们在FTP和SMTP协议中所看到的。</li>
</ul>
<h3 id="3-Whois协议"><a href="#3-Whois协议" class="headerlink" title="3. Whois协议"></a>3. Whois协议</h3><ul>
<li>从协议的角度来看，Whois服务器有一个知名的TCP端口43。它接受客户的连接请求，客户向服务器发送一个在线的查询。服务器响应以任何可用的信息，然后关闭连接。请求和应答都以NVT ASCII来传输。除了请求和应答所包含的信息不一样，Whois服务器和Finger服务器几乎是一样的。</li>
<li>讲真的，本地的whois程序知道一些，不太明白这个协议是干嘛的</li>
</ul>
<h3 id="4-Archie、WAIS、Gopher、Veronica和WWW"><a href="#4-Archie、WAIS、Gopher、Veronica和WWW" class="headerlink" title="4. Archie、WAIS、Gopher、Veronica和WWW"></a>4. Archie、WAIS、Gopher、Veronica和WWW</h3><ul>
<li><p>前两节我们讨论的工具—Finger、Whois和一个白页服务—是用来查找人的信息的。还有一些工具是用来定位文件和文档的，本节中对这些工具给出了一个概述。</p>
</li>
<li><p>Archie提供了Internet上几千个FTP服务器的目录。我们可以通过登录进一个Archie服务器，搜索那些名字中包含了一个指定的常规表达式的文件。</p>
</li>
<li><p>其他。。。略，也不懂是干嘛的</p>
</li>
</ul>
<h3 id="5-X窗口系统"><a href="#5-X窗口系统" class="headerlink" title="5. X窗口系统"></a>5. X窗口系统</h3><ul>
<li><p>X窗口系统(XWindow System)，或简称为X，是一种客户-服务器应用程序。它可以使得多个客户（应用）使用由一个服务器管理的位映射显示器。</p>
</li>
<li><p>服务器是一个软件，用来管理显示器、键盘和鼠标。</p>
</li>
<li><p>客户是一个应用程序，它与服务器在同一台主机上或者在不同的主机上。在后一种情况下，客户与服务器之间通信的通用形式是TCP，尽管也可以使用诸如DECNET的其他协议。</p>
<ul>
<li>在有些场合，服务器是与其他主机上客户通信的一个专门的硬件（一个X终端）。</li>
<li>在另一种场合，一个独立的工作站，客户与服务器位于同一台主机，使用那台主机上的进程间通信机制进行通信，而根本不涉及任何网络操作。在这两种极端情况之间，是一台既支持同一台主机上的客户又支持不同主机上的客户的工作站。</li>
</ul>
</li>
<li><p>在一个Unix系统中，当X客户和X服务器在同一台主机上时，一般使用Unix系统的本地协议，而不使用TCP协议，因为这样比使用TCP的情况减少了协议处理时间。Unix系统的本地协议是同一台主机上的客户和服务器之间可以使用的一种进程间通信的形式。</p>
</li>
<li><p>下图显示了三个客户使用一个显示器的可能的脚本。一个客户与服务器在同一台主机上，使用Unix系统的本地协议。另外两个位于不同的主机上，使用TCP。</p>
</li>
<li><p>一般来说，其中一个客户是一个窗口管理程序(window manager)，它有权限管理显示器上窗口的布局。例如，窗口管理程序允许我们在屏幕上移动窗口，或者改变窗口的大小。</p>
  <!-- ![xwindow](./img/xwindow.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/xwindow.png" class="" title="xwindow.png">
</li>
<li><p>在这里客户和服务器这两个词猛一看含义相反了。对于Telnet和FTP的应用，我们把客户看作是在键盘和显示器上的交互式用户。但是对于X，键盘和显示器是属于服务器的。服务器被认为是提供服务的一方。X提供的服务是对窗口、键盘和鼠标的访问。对于Telnet，服务是登录远程的主机。对于FTP，服务是服务器上的文件系统。</p>
</li>
<li><p>当一个客户在另一台主机上启动时，它创建一个TCP端点，对服务器上的端口6000+n做一个主动打开。每个客户都得到了一个自己与服务器的连接。服务器负责对所有的客户请求进行复用。从这点开始，客户通过TCP连接向服务器发送请求（例如，创建一个窗口），服务器返回应答，服务器也发送事件给客户（鼠标按钮按下，键盘键按下，窗口暴露，窗口大小改变，等等）。</p>
  <!-- ![x服务器进程](./img/x服务器进程.png) -->
  <img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/x%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E7%A8%8B.png" class="" title="x服务器进程.png">
</li>
<li><p>Xscope程序</p>
<ul>
<li>Xscope是检查X客户与它的服务器之间交换的信息的一个方便的程序。</li>
<li>它处在客户与服务器之间，双向传输所有的数据，同时解析所有的客户请求和服务器应答。<!-- ![xscope](./img/xscope.png) -->
<img src="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/xscope.png" class="" title="xscope.png"></li>
<li>首先，我们在服务器所在的主机上启动xscope进程，但是xscope不是在端口6000而是在端口6001上监听TCP的连接请求。然后我们在另一台主机上启动一个客户，指明显示器号为1，而不是0，使得客户与xscope相连，而不直接与服务器相连。当客户的连接请求到达时，xscope创建与端口6000上的真正的服务器的一个TCP连接，在客户与服务器之间复制所有的数据，同时生成请求与应答的一个可读的描述。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>ip</tag>
      </tags>
  </entry>
</search>
