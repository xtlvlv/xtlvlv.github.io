<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/head.jpeg">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xtlvlv.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":2,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.视C++为一个语言联邦C++C++是一个多重泛型编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式，具有强大的能力和弹性。">
<meta property="og:type" content="article">
<meta property="og:title" content="《Effective C++》">
<meta property="og:url" content="https://xtlvlv.github.io/%E3%80%8AEffective-C-%E3%80%8B/index.html">
<meta property="og:site_name" content="不知自己不知">
<meta property="og:description" content="1.视C++为一个语言联邦C++C++是一个多重泛型编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式，具有强大的能力和弹性。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-16T04:29:07.000Z">
<meta property="article:modified_time" content="2021-01-17T14:54:15.641Z">
<meta property="article:author" content="不知自己不知">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xtlvlv.github.io/%E3%80%8AEffective-C-%E3%80%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《Effective C++》 | 不知自己不知</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">

<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->

<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 

  <!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
  
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不知自己不知</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">59</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">13</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">70</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xtlvlv.github.io/%E3%80%8AEffective-C-%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpeg">
      <meta itemprop="name" content="不知自己不知">
      <meta itemprop="description" content="o.O">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不知自己不知">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Effective C++》
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-16 12:29:07" itemprop="dateCreated datePublished" datetime="2021-01-16T12:29:07+08:00">2021-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-17 22:54:15" itemprop="dateModified" datetime="2021-01-17T22:54:15+08:00">2021-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/%E3%80%8AEffective-C-%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E3%80%8AEffective-C-%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-视C-为一个语言联邦"><a href="#1-视C-为一个语言联邦" class="headerlink" title="1.视C++为一个语言联邦"></a>1.视C++为一个语言联邦</h1><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><p>C++是一个多重泛型编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式，具有强大的能力和弹性。</p>
<a id="more"></a>
<h5 id="四个次语言"><a href="#四个次语言" class="headerlink" title="四个次语言"></a>四个次语言</h5><p>将C++视为语言联邦，有多个次语言</p>
<ol>
<li>C: 没有模板，异常，重载，类的C。</li>
<li>Object-Oriented C++: C with class, 封装，继承，多态，虚函数。</li>
<li>Template C++: C++泛型编程。拓展出元编程能力。</li>
<li>STL: 容器，迭代器，算法</li>
</ol>
<h5 id="什么是元编程"><a href="#什么是元编程" class="headerlink" title="什么是元编程"></a>什么是元编程</h5><p>可以扩展程序自身，这样的能力，为元编程。<br>扣定义的话，动态生成html的程序也可以叫元编程。<br>Lisp 以元编程为基本。而 Ruby 因为元编程易用又强大。</p>
<h1 id="2-尽量以const-enum-inline替换-define"><a href="#2-尽量以const-enum-inline替换-define" class="headerlink" title="2.尽量以const,enum,inline替换#define"></a>2.尽量以const,enum,inline替换#define</h1><h5 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define &#x2F;&#x2F;处于预处理阶段 </span><br><span class="line">#define MAX 1.6</span><br><span class="line">#define CALL_MAX(a,b) f((a)&gt;(b)?(a):(b)) </span><br></pre></td></tr></table></figure>

<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ol>
<li><p>#define MAX 1.6</p>
<ul>
<li>预处理阶段就会把MAX全换成1.6，当运用此常量得到编译错误信息后，可能不知所云，因为错误信息也许会提到1.6而不是MAX</li>
<li>可能会导致生成多个常量1.6，码量可能会大一点。</li>
</ul>
</li>
<li><p>#define CALL_MAX(a,b) f((a)&gt;(b)?(a):(b)) </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;5;</span><br><span class="line">b&#x3D;0;</span><br><span class="line">CALL_MAX(++a,b);  &#x2F;&#x2F;a被加两次</span><br><span class="line">CALL_MAX(++a,b+10);  &#x2F;&#x2F;a被加一次</span><br><span class="line">    &#x2F;&#x2F;a的递增次数要看代码执行了几次。</span><br></pre></td></tr></table></figure>
<p> 可以改为</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline int test(const int&amp; a,const int&amp; b)&#123;</span><br><span class="line">    return a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在类中使用一个不变的值，可以定义为const,最好再定义为static，只保留一份</p>
</li>
</ol>
<h5 id="谨记"><a href="#谨记" class="headerlink" title="谨记"></a>谨记</h5><ol>
<li>对于单纯常量，最好用const或enum替换#define.</li>
<li>对于形似函数的宏，最好用inline函数替换#define.</li>
<li>#define在控制编译上还是有用的，#ifdef,#ifndef</li>
</ol>
<h1 id="3-尽可能使用const"><a href="#3-尽可能使用const" class="headerlink" title="3.尽可能使用const"></a>3.尽可能使用const</h1><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char val&#x3D;&quot;hello&quot;;</span><br><span class="line">char* p &#x3D; val;</span><br><span class="line">const char* p &#x3D; val;    &#x2F;&#x2F;p指向的数据不能变</span><br><span class="line">char* const p &#x3D; val;    &#x2F;&#x2F;p不能变</span><br><span class="line">const char* const p &#x3D; val;  &#x2F;&#x2F;都不能变</span><br></pre></td></tr></table></figure>

<p>这一条除了上面的懂了，下面的，讲真的，complex。</p>
<h1 id="4-确定对象被使用前已被初始化"><a href="#4-确定对象被使用前已被初始化" class="headerlink" title="4.确定对象被使用前已被初始化"></a>4.确定对象被使用前已被初始化</h1><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ol>
<li>为内置对象进行手工初始化；</li>
<li>对于对象，构造函数最好用初始化列表，在构造函数中写的是赋值，不是初始化。初始化次序和它们在类中声明的顺序一样。</li>
<li>单实例模式。</li>
</ol>
<h1 id="5-了解C-默默编写并调用哪些函数"><a href="#5-了解C-默默编写并调用哪些函数" class="headerlink" title="5.了解C++默默编写并调用哪些函数"></a>5.了解C++默默编写并调用哪些函数</h1><h5 id="一个空类默认生成的几个函数"><a href="#一个空类默认生成的几个函数" class="headerlink" title="一个空类默认生成的几个函数"></a>一个空类默认生成的几个函数</h5><ol>
<li>默认构造     default<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student s;</span><br></pre></td></tr></table></figure></li>
<li>拷贝构造     copy<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student s(s2);</span><br></pre></td></tr></table></figure></li>
<li>=重载    copy assinment<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student s;</span><br><span class="line">s&#x3D;s2;</span><br></pre></td></tr></table></figure></li>
<li>析构函数</li>
</ol>
<h1 id="6-若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#6-若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="6.若不想使用编译器自动生成的函数，就该明确拒绝"></a>6.若不想使用编译器自动生成的函数，就该明确拒绝</h1><ol>
<li>将copy构造和copy assignment声明为private而不实现</li>
<li>写一个uncopyable,将copy构造和copy assignment声明为private而不实现，然后继承此类的类就都不能copy和=了。</li>
</ol>
<h1 id="7-为多态基类生明virtual析构函数"><a href="#7-为多态基类生明virtual析构函数" class="headerlink" title="7.为多态基类生明virtual析构函数"></a>7.为多态基类生明virtual析构函数</h1><h5 id="virtual析构函数"><a href="#virtual析构函数" class="headerlink" title="virtual析构函数"></a>virtual析构函数</h5><ol>
<li>抽象类最好声明一个virtual的析构函数。如果类中带有任何virtual，都最好声明一个virtual的析构函数。</li>
<li>非基类最好不要声明virtual析构函数</li>
</ol>
<h1 id="8-别让异常逃离析构函数"><a href="#8-别让异常逃离析构函数" class="headerlink" title="8.别让异常逃离析构函数"></a>8.别让异常逃离析构函数</h1><h5 id="析构函数的异常"><a href="#析构函数的异常" class="headerlink" title="析构函数的异常"></a>析构函数的异常</h5><ol>
<li><p>析构函数最好不要抛出任何异常，不然会导致不可预料的结果。如果可能有异常，就在异常发生时强制结束程序或者记录异常，不处理继续执行。</p>
</li>
<li><p>析构函数中的异常处理，程序猿最好在外面自己另外定义一个函数处理。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">有一个数据库管理类，在析构函数中要调用db.close()。可能会有异常。</span><br><span class="line">这是应该自己写个close函数，将关闭数据库的函数写到自己的函数中，并自己调用，而不应该交给析构函数。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="9-绝不在构造和析构过程中调用virtual函数"><a href="#9-绝不在构造和析构过程中调用virtual函数" class="headerlink" title="9.绝不在构造和析构过程中调用virtual函数"></a>9.绝不在构造和析构过程中调用virtual函数</h1><ol>
<li>因为基类在构造和析构过程中调用的虚函数不能传到派生类</li>
<li>派生类实例化时，先基类调用构造函数，但此时虚函数还是一个未知的函数。</li>
</ol>
<h1 id="10-令operator-返回一个reference-to-this"><a href="#10-令operator-返回一个reference-to-this" class="headerlink" title="10.令operator=返回一个reference to *this"></a>10.令operator=返回一个reference to *this</h1><h5 id="为了实现连锁赋值"><a href="#为了实现连锁赋值" class="headerlink" title="为了实现连锁赋值"></a>为了实现连锁赋值</h5><ol>
<li><p>x=y=z=5 等价于 x=(y=(z=5))</p>
</li>
<li><p>为了实现“连锁赋值”，必须返回一个reference to *this.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int&amp; operator&#x3D;(const int&amp; rhs)&#123;</span><br><span class="line">    ---</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="11-在operator-中处理”自我赋值”"><a href="#11-在operator-中处理”自我赋值”" class="headerlink" title="11.在operator=中处理”自我赋值”"></a>11.在operator=中处理”自我赋值”</h1></li>
<li><p>必须判断自我赋值，不然可能出问题，例如返回本身的引用，却在赋值前先把自己delete了（书上的例子），总之实现自我赋值就是了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(this&#x3D;&#x3D;&amp;rhs)&#123;</span><br><span class="line">    &#x2F;&#x2F;如果是本身就不做操作</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line">else 做其他的赋值操作</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="12-复制对象时勿忘其每一个成分"><a href="#12-复制对象时勿忘其每一个成分" class="headerlink" title="12.复制对象时勿忘其每一个成分"></a>12.复制对象时勿忘其每一个成分</h1><h5 id="copy构造和copy-assignment要写完全"><a href="#copy构造和copy-assignment要写完全" class="headerlink" title="copy构造和copy assignment要写完全"></a>copy构造和copy assignment要写完全</h5><ol>
<li>即该复制的都要复制</li>
<li>派生类复制对象的时候也必须调用基类的拷贝函数</li>
<li>一般自己写copy构造是需要深拷贝的情况，即有指针的情况下，不然的话默认拷贝构造可能比自己写的好用。</li>
<li>不要让赋值函数调用拷贝构造函数，建立独立的成员函数来做这件事。一般是private函数并命名为Init。所有copying函数共同调用此函数</li>
</ol>
<h1 id="13-以对象管理资源"><a href="#13-以对象管理资源" class="headerlink" title="13.以对象管理资源"></a>13.以对象管理资源</h1><h5 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h5><ol>
<li>动态分配内存</li>
<li>文件描述符</li>
<li>互斥锁</li>
<li>图形界面中的笔刷</li>
<li>数据库连接</li>
<li>socket</li>
<li>……</li>
</ol>
<h5 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h5><ol>
<li><p>获得资源后立即放进管理对象，如智能指针auto_ptr，定义为智能指针，自己不用释放，指针结束后会自己调用析构函数释放资源。</p>
</li>
<li><p>管理对象运用析构函数确保资源被释放</p>
</li>
<li><p>两个RAII(罐装容器)：tr1::shared_ptr 和 auto_ptr. RAII设计还是比较精巧的，而且很有用，不过比较难用。</p>
</li>
<li><p>tr1::shared_ptr 的复制会增加引用计数，析构会减少引用计数。当引用计数变成0才真正释放资源。</p>
</li>
<li><p>auto_ptr 复制的时候，原来的指针变为NULL,只保留一份资源</p>
</li>
</ol>
<h1 id="14-在资源管理类中小心coping行为"><a href="#14-在资源管理类中小心coping行为" class="headerlink" title="14.在资源管理类中小心coping行为"></a>14.在资源管理类中小心coping行为</h1><ol>
<li>复制RAII对象必须一起复制他所管理的资源，资源的copying行为决定了RAII（罐装容器）对象的copying行为</li>
<li>RAII即对对象资源处理的封装，要控制释放资源。</li>
<li>RAII class copying行为一般有两种：禁止copy，对资源引用计数。</li>
</ol>
<h1 id="15-在资源管理类中提供对原始资源的访问"><a href="#15-在资源管理类中提供对原始资源的访问" class="headerlink" title="15.在资源管理类中提供对原始资源的访问"></a>15.在资源管理类中提供对原始资源的访问</h1><ol>
<li>每一个RAII class应该提供一个”取得资源” 的办法</li>
<li>比如tr1::shared_ptr 提供了get函数</li>
</ol>
<h1 id="16-成对使用new和delete时要采取相同形式"><a href="#16-成对使用new和delete时要采取相同形式" class="headerlink" title="16.成对使用new和delete时要采取相同形式"></a>16.成对使用new和delete时要采取相同形式</h1><ol>
<li>new[] –&gt; delete[]，即new中不用[]，delete也不要用[]，要不就都用。</li>
</ol>
<h1 id="17-以独立语句将newed对象置入智能指针"><a href="#17-以独立语句将newed对象置入智能指针" class="headerlink" title="17.以独立语句将newed对象置入智能指针"></a>17.以独立语句将newed对象置入智能指针</h1><ol>
<li>总结就是 new 一个对象和把它放入一个只能指针中间不能再执行其他代码，不然抛异常的话，对象没有被智能指针管理，就会造成内存泄露。书上的例子比较有意思。</li>
</ol>
<h1 id="18-让接口容易被正确使用，不易被误用"><a href="#18-让接口容易被正确使用，不易被误用" class="headerlink" title="18.让接口容易被正确使用，不易被误用"></a>18.让接口容易被正确使用，不易被误用</h1><ol>
<li><p>不一致性造成的开发人员心理和肉体上的摩擦与争执，没任何一个IDE可以完全消除</p>
</li>
<li><p>“促进正确使用”的办法包括接口的一致性以及与内置类型的行为兼容</p>
</li>
<li><p>“阻止误用”的办法包括建立新类型、限制类型上的操作、束缚对象值、消除客户的资源管理责任</p>
</li>
<li><p>tr1::shared_ptr 支持定制型删除器。可被用来自动解除互斥锁</p>
</li>
</ol>
<h1 id="19-设计class犹如设计type"><a href="#19-设计class犹如设计type" class="headerlink" title="19.设计class犹如设计type"></a>19.设计class犹如设计type</h1><ol>
<li>就是设计class时要考虑全面</li>
</ol>
<h1 id="20-宁以pass-by-reference-to-const替换pass-by-value"><a href="#20-宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="20.宁以pass-by-reference-to-const替换pass-by-value"></a>20.宁以pass-by-reference-to-const替换pass-by-value</h1><ol>
<li>自己定义的对向尽量引用传递，而不是值传递。</li>
<li>引用传递可以避免切割问题。什么是切割问题呢？就是传一个带有自己特性的子类对象，若直接值传递，就会复制，可能就传的是个基类对向了。如传Windows窗口，具体看书吧。</li>
</ol>
<h1 id="21-必须返回对象时，别妄想返回其reference"><a href="#21-必须返回对象时，别妄想返回其reference" class="headerlink" title="21.必须返回对象时，别妄想返回其reference"></a>21.必须返回对象时，别妄想返回其reference</h1><ol>
<li>不要返回一个reference指向local stack对象或者heap-allcated对象</li>
</ol>
<h1 id="22-将成员变量声明为private"><a href="#22-将成员变量声明为private" class="headerlink" title="22.将成员变量声明为private"></a>22.将成员变量声明为private</h1><ol>
<li><p>这可赋予用户数据访问的一致性。</p>
</li>
<li><p>protected不比public更具封装性</p>
</li>
<li><p>封装性与 “当其内容改变时可能造成的代码破坏量” 成反比。（封装的越好，内容改变造成的破坏越小）</p>
</li>
</ol>
<h1 id="23-宁以non-member、non-friend替换member函数"><a href="#23-宁以non-member、non-friend替换member函数" class="headerlink" title="23.宁以non-member、non-friend替换member函数"></a>23.宁以non-member、non-friend替换member函数</h1><ol>
<li>即如果可以的话，尽量非成员函数实现某些功能，可以传入对向的引用对对象进行操作。</li>
</ol>
<h1 id="24-若所有参数皆需类型转换，请为此采用non-member函数"><a href="#24-若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="24.若所有参数皆需类型转换，请为此采用non-member函数"></a>24.若所有参数皆需类型转换，请为此采用non-member函数</h1><ol>
<li><p>令classes支持隐式类型转换是个糟糕的主意，即最好加上explicit声明禁止隐式转换。</p>
</li>
<li><p>如果需要为某个函数的所有参数进行类型转换，那么这个函数必须是一个non-member</p>
</li>
</ol>
<h1 id="25-考虑写出一个不抛异常的swap函数"><a href="#25-考虑写出一个不抛异常的swap函数" class="headerlink" title="25.考虑写出一个不抛异常的swap函数"></a>25.考虑写出一个不抛异常的swap函数</h1><ol>
<li><p>标准库的swap(T &amp;a,T &amp;b);仅支持T类型有copy构造或copy assignment的情况。</p>
</li>
<li><p>需要自己写swap的时候要注意，，，一般也不需要自己写吧。</p>
</li>
</ol>
<h1 id="26-尽可能延后变量定义式的出现时间"><a href="#26-尽可能延后变量定义式的出现时间" class="headerlink" title="26.尽可能延后变量定义式的出现时间"></a>26.尽可能延后变量定义式的出现时间</h1><ol>
<li><p>对象的构造和析构都会造成开销。尽量在使用的时候再定义。</p>
</li>
<li><p>最好在定义的时候初始化，可以省去默认构造的开销。</p>
</li>
</ol>
<h1 id="27-尽量少做转型动作"><a href="#27-尽量少做转型动作" class="headerlink" title="27.尽量少做转型动作"></a>27.尽量少做转型动作</h1><h4 id="转型"><a href="#转型" class="headerlink" title="转型"></a>转型</h4><h6 id="1-旧式转型"><a href="#1-旧式转型" class="headerlink" title="(1)旧式转型"></a>(1)旧式转型</h6><pre><code>(int)a;
int(a);//都是将a转换成int类型</code></pre>
<h5 id="2-C-新式转型"><a href="#2-C-新式转型" class="headerlink" title="(2)C++新式转型"></a>(2)C++新式转型</h5><pre><code>const_case&lt;T&gt;( expression )     //移除对象的常量性
dynamic_case&lt;T&gt;( expression )   //安全向下转型
reinterpret_case&lt;T&gt;( expression )   //低级转型
static_case&lt;T&gt;( expression )    //强迫隐士转换，和(int)a类似</code></pre>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>尽量避免转型</li>
<li>如果必须转型，应将转型动作隐藏在函数里，客户直接调用函数。</li>
<li>尽量使用C++新式转型</li>
</ol>
<h1 id="28-避免返回handles指向对象内部成分"><a href="#28-避免返回handles指向对象内部成分" class="headerlink" title="28.避免返回handles指向对象内部成分"></a>28.避免返回handles指向对象内部成分</h1><ol>
<li><p>不要返回内部handle，也不要返回指向访问级别较低的成员函数。降低dangling handle的可能性</p>
</li>
<li><p>即public函数不要返回private成员的引用，必须返回的话，要加上const，即返回const XXX&amp; 类型。</p>
</li>
</ol>
<h1 id="29-为“异常安全”而努力是值得的"><a href="#29-为“异常安全”而努力是值得的" class="headerlink" title="29.为“异常安全”而努力是值得的"></a>29.为“异常安全”而努力是值得的</h1><h5 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h5><ol>
<li>不泄露任何资源</li>
<li>不允许数据败坏</li>
</ol>
<h5 id="异常安全函数的三个保证"><a href="#异常安全函数的三个保证" class="headerlink" title="异常安全函数的三个保证"></a>异常安全函数的三个保证</h5><ol>
<li>基本承诺：如果异常抛出，程序的其他数据仍然保持有效状态，不会被破坏，例如改变屏幕背景，若失败，背景应该为改变前的样子或默认背景。</li>
<li>强烈保证：如果函数失败，会回到程序调用函数前的状态。能通过copy-and-swap实现，但并非对所有函数都可实现且有意义。</li>
<li>不抛掷保证：承诺不抛出异常，函数总能完成它该有的功能。</li>
</ol>
<h1 id="30-透彻了解inlining的里里外外"><a href="#30-透彻了解inlining的里里外外" class="headerlink" title="30.透彻了解inlining的里里外外"></a>30.透彻了解inlining的里里外外</h1><ol>
<li>inline应该用在小型的、频繁的函数，主要是省去函数调用的开销。</li>
<li>若过多用inline，代码量就会增大，代码膨胀可能会导致额外的换页行为，降低指令告诉缓存的命中率，随而降低效率。</li>
</ol>
<h1 id="31-将文件间的编译依存关系降至最低"><a href="#31-将文件间的编译依存关系降至最低" class="headerlink" title="31.将文件间的编译依存关系降至最低"></a>31.将文件间的编译依存关系降至最低</h1><ol>
<li>能使用reference 和pointer的，就不要用object，就是尽量用引用和指针。</li>
<li>类中用对象的话，编译阶段就会确定类的大小，用指针的话计算的是指针的大小。</li>
<li>类中尽量用指针，不过用指针的话要注意深度拷贝和析构的问题，默认析构函数不会delete指针成员</li>
<li>程序库头文件应该仅有声明式</li>
</ol>
<h1 id="32-确定你的public继承塑模出is-a关系"><a href="#32-确定你的public继承塑模出is-a关系" class="headerlink" title="32.确定你的public继承塑模出is-a关系"></a>32.确定你的public继承塑模出is-a关系</h1><ol>
<li>如果要继承的话，一定要是is-a关系，即基类的每个函数都适用于派生类</li>
</ol>
<h1 id="33-避免遮掩继承而来的名称"><a href="#33-避免遮掩继承而来的名称" class="headerlink" title="33.避免遮掩继承而来的名称"></a>33.避免遮掩继承而来的名称</h1><ol>
<li><p>在子类中的同名成员会遮掩基类中的成员</p>
</li>
<li><p>适用using:Base::函数名()，就可以让基类中使用基类中的函数</p>
<ul>
<li>若基类有多个重载，子类中有重名函数就会覆盖所有重载，而使用using就可以重新用那些重载</li>
<li>若基类中是私有变量，使用using就能在子类中使用</li>
</ul>
</li>
</ol>
<h1 id="34-区分接口继承和实现继承"><a href="#34-区分接口继承和实现继承" class="headerlink" title="34.区分接口继承和实现继承"></a>34.区分接口继承和实现继承</h1><ol>
<li><p>pure virtual —— 接口继承，在子类中必须实现</p>
</li>
<li><p>non-pure virtual —— 接口 + 缺省实现继承，子类中可以再实现，也可以用默认的，不过有时候不想用默认的却会忘了实现，可以看书中飞机例子的解决办法。</p>
</li>
<li><p>non virtual —— 接口+强制实现继承，子类中不能更改它的行为</p>
</li>
</ol>
<h1 id="35-考虑virtual函数以外的其他选择"><a href="#35-考虑virtual函数以外的其他选择" class="headerlink" title="35.考虑virtual函数以外的其他选择"></a>35.考虑virtual函数以外的其他选择</h1><ol>
<li>不一定非得用virtual函数，替代方案有很多，比如：函数指针成员变量，NVI手法，Strategy设计模式等</li>
</ol>
<h1 id="36-绝不重新定义继承而来的non-virtual函数"><a href="#36-绝不重新定义继承而来的non-virtual函数" class="headerlink" title="36.绝不重新定义继承而来的non-virtual函数"></a>36.绝不重新定义继承而来的non-virtual函数</h1><ol>
<li>对应34条，不要在子类中重新定义non-virtual，若需要重写，就把基类中的定义为virtual（怎么感觉又和35矛盾了。。。）</li>
</ol>
<h1 id="37-绝不重新定义继承而来的缺省参数值"><a href="#37-绝不重新定义继承而来的缺省参数值" class="headerlink" title="37.绝不重新定义继承而来的缺省参数值"></a>37.绝不重新定义继承而来的缺省参数值</h1><ol>
<li>主要是对virtual的子类实现来说，若基类中virtual函数有缺省值，子类中不应该改变。</li>
<li>缺省值是静态绑定的，而virtual是动态绑定的。</li>
</ol>
<h1 id="38-通过复合塑模出has-a或“根据某物实现出”"><a href="#38-通过复合塑模出has-a或“根据某物实现出”" class="headerlink" title="38.通过复合塑模出has-a或“根据某物实现出”"></a>38.通过复合塑模出has-a或“根据某物实现出”</h1><ol>
<li>“复合(composition)”的近义词：组合，分层(layering)，内含(containment)，聚合(aggregation)，内嵌(embedding)</li>
<li>要有 has-a 的关系</li>
</ol>
<h1 id="39-明智而审慎地使用private继承"><a href="#39-明智而审慎地使用private继承" class="headerlink" title="39.明智而审慎地使用private继承"></a>39.明智而审慎地使用private继承</h1><ol>
<li><p>一般而言，不需要用private继承。复合基本可以完全包含private继承的能力</p>
</li>
<li><p>一般必须要用virtual函数的时候可以用私有继承，否则复合基本可以完全包含private继承的能力</p>
</li>
<li><p>2可能说的不对0.0</p>
</li>
</ol>
<h1 id="40-明智而审慎地使用多重继承"><a href="#40-明智而审慎地使用多重继承" class="headerlink" title="40.明智而审慎地使用多重继承"></a>40.明智而审慎地使用多重继承</h1><ol>
<li><p>多重继承可能导致成员歧义，即基类中有相同的成员名字</p>
</li>
<li><p>菱形/钻石继承，所有继承的类都变为虚继承，但是，虚继承的那些class产生的对象往往比使用non-virtual继承的体积大，访问这些成员变量也相对较慢。</p>
</li>
</ol>
<h1 id="41-了解隐式接口和编译期多态"><a href="#41-了解隐式接口和编译期多态" class="headerlink" title="41.了解隐式接口和编译期多态"></a>41.了解隐式接口和编译期多态</h1><ol>
<li><p>在构造函数前声明 explicit 关键字，禁止隐式转换，从而变成显式接口</p>
</li>
<li><p>类中某些成员函数是virtual的，当调用这些函数的时候就表现出运行期多态。</p>
</li>
<li><p>编译期多态主要是对templates模板来说，类型的多态</p>
</li>
</ol>
<h1 id="42-了解typename的双重意义"><a href="#42-了解typename的双重意义" class="headerlink" title="42.了解typename的双重意义"></a>42.了解typename的双重意义</h1><ol>
<li>声明template时，可以用class或typename，二者等价<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">template&lt;typename T&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="43-学习处理模块化基类内的名称"><a href="#43-学习处理模块化基类内的名称" class="headerlink" title="43.学习处理模块化基类内的名称"></a>43.学习处理模块化基类内的名称</h1><ol>
<li>不太懂，等需要模板编程的时候再细看吧。</li>
</ol>
<h1 id="44-将与参数无关的代码抽离templates"><a href="#44-将与参数无关的代码抽离templates" class="headerlink" title="44.将与参数无关的代码抽离templates"></a>44.将与参数无关的代码抽离templates</h1><ol>
<li><p>若两个函数实现过程中有很多重复代码，应该将重复代码单独写成一个函数，调用之。</p>
</li>
<li><p>对模板同理，至于怎么操作。。。</p>
</li>
</ol>
<h1 id="45-运用成员函数模板接受所有兼容类型"><a href="#45-运用成员函数模板接受所有兼容类型" class="headerlink" title="45.运用成员函数模板接受所有兼容类型"></a>45.运用成员函数模板接受所有兼容类型</h1><ol>
<li>模板这块先略过吧，没有什么编程需求，所以没有直观感受。</li>
</ol>
<h1 id="46-需要类型转换时请为模板定义非成员函数"><a href="#46-需要类型转换时请为模板定义非成员函数" class="headerlink" title="46.需要类型转换时请为模板定义非成员函数"></a>46.需要类型转换时请为模板定义非成员函数</h1><ol>
<li>模板这块先略过吧，没有什么编程需求，所以没有直观感受。</li>
</ol>
<h1 id="47-请使用traits-classes表现类型信息"><a href="#47-请使用traits-classes表现类型信息" class="headerlink" title="47.请使用traits classes表现类型信息"></a>47.请使用traits classes表现类型信息</h1><ol>
<li>模板这块先略过吧，没有什么编程需求，所以没有直观感受。</li>
</ol>
<h1 id="48-认识template元编程"><a href="#48-认识template元编程" class="headerlink" title="48.认识template元编程"></a>48.认识template元编程</h1><ol>
<li><p>元编程执行于编译期，可以把工作转移一部分到编译期，而且一些在运行期才能检查出来的错误也能转到在编译期检查出来。</p>
</li>
<li><p>通过template&lt;当做参数&gt;实现</p>
</li>
</ol>
<h1 id="49-了解new-handler的行为"><a href="#49-了解new-handler的行为" class="headerlink" title="49.了解new-handler的行为"></a>49.了解new-handler的行为</h1><ol>
<li>new_handler声明与std</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace std&#123;</span><br><span class="line">    typedef void (*new_handler);</span><br><span class="line">    new_handler set_new_handler(new_handler p) throw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>new_handler 是一个函数指针，它有什么用呢？<br> 当new一块空间不足时，它就会抛出异常，但在异常之前会先调用一个客户指定 的错误处理函数，就是new_handler，通过ser_new_handler(函数名)来设置。</p>
</li>
<li><p>卸载new_handler<br> set_new_handler(NULL)</p>
</li>
<li><p>作用局限，只适用于内存分配，后续的构造函数调用可能还是会抛出异常。</p>
</li>
</ol>
<h1 id="50-了解new和delete的合理替换时机"><a href="#50-了解new和delete的合理替换时机" class="headerlink" title="50.了解new和delete的合理替换时机"></a>50.了解new和delete的合理替换时机</h1><ol>
<li><p>一般替换掉默认的new和delete一般是为了： 提高性能（比如tcmalloc），收集数据、检测错误等。比如valgrind之类（Valgrind是一款用于内存调试、内存泄漏检测以及性能分析的软件开发工具。）</p>
</li>
<li><p>替换方法：简单来说就是封装malloc和free,relloc等，做出自己想要的效果。。。。简单来说。</p>
</li>
</ol>
<h1 id="51-编写new和delete时需固守常规"><a href="#51-编写new和delete时需固守常规" class="headerlink" title="51.编写new和delete时需固守常规"></a>51.编写new和delete时需固守常规</h1><ol>
<li><p>无限循环尝试分配内存，若无法满足内存需求，就该调用new_handler</p>
</li>
<li><p>也要有能力处理0bytes申请。还应该能处理比正确大小更大的申请</p>
</li>
<li><p>delete 应该在收到NULL指针时不做任何事</p>
</li>
</ol>
<h1 id="52-写了placement-new也要写placement-delete"><a href="#52-写了placement-new也要写placement-delete" class="headerlink" title="52.写了placement new也要写placement delete"></a>52.写了placement new也要写placement delete</h1><ol>
<li><p>主要讨论一个在构造函数中抛出异常会不会内存泄露的问题。placement new/delete 就是在类中自己重载new和delete操作符。</p>
</li>
<li><p>一个对象在构造函数中抛出异常，对象本身的内存会被成功释放，但是其析构函数不会被调用。其内部局部成员对象清栈时是会被释放掉的，故其析构函数被调用，但是用户在构造函数中动态生成的对象没有被delete掉（new出来的是一个指针，清栈时是不会delete掉栈里的指针）。</p>
</li>
<li><p>如果一个对象在构造函数中打开很多系统资源，但是构造函数中后续代码抛出了异常，则这些资源将不会被释放，建议在构造函数中加入try catch语句，对先前申请的资源进行释放后（也就是做析构函数该做的事情）再次抛出异常，确保内存和其他资源被成功回收。</p>
</li>
</ol>
<h1 id="53-不要轻忽编译器的警告"><a href="#53-不要轻忽编译器的警告" class="headerlink" title="53.不要轻忽编译器的警告"></a>53.不要轻忽编译器的警告</h1><ol>
<li>额总之就是在不过度依赖编译器的情况下达到0警告</li>
</ol>
<h1 id="54-让自己熟悉包括TR1在内的标准程序库"><a href="#54-让自己熟悉包括TR1在内的标准程序库" class="headerlink" title="54.让自己熟悉包括TR1在内的标准程序库"></a>54.让自己熟悉包括TR1在内的标准程序库</h1><h5 id="C-98加入的新特性"><a href="#C-98加入的新特性" class="headerlink" title="C++98加入的新特性"></a>C++98加入的新特性</h5><ol>
<li>STL</li>
<li>iostreams</li>
<li>国际化支持，如：wchar_t等</li>
<li>数值处理：如复数模板complex</li>
<li>异常阶层体系</li>
<li>C89标准程序库</li>
</ol>
<h5 id="TR1"><a href="#TR1" class="headerlink" title="TR1"></a>TR1</h5><p>14个新组件，std::tr1::shared_ptr</p>
<ol>
<li>智能指针</li>
<li>tr1::function，传递函数指针，详情再看教程吧。</li>
<li>tr1::bind，比bind1st,bind2nd更好用的STL绑定器，绑定的函数有点像传递仿函数的功能。</li>
<li>Hash tables，STL的map和se是用红黑树实现的，这实现的Hash结构的。</li>
<li>正则表达式</li>
<li>Tuples(变量组)</li>
<li>tr1::array</li>
<li>tr1::mem_fun</li>
<li>tr1::reference_wrapper</li>
<li>随机数，超越rand,rand是C库的</li>
<li>数学特殊函数，拉格朗日等</li>
<li>C99 兼容扩充</li>
</ol>
<h5 id="tr2"><a href="#tr2" class="headerlink" title="tr2"></a>tr2</h5><ol start="13">
<li>type traits </li>
<li>tr1::result_of</li>
</ol>
<h5 id=""><a href="#" class="headerlink" title="???"></a>???</h5><p>看到最后，来一句：TR1只是规范，还没有实物？？？但是智能指针什么的《C++ primer》都说了。。。好吧，05年的书太早了，看了上面这么多，瞬间觉得自己根本不懂C++，都快C++20了，complex，学的好累0.0，还是python简单些。。。</p>
<h1 id="55-让自己熟悉Boost"><a href="#55-让自己熟悉Boost" class="headerlink" title="55.让自己熟悉Boost"></a>55.让自己熟悉Boost</h1><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul>
<li>Boost是一个C++开发者的社群，也是一个免费的C++程序库群。它的网址是<a target="_blank" rel="noopener" href="http://www.boost.org/">www.boost.org</a>  </li>
</ul>
<h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><ul>
<li>作为一个“可被加入标准C++库的测试场”，以TR1提案进入标准C++的14个新程序序库中，超过三分之二是基于Boost的成果</li>
</ul>
<h5 id="网上言论"><a href="#网上言论" class="headerlink" title="网上言论"></a>网上言论</h5><ol>
<li>说尽量用STL不要用boost什么的，现在很多boost都成标准了什么的。。。崩溃，STL还了解一些，不过理解也就是一些容器迭代器仿函数什么的。看了boost那么大，及其崩溃，不知从何学起。唉慢慢来吧。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag">C++</i></a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E3%80%8ACpp-Primer-Plus%E3%80%8B/" rel="prev" title="《Cpp Primer Plus》">
      <i class="fa fa-chevron-left"></i> 《Cpp Primer Plus》
    </a></div>
      <div class="post-nav-item">
    <a href="/1-muduo%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AF%B4%E6%98%8E/" rel="next" title="1.muduo安装使用与源码阅读说明">
      1.muduo安装使用与源码阅读说明 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E8%A7%86C-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6"><span class="nav-text">1.视C++为一个语言联邦</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#C"><span class="nav-text">C++</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E4%B8%AA%E6%AC%A1%E8%AF%AD%E8%A8%80"><span class="nav-text">四个次语言</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%83%E7%BC%96%E7%A8%8B"><span class="nav-text">什么是元编程</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%B0%BD%E9%87%8F%E4%BB%A5const-enum-inline%E6%9B%BF%E6%8D%A2-define"><span class="nav-text">2.尽量以const,enum,inline替换#define</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#define"><span class="nav-text">#define</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-text">问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%A8%E8%AE%B0"><span class="nav-text">谨记</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const"><span class="nav-text">3.尽可能使用const</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const"><span class="nav-text">const</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">4.确定对象被使用前已被初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">初始化</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E4%BA%86%E8%A7%A3C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="nav-text">5.了解C++默默编写并调用哪些函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%B1%BB%E9%BB%98%E8%AE%A4%E7%94%9F%E6%88%90%E7%9A%84%E5%87%A0%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="nav-text">一个空类默认生成的几个函数</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="nav-text">6.若不想使用编译器自动生成的函数，就该明确拒绝</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E7%94%9F%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">7.为多态基类生明virtual析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#virtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">virtual析构函数</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">8.别让异常逃离析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-text">析构函数的异常</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0"><span class="nav-text">9.绝不在构造和析构过程中调用virtual函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E4%BB%A4operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAreference-to-this"><span class="nav-text">10.令operator&#x3D;返回一个reference to *this</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BA%86%E5%AE%9E%E7%8E%B0%E8%BF%9E%E9%94%81%E8%B5%8B%E5%80%BC"><span class="nav-text">为了实现连锁赋值</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-%E5%9C%A8operator-%E4%B8%AD%E5%A4%84%E7%90%86%E2%80%9D%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9D"><span class="nav-text">11.在operator&#x3D;中处理”自我赋值”</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86"><span class="nav-text">12.复制对象时勿忘其每一个成分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#copy%E6%9E%84%E9%80%A0%E5%92%8Ccopy-assignment%E8%A6%81%E5%86%99%E5%AE%8C%E5%85%A8"><span class="nav-text">copy构造和copy assignment要写完全</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="nav-text">13.以对象管理资源</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%84%E6%BA%90"><span class="nav-text">资源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE"><span class="nav-text">资源释放</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83coping%E8%A1%8C%E4%B8%BA"><span class="nav-text">14.在资源管理类中小心coping行为</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-text">15.在资源管理类中提供对原始资源的访问</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="nav-text">16.成对使用new和delete时要采取相同形式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86newed%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">17.以独立语句将newed对象置入智能指针</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="nav-text">18.让接口容易被正确使用，不易被误用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type"><span class="nav-text">19.设计class犹如设计type</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value"><span class="nav-text">20.宁以pass-by-reference-to-const替换pass-by-value</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference"><span class="nav-text">21.必须返回对象时，别妄想返回其reference</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate"><span class="nav-text">22.将成员变量声明为private</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-%E5%AE%81%E4%BB%A5non-member%E3%80%81non-friend%E6%9B%BF%E6%8D%A2member%E5%87%BD%E6%95%B0"><span class="nav-text">23.宁以non-member、non-friend替换member函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0"><span class="nav-text">24.若所有参数皆需类型转换，请为此采用non-member函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0"><span class="nav-text">25.考虑写出一个不抛异常的swap函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4"><span class="nav-text">26.尽可能延后变量定义式的出现时间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C"><span class="nav-text">27.尽量少做转型动作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E5%9E%8B"><span class="nav-text">转型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E6%97%A7%E5%BC%8F%E8%BD%AC%E5%9E%8B"><span class="nav-text">(1)旧式转型</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-C-%E6%96%B0%E5%BC%8F%E8%BD%AC%E5%9E%8B"><span class="nav-text">(2)C++新式转型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-text">注意</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86"><span class="nav-text">28.避免返回handles指向对象内部成分</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29-%E4%B8%BA%E2%80%9C%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="nav-text">29.为“异常安全”而努力是值得的</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8"><span class="nav-text">异常安全</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%89%E4%B8%AA%E4%BF%9D%E8%AF%81"><span class="nav-text">异常安全函数的三个保证</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30-%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="nav-text">30.透彻了解inlining的里里外外</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E"><span class="nav-text">31.将文件间的编译依存关系降至最低</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB"><span class="nav-text">32.确定你的public继承塑模出is-a关系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="nav-text">33.避免遮掩继承而来的名称</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="nav-text">34.区分接口继承和实现继承</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-%E8%80%83%E8%99%91virtual%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="nav-text">35.考虑virtual函数以外的其他选择</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#36-%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0"><span class="nav-text">36.绝不重新定义继承而来的non-virtual函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#37-%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="nav-text">37.绝不重新定义继承而来的缺省参数值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#38-%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BAhas-a%E6%88%96%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D"><span class="nav-text">38.通过复合塑模出has-a或“根据某物实现出”</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF"><span class="nav-text">39.明智而审慎地使用private继承</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-text">40.明智而审慎地使用多重继承</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#41-%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81"><span class="nav-text">41.了解隐式接口和编译期多态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#42-%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="nav-text">42.了解typename的双重意义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#43-%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="nav-text">43.学习处理模块化基类内的名称</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#44-%E5%B0%86%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BBtemplates"><span class="nav-text">44.将与参数无关的代码抽离templates</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#45-%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="nav-text">45.运用成员函数模板接受所有兼容类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#46-%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%AF%B7%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">46.需要类型转换时请为模板定义非成员函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#47-%E8%AF%B7%E4%BD%BF%E7%94%A8traits-classes%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="nav-text">47.请使用traits classes表现类型信息</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#48-%E8%AE%A4%E8%AF%86template%E5%85%83%E7%BC%96%E7%A8%8B"><span class="nav-text">48.认识template元编程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#49-%E4%BA%86%E8%A7%A3new-handler%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="nav-text">49.了解new-handler的行为</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#50-%E4%BA%86%E8%A7%A3new%E5%92%8Cdelete%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="nav-text">50.了解new和delete的合理替换时机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#51-%E7%BC%96%E5%86%99new%E5%92%8Cdelete%E6%97%B6%E9%9C%80%E5%9B%BA%E5%AE%88%E5%B8%B8%E8%A7%84"><span class="nav-text">51.编写new和delete时需固守常规</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#52-%E5%86%99%E4%BA%86placement-new%E4%B9%9F%E8%A6%81%E5%86%99placement-delete"><span class="nav-text">52.写了placement new也要写placement delete</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#53-%E4%B8%8D%E8%A6%81%E8%BD%BB%E5%BF%BD%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%AD%A6%E5%91%8A"><span class="nav-text">53.不要轻忽编译器的警告</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#54-%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89%E5%8C%85%E6%8B%ACTR1%E5%9C%A8%E5%86%85%E7%9A%84%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93"><span class="nav-text">54.让自己熟悉包括TR1在内的标准程序库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#C-98%E5%8A%A0%E5%85%A5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">C++98加入的新特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TR1"><span class="nav-text">TR1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#tr2"><span class="nav-text">tr2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-text">???</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#55-%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89Boost"><span class="nav-text">55.让自己熟悉Boost</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87"><span class="nav-text">目标</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E4%B8%8A%E8%A8%80%E8%AE%BA"><span class="nav-text">网上言论</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不知自己不知"
      src="/images/head.jpeg">
  <p class="site-author-name" itemprop="name">不知自己不知</p>
  <div class="site-description" itemprop="description">o.O</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
    <!--
    <div id="music163player">
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&id=5445280661&auto=0&height=90"></iframe>
       </div>
    -->
  </aside>
  
  
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不知自己不知</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">412k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">6:14</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='255,255,255' opacity='1' zIndex='-1' count='100' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'Dv4yd2JUuvVhLBe640B6m1jw-gzGzoHsz',
      appKey     : 'sNdrMuVcw6jJzlz0HpXBNhdB',
      placeholder: "来交流交流吧~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>



