<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/head.jpeg">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xtlvlv.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":2,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="置顶 之前有用Django2.1做过个小项目，有点经验，可惜这本书是1.8的，之前的没整理笔记很多细节都忘了，做了个思维导图还是在Windows上，在另一个硬盘里也不知道丢哪了，唉">
<meta property="og:type" content="article">
<meta property="og:title" content="《精通Django》">
<meta property="og:url" content="https://xtlvlv.github.io/%E3%80%8A%E7%B2%BE%E9%80%9ADjango%E3%80%8B/index.html">
<meta property="og:site_name" content="不知自己不知">
<meta property="og:description" content="置顶 之前有用Django2.1做过个小项目，有点经验，可惜这本书是1.8的，之前的没整理笔记很多细节都忘了，做了个思维导图还是在Windows上，在另一个硬盘里也不知道丢哪了，唉">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-06T03:05:06.000Z">
<meta property="article:modified_time" content="2021-01-06T03:18:02.864Z">
<meta property="article:author" content="不知自己不知">
<meta property="article:tag" content="python">
<meta property="article:tag" content="django">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xtlvlv.github.io/%E3%80%8A%E7%B2%BE%E9%80%9ADjango%E3%80%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《精通Django》 | 不知自己不知</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">

<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->

<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 

  <!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
  
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不知自己不知</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">59</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">13</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">70</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xtlvlv.github.io/%E3%80%8A%E7%B2%BE%E9%80%9ADjango%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpeg">
      <meta itemprop="name" content="不知自己不知">
      <meta itemprop="description" content="以阅读为生是一件很酷的事，以写作为生是一件更酷的事。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不知自己不知">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《精通Django》
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-06 11:05:06 / 修改时间：11:18:02" itemprop="dateCreated datePublished" datetime="2021-01-06T11:05:06+08:00">2021-01-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/%E3%80%8A%E7%B2%BE%E9%80%9ADjango%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E3%80%8A%E7%B2%BE%E9%80%9ADjango%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>65k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>59 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ul>
<li>之前有用Django2.1做过个小项目，有点经验，可惜这本书是1.8的，之前的没整理笔记很多细节都忘了，做了个思维导图还是在Windows上，在另一个硬盘里也不知道丢哪了，唉</li>
</ul>
<a id="more"></a>

<h1 id="第一章：新手入门"><a href="#第一章：新手入门" class="headerlink" title="第一章：新手入门"></a>第一章：新手入门</h1><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><ul>
<li>python</li>
<li>django</li>
<li>python虚拟环境<ul>
<li>virtualenv</li>
<li>这个非必须</li>
</ul>
</li>
<li>数据库</li>
<li>具体怎么安装就不说了</li>
</ul>
<h3 id="2-新建项目"><a href="#2-新建项目" class="headerlink" title="2. 新建项目"></a>2. 新建项目</h3><ul>
<li><p>新建</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在当前目录新建名为mysite的项目</span><br><span class="line">django-admin startproject mysite</span><br></pre></td></tr></table></figure>
</li>
<li><p>目录结构</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysite&#x2F;     &#x2F;&#x2F;项目的容器。这个目录的名称对 Django 没什么作用,你可以根据喜好重命名</span><br><span class="line">    manage.py   &#x2F;&#x2F;命令行实用脚本,可以通过不同的方式与 Django 项目交互</span><br><span class="line">    mysite&#x2F;     &#x2F;&#x2F;项目的 Python 包。导入这里面的内容要使用目录的名称(如mysite.urls )</span><br><span class="line">        __init__.py &#x2F;&#x2F;空文件,目的是让 Python 把这个目录识别为 Python 包。</span><br><span class="line">        settings.py &#x2F;&#x2F;Django 项目的设置&#x2F;配置</span><br><span class="line">        urls.py &#x2F;&#x2F;URL 声明</span><br><span class="line">        wsgi.py &#x2F;&#x2F;兼容 WSGI 的 Web 服务器的入口点,用于伺服项目</span><br></pre></td></tr></table></figure>
<h3 id="3-Django-的设置"><a href="#3-Django-的设置" class="headerlink" title="3. Django 的设置"></a>3. Django 的设置</h3></li>
<li><p>编辑 mysite/settings.py</p>
</li>
<li><p>TIME_ZONE</p>
<ul>
<li>设置时区</li>
<li>‘Asia/Shanghai’ 上海时间</li>
<li>‘UTC’ 世界标准时间</li>
</ul>
</li>
<li><p>LANGUAGE_CODE</p>
<ul>
<li>设置语言</li>
<li>‘zh-Hans’ 汉语</li>
<li>‘en-us’ 英语</li>
</ul>
</li>
<li><p>ROOT_URLCONF = ‘mysite.urls’</p>
<ul>
<li>设置URL解析的文件</li>
</ul>
</li>
<li><p>INSTALLED_APPS</p>
<ul>
<li>其值是这个 Django 实例中激活的全部 Django 应用</li>
<li>一个应用可以在多个项目中使用,而且应用可以打包,供其他项目使用</li>
<li>默认包含<ul>
<li>django.contrib.admin :管理后台</li>
<li>django.contrib.auth :身份验证系统</li>
<li>django.contrib.contenttypes :内容类型框架</li>
<li>django.contrib.sessions :会话框架</li>
<li>django.contrib.messages :消息框架</li>
<li>django.contrib.staticfiles :管理静态文件的框架</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-开发服务器"><a href="#4-开发服务器" class="headerlink" title="4. 开发服务器"></a>4. 开发服务器</h3><ul>
<li>运行自带的服务器  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure></li>
<li>注意,别在任何生产环境中使用这个服务器,它只能在开发过程中使用。</li>
</ul>
<h3 id="5-模型-视图-控制器设计模式"><a href="#5-模型-视图-控制器设计模式" class="headerlink" title="5. 模型-视图-控制器设计模式"></a>5. 模型-视图-控制器设计模式</h3><ul>
<li>Django 严格遵守 MVC 模式,但是有自己的实现逻辑。“C”部分由框架处理,多数时候,我们的工作在模型、模板和视图中,因此 Django 经常被称为 MTV 框架。在 MTV 开发模式中:</li>
<li>M 表示“模型”,即数据访问层。这一层包含所有与数据相关的功能:访问数据的方式、验证数据的方式、数据的行为、数据之间的关系。第 4 章将深入探讨 Django 的模型。</li>
<li>T 表示“模板”,即表现层。这一层包含表现相关的决策:在网页或其他文档类型中如何显示某个东西。第 3 章将探讨 Django 的模板。</li>
<li>V 表示“视图”,即业务逻辑层。这一层包含访问模型和选择合适模板的逻辑。你可以把视图看做模型和模板之间的桥梁。下一章将讨论 Django 的视图。</li>
</ul>
<h1 id="第二章：视图和-URL-配置"><a href="#第二章：视图和-URL-配置" class="headerlink" title="第二章：视图和 URL 配置"></a>第二章：视图和 URL 配置</h1><h3 id="1-Django-驱动的页面"><a href="#1-Django-驱动的页面" class="headerlink" title="1. Django 驱动的页面"></a>1. Django 驱动的页面</h3><ul>
<li>编写视图<ul>
<li>在前一章创建的 mysite 目录中新建一个空文件,名为 views.py  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line">def hello(request):</span><br><span class="line">    return HttpResponse(&quot;Hello world&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>URL 配置<ul>
<li>修改urls.py  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, include(admin.site.urls)),</span><br><span class="line">    url(r&#39;^hello&#x2F;$&#39;, hello),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>流程  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 请求 &#x2F;hello&#x2F; 。</span><br><span class="line">2. Django 查看 ROOT_URLCONF 设置,找到根 URL 配置。</span><br><span class="line">3. Django 比较 URL 配置中的各个 URL 模式,找到与 &#x2F;hello&#x2F; 匹配的那个。</span><br><span class="line">4. 如果找到匹配的模式,调用对应的视图函数。</span><br><span class="line">5. 视图函数返回一个 HttpResponse 对象。</span><br><span class="line">6. Django 把 HttpResponse 对象转换成正确的 HTTP 响应,得到网页。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-第二个视图：动态内容"><a href="#2-第二个视图：动态内容" class="headerlink" title="2. 第二个视图：动态内容"></a>2. 第二个视图：动态内容</h3><ul>
<li>动态获取时间  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">def hello(request):</span><br><span class="line">    return HttpResponse(&quot;Hello world&quot;)</span><br><span class="line">def current_datetime(request):</span><br><span class="line">    now &#x3D; datetime.datetime.now()</span><br><span class="line">    html &#x3D; &quot;It is now %s.&quot; % now</span><br><span class="line">    return HttpResponse(html)</span><br></pre></td></tr></table></figure>
<h3 id="3-URL-配置和松耦合"><a href="#3-URL-配置和松耦合" class="headerlink" title="3. URL 配置和松耦合"></a>3. URL 配置和松耦合</h3></li>
<li>URL 配置和视图之间就是松耦合的  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果想把这个功能对应的 URL 从 &#x2F;time&#x2F; 移到 &#x2F;current-time&#x2F; ,只需修改URL 配置,视图则不用动</span><br><span class="line">&#x2F;&#x2F;还可以多个URL指向同一个视图</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, include(admin.site.urls)),</span><br><span class="line">    url(r&#39;^hello&#x2F;$&#39;, hello),</span><br><span class="line">    url(r&#39;^time&#x2F;$&#39;, current_datetime),</span><br><span class="line">    url(r&#39;^another-time-page&#x2F;$&#39;, current_datetime),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="4-第三个视图-动态-URL"><a href="#4-第三个视图-动态-URL" class="headerlink" title="4. 第三个视图:动态 URL"></a>4. 第三个视图:动态 URL</h3></li>
<li>处理url带参数的情况</li>
<li>以一定的偏移量显示当前日期和时间。我们的目标是让 /time/plus/1/ 页面显示一小时之后的日期和时间,让 /time/plus/2/ 页面显示两小时之后的日期和时间,以此类推。<ul>
<li>url  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&#39;^time&#x2F;plus&#x2F;(\d&#123;1,2&#125;)&#x2F;$&#39;, hours_ahead),</span><br></pre></td></tr></table></figure></li>
<li>视图  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from django.http import Http404, HttpResponse</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">def hours_ahead(request, offset):</span><br><span class="line">    try:</span><br><span class="line">        offset &#x3D; int(offset)</span><br><span class="line">    except ValueError:</span><br><span class="line">        raise Http404()</span><br><span class="line">    dt &#x3D; datetime.datetime.now() + datetime.timedelta(hours&#x3D;offset)</span><br><span class="line">    html &#x3D; &quot;In %s hour(s), it will be %s.&quot; % (offset, dt)</span><br><span class="line">    return HttpResponse(html)</span><br></pre></td></tr></table></figure></li>
<li>每个视图的第一个参数都是 HttpRequest 对象。</li>
<li>offset 是 URL 模式中那对圆括号捕获的字符串。</li>
</ul>
</li>
<li>这个url写法是1.8，要用正则表达式，貌似2.1有更好写的，不用正则表达式的写法。<ul>
<li>系统的urls.py里，在1.X的时候，都是采用的url方式。如下  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&#39;^&#39;, include(&quot;test1.urls&quot;)),</span><br></pre></td></tr></table></figure></li>
<li>在2.0中，它推荐使用的是path模块，所以这里就改写一下。引包from django.urls import path  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path(&#39;&#39;, include(&quot;test1.urls&quot;)),</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>自己项目的urls.py里，我们也使用path<ul>
<li>1.x里面的写法是  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r’^page&#x3D;(\d+)&amp;key&#x3D;(\w+)$’, views.detail, name&#x3D;”detail”), </span><br></pre></td></tr></table></figure></li>
<li>现在的写法  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re_path(&#39;page&#x3D;(?P&lt;page&gt;\d+)&amp;key&#x3D;(?P&lt;key&gt;\w+)&#39;, views.detail, name&#x3D;&quot;detail&quot;),</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="第三章：Django-模板"><a href="#第三章：Django-模板" class="headerlink" title="第三章：Django 模板"></a>第三章：Django 模板</h1><h3 id="1-模板基础"><a href="#1-模板基础" class="headerlink" title="1. 模板基础"></a>1. 模板基础</h3><ul>
<li>作用<ul>
<li>Django 模板是一些文本字符串,作用是把文档的表现与数据区分开。模板定义一些占位符和基本的逻辑(模板标签),规定如何显示文档。通常,模板用于生成 HTML,不过 Django 模板可以生成任何基于文本的格式。</li>
</ul>
</li>
<li>变量<ul>
<li>两对花括号包围的文本<code>(如 &#123;&#123; person_name &#125;&#125; )</code>是变量,意思是“把指定变量的值插入这里”。如何指定变量的值呢?稍后说明。</li>
</ul>
</li>
<li>条件判断<ul>
<li>一对花括号和百分号包围的文本<code>(如 &#123;% if ordered_warranty %&#125; )`是模板标签。标签的定义相当宽泛:只要能让模板系统“做些事”的就是标签。
- 循环
    - 这个示例模板中有一个 for 标签`( &#123;% for item in item_list %&#125; )`和一个 if 标签`( &#123;% if or-dered_warranty %&#125; )`。 for 标签的作用与 Python 中的 for 语句很像,用于迭代序列中的各个元素。与你预期的一样, if 标签的作用是编写逻辑判断语句。这里, if 标签检查 ordered_warranty 变量的求值结果是不是 True 。如果是,模板系统将显示 `&#123;% ifordered_warranty %&#125;` 和 `&#123;% else %&#125;` 之间的内容;如果不是,模板系统将显示 `&#123;% else %&#125;` 和 `&#123;% endif%&#125;</code> 之间的内容。注意, <code>&#123;% else %&#125;</code> 是可选的。</li>
</ul>
</li>
<li>过滤器<ul>
<li>最后,这个模板的第二段包含一个过滤器,这是调整变量格式最为便利的方式。对这个示例中的 <code>&#123;&#123;ship_date|date:"F j, Y" &#125;&#125;</code> 来说,我们把 ship_date 变量传给 date 过滤器,并且为 date 过滤器指定”F j, Y” 参数。 date 过滤器使用参数指定的格式格式化日期。过滤器使用管道符号<code>|</code>依附,类似于 Unix 管道。</li>
</ul>
</li>
</ul>
<h3 id="2-使用模板系统"><a href="#2-使用模板系统" class="headerlink" title="2. 使用模板系统"></a>2. 使用模板系统</h3><h5 id="创建template对象"><a href="#创建template对象" class="headerlink" title="创建template对象"></a>创建template对象</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from django.template import Template</span><br><span class="line">t &#x3D; Template(&#39;My name is &#123;&#123; name &#125;&#125;.&#39;)</span><br><span class="line">print (t)  </span><br><span class="line">&#x2F;&#x2F;输出：&lt;django.template.base.Template object at 0x030396B0&gt;</span><br></pre></td></tr></table></figure></code></pre>
<h5 id="渲染模板"><a href="#渲染模板" class="headerlink" title="渲染模板"></a>渲染模板</h5><ul>
<li>有了 Template 对象之后,可以为其提供上下文,把数据传给它。上下文就是一系列模板变量和相应的值。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django.template import Context, Template</span><br><span class="line">t &#x3D; Template(&#39;My name is &#123;&#123; name &#125;&#125;.&#39;)</span><br><span class="line">c &#x3D; Context(&#123;&#39;name&#39;: &#39;Stephane&#39;&#125;)</span><br><span class="line">t.render(c)</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">&#39;My name is Stephane.&#39;</span><br></pre></td></tr></table></figure>
<h5 id="Django-模板系统的基本用法"><a href="#Django-模板系统的基本用法" class="headerlink" title="Django 模板系统的基本用法"></a>Django 模板系统的基本用法</h5></li>
<li>编写模板字符串</li>
<li>创建 Template 对象</li>
<li>创建 Context 对象</li>
<li>调用 render() 方法。</li>
</ul>
<h3 id="3-字典和上下文"><a href="#3-字典和上下文" class="headerlink" title="3. 字典和上下文"></a>3. 字典和上下文</h3><ul>
<li>Python 字典是键和值的映射。 Context 对象类似于字典,但是它有额外的功能<h5 id="多个上下文-同一个模板"><a href="#多个上下文-同一个模板" class="headerlink" title="多个上下文,同一个模板"></a>多个上下文,同一个模板</h5>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t &#x3D; Template(&#39;Hello, &#123;&#123; name &#125;&#125;&#39;)</span><br><span class="line">for name in (&#39;John&#39;, &#39;Julie&#39;, &#39;Pat&#39;):</span><br><span class="line">    print (t.render(Context(&#123;&#39;name&#39;: name&#125;)))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="上下文变量查找"><a href="#上下文变量查找" class="headerlink" title="上下文变量查找"></a>上下文变量查找</h5><ul>
<li>模板系统遇到变量名中的点号时会按照下述顺序尝试查找:<ul>
<li>字典查找(如 foo[“bar”] )</li>
<li>属性查找(如 foo.bar )</li>
<li>方法调用(如 foo.bar() )</li>
<li>列表索引查找(如 foo[2] )</li>
</ul>
</li>
<li>下述示例使用的  ,相当于一个字典查找( person[‘name’] )加上一个方法调用( upper() ):  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from django.template import Template, Context</span><br><span class="line">&gt;&gt;&gt; person &#x3D; &#123;&#39;name&#39;: &#39;Sally&#39;, &#39;age&#39;: &#39;43&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; t &#x3D; Template(&#39;&#123;&#123; person.name.upper &#125;&#125; is &#123;&#123; person.age &#125;&#125; years old.&#39;)</span><br><span class="line">&gt;&gt;&gt; c &#x3D; Context(&#123;&#39;person&#39;: person&#125;)</span><br><span class="line">&gt;&gt;&gt; t.render(c)</span><br><span class="line">&#39;SALLY is 43 years old.&#39;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="方法调用的行为"><a href="#方法调用的行为" class="headerlink" title="方法调用的行为"></a>方法调用的行为</h5><ul>
<li>在方法查找的过程中,如果方法抛出异常,异常会向上冒泡,除非异常有 silent_variable_failure 属性,而且值为 True 。如果异常确实有 silent_variable_failure 属性,使用引擎的 string_if_invalid配置选项(默认为一个空字符串)渲染变量。</li>
<li>方法不能有必须的参数。否则,模板系统向后移动到下一种查询类型(列表索引查询)。</li>
<li>按照设计,Django 限制了在模板中可以处理的逻辑量,因此在模板中不能给方法传递参数。数据应该在视图中计算之后再传给模板显示。</li>
<li>显然,有些方法有副作用,如果允许模板系统访问这样的方法,那就愚蠢之极,甚至还可能埋下安全漏洞。</li>
<li>假如有个 BankAccount 对象,它有个 delete() 方法。如果模板中有  这样的内容,其中 account 是 BankAccount 对象,那么渲染模板时会把 account 删除。为了避免这种行为,在方法上设定函数属性 alters_data</li>
</ul>
<h5 id="如何处理无效变量"><a href="#如何处理无效变量" class="headerlink" title="如何处理无效变量"></a>如何处理无效变量</h5><ul>
<li>如果变量不存在,模板系统在变量处插入引擎的 string_if_invalid 配置选项。这个选项的默认值为一个空字符串。</li>
<li>例如  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from django.template import Template, Context</span><br><span class="line">&gt;&gt;&gt; t &#x3D; Template(&#39;Your name is &#123;&#123; name &#125;&#125;.&#39;)</span><br><span class="line">&gt;&gt;&gt; t.render(Context())</span><br><span class="line">&#39;Your name is .&#39;</span><br><span class="line">&gt;&gt;&gt; t.render(Context(&#123;&#39;var&#39;: &#39;hello&#39;&#125;))</span><br><span class="line">&#39;Your name is .&#39;</span><br></pre></td></tr></table></figure>
<h3 id="4-基本的模板标签和过滤器"><a href="#4-基本的模板标签和过滤器" class="headerlink" title="4. 基本的模板标签和过滤器"></a>4. 基本的模板标签和过滤器</h3></li>
</ul>
<h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><ul>
<li>if/elif/else/endif  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if athlete_list %&#125;</span><br><span class="line">Number of athletes: &#123;&#123; athlete_list|length &#125;&#125;</span><br><span class="line">&#123;% elif athlete_in_locker_room_list %&#125;</span><br><span class="line">&lt;p&gt;Athletes should be out of the locker room soon! &lt;&#x2F;p&gt;</span><br><span class="line">&#123;% elif ...</span><br><span class="line">...</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">&lt;p&gt;No athletes. &lt;&#x2F;p&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&#123;% if %&#125;</code> 支持使用 and 、 or 或 not 测试多个变量,或者取反指定的变量。</li>
<li>在同一个标签中可以同时使用 and 和 or ,此时, and 的优先级比 or 高。</li>
<li>在 if 标签中使用括号是无效的句法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if athlete_list and coach_list or cheerleader_list %&#125;</span><br><span class="line">&#x2F;&#x2F;像下面这样解释:但不能像下面这样写</span><br><span class="line">if (athlete_list and coach_list) or cheerleader_list</span><br></pre></td></tr></table></figure></li>
<li>如果需要通过括号指明优先级,应该使用嵌套的 if 标签。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if athlete_list %&#125;</span><br><span class="line">    &#123;% if coach_list or cheerleader_list %&#125;</span><br><span class="line">        &lt;p&gt;We have athletes, and either coaches or cheerleaders! &lt;&#x2F;p&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>for  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for athlete in athlete_list %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; athlete.name &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% empty %&#125;</span><br><span class="line">    &lt;p&gt;There are no athletes. Only computer programmers.&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>&#123;% for %&#125;</code> 循环内部,可以访问一个名为 forloop 的模板变量。这个变量有几个属性,通过它们可以获知循环进程的一些信息:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for item in todo_list %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; forloop.counter &#125;&#125;: &#123;&#123; item &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>forloop.counter 的值是一个整数,表示循环的次数。这个属性的值从 1 开始,因此第一次循环时,forloop.counter 等于 1 。</li>
<li>forloop.counter0 与 forloop.counter 类似,不过是从零开始的。第一次循环时,其值为 0 。</li>
<li>forloop.revcounter 的值是一个整数,表示循环中剩余的元素数量。第一次循环时, for-loop.revcounter 的值是序列中要遍历的元素总数。最后一次循环时, forloop.revcounter 的值为 1 。</li>
<li>forloop.revcounter0 与 forloop.revcounter 类似,不过索引是基于零的。第一次循环时, for-loop.revcounter0 的值是序列中元素数量减去一。最后一次循环时, forloop.revcounter0 的值为 0 。</li>
<li>forloop.first 是个布尔值,第一次循环时为 True 。需要特殊处理第一个元素时很方便:</li>
<li>forloop.last 是个布尔值,最后一次循环时为 True 。经常用它在一组链接之间放置管道符号:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for link in links %&#125;</span><br><span class="line">    &#123;&#123; link &#125;&#125;</span><br><span class="line">    &#123;% if not forloop.last %&#125; </span><br><span class="line">    ， </span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#x2F;&#x2F;结果</span><br><span class="line">Link1 ， Link2 ， Link3 ， Link4</span><br></pre></td></tr></table></figure></li>
<li>在嵌套的循环中, forloop.parentloop 引用父级循环的 forloop 对象。  </li>
</ul>
</li>
</ul>
</li>
<li>ifequal/ifnotequal  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ifequal section &#39;sitenews&#39; %&#125;</span><br><span class="line">    &lt;h1&gt;Site News&lt;&#x2F;h1&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    &lt;h1&gt;No News Here&lt;&#x2F;h1&gt;</span><br><span class="line">&#123;% endifequal %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以下都合法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ifequal variable True %&#125;</span><br><span class="line">&#123;% ifequal variable [1, 2, 3] %&#125;</span><br><span class="line">&#123;% ifequal variable &#123;&#39;key&#39;: &#39;value&#39;&#125; %&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>注释  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;# This is a comment #&#125;</span><br><span class="line">&#123;% comment %&#125;</span><br><span class="line">This is a</span><br><span class="line">multi-line comment.</span><br><span class="line">&#123;% endcomment %&#125;</span><br></pre></td></tr></table></figure>
<h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5></li>
<li>获取列表中的第一个元素,然后将其转换成大写:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; my_list|first|upper &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li>显示 bio 变量的前 30 个词。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; bio|truncatewords:&quot;30&quot; &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li>几个重要过滤器<ul>
<li>addslashes :在反斜线、单引号和双引号前面添加一个反斜线。可用于转义字符串。例如: <code>&#123;&#123; val-ue|addslashes &#125;&#125;</code> 。</li>
<li>date :根据参数中的格式字符串格式化 date 或 datetime 对象。例如: <code>&#123;&#123; pub_date|date:"F j, Y"&#125;&#125;</code> 。格式字符串在附录 E 中说明。</li>
<li>length :返回值的长度。对列表来说,返回元素的数量。对字符串来说,返回字符的数量。如果变量未定义,返回 0 。</li>
</ul>
</li>
</ul>
<h3 id="5-理念和局限"><a href="#5-理念和局限" class="headerlink" title="5. 理念和局限"></a>5. 理念和局限</h3><h5 id="Django-的核心理念"><a href="#Django-的核心理念" class="headerlink" title="Django 的核心理念"></a>Django 的核心理念</h5><ol>
<li>表现与逻辑分离<ul>
<li>模板系统用于控制表现及与其相关的逻辑,仅此而已。超出这一基本目标的功能都不应该支持。</li>
</ul>
</li>
<li>避免重复<ul>
<li>大多数动态网站都使用某种全站通用的设计,例如通用的页头、页脚、导航栏,等等。Django 模板系统应该为此提供便利的方式,把这些元素存储在一个位置,减少重复的代码。模板继承背后就是这个理念。</li>
</ul>
</li>
<li>与 HTML 解耦<ul>
<li>模板系统不应该只能输出 HTML,还要能够生成其他基于文本的格式(也就是纯文本)。</li>
</ul>
</li>
<li>XML 不应该作为模板语言<ul>
<li>如果使用 XML 引擎解析模板,编辑模板时可能引入大量人为错误,而且处理模板有很多额外消耗。 </li>
</ul>
</li>
<li>不要求具备设计能力<ul>
<li>模板系统不应该必须在 WYSIWYG 编辑器(如 Dreamweaver)中才能写出。这样有太多局限,句法不够灵活。</li>
<li>Django 的目标是让模板编写人员能直接编辑 HTML。</li>
</ul>
</li>
<li>透明处理空格<ul>
<li>模板系统不应该特殊处理空格。模板中的空格就是空格,要像文本那样显示出来。不在模板标签中的空格都应该显示。</li>
</ul>
</li>
<li>不重造一门编程语言<ul>
<li>模板系统一定不能允许:<br>  ◦ 为变量赋值<br>  ◦ 编写高级的逻辑</li>
<li>也就是不能重造一门编程语言。模板系统的目标是提供适量的编程功能,例如分支和循环,足够做表现相关的判断就行。</li>
<li>Django 模板系统知道模板最常由设计师编写,而不是程序员,因此不要求具备 Python 知识。</li>
</ul>
</li>
<li>确保安全有保障<ul>
<li>模板系统默认应该禁止包含恶意代码,例如删除数据库记录的命令。这是模板系统不允许随意使用Python 代码的另一个原因。</li>
</ul>
</li>
<li>可扩展<ul>
<li>模板系统应该认识到,高级模板编写人员可能想扩展功能。这是自定义模板标签和过滤器背后的理念。</li>
</ul>
</li>
</ol>
<h3 id="6-在视图中使用模板"><a href="#6-在视图中使用模板" class="headerlink" title="6. 在视图中使用模板"></a>6. 在视图中使用模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from django.template import Template, Context</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line">import datetime</span><br><span class="line">def current_datetime(request):</span><br><span class="line">now &#x3D; datetime.datetime.now()</span><br><span class="line"># 使用文件系统中模板的简单方式</span><br><span class="line"># 这样做不好,因为没有考虑缺少文件的情况</span><br><span class="line">fp &#x3D; open(&#39;&#x2F;home&#x2F;djangouser&#x2F;templates&#x2F;mytemplate.html&#39;)</span><br><span class="line">t &#x3D; Template(fp.read())</span><br><span class="line">fp.close()</span><br><span class="line">html &#x3D; t.render(Context(&#123;&#39;current_date&#39;: now&#125;))</span><br><span class="line">return HttpResponse(html)</span><br></pre></td></tr></table></figure>
<ul>
<li>这么做不够优雅,原因如下:<ol>
<li>没有处理缺少文件的情况。如果 mytemplate.html 文件不存在或不可读, open() 调用会抛出 IOError异常。</li>
<li>模板位置是硬编码的。如果每个视图函数都这么做,要重复编写模板的位置。更别提要输入很多内容了!</li>
<li>有大量乏味的样板代码。生活如此美好,为何每次加载模板时要浪费时间编写 open() 、 fp.read() 和fp.close() 调用。</li>
</ol>
</li>
</ul>
<h3 id="7-模板加载机制"><a href="#7-模板加载机制" class="headerlink" title="7. 模板加载机制"></a>7. 模板加载机制</h3><ol>
<li>为了从文件系统中加载模板,Django 提供了便利而强大的 API,力求去掉模板加载调用和模板自身的冗余</li>
<li>若想使用这个模板加载 API,首先要告诉框架模板的存储位置。这个位置在设置文件中配置。</li>
<li>打开 settings..py 文件,找到 TEMPLATES 设置。它的值是一个列表,分别针对各个模板引擎: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,</span><br><span class="line">        &#39;DIRS&#39;: [],</span><br><span class="line">        &#39;APP_DIRS&#39;: True,</span><br><span class="line">        &#39;OPTIONS&#39;: &#123;</span><br><span class="line">            &#39;context_processors&#39;: [</span><br><span class="line">                &#39;django.template.context_processors.debug&#39;,</span><br><span class="line">                &#39;django.template.context_processors.request&#39;,</span><br><span class="line">                &#39;django.contrib.auth.context_processors.auth&#39;,</span><br><span class="line">                &#39;django.contrib.messages.context_processors.messages&#39;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>BACKEND 的值是一个点分 Python 路径,指向实现 Django 模板后端 API 的模板引擎类。</li>
<li>内置的后端有 <ul>
<li>djan-go.template.backends.django.DjangoTemplates</li>
<li>django.template.backends.jinja2.Jinja2 。</li>
</ul>
</li>
<li>因为多数引擎从文件中加载模板,所以各个引擎的顶层配置包含三个通用的设置:<ul>
<li>DIRS 定义一个目录列表,模板引擎按顺序在里面查找模板源文件。</li>
<li>APP_DIRS 设定是否在安装的应用中查找模板。按约定, APPS_DIRS 设为 True 时, DjangoTemplates 会在INSTALLED_APPS 中的各个应用里查找名为“templates”的子目录。这样,即使 DIRS 为空,模板引擎还能查找应用模板。</li>
<li>OPTIONS 是一些针对后端的设置。</li>
</ul>
</li>
<li>注意<ul>
<li>如果不是构建没有应用的极简程序,最好留空 DIRS 。设置文件默认把 APP_DIRS 设为 True ,因此最好在 Django 应用中放一个“templates”子目录。</li>
<li>如果想在项目根目录中放一些主模板(例如在 mysite/templates 目录中),需要像这样设定 DIRS :  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>代码 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from django.template.loader import get_template</span><br><span class="line">from django.template import Context</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">def current_datetime(request):</span><br><span class="line">    now &#x3D; datetime.datetime.now()</span><br><span class="line">    t &#x3D; get_template(&#39;current_datetime.html&#39;)</span><br><span class="line">    html &#x3D; t.render(Context(&#123;&#39;current_date&#39;: now&#125;))</span><br><span class="line">    return HttpResponse(html)</span><br></pre></td></tr></table></figure>
<h3 id="8-render"><a href="#8-render" class="headerlink" title="8. render()"></a>8. render()</h3></li>
<li>使用 render() 重写的 current_datetime 视图 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django.shortcuts import render</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">def current_datetime(request):</span><br><span class="line">    now &#x3D; datetime.datetime.now()</span><br><span class="line">    return render(request, &#39;current_datetime.html&#39;, &#123;&#39;current_date&#39;: now&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="9-模板子目录"><a href="#9-模板子目录" class="headerlink" title="9. 模板子目录"></a>9. 模板子目录</h3><ul>
<li><p>如果把所有模板存放在一个目录中,很快就会变得不灵便。你可能想把模板存储在模板目录的子目录里,这么做很好。</p>
</li>
<li><p>把模板放到模板目录的子目录中不是难事。调用 get_template() 时,只需在模板名称前面加上子目录的名称和一条斜线,如下所示:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t &#x3D; get_template(&#39;dateapp&#x2F;current_datetime.html&#39;)</span><br><span class="line">&#x2F;&#x2F;或者用render</span><br><span class="line">return render(request, &#39;dateapp&#x2F;current_datetime.html&#39;, &#123;&#39;current_date&#39;: now&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="10-include-模板标签"><a href="#10-include-模板标签" class="headerlink" title="10. include 模板标签"></a>10. include 模板标签</h3></li>
<li><p>只要想在多个模板中使用相同的代码,就可以考虑使用 <code>&#123;% include %&#125;</code> ,去除重复。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include &#39;nav.html&#39; %&#125;</span><br><span class="line">&#123;% include &quot;nav.html&quot; %&#125;</span><br><span class="line">&#123;% include &#39;includes&#x2F;nav.html&#39; %&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># mypage.html</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#123;% include &quot;includes&#x2F;nav.html&quot; %&#125;</span><br><span class="line">&lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line"># includes&#x2F;nav.html</span><br><span class="line">&lt;div id&#x3D;&quot;nav&quot;&gt;</span><br><span class="line">You are in: &#123;&#123; current_section &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>如果 <code>&#123;% include %&#125;</code> 标签的参数指定的模板不存在,Django 会做下面两件事中的一件:</p>
<ul>
<li>DEBUG 为 True 时,渲染 Django 错误页面,显示 TemplateDoesNotExist 异常。</li>
<li>DEBUG 为 False 时,静默,那个标签的位置什么也不显示。</li>
</ul>
</li>
</ul>
<h3 id="11-模板继承"><a href="#11-模板继承" class="headerlink" title="11. 模板继承"></a>11. 模板继承</h3><ul>
<li><p>模板继承是指创建一个基底“骨架”模板,包含网站的所有通用部分,并且定义一些“块”,让子模板覆盖。</p>
</li>
<li><p>基模板base.html</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01&#x2F;&#x2F;EN&quot;&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;My helpful timestamp site&lt;&#x2F;h1&gt;</span><br><span class="line">        &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">        &#123;% block footer %&#125;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &lt;p&gt;Thanks for visiting my site.&lt;&#x2F;p&gt;</span><br><span class="line">        &#123;% endblock %&#125;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>继承基类的current_datetime.html</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;The current time&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">&lt;p&gt;It is now &#123;&#123; current_date &#125;&#125;.&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>继承不影响模板的上下文。也就是说,继承树中的任何模板都能访问上下文中的每一个模板变量。</p>
</li>
<li><p>继承经常使用下述三层结构:</p>
<ol>
<li>创建 base.html 模板,定义网站的整体外观。这个模板的内容很少变化。</li>
<li>为网站中的各个“区域”创建 base_SECTION.html 模板(如 base_photos.html 和 base_forum.html )。这些模板扩展 base.html ,包含各区域专属的样式和设计。</li>
<li>为各种页面创建单独的模板,例如论坛页面或相册。这些模板扩展相应的区域模板。</li>
</ol>
</li>
<li><p>使用模板继承的一些指导方针:</p>
<ol>
<li>如果模板中有 <code>&#123;% extends %&#125;</code> ,必须是模板中的第一个标签。否则,模板继承不起作用。</li>
<li>一般来说,基模板中的 <code>&#123;% block %&#125;</code> 标签越多越好。记住,子模板无需定义父模板中的全部块,因此可以为一些块定义合理的默认内容,只在子模板中覆盖需要的块。钩子多总是好的。</li>
<li>如果发现要在多个模板中重复编写相同的代码,或许说明应该把那些代码移到父模板中的一个 <code>&#123;%block %&#125;</code> 标签里。</li>
<li>如果需要从父模板中的块里获取内容,使用 <code>&#123;&#123; block.super &#125;&#125;</code> ,这是一个“魔法”变量,提供父模板中渲染后的文本。向块中添加内容,而不是完全覆盖时就可以这么做。</li>
<li>在同一个模板中不能为多个 <code>&#123;% block %&#125;</code> 标签定义相同的名称。之所以有这个限制,是因为 block 标签是双向的。即, block 标签不仅标识供填充的空位,还用于定义填充父模板中空位的内容。如果一个模板中有两个同名的块,那么父模板就不知道使用哪个块里的内容。</li>
<li>传给 <code>&#123;% extends %&#125;</code> 的模板名称使用与 get_template() 相同的方法加载。即,模板在 DIRS 设置定义的目录中,或者在当前 Django 应用的“templates”目录里。</li>
<li>多数情况下, <code>&#123;% extends %&#125;</code> 的参数是字符串,不过如果直到运行时才知道父模板的名称,也可以用变量。通过这一点可以做些动态判断。</li>
</ol>
</li>
</ul>
<h1 id="第四章：Django模型"><a href="#第四章：Django模型" class="headerlink" title="第四章：Django模型"></a>第四章：Django模型</h1><h3 id="1-在视图中执行数据库查询的“愚蠢”方式"><a href="#1-在视图中执行数据库查询的“愚蠢”方式" class="headerlink" title="1. 在视图中执行数据库查询的“愚蠢”方式"></a>1. 在视图中执行数据库查询的“愚蠢”方式</h3><ul>
<li>通过MySQLdb连接  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from django.shortcuts import render</span><br><span class="line">import MySQLdb</span><br><span class="line"></span><br><span class="line">def book_list(request):</span><br><span class="line">    db &#x3D; MySQLdb.connect(user&#x3D;&#39;me&#39;, db&#x3D;&#39;mydb&#39;, passwd&#x3D;&#39;secret&#39;, host&#x3D;&#39;localhost&#39;)</span><br><span class="line">    cursor &#x3D; db.cursor()</span><br><span class="line">    cursor.execute(&#39;SELECT name FROM books ORDER BY name&#39;)</span><br><span class="line">    names &#x3D; [row[0] for row in cursor.fetchall()]</span><br><span class="line">    db.close()</span><br><span class="line">    return render(request, &#39;book_list.html&#39;, &#123;&#39;names&#39;: names&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-配置数据库"><a href="#2-配置数据库" class="headerlink" title="2. 配置数据库"></a>2. 配置数据库</h3><ul>
<li>在 settings.py 文件中添加的初始配置  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DATABASES &#x3D; &#123;</span><br><span class="line">    &#39;default&#39;: &#123;</span><br><span class="line">        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,</span><br><span class="line">        &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ENGINE 告诉 Django 使用哪个数据库引擎。默认sqlite3</li>
<li>NAME 告诉 Django 数据库的名称。例如: ‘NAME’: ‘mydb’, 。</li>
<li>一个连接mysql的示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATABASES &#x3D; &#123;</span><br><span class="line">    &#39;default&#39;: &#123;</span><br><span class="line">    &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,</span><br><span class="line">    &#39;NAME&#39;: &#39;schemename&#39;,</span><br><span class="line">    &#39;USER&#39;: &#39;root&#39;,</span><br><span class="line">    &#39;PASSWORD&#39;:&#39;...&#39;,</span><br><span class="line">    &#39;HOST&#39;:&#39;localhost&#39;,</span><br><span class="line">    &#39;PORT&#39;:&#39;3306&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-第一个应用"><a href="#3-第一个应用" class="headerlink" title="3. 第一个应用"></a>3. 第一个应用</h3></li>
</ul>
</li>
<li>项目与应用之间有什么区别呢?<ol>
<li>区别是一个是配置,一个是代码。</li>
<li>一个项目是一系列 Django 应用的实例,外加那些应用的配置。严格来说,一个项目唯一需要的是一个设定文件,定义数据库连接信息、安装的应用列表、 DIRS ,等等。</li>
<li>一个应用是一系列便携的 Django 功能,通常包含模型和视图。打包在一个 Python 包里。Django 自带了一些应用,例如管理后台。这些应用的独特之处是便携,可以在多个项目中复用。</li>
<li>编写的代码在这二者之间游走,没有严格的界限。如果构建的是简单的网站,可能只会使用一个应用;如果构建复杂的网站,有几个不相关的部分,如电商系统和留言板,可能想把各部分放在单独的应用中,这样以后可以复用。</li>
<li>如果使用 Django 的数据库层(模型),必须创建 Django 应用。模型必须保存在应用中。因此,编写模型之前,要新建一个应用。</li>
</ol>
</li>
<li>创建应用  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp books </span><br></pre></td></tr></table></figure></li>
<li>应用目录结构  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">books&#x2F;</span><br><span class="line">    &#x2F;migrations</span><br><span class="line">    __init__.py</span><br><span class="line">    admin.py</span><br><span class="line">    models.py</span><br><span class="line">    tests.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-使用-Python-定义模型"><a href="#4-使用-Python-定义模型" class="headerlink" title="4. 使用 Python 定义模型"></a>4. 使用 Python 定义模型</h3><ul>
<li>Django 模型是使用 Python 代码对数据库中数据的描述,是数据的结构,等效于 SQL 中的 CREATE TABLE 语句,不过是用 Python 代码而非 SQL 表述的,而且不仅包含数据库列的定义。</li>
<li>“使用 Python 代替 SQL 定义数据模型是不是多此一举?”Django 之所以这么做有几个原因:<ul>
<li>内省(introspection)有开销,而且不完美。为了提供便利的数据访问 API,Django 需要以某种方式知晓数据库布局,而这一需求有两种实现方式。第一种是使用 Python 明确描述数据,第二种是在运行时内省数据库,推知数据模型。第二种方式在一个地方存储表的元数据,看似更简单,其实会导致几个问题。首先,运行时内省数据库肯定有消耗。如果每次执行请求,或者只是初始化 Web 服务器都要内省数据库,那带来的消耗是无法接受的。其次,有些数据库,尤其是旧版 MySQL,存储的元数据不足以完成内省。</li>
<li>Python 编写起来让人心情舒畅,而且使用 Python 编写所有代码无需频繁让大脑切换情境。</li>
<li>把数据模型保存在代码中比保存在数据库中易于做版本控制,易于跟踪数据布局的变化。</li>
<li>SQL 对数据布局的元数据只有部分支持。例如,多数数据库系统没有提供专门表示电子邮件地址或URL 的数据类型。而 Django 模型有。高层级的数据结构有助于提升效率,让代码更便于复用。</li>
<li>不同数据库平台使用的 SQL 不一致。</li>
</ul>
</li>
<li>缺点:<ul>
<li>模型的 Python 代码可能与数据库的真正结构脱节。如果修改了 Django 模型,还要在数据库中做相同的改动,让数据库与模型保持一致。本章后面讨论迁移(migration)时会说明如何处理这个问题。</li>
</ul>
</li>
</ul>
<h5 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h5><ul>
<li><p>在models.py文件中</p>
</li>
<li><p>图书-作者-出版社</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class Publisher(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    address &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    city &#x3D; models.CharField(max_length&#x3D;60)</span><br><span class="line">    state_province &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    country &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    website &#x3D; models.URLField()</span><br><span class="line"></span><br><span class="line">class Author(models.Model):</span><br><span class="line">    first_name &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    last_name &#x3D; models.CharField(max_length&#x3D;40)</span><br><span class="line">    email &#x3D; models.EmailField()</span><br><span class="line"></span><br><span class="line">class Book(models.Model):</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;100)</span><br><span class="line">    authors &#x3D; models.ManyToManyField(Author)</span><br><span class="line">    publisher &#x3D; models.ForeignKey(Publisher)</span><br><span class="line">    publication_date &#x3D; models.DateField()</span><br></pre></td></tr></table></figure>
<h5 id="安装模型"><a href="#安装模型" class="headerlink" title="安装模型"></a>安装模型</h5></li>
<li><p>编写好代码之后,要在数据库中创建表。为此,第一步是在 Django 项目中激活那些模型。激活的方法是把books 应用添加到设置文件中“安装的应用”列表中。</p>
</li>
<li><p>打开 settings.py 文件,找到 INSTALLED_APPS 设置。它的作用是告诉 Django,当前项目激活了哪些应用。</p>
</li>
<li><p>为了注册我们开发的“books”应用,要把 ‘books’ (指代我们正在开发的“books”应用)添加到 INSTALLED_APPS中,得到下述设置:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS &#x3D; [</span><br><span class="line">    &#39;django.contrib.admin&#39;,</span><br><span class="line">    &#39;django.contrib.auth&#39;,</span><br><span class="line">    &#39;django.contrib.contenttypes&#39;,</span><br><span class="line">    &#39;django.contrib.sessions&#39;,</span><br><span class="line">    &#39;django.contrib.messages&#39;,</span><br><span class="line">    &#39;django.contrib.staticfiles&#39;,</span><br><span class="line">    &#39;books&#39;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>首先,运行下述命令,验证模型:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py check</span><br></pre></td></tr></table></figure>
<ul>
<li>check 命令运行 Django 系统检查框架,即验证 Django 项目的一系列静态检查。如果一切正常,你将看到这个消息: System check identified no issues (0 silenced) 。如若不然,请确保你输入的模型代码是正确的。错误消息应该会告诉你代码哪里出错了。</li>
<li>只要觉得模型有问题,就可以运行 python manage.py check ,它能捕获全部常见的模型问题。</li>
</ul>
</li>
<li><p>告诉 Django ，对模型做了修改(第一次运行是新建了模型):</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations books   </span><br><span class="line">&#x2F;&#x2F;books是应用名</span><br></pre></td></tr></table></figure>
<ul>
<li>Django 把对模型(也就是数据库模式)的改动存储在迁移中,迁移就是磁盘中的文件。</li>
<li>运行上述命令后,books 应用的 migrations 文件夹里会出现一个名为 0001_initial.py 的文件。</li>
<li>migrate 命令会查看最新的迁移文件,自动更新数据库模式</li>
<li>查看将运行的 SQL。 sqlmigrate 命令的参数是迁移名称,输出的结果是对应的 SQL:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py sqlmigrate books 0001</span><br></pre></td></tr></table></figure></li>
<li>你应该看到类似下面的输出(为了便于阅读,重新做了排版):  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">CREATE TABLE &quot;books_author&quot; (</span><br><span class="line">    &quot;id&quot; integer NOT NULL PRIMARY KEY AUTOINCREMENT,</span><br><span class="line">    &quot;first_name&quot; varchar(30) NOT NULL,</span><br><span class="line">    &quot;last_name&quot; varchar(40) NOT NULL,</span><br><span class="line">    &quot;email&quot; varchar(254) NOT NULL</span><br><span class="line">);</span><br><span class="line">......&#x2F;&#x2F;省略</span><br></pre></td></tr></table></figure></li>
<li>sqlmigrate 命令并不创建表,其实它根本不接触数据库,而是在屏幕上输出 Django 将执行的 SQL。如果愿意,可以把输出的 SQL 复制粘贴到数据库客户端里</li>
</ul>
</li>
<li><p>提交SQL</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>
<ul>
<li>迁移是 Django 把模型改动(添加字段、删除模型,等等)应用到数据库模式的方式。大多数情况下,迁移能自动完成工作,然而也有一些不足。</li>
</ul>
</li>
</ul>
<h3 id="5-基本的数据访问"><a href="#5-基本的数据访问" class="headerlink" title="5. 基本的数据访问"></a>5. 基本的数据访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from books.models import Publisher</span><br><span class="line">&gt;&gt;&gt; p1 &#x3D; Publisher(name&#x3D;&#39;Apress&#39;, address&#x3D;&#39;2855 Telegraph Avenue&#39;,</span><br><span class="line">...</span><br><span class="line">city&#x3D;&#39;Berkeley&#39;, state_province&#x3D;&#39;CA&#39;, country&#x3D;&#39;U.S.A.&#39;,</span><br><span class="line">...</span><br><span class="line">website&#x3D;&#39;http:&#x2F;&#x2F;www.apress.com&#x2F;&#39;)</span><br><span class="line">&gt;&gt;&gt; p1.save()</span><br><span class="line">&gt;&gt;&gt; p2 &#x3D; Publisher(name&#x3D;&quot;O&#39;Reilly&quot;, address&#x3D;&#39;10 Fawcett St.&#39;,</span><br><span class="line">...</span><br><span class="line">city&#x3D;&#39;Cambridge&#39;, state_province&#x3D;&#39;MA&#39;, country&#x3D;&#39;U.S.A.&#39;,</span><br><span class="line">...</span><br><span class="line">website&#x3D;&#39;http:&#x2F;&#x2F;www.oreilly.com&#x2F;&#39;)</span><br><span class="line">&gt;&gt;&gt; p2.save()</span><br><span class="line">&gt;&gt;&gt; publisher_list &#x3D; Publisher.objects.all()</span><br><span class="line">&gt;&gt;&gt; publisher_list</span><br><span class="line">[&lt;Publisher: Publisher object&gt;, &lt;Publisher: Publisher object&gt;]</span><br></pre></td></tr></table></figure>
<ul>
<li>这几行代码完成的工作<ul>
<li>首先,导入 Publisher 模型类,以便与保存出版社的数据库表交互。</li>
<li>提供各个字段的值, name 、 address ,等等,实例化一个 Publisher 对象。</li>
<li>为了把对象保存到数据库中,调用 save() 方法。Django 在背后执行 SQL INSERT 语句。</li>
<li>为了从数据库中检索出版社,使用 Publisher.objects 属性,你可以把它的值理解为全部出版社。使用 Publisher.objects.all() 获取数据库中的所有 Publisher 对象。Django 在背后执行 SQL SELECT 语句。</li>
</ul>
</li>
<li>使用 Django 模型 API 创建的对象不会自动保存,只能自己动手调用 save() 方法</li>
</ul>
<h5 id="添加模型的字符串表示形式"><a href="#添加模型的字符串表示形式" class="headerlink" title="添加模型的字符串表示形式"></a>添加模型的字符串表示形式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; publisher_list</span><br><span class="line">[&lt;Publisher: Publisher object&gt;, &lt;Publisher: Publisher object&gt;]</span><br></pre></td></tr></table></figure>
<ul>
<li>上例得到的输出,不易区分各个 Publisher 对象，这个问题易于修正,为 Publisher 类添加一个名为 <strong>str</strong>() 的方法即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Publisher(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    address &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    city &#x3D; models.CharField(max_length&#x3D;60)</span><br><span class="line">    state_province &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    country &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    website &#x3D; models.URLField()</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br></pre></td></tr></table></figure></li>
<li>新的输出<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; publisher_list</span><br><span class="line">[&lt;Publisher: Apress&gt;, &lt;Publisher: O&#39;Reilly&gt;]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="插入和更新数据"><a href="#插入和更新数据" class="headerlink" title="插入和更新数据"></a>插入和更新数据</h5><ul>
<li>插入如上例中的，创建对象p,p.save();</li>
<li>更新就是更改p,例如  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.name&#x3D;&quot;newname&quot;</span><br><span class="line">p.save()    &#x2F;&#x2F;还要调用这一步，而且是全部更新，并不是只更新修改的，这在某些逻辑中可能导致条件竞争。</span><br></pre></td></tr></table></figure>
<h5 id="选择对象"><a href="#选择对象" class="headerlink" title="选择对象"></a>选择对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.all()</span><br><span class="line">[&lt;Publisher: Apress&gt;, &lt;Publisher: O&#39;Reilly&gt;]</span><br><span class="line">&#x2F;&#x2F;这基本上相当于下述 SQL 语句:</span><br><span class="line">SELECT id, name, address, city, state_province, country, website</span><br><span class="line">FROM books_publisher;</span><br></pre></td></tr></table></figure></li>
<li>分析 Publisher.objects.all() 这行代码:<ul>
<li>首先, Publisher 是我们定义的模型。这没什么可意外的,想查找数据就应该使用相应的模型。</li>
<li>然后,访问 objects 属性。这叫管理器(manager),在第 9 章详述。现在,你只需知道,管理器负责<br>所有“表层”数据操作,包括(最重要的)数据查询。所有模型都自动获得一个 objects 管理器,需要查询模型实例时都要使用它。</li>
<li>最后,调用 all() 方法。这是 objects 管理器的一个方法,返回数据库中的所有行。虽然返回的对象看似一个列表,但其实是一个查询集合(QuerySet)——表示数据库中一系列行的对象。附录 C 将详细说明查询集合。本章都将把它视作它所模仿的列表。</li>
</ul>
</li>
</ul>
<h5 id="过滤数据-filter"><a href="#过滤数据-filter" class="headerlink" title="过滤数据,filter()"></a>过滤数据,filter()</h5><ul>
<li>我们很少需要一次性从数据库中选择所有数据。多数情况下,我们只想处理数据的子集。</li>
<li>可以使用 filter() 方法过滤数据:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.filter(name&#x3D;&#39;Apress&#39;)</span><br><span class="line">[&lt;Publisher: Apress&gt;]</span><br></pre></td></tr></table></figure></li>
<li>与 Python 一样,Django 使用双下划线表示“魔法”操作。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.filter(name__contains&#x3D;&quot;press&quot;)</span><br><span class="line">[&lt;Publisher: Apress&gt;]</span><br><span class="line">&#x2F;&#x2F;Django 把 __contains 部分转换成 SQL LIKE 语句:</span><br><span class="line">SELECT id, name, address, city, state_province, country, website</span><br><span class="line">FROM books_publisher</span><br><span class="line">WHERE name LIKE &#39;%press%&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li>支持的其他查找类型有: icontains (不区分大小写的 LIKE ), startswith 和 endswith ,以及 range (SQLBETWEEN 语句)<h5 id="检索单个对象-get"><a href="#检索单个对象-get" class="headerlink" title="检索单个对象,get()"></a>检索单个对象,get()</h5></li>
</ul>
</li>
<li>上述 filter() 示例都返回一个查询集合(可视作列表)。有时,较之列表,更适合获取单个对象。此时应该使用 get() 方法:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.get(name&#x3D;&quot;Apress&quot;)</span><br><span class="line">&lt;Publisher: Apress&gt;</span><br></pre></td></tr></table></figure></li>
<li>返回多个对象和不返回对象都会导致异常</li>
</ul>
<h5 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.order_by(&quot;name&quot;)</span><br><span class="line">[&lt;Publisher: Apress&gt;, &lt;Publisher: O&#39;Reilly&gt;]</span><br></pre></td></tr></table></figure>
<ul>
<li>逆序，加减号-<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.order_by(&quot;-name&quot;)</span><br><span class="line">[&lt;Publisher: O&#39;Reilly&gt;, &lt;Publisher: Apress&gt;]</span><br></pre></td></tr></table></figure></li>
<li>可以在模型中指定排序  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Publisher(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    address &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    city &#x3D; models.CharField(max_length&#x3D;60)</span><br><span class="line">    state_province &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    country &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    website &#x3D; models.URLField()</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        ordering &#x3D; [&#39;name&#39;]</span><br></pre></td></tr></table></figure>
<h5 id="链式查找"><a href="#链式查找" class="headerlink" title="链式查找"></a>链式查找</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.filter(country&#x3D;&quot;U.S.A.&quot;).order_by(&quot;-name&quot;)</span><br><span class="line">[&lt;Publisher: O&#39;Reilly&gt;, &lt;Publisher: Apress&gt;]</span><br></pre></td></tr></table></figure>
<h5 id="切片数据"><a href="#切片数据" class="headerlink" title="切片数据"></a>切片数据</h5></li>
<li>返回第一个  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.order_by(&#39;name&#39;)[0]   &#x2F;&#x2F;注意,不支持使用负数:</span><br><span class="line">&lt;Publisher: Apress&gt;</span><br></pre></td></tr></table></figure></li>
<li>检索数据子集:得到的是两个对象  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Publisher.objects.order_by(&#39;name&#39;)[0:2]</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">SELECT id, name, address, city, state_province, country, website</span><br><span class="line">FROM books_publisher</span><br><span class="line">ORDER BY name</span><br><span class="line">OFFSET 0 LIMIT 2;</span><br></pre></td></tr></table></figure>
<h5 id="在一个语句中更新多个对象"><a href="#在一个语句中更新多个对象" class="headerlink" title="在一个语句中更新多个对象"></a>在一个语句中更新多个对象</h5></li>
<li>这种办法会导致竞争条件  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p &#x3D; Publisher.objects.get(name&#x3D;&#39;Apress&#39;)</span><br><span class="line">&gt;&gt;&gt; p.name &#x3D; &#39;Apress Publishing&#39;</span><br><span class="line">&gt;&gt;&gt; p.save()</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">SELECT id, name, address, city, state_province, country, website</span><br><span class="line">FROM books_publisher</span><br><span class="line">WHERE name &#x3D; &#39;Apress&#39;;</span><br><span class="line"></span><br><span class="line">UPDATE books_publisher SET</span><br><span class="line">    name &#x3D; &#39;Apress Publishing&#39;,</span><br><span class="line">    address &#x3D; &#39;2855 Telegraph Ave.&#39;,</span><br><span class="line">    city &#x3D; &#39;Berkeley&#39;,</span><br><span class="line">    state_province &#x3D; &#39;CA&#39;,</span><br><span class="line">    country &#x3D; &#39;U.S.A.&#39;,</span><br><span class="line">    website &#x3D; &#39;http:&#x2F;&#x2F;www.apress.com&#39;</span><br><span class="line">WHERE id &#x3D; 52;</span><br></pre></td></tr></table></figure></li>
<li>更高效,而且不会导致条件竞争的办法  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Publisher.objects.filter(id&#x3D;52).update(name&#x3D;&#39;Apress Publishing&#39;)</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">UPDATE books_publisher</span><br><span class="line">SET name &#x3D; &#39;Apress Publishing&#39;</span><br><span class="line">WHERE id &#x3D; 52;</span><br></pre></td></tr></table></figure></li>
<li>update() 方法可以在任何 QuerySet 对象上调用,这意味着可以通过它批量编辑多个记录。下述代码把每个Publisher 记录的 country 列都由 ‘U.S.A.’ 改为 ‘USA’ :  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Publisher.objects.all().update(country&#x3D;&#39;USA&#39;)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<ul>
<li>update() 方法有返回值,是一个整数,表示修改的记录数量。在上述示例中,返回值是 2 。</li>
</ul>
</li>
</ul>
<h5 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;method 1</span><br><span class="line">&gt;&gt;&gt; p &#x3D; Publisher.objects.get(name&#x3D;&quot;O&#39;Reilly&quot;)</span><br><span class="line">&gt;&gt;&gt; p.delete()</span><br><span class="line">&gt;&gt;&gt; Publisher.objects.all()</span><br><span class="line">[&lt;Publisher: Apress Publishing&gt;]</span><br><span class="line">&#x2F;&#x2F;way 2</span><br><span class="line">&gt;&gt;&gt; Publisher.objects.filter(country&#x3D;&#39;USA&#39;).delete()</span><br><span class="line">&gt;&gt;&gt; Publisher.objects.all().delete()</span><br></pre></td></tr></table></figure>

<h1 id="第五章：Django-管理后台"><a href="#第五章：Django-管理后台" class="headerlink" title="第五章：Django 管理后台"></a>第五章：Django 管理后台</h1><h3 id="1-使用-Django-管理后台"><a href="#1-使用-Django-管理后台" class="headerlink" title="1. 使用 Django 管理后台"></a>1. 使用 Django 管理后台</h3><ul>
<li>运行 django-admin startproject mysite 时,Django 为我们创建并配置了默认的管理后台。我们只需创建一个管理员用户(超级用户),就可以登录管理后台。<h5 id="创建管理员用户"><a href="#创建管理员用户" class="headerlink" title="创建管理员用户"></a>创建管理员用户</h5>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br><span class="line">Username: admin</span><br><span class="line">Email address: admin@example.com</span><br><span class="line">Password: **********</span><br><span class="line">Password (again): *********</span><br><span class="line">Superuser created successfully.</span><br></pre></td></tr></table></figure>
<h5 id="登录后台"><a href="#登录后台" class="headerlink" title="登录后台"></a>登录后台</h5></li>
<li>/admin</li>
<li>input the username and password</li>
</ul>
<h3 id="2-把模型添加到-Django-管理后台中"><a href="#2-把模型添加到-Django-管理后台中" class="headerlink" title="2. 把模型添加到 Django 管理后台中"></a>2. 把模型添加到 Django 管理后台中</h3><ul>
<li>在应用文件夹下有个admin.py文件，如果没有自己创建  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from .models import Publisher, Author, Book</span><br><span class="line"></span><br><span class="line">admin.site.register(Publisher)</span><br><span class="line">admin.site.register(Author)</span><br><span class="line">admin.site.register(Book)</span><br></pre></td></tr></table></figure>
<h3 id="3-把字段设为可选的"><a href="#3-把字段设为可选的" class="headerlink" title="3. 把字段设为可选的"></a>3. 把字段设为可选的</h3></li>
<li>即数据库中表的某些字段可以为空，要修改模型，加上blank=True  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Author(models.Model):</span><br><span class="line">    first_name &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    last_name &#x3D; models.CharField(max_length&#x3D;40)</span><br><span class="line">    email &#x3D; models.EmailField(blank&#x3D;True)</span><br></pre></td></tr></table></figure>
<h5 id="把日期和数值字段设为可选的"><a href="#把日期和数值字段设为可选的" class="headerlink" title="把日期和数值字段设为可选的"></a>把日期和数值字段设为可选的</h5></li>
<li>若是字符串,可以不设置blank=true，如果不输入，默认为””,注意NULL和空字符串不一样</li>
<li>如果想让日期字段(如 DateField 、TimeField 、DateTimeField )或数值字段(如IntegerField 、DecimalField 、FloatField )接受空值,要同时添加 null=True 和 blank=True 。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;100)</span><br><span class="line">    authors &#x3D; models.ManyToManyField(Author)</span><br><span class="line">    publisher &#x3D; models.ForeignKey(Publisher)</span><br><span class="line">    publication_date &#x3D; models.DateField(blank&#x3D;True, null&#x3D;True)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-自定义字段的标注"><a href="#4-自定义字段的标注" class="headerlink" title="4. 自定义字段的标注"></a>4. 自定义字段的标注</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Author(models.Model):</span><br><span class="line">    first_name &#x3D; models.CharField(max_length&#x3D;30)</span><br><span class="line">    last_name &#x3D; models.CharField(max_length&#x3D;40)</span><br><span class="line">    email &#x3D; models.EmailField(blank&#x3D;True, verbose_name&#x3D;&#39;e-mail&#39;)</span><br><span class="line">    &#x2F;&#x2F;使用e-mail作为名字</span><br></pre></td></tr></table></figure>

<h3 id="5-自定义-ModelAdmin-类"><a href="#5-自定义-ModelAdmin-类" class="headerlink" title="5. 自定义 ModelAdmin 类"></a>5. 自定义 ModelAdmin 类</h3><h5 id="自定义修改列表"><a href="#自定义修改列表" class="headerlink" title="自定义修改列表"></a>自定义修改列表</h5><ul>
<li>默认情况下,修改列表显示的是各个对象的 __str__() 方法返回的结果。</li>
<li>我们可以改进这种默认行为,在修改列表中添加几个其他字段。比如说,可以在列表中显示作者的电子邮件地址;另外,如果能按照名字和姓排序就好了。</li>
<li>为此,要为 Author 模型定义一个 ModelAdmin 子类。这个类是定制管理后台的关键,其中最基本的一件事是指定修改列表页面显示的字段。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;修改 admin.py 文件</span><br><span class="line">from django.contrib import admin</span><br><span class="line">from mysite.books.models import Publisher, Author, Book</span><br><span class="line"></span><br><span class="line">class AuthorAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display &#x3D; (&#39;first_name&#39;, &#39;last_name&#39;, &#39;email&#39;)</span><br><span class="line">    search_fields &#x3D; (&#39;first_name&#39;, &#39;last_name&#39;)</span><br><span class="line"></span><br><span class="line">class BookAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display &#x3D; (&#39;title&#39;, &#39;publisher&#39;, &#39;publication_date&#39;)</span><br><span class="line">    list_filter &#x3D; (&#39;publication_date&#39;,)</span><br><span class="line">    date_hierarchy &#x3D; &#39;publication_date&#39;</span><br><span class="line">    ordering &#x3D; (&#39;-publication_date&#39;,)</span><br><span class="line"></span><br><span class="line">admin.site.register(Publisher)</span><br><span class="line">admin.site.register(Author, AuthorAdmin)</span><br><span class="line">admin.site.register(Book)</span><br></pre></td></tr></table></figure>
<ul>
<li>list_display是显示哪些内容</li>
<li>search_fields 是可以按照这些字段搜索</li>
<li>list_filter 是添加过滤，比如：今天，近7天，近1个月。list_filter 也能处理其他类型的字段,而非 DateField 一个。(比如说,可以试试 BooleanField 和 For-eignKey 字段。)只要有超过两个值供选择,过滤器就会显示。</li>
<li>提供日期过滤器的另一种方法是使用date_hierarchy 选项，添加这个选项之后,修改列表上边会显示一个日期层级导航栏</li>
<li>ordering，让修改列表页面的图书始终以出版日期倒序排列</li>
</ul>
</li>
</ul>
<h5 id="自定义编辑表单"><a href="#自定义编辑表单" class="headerlink" title="自定义编辑表单"></a>自定义编辑表单</h5><ul>
<li>我们可以在 ModelAdmin 子类中使用 fields 选项修改排序:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class BookAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display &#x3D; (&#39;title&#39;, &#39;publisher&#39;, &#39;publication_date&#39;)</span><br><span class="line">    list_filter &#x3D; (&#39;publication_date&#39;,)</span><br><span class="line">    date_hierarchy &#x3D; &#39;publication_date&#39;</span><br><span class="line">    ordering &#x3D; (&#39;-publication_date&#39;,)</span><br><span class="line">    fields &#x3D; (&#39;title&#39;, &#39;authors&#39;, &#39;publisher&#39;, &#39;publication_date&#39;)</span><br><span class="line">    filter_horizontal &#x3D; (&#39;authors&#39;,)</span><br><span class="line">    raw_id_fields &#x3D; (&#39;publisher&#39;,)</span><br></pre></td></tr></table></figure>
<ul>
<li>filter_horizontal,用于多对多的字段</li>
<li>raw_id_fields 用于一对多的字段</li>
</ul>
</li>
<li>fields 选项还有一个作用:排除特定的字段,禁止编辑。只需去掉想排除的字段即可。</li>
</ul>
<h3 id="6-用户、分组和权限"><a href="#6-用户、分组和权限" class="headerlink" title="6. 用户、分组和权限"></a>6. 用户、分组和权限</h3><ul>
<li>有一些字段用于定义允许用户在管理界面中做什么<ul>
<li>“Active”控制是否激活用户。如果未勾选,即便用户使用有效的密码也无法登录。</li>
<li>“Staff status”控制是否允许用户登录管理界面(即是否把用户当做组织中的一员)。因为这个用户系统也用于控制面向公众的网站(即前台,参见第 11 章),所以这个旗标对公开用户和管理员是有区别的。</li>
<li>“Superuser status”为用户赋予所有权限,可以在管理界面中添加、编辑和删除任何对象。如果勾选,用户的常规权限(即使没有)不再考虑。</li>
</ul>
</li>
<li>“普通的”管理员,即已激活且不是超级用户,所具有的管理权限是一项项赋予的。</li>
</ul>
<h3 id="7-何时以及为何使用管理界面"><a href="#7-何时以及为何使用管理界面" class="headerlink" title="7. 何时以及为何使用管理界面"></a>7. 何时以及为何使用管理界面</h3><ul>
<li>一个在线功能(例如市政供水水质特别报道)的开发过程通常是这样的:<ul>
<li>负责该项目的记者与一位开发者碰头,指出所需的数据。</li>
<li>开发者设计满足需求的 Django 模型,然后打开管理后台给记者看。</li>
<li>记者审查管理后台,及时指出缺少或多余的字段。开发者不断修改模型。</li>
<li>得到满意的模型之后,记者开始在管理后台中输入数据。与此同时,程序员可以集中精力开发面向公众的视图/模板(即开发过程中有趣的部分)。</li>
</ul>
</li>
<li>除了输入数据之外,管理后台还有很多用处:<ul>
<li>审查数据模型:定义几个模型之后,可以在管理界面中查看,输入一些虚拟数据。有时,在这个过程中能够发现数据建模等问题。</li>
<li>管理从别处得到的数据:对依靠外部源(例如用户或 Web 爬虫)提供数据的应用程序来说,通过管理后台便于审查或编辑数据。你可以把管理后台看做数据库命令行工具的另一个版本,虽然不那么强大,但是足够便利。</li>
<li>临时的数据管理应用:你可以使用管理后台构建一个特别轻量级的数据管理应用,例如记录花销。如果只构建给自己用的功能,而不面向公众,管理后台能节省很多时间。在这个意义上,管理后台相当于增强版关系型电子表格。</li>
</ul>
</li>
</ul>
<h1 id="第六章：Django-表单"><a href="#第六章：Django-表单" class="headerlink" title="第六章：Django 表单"></a>第六章：Django 表单</h1><h3 id="1-从请求对象中获取数据"><a href="#1-从请求对象中获取数据" class="headerlink" title="1. 从请求对象中获取数据"></a>1. 从请求对象中获取数据</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line"></span><br><span class="line">def hello(request):</span><br><span class="line">    return HttpResponse(&quot;Hello world&quot;)</span><br></pre></td></tr></table></figure></code></pre>
<h5 id="关于-URL-的信息-HttpRequest-对象的方法和属性"><a href="#关于-URL-的信息-HttpRequest-对象的方法和属性" class="headerlink" title="关于 URL 的信息: HttpRequest 对象的方法和属性"></a>关于 URL 的信息: HttpRequest 对象的方法和属性</h5><table>
<thead>
<tr>
<th>属性/方法</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>request.path</td>
<td>完整的路径,不含域名,但是包含前导斜线</td>
<td>“/hello/”</td>
</tr>
<tr>
<td>request.get_host()</td>
<td>主机名(即通常所说的“域名”)</td>
<td>“127.0.0.1:8000”或“<a target="_blank" rel="noopener" href="http://www.exam-ple.com”/">www.exam-ple.com”</a></td>
</tr>
<tr>
<td>request.get_full_path()</td>
<td>包含查询字符串(如果有的话)的路径</td>
<td>“/hello/?print=true”</td>
</tr>
<tr>
<td>request.is_secure()</td>
<td>通过 HTTPS 访问时为 True ,否则为 False</td>
<td>True 或 False</td>
</tr>
</tbody></table>
<h5 id="关于请求的其他信息"><a href="#关于请求的其他信息" class="headerlink" title="关于请求的其他信息"></a>关于请求的其他信息</h5><ul>
<li>request.META 的值是一个 Python 字典,包含请求的所有 HTTP 首部,例如用户的 IP 地址和用户代理(useragent,通常是 Web 浏览器的名称和版本)。</li>
<li>注意,具体包含哪些首部取决于用户发送了什么首部,以及Web 服务器返回了什么首部。这个字典中常见的几个键有:<ul>
<li>HTTP_REFERER :入站前的 URL(可能没有)。(注意,要使用错误的拼写,即 REFERER 。)</li>
<li>HTTP_USER_AGENT :浏览器的用户代理(可能没有)。例如: “Mozilla/5.0 (X11; U; Linux i686; fr-FR; rv:1.8.1.17) Gecko/20080829 Firefox/2.0.0.17” 。</li>
<li>REMOTE_ADDR :客户端的 IP 地址,例如 “12.345.67.89” 。(如果请求经由代理,这个首部的值可能是一组 IP 地址,以逗号分隔,例如 “12.345.67.89,23.456.78.90” 。)</li>
</ul>
</li>
<li>因为 request.META 是个普通的 Python 字典,所以尝试访问不存在的键时,抛出 KeyError 异常。(HTTP 首部是外部数据,即由用户的浏览器提交,因此不能完全相信,当某个首部为空或不存在时,应该让应用程序优雅失败。)为了处理未定义的键,应该使用 try / except 子句,或者 get() 方法</li>
<li>可以编写一个简单的视图,显示 request.META 中的所有信息,以便查阅。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def display_meta(request):</span><br><span class="line">    values &#x3D; request.META.items()</span><br><span class="line">    values.sort()</span><br><span class="line">    html &#x3D; []</span><br><span class="line">    for k, v in values:</span><br><span class="line">    html.append(&#39;&lt;tr&gt;&lt;td&gt;%s&lt;&#x2F;td&gt;&lt;td&gt;%s&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&#39; % (k, v))</span><br><span class="line">    return HttpResponse(&#39;&lt;table&gt;%s&lt;&#x2F;table&gt;&#39; % &#39;\n&#39;.join(html))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="关于提交数据的信息"><a href="#关于提交数据的信息" class="headerlink" title="关于提交数据的信息"></a>关于提交数据的信息</h5><ul>
<li>除了关于请求的基本元数据之外, HttpRequest 对象还有两个属性包含用户提交的信息: request.GET 和 request.POST 。</li>
<li>这两个属性的值都是类似字典的对象,分别用于获取 GET 和 POST 数据。 POST 数据一般由 HTML表单提交,而 GET 数据既可以来自表单,也可以来自页面 URL 中的查询字符串。</li>
</ul>
<h3 id="2-一个简单的表单处理"><a href="#2-一个简单的表单处理" class="headerlink" title="2. 一个简单的表单处理"></a>2. 一个简单的表单处理</h3><ul>
<li>创建一个简单的视图,让用户通过书名搜索数据库中的图书。</li>
<li>表单分为两部分:用户界面 HTML 和处理提交数据的后端视图代码。<ul>
<li>视图  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from django.shortcuts import render</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line"></span><br><span class="line">def search_form(request):</span><br><span class="line">    return render(request, &#39;search_form.html&#39;)</span><br><span class="line"></span><br><span class="line">def search(request):</span><br><span class="line">    if &#39;q&#39; in request.GET:</span><br><span class="line">    message &#x3D; &#39;You searched for: %r&#39; % request.GET[&#39;q&#39;]</span><br><span class="line">    else:</span><br><span class="line">    message &#x3D; &#39;You submitted an empty form.&#39;</span><br><span class="line">    return HttpResponse(message)</span><br></pre></td></tr></table></figure></li>
<li>search_form.html  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Search&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;&#x2F;search&#x2F;&quot; method&#x3D;&quot;get&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;q&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Search&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h5><ul>
<li>GET 数据通过查询字符串传递(例如 /search/?q=django ),因此可以使用 request.GET 获取查询字符串参数。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line">from django.shortcuts import render</span><br><span class="line">from books.models import Book</span><br><span class="line"></span><br><span class="line">def search(request):</span><br><span class="line">    if &#39;q&#39; in request.GET and request.GET[&#39;q&#39;]:</span><br><span class="line">        q &#x3D; request.GET[&#39;q&#39;]</span><br><span class="line">        books &#x3D; Book.objects.filter(title__icontains&#x3D;q)</span><br><span class="line">        return render(request, &#39;search_results.html&#39;,&#123;&#39;books&#39;: books, &#39;query&#39;: q&#125;)</span><br><span class="line">    else:</span><br><span class="line">        return HttpResponse(&#39;Please submit a search term.&#39;)</span><br></pre></td></tr></table></figure>
<ul>
<li>不建议在大型生产数据库中使用 icontains 查询,因为速度可能很慢。(在实际运用中,你可能想使用某种自定义的搜索系统。你可以搜索一下开源的全文搜索引擎。)</li>
</ul>
</li>
</ul>
<h3 id="3-改进这个简单的表单处理示例"><a href="#3-改进这个简单的表单处理示例" class="headerlink" title="3. 改进这个简单的表单处理示例"></a>3. 改进这个简单的表单处理示例</h3><ul>
<li><p>search() 视图对空查询的处理不完美,我们只是显示“Please submit a search term.”消息,用户必须点击浏览器的后退按钮。</p>
</li>
<li><p>这样做不友好,而且显得不专业,这样的实现会再次经由 Django 处理。遇到这种情况时,重新显示表单,并且在上部显示错误更好,这样用户可以立即再试一次。为此,最简单的方法是再次渲染模板,如下所示:</p>
<ul>
<li>视图<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line">from django.shortcuts import render</span><br><span class="line">from books.models import Book</span><br><span class="line"></span><br><span class="line">def search(request):</span><br><span class="line">    if &#39;q&#39; in request.GET and request.GET[&#39;q&#39;]:</span><br><span class="line">        q &#x3D; request.GET[&#39;q&#39;]</span><br><span class="line">        books &#x3D; Book.objects.filter(title__icontains&#x3D;q)</span><br><span class="line">        return render(request, &#39;search_results.html&#39;,&#123;&#39;books&#39;: books, &#39;query&#39;: q&#125;)</span><br><span class="line">    else:</span><br><span class="line">        return render(request, &#39;search_form.html&#39;,&#123;&#39;error&#39;: True&#125;)</span><br></pre></td></tr></table></figure></li>
<li>search_form.html<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Search&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;% if error %&#125;</span><br><span class="line">        &lt;p style&#x3D;&quot;color: red;&quot;&gt;Please submit a search term.&lt;&#x2F;p&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    &lt;form action&#x3D;&quot;&#x2F;search&#x2F;&quot; method&#x3D;&quot;get&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;q&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Search&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>不需要search_form视图了</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def search(request):</span><br><span class="line">    error &#x3D; False</span><br><span class="line">    if &#39;q&#39; in request.GET:</span><br><span class="line">        q &#x3D; request.GET[&#39;q&#39;]</span><br><span class="line">        if not q:</span><br><span class="line">            error &#x3D; True</span><br><span class="line">    else:</span><br><span class="line">        books &#x3D; Book.objects.filter(title__icontains&#x3D;q)</span><br><span class="line">        return render(request, &#39;search_results.html&#39;,&#123;&#39;books&#39;: books, &#39;query&#39;: q&#125;)</span><br><span class="line">    return render(request, &#39;search_form.html&#39;,&#123;&#39;error&#39;: error&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>那么 search_form.html 中的 HTML &lt;form&gt; 不再需要硬编码 URL</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;&#x2F;search&#x2F;&quot; method&#x3D;&quot;get&quot;&gt;</span><br><span class="line">把上面改为</span><br><span class="line">&lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;get&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;action&#x3D;&quot;&quot; 的意思是,“把表单提交到与当前页面相同的 URL”。</span><br><span class="line">&#x2F;&#x2F;这样修改之后,如果想把 search() 视图放到别的 URL 上,不用再修改 action 属性。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-简单的验证"><a href="#4-简单的验证" class="headerlink" title="4. 简单的验证"></a>4. 简单的验证</h3><ul>
<li><p>验证输入信息的准确性，如长度不能超过20</p>
<ul>
<li>视图<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def search(request):</span><br><span class="line">    errors &#x3D; []</span><br><span class="line">    if &#39;q&#39; in request.GET:</span><br><span class="line">        q &#x3D; request.GET[&#39;q&#39;]</span><br><span class="line">        if not q:</span><br><span class="line">            errors.append(&#39;Enter a search term.&#39;)</span><br><span class="line">        elif len(q) &gt; 20:</span><br><span class="line">            errors.append(&#39;Please enter at most 20 characters.&#39;)</span><br><span class="line">        else:</span><br><span class="line">            books &#x3D; Book.objects.filter(title__icontains&#x3D;q)</span><br><span class="line">            return render(request, &#39;search_results.html&#39;,&#123;&#39;books&#39;: books, &#39;query&#39;: q&#125;)</span><br><span class="line">    return render(request, &#39;search_form.html&#39;,&#123;&#39;errors&#39;: errors&#125;)</span><br></pre></td></tr></table></figure></li>
<li>search_form.html<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Search&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;% if error %&#125;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#123;% for error in errors %&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123; error &#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    &lt;form action&#x3D;&quot;&#x2F;search&#x2F;&quot; method&#x3D;&quot;get&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;q&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Search&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5-创建一个联系表单"><a href="#5-创建一个联系表单" class="headerlink" title="5. 创建一个联系表单"></a>5. 创建一个联系表单</h3></li>
</ul>
</li>
<li><p>Django 自带了一个表单库, django.forms ,它能处理本章所述的多数问题,从显示 HTML 表单到验证,都能胜任。</p>
</li>
<li><p>这个表单框架的主要用法是为要处理的每个 HTML 表单定义一个 Form 类。</p>
</li>
<li><p>这个类可以放在任意位置,例如直接放在 views.py 文件中,不过社区的约定是,把 Form 类放在单独的 forms.py 文件中。在 views.py 文件所在的目录( mysite )中创建这个文件。</p>
<ul>
<li>forms.py<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django import forms</span><br><span class="line"></span><br><span class="line">class ContactForm(forms.Form):</span><br><span class="line">    subject &#x3D; forms.CharField()</span><br><span class="line">    email &#x3D; forms.EmailField(required&#x3D;False)</span><br><span class="line">    message &#x3D; forms.CharField()</span><br></pre></td></tr></table></figure>
<h3 id="6-在视图中使用表单对象"><a href="#6-在视图中使用表单对象" class="headerlink" title="6. 在视图中使用表单对象"></a>6. 在视图中使用表单对象</h3></li>
</ul>
</li>
<li><p>所有通过 POST 指向内部URL 的表单都应该使用 <code>&#123;% csrf_token %&#125;</code> 模板标签,跨站请求伪造(Cross Site Request Forgery,CSRF)</p>
</li>
<li><p>就是一个利用表单提交数据，在视图里调用send_mail模块发送邮件的例子，代码太长，粘贴过来占行数，需要的时候再看吧</p>
</li>
</ul>
<h3 id="7-表单的一些设置"><a href="#7-表单的一些设置" class="headerlink" title="7. 表单的一些设置"></a>7. 表单的一些设置</h3><ul>
<li><p>message 字段显示为 &lt;input type=”text”&gt; ,而它应该为&lt;textarea&gt; 。这个问题可以通过设定字段的 widget 参数修正，还有一些其他设置如下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django import forms</span><br><span class="line"></span><br><span class="line">class ContactForm(forms.Form):</span><br><span class="line">    subject &#x3D; forms.CharField(max_length&#x3D;100, label&#x3D;&#39;sss&#39;)   &#x2F;&#x2F;设定最大长度,label是自定义标注</span><br><span class="line">    email &#x3D; forms.EmailField(required&#x3D;False)&#x2F;&#x2F;可以为空</span><br><span class="line">    message &#x3D; forms.CharField(widget&#x3D;forms.Textarea)&#x2F;&#x2F;改变字段的渲染方式</span><br></pre></td></tr></table></figure></li>
<li><p>设定初始值</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">form &#x3D; ContactForm(</span><br><span class="line">    initial&#x3D;&#123;&#39;subject&#39;: &#39;I love your site!&#39;&#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li>
<li><p>自定义验证规则，在 Form 类中添加一个 clean_message() 方法:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from django import forms</span><br><span class="line"></span><br><span class="line">class ContactForm(forms.Form):</span><br><span class="line">    subject &#x3D; forms.CharField(max_length&#x3D;100)</span><br><span class="line">    email &#x3D; forms.EmailField(required&#x3D;False)</span><br><span class="line">    message &#x3D; forms.CharField(widget&#x3D;forms.Textarea)</span><br><span class="line"></span><br><span class="line">    def clean_message(self):</span><br><span class="line">        message &#x3D; self.cleaned_data[&#39;message&#39;]</span><br><span class="line">        num_words &#x3D; len(message.split())</span><br><span class="line">        if num_words &lt; 4:</span><br><span class="line">            raise forms.ValidationError(&quot;Not enough words!&quot;)</span><br><span class="line">            return message</span><br></pre></td></tr></table></figure>
<ul>
<li>Django 的表单系统会自动查找名称以 clean_ 开头、以字段名结尾的方法。如果存在这样的方法,在验证过程中调用。</li>
<li>注意,方法的最后一定要显式返回那个字段清理后的值。如果没有 return语句,返回的是 None ,如此一来原来的值就丢失了。</li>
</ul>
</li>
<li><p>自定义表单的外观</p>
<ul>
<li>自定义表单外观最简便的方法是使用 CSS。</li>
<li>根据情况改变css类</li>
</ul>
</li>
</ul>
<h1 id="第7章：高级视图和-URL-配置"><a href="#第7章：高级视图和-URL-配置" class="headerlink" title="第7章：高级视图和 URL 配置"></a>第7章：高级视图和 URL 配置</h1><h3 id="1-URL-配置小技巧"><a href="#1-URL-配置小技巧" class="headerlink" title="1. URL 配置小技巧"></a>1. URL 配置小技巧</h3><h5 id="在调试模式下提供特殊的-URL"><a href="#在调试模式下提供特殊的-URL" class="headerlink" title="在调试模式下提供特殊的 URL"></a>在调试模式下提供特殊的 URL</h5><pre><code>- views.py文件中
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if settings.DEBUG:</span><br><span class="line">    urlpatterns +&#x3D; [url(r&#39;^debuginfo&#x2F;$&#39;, views.debug),]</span><br></pre></td></tr></table></figure></code></pre>
<h5 id="具名分组"><a href="#具名分组" class="headerlink" title="具名分组"></a>具名分组</h5><ul>
<li>以位置参数传给视图函数<ul>
<li>views..py  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&#39;^reviews&#x2F;([0-9]&#123;4&#125;)&#x2F;([0-9]&#123;2&#125;)&#x2F;$&#39;, views.month_archive),</span><br></pre></td></tr></table></figure></li>
<li>对 /reviews/2005/03/ 的请求匹配上述列表中的第三个条目。Django 调用 views.month_archive(request, ‘2005’, ‘03’) 函数。在视图函数中以位置参数获得参数</li>
</ul>
</li>
<li>以关键字参数传给视图函数<ul>
<li>views..py  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&#39;^reviews&#x2F;(?P&lt;year&gt;[0-9]&#123;4&#125;)&#x2F;(?P&lt;month&gt;[0-9]&#123;2&#125;)&#x2F;$&#39;,views.month_archive),</span><br></pre></td></tr></table></figure></li>
<li>在实际运用中,这样做的好处是 URL 配置的意图稍微明显一些,而且不容易出现由于参数顺序不当导致的缺陷,因为视图函数定义中的参数顺序可以调整。当然,这也牺牲了一些简洁性,有些开发者觉得具名分组句法不美观,而且太啰嗦。</li>
</ul>
</li>
<li>匹配/分组算法<ol>
<li>如果有具名分组,使用具名分组,忽略非具名分组。</li>
<li>否则,以位置参数传递所有非具名分组。</li>
</ol>
</li>
</ul>
<p>#####　URL 配置搜索的范围<br>－　对 <a target="_blank" rel="noopener" href="http://www.example.com/myapp/?page=3">http://www.example.com/myapp/?page=3</a> 的请求,URL 配置只查找 myapp/ 。URL 配置不关心请求方法。<br>－　也就是说,相同URL 的所有请求方法( POST 、 GET 、 HEAD ,等等)都交由同一个视图函数处理。</p>
<h5 id="捕获的参数始终是字符串"><a href="#捕获的参数始终是字符串" class="headerlink" title="捕获的参数始终是字符串"></a>捕获的参数始终是字符串</h5><ul>
<li>虽然 [0-9]{4} 只匹配字符串中的整数,但是传给views.year_archive() 视图函数的 year 参数是字符串,需要在视图中自己处理</li>
<li>但是2.1貌似有区别</li>
</ul>
<h5 id="为视图的参数指定默认值"><a href="#为视图的参数指定默认值" class="headerlink" title="为视图的参数指定默认值"></a>为视图的参数指定默认值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 视图(在 reviews&#x2F;views.py 文件中)</span><br><span class="line">def page(request, num&#x3D;&quot;1&quot;):</span><br><span class="line">    # 输出指定数量的书评</span><br></pre></td></tr></table></figure>

<h3 id="2-错误处理"><a href="#2-错误处理" class="headerlink" title="2. 错误处理"></a>2. 错误处理</h3><ul>
<li>找不到匹配所请求 URL 的正则表达式或有异常抛出时,Django 会调用一个错误处理视图。具体使用的视图由四个参数指定。这四个参数是:<ul>
<li>handler404<ul>
<li>没有这个页面</li>
</ul>
</li>
<li>handler500<ul>
<li>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。</li>
<li>服务器内部资源出故障</li>
</ul>
</li>
<li>handler403<ul>
<li>请求资源的访问被服务器拒绝了</li>
<li>可能没有权限</li>
</ul>
</li>
<li>handler400<ul>
<li>该状态码表示请求报文中存在语法错误。</li>
<li>服务器无法理解的请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-引入其他-URL-配置"><a href="#3-引入其他-URL-配置" class="headerlink" title="3. 引入其他 URL 配置"></a>3. 引入其他 URL 配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.conf.urls import include, url</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    # ...</span><br><span class="line">    url(r&#39;^community&#x2F;&#39;, include(&#39;django_website.aggregator.urls&#39;)),</span><br><span class="line">    url(r&#39;^contact&#x2F;&#39;, include(&#39;django_website.contact.urls&#39;)),</span><br><span class="line">    # ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h5 id="去除-URL-配置中的重复-在多处使用相同的模式前缀。"><a href="#去除-URL-配置中的重复-在多处使用相同的模式前缀。" class="headerlink" title="去除 URL 配置中的重复,在多处使用相同的模式前缀。"></a>去除 URL 配置中的重复,在多处使用相同的模式前缀。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^(?P&lt;page_slug&gt;\w+)-(?P&lt;page_id&gt;\w+)&#x2F;history&#x2F;$&#39;,views.history),</span><br><span class="line">    url(r&#39;^(?P&lt;page_slug&gt;\w+)-(?P&lt;page_id&gt;\w+)&#x2F;edit&#x2F;$&#39;,views.edit),</span><br><span class="line">    url(r&#39;^(?P&lt;page_slug&gt;\w+)-(?P&lt;page_id&gt;\w+)&#x2F;discuss&#x2F;$&#39;,views.discuss),</span><br><span class="line">    url(r&#39;^(?P&lt;page_slug&gt;\w+)-(?P&lt;page_id&gt;\w+)&#x2F;permissions&#x2F;$&#39;,views.permissions),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以改进这个 URL 配置,把共用的路径前缀提取出来,再把不同的部分放在其后:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from django.conf.urls import include, url</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^(?P&lt;page_slug&gt;\w+)-(?P&lt;page_id&gt;\w+)&#x2F;&#39;,</span><br><span class="line">        include([</span><br><span class="line">            url(r&#39;^history&#x2F;$&#39;, views.history),</span><br><span class="line">            url(r&#39;^edit&#x2F;$&#39;, views.edit),</span><br><span class="line">            url(r&#39;^discuss&#x2F;$&#39;, views.discuss),</span><br><span class="line">            url(r&#39;^permissions&#x2F;$&#39;, views.permissions),</span><br><span class="line">        ])</span><br><span class="line">    ),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="捕获的参数"><a href="#捕获的参数" class="headerlink" title="捕获的参数"></a>捕获的参数</h5><ul>
<li>被引入的 URL 配置会接收到父级 URL 配置捕获的参数</li>
</ul>
<h3 id="5-给视图函数传递额外参数"><a href="#5-给视图函数传递额外参数" class="headerlink" title="5. 给视图函数传递额外参数"></a>5. 给视图函数传递额外参数</h3><ul>
<li>URL 配置允许向视图函数传递额外的参数,这些参数放在一个 Python 字典中。</li>
<li>django.conf.urls.url() 函数的第三个参数是可选的,如果指定,应该是一个字典,指定要传给视图函数的额外关键字参数及其值  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^reviews&#x2F;(?P&lt;year&gt;[0-9]&#123;4&#125;)&#x2F;$&#39;,</span><br><span class="line">        views.year_archive,</span><br><span class="line">        &#123;&#39;foo&#39;: &#39;bar&#39;&#125;</span><br><span class="line">    ),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>处理冲突<ul>
<li>有可能 URL 模式捕获了具名关键字参数,又在第三个参数中传递同名的参数。此时,Django使用字典中的参数,而不是从 URL 中捕获的参数。</li>
</ul>
</li>
</ul>
</li>
<li>同样,也可以为 include() 传递额外参数。还是写第三个参数。</li>
</ul>
<h3 id="6-反向解析-URL"><a href="#6-反向解析-URL" class="headerlink" title="6. 反向解析 URL"></a>6. 反向解析 URL</h3><ul>
<li>执行 URL 反转所需的工具:<ul>
<li>在模板中,使用 url 模板标签。</li>
<li>在 Python 代码中,使用 django.core.urlresolvers.reverse() 函数。</li>
</ul>
</li>
<li>例子<ul>
<li>url配置  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    #...</span><br><span class="line">    url(r&#39;^reviews&#x2F;([0-9]&#123;4&#125;)&#x2F;$&#39;, views.year_archive,name&#x3D;&#39;reviews-year-archive&#39;),</span><br><span class="line">    #...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>html  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&#123;% url &#39;reviews-year-archive&#39; 2012 %&#125;&quot;&gt;2012 Archive&lt;&#x2F;a&gt;</span><br><span class="line">&#123;# 或者把年份存储在一个模板上下文变量中:#&#125;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% for yearvar in year_list %&#125;</span><br><span class="line">    &lt;li&gt;&lt;a href&#x3D;&quot;&#123;% url &#39;reviews-year-archive&#39; yearvar %&#125;&quot;&gt;&#123;&#123; yearvar &#125;&#125; Archive&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure></li>
<li>视图  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def redirect_to_year(request):</span><br><span class="line">    # ...</span><br><span class="line">    year &#x3D; 2012</span><br><span class="line">    # ...</span><br><span class="line">    return HttpResponseRedirect(reverse(&#39;reviews-year-archive&#39;, args&#x3D;(year,)))</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="7-URL-命名空间"><a href="#7-URL-命名空间" class="headerlink" title="7. URL 命名空间"></a>7. URL 命名空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url(r&#39;^reviews&#x2F;&#39;, include(&#39;reviews.urls&#39;,</span><br><span class="line">    namespace&#x3D;&#39;author-reviews&#39;,</span><br><span class="line">    app_name&#x3D;&#39;reviews&#39;)</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<h1 id="第八章：高级模板技术"><a href="#第八章：高级模板技术" class="headerlink" title="第八章：高级模板技术"></a>第八章：高级模板技术</h1><h3 id="1-RequestContext-和上下文处理器"><a href="#1-RequestContext-和上下文处理器" class="headerlink" title="1. RequestContext 和上下文处理器"></a>1. RequestContext 和上下文处理器</h3><ul>
<li><p>RequestContext 默认为模板上下文添加很多变量,例如 HttpRequest 对象或当前登录用户的信息。</p>
</li>
<li><p>Django 提供了全局上下文处理器。 context_processors 设置(在 settings.py 文件中)指明始终提供给 RequestContext 的上下文处理器。</p>
</li>
<li><p>context_processors 的默认值如下:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#39;context_processors&#39;: [</span><br><span class="line">    &#39;django.template.context_processors.debug&#39;,</span><br><span class="line">    &#39;django.template.context_processors.request&#39;,</span><br><span class="line">    &#39;django.contrib.auth.context_processors.auth&#39;,</span><br><span class="line">    &#39;django.contrib.messages.context_processors.messages&#39;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure></li>
<li><p>auth，django.contrib.auth.context_processors.auth</p>
<ul>
<li>启用这个处理器后, RequestContext 中将包含下述变量:<ul>
<li>user : auth.User 的实例,表示当前登录的用户(如未登录,是 AnonymousUser 实例)。</li>
<li>perms : django.contrib.auth.context_processors.PermWrapper 实例,表示当前登录用户拥有的权限。</li>
</ul>
</li>
</ul>
</li>
<li><p>debug，django.template.context_processors.debug</p>
<ul>
<li>启用这个处理器后, RequestContext 中将包含下面两个变量,但前提是 DEBUG 设置的值是 True ,而且 INTER-NAL_IPS 设置中包含请求的 IP 地址( request.META[‘REMOTE_ADDR’] ):<ul>
<li>debug : True 。可以在模板中测试是否在 DEBUG 模式中。</li>
<li>sql_queries : {‘sql’: …, ‘time’: …} 字典构成的列表,表示处理请求的过程中执行的 SQL 查询及其用时。列表中的值按查询的执行顺序排列,在访问时惰性生成。</li>
</ul>
</li>
</ul>
</li>
<li><p>i18n，django.template.context_processors.i18n</p>
<ul>
<li>启用这个处理器后, RequestContext 中将包含下面两个变量:<ul>
<li>LANGUAGES : LANGUAGES 设置的值。</li>
<li>LANGUAGE_CODE :如果 request.LANGUAGE_CODE 存在,返回它的值;否则返回 LANGUAGE_CODE 设置的值。</li>
</ul>
</li>
</ul>
</li>
<li><p>media，django.template.context_processors.media</p>
<ul>
<li>启用这个处理器后, RequestContext 中将包含 MEDIA_URL 变量,提供 MEDIA_URL 设置的值。<br>static，django.template.context_processors.static</li>
<li>启用这个处理程序后, RequestContext 中将包含 STATIC_URL 变量,提供 STATIC_URL 设置的值。</li>
</ul>
</li>
<li><p>csrf，django.template.context_processors.csrf</p>
<ul>
<li>这个处理器添加一个令牌,供 csrf_token 模板标签使用,用于防范跨站请求伪造(参见第 19 章)。</li>
</ul>
</li>
<li><p>request，django.template.context_processors.request</p>
<ul>
<li>启用这个处理器后, RequestContext 中将包含 request 变量,它的值是当前的 HttpRequest 对象。</li>
</ul>
</li>
<li><p>messages，django.contrib.messages.context_processors.messages</p>
<ul>
<li>启用这个处理器后, RequestContext 中将包含下面两个变量:<ul>
<li>messages :消息框架设定的消息列表(里面的值是字符串)。</li>
<li>DEFAULT_MESSAGE_LEVELS :消息等级名称到数字值的映射。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-自定义上下文处理器的指导方针"><a href="#2-自定义上下文处理器的指导方针" class="headerlink" title="2. 自定义上下文处理器的指导方针"></a>2. 自定义上下文处理器的指导方针</h3><ul>
<li>上下文处理器的接口十分简单,它就是普通的 Python 函数,有一个参数,是一个 HttpRequest 对象,返回一个字典,用于添加到模板上下文中。</li>
<li>自定义的上下文处理器可以放在代码基的任何位置。Django 只关心 TEMPLATES 设置中的 ‘con-text_processors’ 选项或者 Engine 的 context_processors 参数(直接使用 Engine 时)有没有指向你的上下文处理器。尽管如此,约定的做法是把上下文处理器保存在应用或项目中一个名为 con-text_processors.py 的文件中。</li>
</ul>
<h3 id="3-自动转义-HTML"><a href="#3-自动转义-HTML" class="headerlink" title="3. 自动转义 HTML"></a>3. 自动转义 HTML</h3><h5 id="跨站脚本攻击-Cross-Site-Scripting-XSS"><a href="#跨站脚本攻击-Cross-Site-Scripting-XSS" class="headerlink" title="跨站脚本攻击(Cross Site Scripting,XSS)"></a>跨站脚本攻击(Cross Site Scripting,XSS)</h5><ul>
<li>使用模板生成 HTML 时,变量的值可能包含特殊的字符,对得到的 HTML 产生影响。对下述模板片段来说:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, &#123;&#123; name &#125;&#125;.</span><br></pre></td></tr></table></figure></li>
<li>乍一看这样显示用户的名字没什么危害。但是,如果用户输入的名字是这样的呢:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&#39;hello&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li>此时,渲染模板后得到的结果是:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, &lt;script&gt;alert(&#39;hello&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li>因此,浏览器会弹出一个对话框。同样,如果名字中包含 ‘&lt;’ 符号呢:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;username</span><br></pre></td></tr></table></figure></li>
<li>此时,渲染模板后得到的结果是:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, &lt;b&gt;username</span><br></pre></td></tr></table></figure></li>
<li>这样,网页中的后续内容都会显示为粗体。</li>
<li>显然,用户提交的数据不该盲目信任,不能直接插入网页,因为恶意用户可以利用这种漏洞做些坏事。这种安全漏洞称为跨站脚本攻击</li>
<li>为了避免这种漏洞,有两个选择:<ol>
<li>每个不信任的变量都传给 escape 过滤器,把有潜在危害的 HTML 字符转换成无危害的。Django 起初的几年默认采用这种方案,它的问题是把责任强加到开发者或模板编写者身上了,你要确保转义一切。但是,忘记转义数据是常事。</li>
<li>利用 Django 的自动转义 HTML 特性。本节余下的内容说明自动转义的工作方式。</li>
</ol>
</li>
<li>Django 默认转义模板中的每个变量标签。具体而言,转义的是下面五个字符:<br>  • &lt; 转换成 &amp;lt;<br>  • &gt; 转换成 &amp;gt;<br>  • ‘ (单引号)转换成 &amp;#39;<br>  • “ (双引号)转换成 &amp;quot;<br>  • &amp; 转换成 &amp;amp;</li>
</ul>
<h5 id="如何禁用"><a href="#如何禁用" class="headerlink" title="如何禁用"></a>如何禁用</h5><ul>
<li><p>自动转义可以在整站禁用、在模板层禁用或在变量层禁用。为什么要禁用呢?因为有时候想把模板变量包含的数据渲染成原始 HTML,无需转义。</p>
</li>
<li><p>在单个变量中禁用</p>
<ul>
<li>使用 safe 过滤器:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This will be escaped: &#123;&#123; data &#125;&#125;</span><br><span class="line">This will not be escaped: &#123;&#123; data|safe &#125;&#125;</span><br><span class="line">&#x2F;&#x2F;结果</span><br><span class="line">This will be escaped: &lt;b&gt;</span><br><span class="line">This will not be escaped: &lt;b&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在模板中的块里禁用</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% autoescape off %&#125;</span><br><span class="line">Hello &#123;&#123; name &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br></pre></td></tr></table></figure>
<h5 id="自动转义过滤器参数中的字符串字面量"><a href="#自动转义过滤器参数中的字符串字面量" class="headerlink" title="自动转义过滤器参数中的字符串字面量"></a>自动转义过滤器参数中的字符串字面量</h5></li>
<li><p>字符串字面量插入模板时不会自动转义,就像是经过 safe 过滤器处理过了一样。</p>
</li>
<li><p>应该编写:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; data|default:&quot;3 &lt; 2&quot; &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>而不是:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; data|default:&quot;3 &lt; 2&quot; &#125;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-模板加载内部机制"><a href="#4-模板加载内部机制" class="headerlink" title="4. 模板加载内部机制"></a>4. 模板加载内部机制</h3><h5 id="1-DIRS-选项"><a href="#1-DIRS-选项" class="headerlink" title="1. DIRS 选项"></a>1. DIRS 选项</h5><ul>
<li><p>settings.py里的TEMPLATES的DIRS填写template文件的搜索目录</p>
<h5 id="2-加载器的类型"><a href="#2-加载器的类型" class="headerlink" title="2. 加载器的类型"></a>2. 加载器的类型</h5></li>
<li><p>文件系统加载器</p>
<ul>
<li>filesystem.Loader</li>
<li>根据 DIRS 的值,从文件系统中加载模板。这是默认启用的加载器。然而,如果不设定 DIRS 选项,这个加载器找不到任何模板。</li>
</ul>
</li>
<li><p>应用目录加载器</p>
<ul>
<li>app_directories.Loader</li>
<li>从文件系统中的 Django 应用里加载模板。这个加载器在 INSTALLED_APPS 列出的各个应用中查找 templates 子目录。如果找到,Django 在其中查找模板。这意味着,应用可以自带模板。通过这一行为,便于分发带默认模板的 Django 应用。例如,对下面的设置来说:<br>INSTALLED_APPS = [‘myproject.reviews’, ‘myproject.music’]<br>get_template(‘foo.html’) 会按顺序在下述目录中查找 foo.html :<br>• /path/to/myproject/reviews/templates/<br>• /path/to/myproject/music/templates/</li>
<li>只需把 APP_DIRS 选项设为 True 即可启用这个加载器:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES &#x3D; [&#123;</span><br><span class="line">    &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,</span><br><span class="line">    &#39;APP_DIRS&#39;: True,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>其他加载器</p>
<ul>
<li>以在 TEMPLATES 设置中为 DjangoTemplates 后端添加 ‘loaders’ 选项,或者把loaders 参数传给 Engine 启用。这些高级加载器的详细说明,以及构建自定义加载器的方法参见 Django 项目的网站。</li>
</ul>
</li>
</ul>
<h3 id="5-扩展模板系统"><a href="#5-扩展模板系统" class="headerlink" title="5. 扩展模板系统"></a>5. 扩展模板系统</h3><h5 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h5><ul>
<li>自定义的模板标签和过滤器必须放在一个 Django 应用中。如果与现有应用有关,可以放在现有应用中;否则,应该专门创建一个应用存放。</li>
<li>应用中应该有个 templatetags 目录,与 models.py 、 views.py 等文件放在同一级。如果没有这个目录,创建一个,别忘了 <strong>init</strong>.py 文件,这样才能保证所在目录是一个 Python包。</li>
<li>自定义的标签和过滤器在 templatetags 目录里的一个模块中。</li>
<li>假如自定义的标签(过滤器)放在 review_extras.py 文件中,应用的布局可能是下面这样:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reviews&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    models.py</span><br><span class="line">    templatetags&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">        review_extras.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure></li>
<li>在模板中则这样使用:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load review_extras %&#125;</span><br></pre></td></tr></table></figure></li>
<li>包含自定义标签的应用必须在 INSTALLED_APPS 中列出,这样 <code>&#123;% load %&#125;</code> 标签才能起作用。</li>
</ul>
<h5 id="创建模板库"><a href="#创建模板库" class="headerlink" title="创建模板库"></a>创建模板库</h5><ul>
<li><p>首先,如果应用是使用 manage.py startapp 创建的,可以把模板库放在那里;如若不然,可以专门创建一个应用,用于存放模板库。</p>
</li>
<li><p>其次,在 Django 应用中合适的包里创建 templatetags 目录。这个目录应该与 models.py 、 views.py 等文件放在同一级。</p>
<ul>
<li>在 templatetags 目录中创建两个空文件: <strong>init</strong>.py (告诉 Python 这是包含 Python 代码的包)和存放自定义标签(过滤器)的文件。后者的名称是加载标签所用的名称。如上面的例子</li>
</ul>
</li>
<li><p>一个有效的标签库必须有一个名为 register 的模块层变量,其值是 template.Library 的实例。标签和过滤器都通过这种方式注册。因此,在模块顶部要插入下述代码:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from django import template</span><br><span class="line">register &#x3D; template.Library()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-自定义模板标签和过滤器"><a href="#6-自定义模板标签和过滤器" class="headerlink" title="6. 自定义模板标签和过滤器"></a>6. 自定义模板标签和过滤器</h3><h5 id="自定义模板过滤器"><a href="#自定义模板过滤器" class="headerlink" title="自定义模板过滤器"></a>自定义模板过滤器</h5><ul>
<li><p>自定义的过滤器其实就是普通的 Python 函数,接受一个或多个参数:</p>
<ol>
<li>变量的值(输入),不一定是字符串。</li>
<li>参数的值,可以有默认值,也可以留空。</li>
</ol>
</li>
<li><p>例如,对 <code>&#123;&#123; var|foo:"bar" &#125;&#125;</code> 来说,传给 foo 过滤器的变量是 var ,参数是 “bar” 。</p>
</li>
<li><p>一个示例过滤器的定义:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def cut(value, arg):</span><br><span class="line">    &quot;&quot;&quot;Removes all values of arg from the given string&quot;&quot;&quot;</span><br><span class="line">    return value.replace(arg, &#39;&#39;)</span><br></pre></td></tr></table></figure>
<ul>
<li>用法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; somevariable|cut:&quot;0&quot; &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li>多数过滤器没有参数。此时,在函数中留空参数即可。</li>
</ul>
</li>
<li><p>注册自定义的过滤器</p>
<ul>
<li>定义好过滤器之后,要使用 Library 实例注册,让 Django 的模板语言知道它的存在:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">register.filter(&#39;cut&#39;, cut)</span><br><span class="line">register.filter(&#39;lower&#39;, lower)</span><br></pre></td></tr></table></figure></li>
<li>Library.filter() 有两个参数:<ol>
<li>过滤器的名称,一个字符串。</li>
<li>负责处理过滤器的函数,一个 Python 函数(不是函数名称的字符串形式)。</li>
</ol>
</li>
<li>register.filter() 也可以作为装饰器使用:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@register.filter(name&#x3D;&#39;cut&#39;)</span><br><span class="line">def cut(value, arg):</span><br><span class="line">    return value.replace(arg, &#39;&#39;)</span><br><span class="line"></span><br><span class="line">@register.filter    &#x2F;&#x2F;不带name参数，默认函数名为name</span><br><span class="line">def cut(value, arg):</span><br><span class="line">    return value.replace(arg, &#39;&#39;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>期待字符串的模板过滤器</p>
<ul>
<li>如果模板过滤器期望第一个参数是字符串,应该使用 stringfilter 装饰器。这样,对象在传给过滤器之前会先转换成字符串值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from django import template</span><br><span class="line">from django.template.defaultfilters import stringfilter</span><br><span class="line"></span><br><span class="line">register &#x3D; template.Library()</span><br><span class="line"></span><br><span class="line">@register.filter</span><br><span class="line">@stringfilter</span><br><span class="line">def lower(value):</span><br><span class="line">    return value.lower()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>过滤器和自动转义</p>
<ul>
<li>自定义过滤器时,应该想想 Django 的自动转义行为对过滤器有什么影响。</li>
<li>模板代码中存在三种字符串:<ul>
<li>原始字符串是原生的 Python str 或 unicode 类型。输出时,如果启用了自动转义就转义,否则原封不动呈现出来。</li>
<li>安全字符串是标记为安全的字符串,输出时不会转义,因为已经做了必要的转义。</li>
<li>标记为“需要转义”的字符串是在输出时始终应该转义的字符串,不管在不在 autoescape 块中都是如此。然而,即使启用了自动转义,这种字符串也只转义一次。</li>
</ul>
</li>
<li>模板过滤器分属两种情况:<ol>
<li>不在尚未呈现的结果中引入对 HTML 不安全的字符( &lt; 、 &gt; 、 ‘ 、 “ 或 &amp; )。在注册过滤器函数时把 is_safe 旗标设为True <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@register.filter(is_safe&#x3D;True)</span><br><span class="line">def myfilter(value):</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure></li>
<li>过滤器代码自行负责做必要的转义。在结果中引入新的 HTML 标记时必须这么做。</li>
</ol>
</li>
</ul>
</li>
<li><p>过滤器和时区</p>
<ul>
<li>自定义处理 datetime 对象的过滤器时,注册时通常要把 expects_localtime 旗标设为 True :  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@register.filter(expects_localtime&#x3D;True)</span><br><span class="line">def businesshours(value):</span><br><span class="line">    try:</span><br><span class="line">        return 9 &lt;&#x3D; value.hour &lt; 17</span><br><span class="line">    except AttributeError:</span><br><span class="line">        return &#39;&#39;</span><br></pre></td></tr></table></figure></li>
<li>这样设定之后,如果过滤器的第一个参数是涉及时区的日期时间,根据模板中的时区转换规则,必要时Django 会先把它转换成当前时区,然后再传给过滤器。</li>
</ul>
</li>
</ul>
<h5 id="自定义模板标签"><a href="#自定义模板标签" class="headerlink" title="自定义模板标签"></a>自定义模板标签</h5><ul>
<li>就是 <code>&#123;% if xxx %&#125;</code> 自定义个类似if的标签，可以在模板中使用</li>
<li>具体用法再说吧，和自定义过滤器异曲同工</li>
</ul>
<p>#第九章：Django 模型的高级用法</p>
<h3 id="1-相关的对象"><a href="#1-相关的对象" class="headerlink" title="1. 相关的对象"></a>1. 相关的对象</h3><h5 id="访问外键值"><a href="#访问外键值" class="headerlink" title="访问外键值"></a>访问外键值</h5><ul>
<li>访问 ForeignKey 类型的字段时,得到的是相关的模型对象。例如:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b &#x3D; Book.objects.get(id&#x3D;50)</span><br><span class="line">&gt;&gt;&gt; b.publisher</span><br><span class="line">&lt;Publisher: Apress Publishing&gt;</span><br><span class="line">&gt;&gt;&gt; b.publisher.website</span><br><span class="line">&#39;http:&#x2F;&#x2F;www.apress.com&#x2F;&#39;</span><br></pre></td></tr></table></figure></li>
<li>ForeignKey 字段也能反向使用,不过因为关系是不对称的,行为稍有不同。若想获取指定出版社出版的所有图书,要使用 publisher.book_set.all() ,如下所示:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p &#x3D; Publisher.objects.get(name&#x3D;&#39;Apress Publishing&#39;)</span><br><span class="line">&gt;&gt;&gt; p.book_set.all()</span><br><span class="line">[&lt;Book: The Django Book&gt;, &lt;Book: Dive Into Python&gt;, ...]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="访问多对多值"><a href="#访问多对多值" class="headerlink" title="访问多对多值"></a>访问多对多值</h5><ul>
<li>多对多值与外键值的获取方式类似,不过处理的是 QuerySet 值,而非模型实例。例如,查看一本的的作者要这么做:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b &#x3D; Book.objects.get(id&#x3D;50)</span><br><span class="line">&gt;&gt;&gt; b.authors.all()</span><br><span class="line">[&lt;Author: Adrian Holovaty&gt;, &lt;Author: Jacob Kaplan-Moss&gt;]</span><br><span class="line">&gt;&gt;&gt; b.authors.filter(first_name&#x3D;&#39;Adrian&#39;)</span><br><span class="line">[&lt;Author: Adrian Holovaty&gt;]</span><br><span class="line">&gt;&gt;&gt; b.authors.filter(first_name&#x3D;&#39;Adam&#39;)</span><br><span class="line">[]</span><br></pre></td></tr></table></figure></li>
<li>反过来也可以。如果想查看一位作者撰写的所有图书,使用 author.book_set ,如下所示:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; Author.objects.get(first_name&#x3D;&#39;Adrian&#39;,</span><br><span class="line">last_name&#x3D;&#39;Holovaty&#39;)</span><br><span class="line">&gt;&gt;&gt; a.book_set.all()</span><br><span class="line">[&lt;Book: The Django Book&gt;, &lt;Book: Adrian&#39;s Other Book&gt;]</span><br></pre></td></tr></table></figure></li>
<li>与 ForeignKey 字段一样,这里的 book_set 也是生成的:把模型名的小写形式与 _set 连在一起。</li>
</ul>
<h3 id="2-管理器"><a href="#2-管理器" class="headerlink" title="2. 管理器"></a>2. 管理器</h3><ul>
<li>自定义管理器可能出于两方面的原因:<ol>
<li>添加额外的管理器方法</li>
<li>修改管理器返回的 QuerySet 。</li>
</ol>
</li>
</ul>
<h5 id="添加额外的管理器方法"><a href="#添加额外的管理器方法" class="headerlink" title="添加额外的管理器方法"></a>添加额外的管理器方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># models.py</span><br><span class="line">from django.db import models</span><br><span class="line"># ... Author 和 Publisher 模型省略了 ...</span><br><span class="line"></span><br><span class="line">class BookManager(models.Manager):</span><br><span class="line">    def title_count(self, keyword):</span><br><span class="line">        return self.filter(title__icontains&#x3D;keyword).count()</span><br><span class="line"></span><br><span class="line">class Book(models.Model):</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;100)</span><br><span class="line">    authors &#x3D; models.ManyToManyField(Author)</span><br><span class="line">    publisher &#x3D; models.ForeignKey(Publisher)</span><br><span class="line">    publication_date &#x3D; models.DateField()</span><br><span class="line">    num_pages &#x3D; models.IntegerField(blank&#x3D;True, null&#x3D;True)</span><br><span class="line">    objects &#x3D; BookManager()</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br></pre></td></tr></table></figure>
<ul>
<li>创建好管理器之后,可以像下面这样使用  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Book.objects.title_count(&#39;django&#39;)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; Book.objects.title_count(&#39;python&#39;)</span><br><span class="line">18</span><br></pre></td></tr></table></figure></li>
<li>为什么想要添加 title_count() 这样的方法呢?为的是封装经常执行的查询,以免代码重复。</li>
</ul>
<h5 id="修改管理器返回的查询集合"><a href="#修改管理器返回的查询集合" class="headerlink" title="修改管理器返回的查询集合"></a>修改管理器返回的查询集合</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MaleManager(models.Manager):</span><br><span class="line">    def get_queryset(self):</span><br><span class="line">        return super(MaleManager, self).get_queryset().filter(sex&#x3D;&#39;M&#39;)</span><br><span class="line">class FemaleManager(models.Manager):</span><br><span class="line">    def get_queryset(self):</span><br><span class="line">        return super(FemaleManager, self).get_queryset().filter(sex&#x3D;&#39;F&#39;)</span><br><span class="line">class Person(models.Model):</span><br><span class="line">    first_name &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    last_name &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    sex &#x3D; models.CharField(max_length&#x3D;1,</span><br><span class="line">                        choices&#x3D;(</span><br><span class="line">                                    (&#39;M&#39;, &#39;Male&#39;),</span><br><span class="line">                                    (&#39;F&#39;, &#39;Female&#39;)</span><br><span class="line">                                )</span><br><span class="line">                            )</span><br><span class="line">    people &#x3D; models.Manager()</span><br><span class="line">    men &#x3D; MaleManager()</span><br><span class="line">    women &#x3D; FemaleManager()</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义 Manager 对象时要注意,Django 遇到的第一个管理器(按照在模型中定义的顺序)有特殊的状态。Django 把它解释的第一个管理器定义为“默认的”管理器,而且 Django 在很多地方(管理后台不在此列)只使用那个管理器。</li>
</ul>
<h3 id="3-模型方法"><a href="#3-模型方法" class="headerlink" title="3. 模型方法"></a>3. 模型方法</h3><ul>
<li><p>管理器的作用是执行数据表层的操作,而模型方法处理的是具体的模型实例。这个技术的价值很大,能把业务逻辑统一放在一个地方,即模型中。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">class Person(models.Model):</span><br><span class="line">    first_name &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    last_name &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    birth_date &#x3D; models.DateField()</span><br><span class="line"></span><br><span class="line">    def baby_boomer_status(self):</span><br><span class="line">        # 返回一个人的出生日期与婴儿潮的关系</span><br><span class="line">        import datetime</span><br><span class="line">        if self.birth_date &lt; datetime.date(1945, 8, 1):</span><br><span class="line">            return &quot;Pre-boomer&quot;</span><br><span class="line">        elif self.birth_date &lt; datetime.date(1965, 1, 1):</span><br><span class="line">            return &quot;Baby boomer&quot;</span><br><span class="line">        else:</span><br><span class="line">            return &quot;Post-boomer&quot;</span><br><span class="line"></span><br><span class="line">    def _get_full_name(self):</span><br><span class="line">        # 返回一个人的全名</span><br><span class="line">        return &#39;%s %s&#39; % (self.first_name, self.last_name)</span><br><span class="line">    full_name &#x3D; property(_get_full_name)</span><br></pre></td></tr></table></figure></li>
<li><p>覆盖预定义的模型方法</p>
<ul>
<li>如<strong>str</strong>(),get_absolute_url(),save()</li>
</ul>
</li>
</ul>
<h3 id="4-执行原始-SQL"><a href="#4-执行原始-SQL" class="headerlink" title="4. 执行原始 SQL"></a>4. 执行原始 SQL</h3><ul>
<li>Django 为执行原始 SQL 查询提供了两种方式:<ul>
<li>使用 Manag-er.raw() 执行,返回模型实例集合;</li>
<li>或者完全不用模型层,直接执行自定义的 SQL。</li>
</ul>
</li>
</ul>
<h3 id="5-执行原始查询"><a href="#5-执行原始查询" class="headerlink" title="5. 执行原始查询"></a>5. 执行原始查询</h3><ul>
<li>管理器的 raw() 方法用于执行原始的 SQL 查询,其返回结果是模型实例集合:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Manager.raw(raw_query, params&#x3D;None, translations&#x3D;None)</span><br></pre></td></tr></table></figure></li>
<li>SQL查询  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for p in Person.objects.raw(&#39;SELECT * FROM myapp_person&#39;):</span><br><span class="line">...</span><br><span class="line">print(p)</span><br><span class="line">John Smith</span><br><span class="line">Jane Jones</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-直接执行自定义的-SQL"><a href="#6-直接执行自定义的-SQL" class="headerlink" title="6. 直接执行自定义的 SQL"></a>6. 直接执行自定义的 SQL</h3><ul>
<li>django.db.connection 对象表示默认的数据库连接。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from django.db import connection</span><br><span class="line"></span><br><span class="line">def my_custom_sql(self):</span><br><span class="line">    cursor &#x3D; connection.cursor()</span><br><span class="line">    cursor.execute(&quot;UPDATE bar SET foo &#x3D; 1 WHERE baz &#x3D; %s&quot;, [self.baz])</span><br><span class="line">    cursor.execute(&quot;SELECT foo FROM bar WHERE baz &#x3D; %s&quot;, [self.baz])</span><br><span class="line">    row &#x3D; cursor.fetchone()</span><br><span class="line">    return row</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第十章：通用视图"><a href="#第十章：通用视图" class="headerlink" title="第十章：通用视图"></a>第十章：通用视图</h1><ul>
<li>有点没太理解这个是干嘛的，好像是自己写视图函数的话得自己提取数据库中的数据，用这个通用视图能直接返回整个模型</li>
</ul>
<h3 id="1-视图的使用"><a href="#1-视图的使用" class="headerlink" title="1. 视图的使用"></a>1. 视图的使用</h3><ul>
<li>views..py  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django.views.generic import ListView</span><br><span class="line">from books.models import Publisher</span><br><span class="line"></span><br><span class="line">class PublisherList(ListView):</span><br><span class="line">    model &#x3D; Publisher   &#x2F;&#x2F;指定视图操作的数据库模型</span><br></pre></td></tr></table></figure></li>
<li>urls..py  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from books.views import PublisherList</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^publishers&#x2F;$&#39;, PublisherList.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>模板  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">&lt;h2&gt;Publishers&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% for publisher in object_list %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; publisher.name &#125;&#125;&lt;&#x2F;li&gt;    </span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>渲染这个模板时,上下文中有个名为 object_list 的变量,它的值是所有出版社对象</li>
<li>可以为视图添加一个 template_name 属性,明确指明使用哪个模板;如果没明确指定,Django 将从对象的名称中推知。这里,推知的模板是 books/publisher_list.html  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;或者添加一个 template_name 属性</span><br><span class="line">template_name &#x3D; &#39;books&#x2F;publisher_list.html&#39;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>model 属性。指定视图操作的数据库模型</li>
</ul>
<h3 id="2-提供“友好的”模板上下文"><a href="#2-提供“友好的”模板上下文" class="headerlink" title="2. 提供“友好的”模板上下文"></a>2. 提供“友好的”模板上下文</h3><ul>
<li>就是把 object_list 换个名字</li>
<li>例子  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django.views.generic import ListView</span><br><span class="line">from books.models import Publisher</span><br><span class="line"></span><br><span class="line">class PublisherList(ListView):</span><br><span class="line">    model &#x3D; Publisher   </span><br><span class="line">    context_object_name &#x3D; &#39;my_favorite_publishers&#39;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-提供额外的上下文变量"><a href="#3-提供额外的上下文变量" class="headerlink" title="3. 提供额外的上下文变量"></a>3. 提供额外的上下文变量</h3><ul>
<li>DetailView 通用视图在上下文中提供了出版社信息,但是如何在模板中获取额外的信息呢?答案是扩展 DetailView ,自己实现 get_context_data 方法。</li>
<li>例子  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from django.views.generic import DetailView</span><br><span class="line">from books.models import Publisher, Book</span><br><span class="line"></span><br><span class="line">class PublisherDetail(DetailView):</span><br><span class="line">    model &#x3D; Publisher</span><br><span class="line"></span><br><span class="line">    def get_context_data(self, **kwargs):</span><br><span class="line">        # 先调用原来的实现,获取上下文</span><br><span class="line">        context &#x3D; super(PublisherDetail, self).get_context_data(**kwargs)</span><br><span class="line">        # 把所有图书构成的查询集合添加到上下文中</span><br><span class="line">        context[&#39;book_list&#39;] &#x3D; Book.objects.all()</span><br><span class="line">        return context</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-显示对象子集"><a href="#4-显示对象子集" class="headerlink" title="4. 显示对象子集"></a>4. 显示对象子集</h3><ul>
<li>model 属性指定视图操作的数据库模型</li>
<li>这不是指定视图操作哪些对象的唯一方式,此外还可以使用 queryset 属性指定一组对象:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.views.generic import ListView</span><br><span class="line">from books.models import Book</span><br><span class="line"></span><br><span class="line">class AcmeBookList(ListView):</span><br><span class="line">    context_object_name &#x3D; &#39;book_list&#39;</span><br><span class="line">    queryset &#x3D; Book.objects.filter(publisher__name&#x3D;&#39;Acme Publishing&#39;)</span><br><span class="line">    template_name &#x3D; &#39;books&#x2F;acme_list.html&#39;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-动态过滤"><a href="#5-动态过滤" class="headerlink" title="5. 动态过滤"></a>5. 动态过滤</h3><ul>
<li>根据 URL 中指定的键过滤列表页面中的对象</li>
<li>编写一个视图显示随意一家出版社旗下的所有图书呢?这也很方便,我们可以覆盖 ListView 的 get_queryset() 方法。它的默认实现是返回 queryset 属性的值,不过我们可以添加更多逻辑。</li>
<li>调用基于类的视图时,很多有用的东西存储到 self 中了</li>
<li>URL 配置  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&#39;^books&#x2F;([\w-]+)&#x2F;$&#39;, PublisherBookList.as_view()),</span><br></pre></td></tr></table></figure></li>
<li>views..py  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from django.shortcuts import get_object_or_404</span><br><span class="line">from django.views.generic import ListView</span><br><span class="line">from books.models import Book, Publisher</span><br><span class="line"></span><br><span class="line">class PublisherBookList(ListView):</span><br><span class="line">    template_name &#x3D; &#39;books&#x2F;books_by_publisher.html&#39;</span><br><span class="line">    def get_queryset(self):</span><br><span class="line">        self.publisher &#x3D; get_object_or_404(Publisher, name&#x3D;self.args[0])</span><br><span class="line">        return Book.objects.filter(publisher&#x3D;self.publisher)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="第十一章-在-Django-中验证用户的身份"><a href="#第十一章-在-Django-中验证用户的身份" class="headerlink" title="第十一章;在 Django 中验证用户的身份"></a>第十一章;在 Django 中验证用户的身份</h1><ul>
<li>Django 自带了一套系统,能管理用户的账户、分组和权限,并且实现了基于 cookie 的用户会话。</li>
</ul>
<h3 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h3><ul>
<li><p>Django 的身份验证系统包括:</p>
<ul>
<li>用户</li>
<li>权限:二元(是或否)旗标,指明用户是否能执行特定的任务</li>
<li>分组:把标注和权限赋予多个用户的通用方式</li>
<li>可配置的密码哈希系统</li>
<li>管理身份验证和权限核准的表单</li>
<li>登录用户或限制内容的视图工具</li>
<li>可更换的后端系统</li>
</ul>
</li>
<li><p>Django 的身份验证系统十分通用,没有提供 Web 身份验证系统中某些常用的功能。某些常用功能通过第三方包实现:</p>
<ul>
<li>密码强度检查</li>
<li>登录尝试次数限制</li>
<li>通过第三方验证身份(如 OAuth)</li>
</ul>
</li>
</ul>
<h3 id="2-User-对象"><a href="#2-User-对象" class="headerlink" title="2. User 对象"></a>2. User 对象</h3><ul>
<li>在 Django 的身份验证框架中,只有一个用户类存在,因此 superusers或管理后台的 staff 用户只是设定了特殊属性的用户对象,而不是分属不同类的用户对象。</li>
<li>默认用户主要有下面几个属性:<ul>
<li>username</li>
<li>password</li>
<li>email</li>
<li>first_name</li>
<li>last_name</li>
</ul>
</li>
</ul>
<h5 id="创建超级用户"><a href="#创建超级用户" class="headerlink" title="创建超级用户"></a>创建超级用户</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser --username&#x3D;joe --email&#x3D;joe@example.com</span><br></pre></td></tr></table></figure></code></pre>
<h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><ul>
<li>创建和管理用户最简单、最不易出错的方式是使用 Django 管理后台。</li>
<li>Django 还内置了登录、退出和修改密码的视图和表单。</li>
<li>创建用户最直接的方式是使用 create_user() 辅助函数:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from django.contrib.auth.models import User</span><br><span class="line">&gt;&gt;&gt; user &#x3D; User.objects.create_user(&#39;john&#39;, &#39;lennon@thebeatles.com&#39;,</span><br><span class="line">&#39;johnpassword&#39;)</span><br><span class="line"># 此时,user 是一个 User 对象,而且已经保存到数据库中</span><br><span class="line"># 如果想修改其他字段的值,可以继续修改属性</span><br><span class="line">&gt;&gt;&gt; user.last_name &#x3D; &#39;Lennon&#39;</span><br><span class="line">&gt;&gt;&gt; user.save()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h5><ul>
<li>Django 不在用户模型中存储原始(明文)密码,只存储密码的哈希值。因此,不要试图直接处理用户的密码。正是因为这样,创建密码才要使用一个辅助函数。</li>
<li>如果想修改用户的密码,有两个选择:<ul>
<li>在命令行中使用 manage.py changepassword username 命令修改用户的密码。</li>
<li>通过编程方式,使用 set_password() 方法修改:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from django.contrib.auth.models import User</span><br><span class="line">&gt;&gt;&gt; u &#x3D; User.objects.get(username&#x3D;&#39;john&#39;)</span><br><span class="line">&gt;&gt;&gt; u.set_password(&#39;new password&#39;)</span><br><span class="line">&gt;&gt;&gt; u.save()</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="3-权限和权限核准"><a href="#3-权限和权限核准" class="headerlink" title="3. 权限和权限核准"></a>3. 权限和权限核准</h3><ul>
<li>Django 自带了一个简单的权限系统。通过它可以为指定的用户和用户组赋予权限。Django 管理后台就用到了这个系统，就是对数据的增删改查的限制</li>
</ul>
<h3 id="4-在-Web-请求中验证身份"><a href="#4-在-Web-请求中验证身份" class="headerlink" title="4. 在 Web 请求中验证身份"></a>4. 在 Web 请求中验证身份</h3><ul>
<li>Django 使用会话和中间件把身份验证系统插入 request 对象,为每个请求提供 request.user 属性,表示当前用户。如果未登陆,这个属性的值是一个 AnonymousUser 实例,否则是是一个 User 实例。这两种情况可以使用 is_authenticated() 方法区分,例如:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if request.user.is_authenticated():</span><br><span class="line">    # 处理通过身份验证的用户</span><br><span class="line">else:</span><br><span class="line">    # 处理匿名用户</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="如何登录用户"><a href="#如何登录用户" class="headerlink" title="如何登录用户"></a>如何登录用户</h5><ul>
<li>在视图中使用 login() 登录用户。</li>
<li>它的参数是一个 HttpRequest 对象和一个 User 对象。 login() 使用 Django的会话框架把用户的 ID 保存到会话中。注意,匿名期间设定的会话数据在用户登录后依然存在。</li>
<li>下述示例展示 authenticate() 和 login() 的用法:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib.auth import authenticate, login</span><br><span class="line">def my_view(request):</span><br><span class="line">    username &#x3D; request.POST[&#39;username&#39;]</span><br><span class="line">    password &#x3D; request.POST[&#39;password&#39;]</span><br><span class="line">    user &#x3D; authenticate(username&#x3D;username, password&#x3D;password)</span><br><span class="line">    if user is not None:</span><br><span class="line">        if user.is_active:</span><br><span class="line">            login(request, user)</span><br><span class="line">            # 重定向到成功登录页面</span><br><span class="line">        else:</span><br><span class="line">            # 返回“账户未激活”错误消息</span><br><span class="line">    else:</span><br><span class="line">        # 返回“无效登录”错误消息</span><br></pre></td></tr></table></figure>
<ul>
<li>先调用 authenticate()<ul>
<li>自己动手登录用户时,必须在 login() 之前调用 authenticate() 。 authenticate() 在 User 对象上设定一个属性,指明成功验证用户身份的是哪个身份验证后端,而登录过程中需要使用这个信息。如果直接登录从数据库中检索的用户对象,Django 报错。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="如何退出用户"><a href="#如何退出用户" class="headerlink" title="如何退出用户"></a>如何退出用户</h5><ul>
<li>在视图中退出通过 login() 登录的用户使用 logout() 。</li>
<li>这个函数的参数是一个 HttpRequest 对象,而且没有返回值。例如:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib.auth import logout</span><br><span class="line">def logout_view(request):</span><br><span class="line">    logout(request)</span><br><span class="line">    # 重定向到成功退出页面</span><br></pre></td></tr></table></figure></li>
<li>如果用户未登录, logout() 函数不报错。调用 logout() 函数后,当前请求的会话数据完全清除,所有数据将被删除。这样能避免其他人在登录的 Web 浏览器中访问用户之前的会话数据。</li>
</ul>
<h5 id="限制已登录用户的访问"><a href="#限制已登录用户的访问" class="headerlink" title="限制已登录用户的访问"></a>限制已登录用户的访问</h5><ul>
<li><p>直接方式</p>
<ul>
<li>限制访问页面简单直接的方式是检查 request.user.is_authenticated() ,如果未通过,可以重定向到登录页面:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django.shortcuts import redirect</span><br><span class="line"></span><br><span class="line">def my_view(request):</span><br><span class="line">    if not request.user.is_authenticated():</span><br><span class="line">        return redirect(&#39;&#x2F;login&#x2F;?next&#x3D;%s&#39; % request.path)</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure></li>
<li>login_required装饰器</li>
</ul>
</li>
<li><p>根据测试条件限制访问</p>
<ul>
<li>下述示例检查用户的电子邮件是否由指定域名提供:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def my_view(request):</span><br><span class="line">    if not request.user.email.endswith(&#39;@example.com&#39;):</span><br><span class="line">        return HttpResponse(&quot;You can&#39;t leave a review for this book.&quot;)</span><br><span class="line">    &#x2F;&#x2F; others</span><br></pre></td></tr></table></figure></li>
<li>user_passes_test装饰器  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def email_check(user):</span><br><span class="line">    return user.email.endswith(&#39;@example.com&#39;)</span><br><span class="line"></span><br><span class="line">@user_passes_test(email_check)</span><br><span class="line">def my_view(request):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li>
<li>permission_required 装饰器<ul>
<li>检查用户有没有特定权限<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@permission_required(&#39;reviews.can_vote&#39;)</span><br><span class="line">def my_view(request):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>修改密码后作废会话</p>
<ul>
<li>如果启用了 SessionAuthenticationMiddleware ,Django 会验证随各个请求发送的哈希值是否与服务器端计算的匹配。这样,修改密码后,用户的所有会话都会失效,从而退出。</li>
</ul>
</li>
</ul>
<h3 id="5-身份验证视图"><a href="#5-身份验证视图" class="headerlink" title="5. 身份验证视图"></a>5. 身份验证视图</h3><ul>
<li>Django 为登录、退出和密码管理提供了视图。这些视图使用 auth 包中内置的表单,不过也可以传入自己编写的视图。</li>
<li>简单也是最常见的做法  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns &#x3D; [url(&#39;^&#39;, include(&#39;django.contrib.auth.urls&#39;))]</span><br></pre></td></tr></table></figure></li>
<li>这样,各个视图在默认的 URL 上</li>
</ul>
<h5 id="默认的URL"><a href="#默认的URL" class="headerlink" title="默认的URL"></a>默认的URL</h5><table>
<thead>
<tr>
<th>视图</th>
<th>默认url</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>login 视图</td>
<td>/login/</td>
<td>登录用户。</td>
</tr>
<tr>
<td>logout 视图</td>
<td>/logout/</td>
<td>退出用户</td>
</tr>
<tr>
<td>logout_then_login 视图</td>
<td>未提供</td>
<td>退出用户,然后重定向到登录页面。</td>
</tr>
</tbody></table>
<ul>
<li>还有一些默认URL没写，每个URL都有可选参数和上下文，需要的时候再查</li>
</ul>
<h3 id="6-模板中的身份验证数据"><a href="#6-模板中的身份验证数据" class="headerlink" title="6. 模板中的身份验证数据"></a>6. 模板中的身份验证数据</h3><ul>
<li>使用 RequestContext 时,当前登录用户及其权限可通过模板上下文访问。</li>
<li>渲染模板的 RequestContext 时,当前登录用户,不管是 User 实例还是 AnonymousUser 实例,都存储在模板变量  中</li>
<li>当前登录用户的权限存储在模板变量  中</li>
</ul>
<h3 id="7-在管理后台中管理用户"><a href="#7-在管理后台中管理用户" class="headerlink" title="7. 在管理后台中管理用户"></a>7. 在管理后台中管理用户</h3><ul>
<li>图形化操作</li>
</ul>
<h3 id="8-密码管理"><a href="#8-密码管理" class="headerlink" title="8. 密码管理"></a>8. 密码管理</h3><ul>
<li>如非必要,不要重新实现密码管理功能,Django 提供的功能足够安全和灵活。</li>
<li>其他的一些改变密码加密算法之类的操作，需要的时候再看</li>
</ul>
<h3 id="9-自定义身份验证"><a href="#9-自定义身份验证" class="headerlink" title="9. 自定义身份验证"></a>9. 自定义身份验证</h3><ul>
<li>可以自己编写后端验证代码，覆盖Django自带的</li>
</ul>
<h3 id="10-扩展现有的-User-模型"><a href="#10-扩展现有的-User-模型" class="headerlink" title="10. 扩展现有的 User 模型"></a>10. 扩展现有的 User 模型</h3><ul>
<li><p>如果想存储关于用户的额外信息,可以与另一个模型建立一对一关系,把信息存储在那个模型的字段中。这种通过一对一关系连接的模型通常称为个人资料模型(profile model),因为它可能存储着与身份验证无关的信息。</p>
</li>
<li><p>比如说,可以创建下述 Employee 模型:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib.auth.models import User</span><br><span class="line"></span><br><span class="line">class Employee(models.Model):</span><br><span class="line">    user &#x3D; models.OneToOneField(User)</span><br><span class="line">    department &#x3D; models.CharField(max_length&#x3D;100)</span><br></pre></td></tr></table></figure></li>
<li><p>假如员工 Fred Smith 既属于 User 模型,也属于 Employee 模型,可以使用 Django 标准的相关模型约定访问额外的信息:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; u &#x3D; User.objects.get(username&#x3D;&#39;fsmith&#39;)</span><br><span class="line">&gt;&gt;&gt; freds_department &#x3D; u.employee.department</span><br></pre></td></tr></table></figure></li>
<li><p>若想把个人资料模型中的字段添加到管理后台中的用户页面中,在应用的 admin.py 文件中定义一个 InlineModelAdmin 类(这里使用的是 StackedInline ),然后把它添加到 UserAdmin 类中,再注册到 User 类上:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.contrib.auth.admin import UserAdmin</span><br><span class="line">from django.contrib.auth.models import User</span><br><span class="line">from my_user_profile_app.models import Employee</span><br><span class="line"></span><br><span class="line"># 它的行为有点像单例</span><br><span class="line">class EmployeeInline(admin.StackedInline):</span><br><span class="line">    model &#x3D; Employee</span><br><span class="line">    can_delete &#x3D; False</span><br><span class="line">    verbose_name_plural &#x3D; &#39;employee&#39;</span><br><span class="line"></span><br><span class="line"># 定义一个 UserAdmin 的子类</span><br><span class="line">class UserAdmin(UserAdmin):</span><br><span class="line">    inlines &#x3D; (EmployeeInline, )</span><br><span class="line"></span><br><span class="line"># 重新注册 UserAdmin</span><br><span class="line">admin.site.unregister(User)</span><br><span class="line">admin.site.register(User, UserAdmin)</span><br></pre></td></tr></table></figure></li>
<li><p>个人资料模型没什么特殊的,就是普通的 Django 模型,只是碰巧与 User 模型有一对一关系。因此,创建用户时不会自动创建对应的个人资料,不过可以通过 django.db.models.signals.post_save 信号创建或更新相关的模型。</p>
</li>
<li><p>通过相关的模型检索数据时有额外的查询或联结,某些情况下替换 User 模型或添加额外的字段可能更好。然而,项目中的应用对默认 User 模型的现有链接可能会调整额外的数据库负载。</p>
</li>
</ul>
<h3 id="11-替换成自定义的-User-模型"><a href="#11-替换成自定义的-User-模型" class="headerlink" title="11. 替换成自定义的 User 模型"></a>11. 替换成自定义的 User 模型</h3><ul>
<li><p>Django 允许覆盖默认的 User 模型,方法是把 AUTH_USER_MODEL 设置的值设为自定义的模型:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AUTH_USER_MODEL &#x3D; &#39;books.MyUser&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>提醒</p>
<ul>
<li>修改 AUTH_USER_MODEL 设置对 Django 项目有重大的影响,尤其是数据库结构。如果在运行迁移之后修改 AUTH_USER_MODEL ,必须自己动手更新数据库,因为很多数据库表的关系受到了影响。除非有特别好的理由,否则不要修改 AUTH_USER_MODEL 。</li>
</ul>
</li>
<li><p>如何自定义用户模型的全面说明,参见 <a href=" https://docs.djangoproject.com/en/1.8/topics/auth/customizing/#a-full-example">Django Project 网站。</a></p>
</li>
</ul>
<h1 id="第十二章：测试-Django-应用程序"><a href="#第十二章：测试-Django-应用程序" class="headerlink" title="第十二章：测试 Django 应用程序"></a>第十二章：测试 Django 应用程序</h1><h3 id="1-测试简介"><a href="#1-测试简介" class="headerlink" title="1. 测试简介"></a>1. 测试简介</h3><ul>
<li>Django 也内置了单元测试功能。单元测试是一种软件测试过程,测试的是软件应用程序的独立单元,确保能做预期中的事情。</li>
<li>单元测试分为不同的层级,可以测试单个方法,看它能不能返回正确的值以及能否处理正确的数据,也可以测试整个方法组件,确保一系列用户输入能得到所需的结果。</li>
<li>在单元测试背后,有四个基本的概念:<ol>
<li>测试固件(test fixture),执行测试所需的设置。包含数据库、示例数据集合服务器搭建。测试固件可能还包括测试完毕后执行的清理操作。</li>
<li>测试用例(test case),测试的基本单元。测试用例检查指定的输入是否能得到预期的结果。</li>
<li>测试组件(test suite),一系列测试用例或其他测试组件,作为一个整体执行。</li>
<li>测试运行程序(test runner),负责执行测试并把结果反馈给用户的软件程序。</li>
</ol>
</li>
</ul>
<h3 id="2-基本的测试策略"><a href="#2-基本的测试策略" class="headerlink" title="2. 基本的测试策略"></a>2. 基本的测试策略</h3><ul>
<li>测试驱动开发(Test-Driven Development,TDD)的准则<ul>
<li>先写测试后写代码</li>
</ul>
</li>
</ul>
<h3 id="这测试。。。跳过吧"><a href="#这测试。。。跳过吧" class="headerlink" title="这测试。。。跳过吧"></a>这测试。。。跳过吧</h3><h1 id="第十三章：部署-Django-应用程序"><a href="#第十三章：部署-Django-应用程序" class="headerlink" title="第十三章：部署 Django 应用程序"></a>第十三章：部署 Django 应用程序</h1><h3 id="1-为上线做好准备"><a href="#1-为上线做好准备" class="headerlink" title="1. 为上线做好准备"></a>1. 为上线做好准备</h3><ul>
<li>部署点检表，部署 Django 项目之前,应该花点时间审查设置,考虑安全、性能和运维。</li>
<li>点检表涉及以下几方面的设置:<ul>
<li>必须正确设置,以便提供预期的安全级别</li>
<li>在各个环境中本该不同</li>
<li>启用可选的安全措施</li>
<li>启用性能优化</li>
<li>提供错误报告</li>
</ul>
</li>
</ul>
<h3 id="2-关键设置"><a href="#2-关键设置" class="headerlink" title="2. 关键设置"></a>2. 关键设置</h3><h5 id="SECRET-KEY"><a href="#SECRET-KEY" class="headerlink" title="SECRET_KEY"></a>SECRET_KEY</h5><ul>
<li>密钥必须是一长串随机值,而且必须保密。</li>
<li>别在设置模块中硬编码密钥,应该考虑从环境变量中加载:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">SECRET_KEY &#x3D; os.environ[&#39;SECRET_KEY&#39;]</span><br></pre></td></tr></table></figure></li>
<li>或者从文件中加载:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&#39;&#x2F;etc&#x2F;secret_key.txt&#39;) as f:</span><br><span class="line">    SECRET_KEY &#x3D; f.read().strip()</span><br></pre></td></tr></table></figure>
<h5 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h5></li>
<li>一定不能在生产环境启用调试模式。</li>
<li>开发环境下 settings.py 文件把 DEBUG 设为 True 。生产环境下应该把 DEBUG 设为 False 。</li>
<li>假如把 DEBUG 设为 True 了,那么:<ul>
<li>所有数据库查询以 django.db.connection.queries 对象的形式存储在内存中。可以想象,这样很耗内存!</li>
<li>404 错误使用 Django 特殊的 404 页面渲染(参见第 3 章),而不是返回 404 响应。那个页面可能包含敏感信息,因此不应该公开在互联网中显示。</li>
<li>Django 应用程序中任何未捕获的异常(从基本的 Python 句法错误、数据库错误,到模板句法错误)都使用 Django 精美的错误页面渲染。这个页面包含的敏感信息比404 页面还多,决不能公开显示。</li>
</ul>
</li>
</ul>
<h3 id="3-各环境专用的设置"><a href="#3-各环境专用的设置" class="headerlink" title="3. 各环境专用的设置"></a>3. 各环境专用的设置</h3><h5 id="ALLOWED-HOSTS"><a href="#ALLOWED-HOSTS" class="headerlink" title="ALLOWED_HOSTS"></a>ALLOWED_HOSTS</h5><ul>
<li>设定 DEBUG = False 之后,如果不为 ALLOWED_HOSTS 设定合适的值,Django 根本无法运转。</li>
<li>这个设置的作用是防范某些 CSRF 攻击,因此必须设定。如果使用泛域名,必须自行验证 HTTP Host 首部,或者确保没有这方面的漏洞。</li>
</ul>
<h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><ul>
<li>如果使用缓存,开发环境和生产环境使用的连接参数可能不同。</li>
<li>缓存服务器往往不严格验证身份,因此要确保只接受来自应用服务器的连接。</li>
<li>如果使用 Memcached,请考虑缓存会话,以提升性能。</li>
</ul>
<h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><ul>
<li>数据库连接参数在开发环境和生产环境中可能不同。数据库密码是敏感信息,应该像 SECRET_KEY 那样保护起来。为了最大限度的增强安全,确保数据库服务器只接受来自应用服务器的连接。</li>
<li>做好数据库备份</li>
</ul>
<p>#####　EMAIL_BACKEND 和相关的设置</p>
<ul>
<li>如果你的网站要发送电子邮件,下述设置要正确设置。</li>
<li>默认情况下,Django 发送的邮件使用的发件人是 webmaster@localhost 和 root@localhost,但是有些邮件提供商拒收这两个地址发送的邮件。如果想使用其他发件地址,修改 DEFAULT_FROM_EMAIL 和 SERVER_EMAIL 设置</li>
</ul>
<h5 id="STATIC-ROOT-和-STATIC-URL"><a href="#STATIC-ROOT-和-STATIC-URL" class="headerlink" title="STATIC_ROOT 和 STATIC_URL"></a>STATIC_ROOT 和 STATIC_URL</h5><ul>
<li>开发服务器自动伺服静态文件。但是在生产环境中必须定义 STATIC_ROOT 目录, collectstatic 命令会自动复制那个目录中的静态文件。</li>
</ul>
<h5 id="MEDIA-ROOT-和-MEDIA-URL"><a href="#MEDIA-ROOT-和-MEDIA-URL" class="headerlink" title="MEDIA_ROOT 和 MEDIA_URL"></a>MEDIA_ROOT 和 MEDIA_URL</h5><ul>
<li>媒体文件由用户上传,是不能信任的</li>
<li>Web 服务器一定不能去解释用户上传的媒体文件</li>
<li>例如,Web 服务器不应该执行用户上传的 .php 文件。现在是检查媒体文件备份策略的好时机。</li>
</ul>
<h3 id="4-HTTPS"><a href="#4-HTTPS" class="headerlink" title="4. HTTPS"></a>4. HTTPS</h3><ul>
<li>允许用户登录的网站都应该强制全站使用 HTTPS,以防明文传输访问令牌。</li>
<li>设置好 HTTPS 后,启用下述设置。<ul>
<li>CSRF_COOKIE_SECURE，设为 True ,以防不小心通过 HTTP 传输 CSRF cookie。</li>
<li>SESSION_COOKIE_SECURE，设为 True ,以防不小心通过 HTTP 传输会话 cookie。</li>
</ul>
</li>
</ul>
<h3 id="5-性能优化"><a href="#5-性能优化" class="headerlink" title="5. 性能优化"></a>5. 性能优化</h3><ul>
<li>设定 DEBUG = False 后,禁用了几个只在开发中有用的功能。此外,可以调整下述几个设置。</li>
</ul>
<h5 id="CONN-MAX-AGE"><a href="#CONN-MAX-AGE" class="headerlink" title="CONN_MAX_AGE"></a>CONN_MAX_AGE</h5><ul>
<li>如果处理请求时连接数据库所用的时间占据相当一部分,可以启用持久数据库连接,有效减少这一部分的耗时。</li>
<li>在网络性能受限的虚拟主机中这么做效果明显。</li>
</ul>
<h5 id="TEMPLATES"><a href="#TEMPLATES" class="headerlink" title="TEMPLATES"></a>TEMPLATES</h5><ul>
<li>缓存模板加载器通常能极大地提升性能,因为无需每次渲染都编译模板。详情参见<a target="_blank" rel="noopener" href="https://docs.djangoproject.com/en/1.8/howto/deployment/checklist/#performance-optimizations">模板加载器的文档</a>。</li>
</ul>
<h3 id="6-错误报告"><a href="#6-错误报告" class="headerlink" title="6. 错误报告"></a>6. 错误报告</h3><h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><ul>
<li>网站上线之前要检查日志配置,而且要确保在有一定流量之后能按预期工作。</li>
</ul>
<h5 id="ADMINS-和-MANAGERS"><a href="#ADMINS-和-MANAGERS" class="headerlink" title="ADMINS 和 MANAGERS"></a>ADMINS 和 MANAGERS</h5><ul>
<li>出现 500 错误时,会通过邮件通知 ADMINS 。出现 404 错误时,会通过邮件通知 MANAGERS 。 IGNORABLE_404_URLS 可以防止误报。</li>
<li>通过电子邮件报告错误不太便利。在收件箱没被报告淹没之前考虑使用错误监控系统吧,例如 Sentry。Sentry还能聚合日志。</li>
</ul>
<h5 id="自定义默认的错误视图"><a href="#自定义默认的错误视图" class="headerlink" title="自定义默认的错误视图"></a>自定义默认的错误视图</h5><ul>
<li>Django 为几个 HTTP 错误码提供了默认的视图和模板。你可以在根模板目录中创建这几个模板覆盖默认的模板: 404.html 、 500.html 、 403.html 和 400.html 。99% 的 Web 应用使用默认视图即可,但是如果你想自定义,请看<a target="_blank" rel="noopener" href="https://docs.djangoproject.com/en/1.8/topics/http/views/#customizing-error-views">这里的说明</a>。那份文档还详细说明了下述默认模板:<br>  • http_not_found_view<br>  • http_internal_server_error_view<br>  • http_forbidden_view<br>  • http_bad_request_view</li>
</ul>
<h3 id="7-使用虚拟环境"><a href="#7-使用虚拟环境" class="headerlink" title="7. 使用虚拟环境"></a>7. 使用虚拟环境</h3><ul>
<li>如果你把项目的 Python 依赖安装到一个虚拟环境中,还要把虚拟环境中的 site-packages 目录添加到 Python路径中。</li>
<li>就是用来virtualenv</li>
</ul>
<h3 id="8-在生产环境中使用不同的设置"><a href="#8-在生产环境中使用不同的设置" class="headerlink" title="8. 在生产环境中使用不同的设置"></a>8. 在生产环境中使用不同的设置</h3><ul>
<li>目前只使用一个设置文件,即 django-admin startproject 命令生成的 settings.py 。</li>
<li>可能需要使用多个设置文件,把开发环境和生产环境区分开。<ul>
<li>使用两个完全独立的设置文件。</li>
</ul>
</li>
</ul>
<h3 id="9-把-Django-应用程序部署到生产服务器"><a href="#9-把-Django-应用程序部署到生产服务器" class="headerlink" title="9. 把 Django 应用程序部署到生产服务器"></a>9. 把 Django 应用程序部署到生产服务器</h3><ul>
<li>如果你真想部署一个线上网站,明智的做法只有一个:找一个明确支持 Django 的主机。</li>
<li>这样的主机不仅自带媒体服务器(通常是 Nginx),还会为你做好一些设置,比如配置好 Apache,以及定期重启 Python 进程的定时任务(cron job,避免网站停机)。有些优秀主机可能还会提供某种形式的“一键”部署功能。</li>
</ul>
<h3 id="10-使用-Apache-和-mod-wsgi-部署-Django-应用程序"><a href="#10-使用-Apache-和-mod-wsgi-部署-Django-应用程序" class="headerlink" title="10. 使用 Apache 和 mod_wsgi 部署 Django 应用程序"></a>10. 使用 Apache 和 mod_wsgi 部署 Django 应用程序</h3><ul>
<li>后面全是部署相关的，不好说，不好说，部署的时候再实践吧，晕乎乎，晕乎乎。</li>
</ul>
<h1 id="第十四章：生成非-HTML-内容"><a href="#第十四章：生成非-HTML-内容" class="headerlink" title="第十四章：生成非 HTML 内容"></a>第十四章：生成非 HTML 内容</h1><ul>
<li>如题，视图返回的不是HTML，而是其他的，如CSV，图片，地图等，有些需要第三方库，具体情况具体分析吧。</li>
</ul>
<h1 id="第十五章：Django-会话"><a href="#第十五章：Django-会话" class="headerlink" title="第十五章：Django 会话"></a>第十五章：Django 会话</h1><ul>
<li>会话是位于浏览器和 Web 服务器之间的半永久性双向通信。大多数情况下,访问现代的网站时,Web 服务器会使用匿名会话记录与访问有关的数据。这种会话之所以是匿名的,原因在于 Web 服务器只能记录你做了什么,却无法得知你是谁。</li>
<li>Django 完全支持匿名会话。通过会话框架可以针对网站的每个访客存储和检索任意的数据。Django 把会话数据存储在服务器端,而且对发送和接收 cookie 的过程做了抽象。cookie 中存储的是会话 ID,而不是数据本身(除非使用基于 cookie 的后端)——这样实现更安全。</li>
</ul>
<h3 id="1-启用会话"><a href="#1-启用会话" class="headerlink" title="1. 启用会话"></a>1. 启用会话</h3><h3 id="2-配置会话引擎"><a href="#2-配置会话引擎" class="headerlink" title="2. 配置会话引擎"></a>2. 配置会话引擎</h3><h3 id="3-在视图中使用会话"><a href="#3-在视图中使用会话" class="headerlink" title="3. 在视图中使用会话"></a>3. 在视图中使用会话</h3><ul>
<li>以上是基本的三个功能，还有其他的，和细节，需要时再看</li>
</ul>
<h1 id="第十六章：Django-的缓存框架"><a href="#第十六章：Django-的缓存框架" class="headerlink" title="第十六章：Django 的缓存框架"></a>第十六章：Django 的缓存框架</h1><ul>
<li>配置缓存的一些东西，目前只是了解一个做网站的框架做个小项目，以后若是真的用Django做大项目的时候在了解这些吧。</li>
</ul>
<h1 id="第十七章：Django-中间件"><a href="#第十七章：Django-中间件" class="headerlink" title="第十七章：Django 中间件"></a>第十七章：Django 中间件</h1><ul>
<li>中间件是插在 Django 的请求和响应过程之中的框架。这是一种轻量级的低层插件系统,用于全局调整 Django 的输入或输出。</li>
<li>一个中间件组件专注于做一件特定的事。例如,Django 使用 AuthenticationMiddleware 这个中间件组件处理带会话的请求。</li>
<li>本章说明中间件的工作方式、如何激活中间件,以及如何自己动手编写中间件。Django 自带了一些中间件,拿来即用。</li>
</ul>
<h3 id="1-激活中间件"><a href="#1-激活中间件" class="headerlink" title="1. 激活中间件"></a>1. 激活中间件</h3><ul>
<li>若想激活一个中间件组件,把它添加到 Django 设置文件中的 MIDDLEWARE_CLASSES 列表里。</li>
<li>默认值:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES &#x3D; [</span><br><span class="line">    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.common.CommonMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>没有任何中间件是必须的,如果愿意, MIDDLEWARE_CLASSES 列表可以为空,但是强烈建议至少要使用 CommonMiddleware 。</li>
<li>MIDDLEWARE_CLASSES 要按照一定顺序罗列中间件,因为中间件之间可能彼此依赖。例如, AuthenticationMiddleware 在会话中存储通过身份验证的用户,因此必须列在SessionMiddleware 后面。</li>
</ul>
<h3 id="2-钩子和应用中间件的顺序"><a href="#2-钩子和应用中间件的顺序" class="headerlink" title="2. 钩子和应用中间件的顺序"></a>2. 钩子和应用中间件的顺序</h3><ul>
<li>处理请求时,在调用视图之前,Django 按照 MIDDLEWARE_CLASSES 列出的顺序从上到下应用各个中间件。这期间有两个钩子可用:<ul>
<li>process_request()</li>
<li>process_view()</li>
</ul>
</li>
<li>处理响应时,在调用视图之后,Django 按照相反的顺序从下到上应用各个中间件。这期间有三个钩子可用:<ul>
<li>process_exception()</li>
<li>process_template_response()</li>
<li>process_response()</li>
</ul>
</li>
</ul>
<h3 id="3-自己动手编写中间件"><a href="#3-自己动手编写中间件" class="headerlink" title="3. 自己动手编写中间件"></a>3. 自己动手编写中间件</h3><ul>
<li>自己编写中间件不难。一个中间件组件就是一个 Python 类,其中定义一个或多个下述方法。<ul>
<li>就是上面的5个钩子方法</li>
<li>再加<strong>init</strong>()<ul>
<li>多数中间件类不需要定义初始化方法,因为中间件类基本上只需实现各个 process_* 方法。但是,如果需要某种全局状态,可以实现<strong>init</strong> 。</li>
<li>Django 初始化中间件时不传入任何参数,因此你定义的 <strong>init</strong> 方法不能有参数。</li>
<li>process_* 方法每次请求调用一次,而 <strong>init</strong> 只在 Web 服务器响应第一个请求时调用一次。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-可用的中间件-和中间件的顺序"><a href="#4-可用的中间件-和中间件的顺序" class="headerlink" title="4. 可用的中间件,和中间件的顺序"></a>4. 可用的中间件,和中间件的顺序</h3><ul>
<li>一堆，需要再看</li>
</ul>
<h1 id="第十八章：国际化"><a href="#第十八章：国际化" class="headerlink" title="第十八章：国际化"></a>第十八章：国际化</h1><ul>
<li>Django 对国际化的支持。</li>
</ul>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><ul>
<li>国际化<ul>
<li>指为任何区域设置提供支持的程序设计过程。这个过程通常由软件开发者处理。国际化包括标记可翻译的文本(例如 UI 元素和错误消息);抽象日期和时间的显示方式,兼顾不同的区域标准;支持不同的时区;以及在代码中不对用户的区域位置做任何假设。国际化经常缩写为 I18N</li>
</ul>
</li>
<li>本地化<ul>
<li>指把国际化的程序翻译成特定区域的语言。这个过程通常由翻译人员处理。本地化有时缩写为 L10N。</li>
</ul>
</li>
</ul>
<h1 id="之后章节：安全和数据库"><a href="#之后章节：安全和数据库" class="headerlink" title="之后章节：安全和数据库"></a>之后章节：安全和数据库</h1><ul>
<li>暂时没必要看</li>
</ul>
<h1 id="附录A-模型定义参考"><a href="#附录A-模型定义参考" class="headerlink" title="附录A:模型定义参考"></a>附录A:模型定义参考</h1><h3 id="1-Django-模型字段类"><a href="#1-Django-模型字段类" class="headerlink" title="1. Django 模型字段类"></a>1. Django 模型字段类</h3><table>
<thead>
<tr>
<th>字段类</th>
<th>默认小组件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AutoField</td>
<td>N/A</td>
<td>根据 ID 自动递增的 IntegerField 。</td>
</tr>
<tr>
<td>BigIntegerField</td>
<td>NumberInput</td>
<td>64 位整数,与 IntegerField 很像,但取值范围是-9223372036854775808 到 9223372036854775807 。</td>
</tr>
<tr>
<td>BinaryField</td>
<td>N/A</td>
<td>存储原始二进制数据的字段。只支持 bytes 类型。注意,这个字段的功能有限。</td>
</tr>
<tr>
<td>BooleanField</td>
<td>CheckboxInput</td>
<td>真假值字段。如果想接受 null 值,使用NullBooleanField 。</td>
</tr>
<tr>
<td>CharField</td>
<td>TextInput</td>
<td>字符串字段,针对长度较小的字符串。大量文本应该使用 TextField 。有个额外的必须参数:max_length ,即字段的最大长度(字符个数)。</td>
</tr>
<tr>
<td>DateField</td>
<td>DateInput</td>
<td>日期,在 Python 中使用 datetime.date 实例表示。有两个额外的可选参数: auto_now ,每次保存对象时自动设为当前日期; auto_now_add ,创建对象时自动设为当前日期。</td>
</tr>
<tr>
<td>DateTimeField</td>
<td>DateTimeInput</td>
<td>日期和时间,在 Python 中使用 datetime.datetime实例表示。与 DateField 具有相同的额外参数。</td>
</tr>
<tr>
<td>DecimalField</td>
<td>TextInput</td>
<td>固定精度的小数,在 Python 中使用 Decimal 实例表示。有两个必须的参数: max_digits 和decimal_places 。</td>
</tr>
<tr>
<td>DurationField</td>
<td>TextInput</td>
<td>存储时间跨度,在 Python 中使用 timedelta 表示。</td>
</tr>
<tr>
<td>EmailField</td>
<td>TextInput</td>
<td>一种 CharField ,使用 EmailValidator 验证输入。max_length 的默认值为 254 。</td>
</tr>
<tr>
<td>FileField</td>
<td>ClearableFileInput</td>
<td>文件上传字段。详情参见下一节。</td>
</tr>
<tr>
<td>FilePathField</td>
<td>Select</td>
<td>一种 CharField ,限定只能在文件系统中的特定目录里选择文件。</td>
</tr>
<tr>
<td>FloatField</td>
<td>NumberInput</td>
<td>浮点数,在 Python 中使用 float 实例表示。注意, field.localize 的值为 False 时,默认的小组件是 TextInput 。</td>
</tr>
<tr>
<td>ImageField</td>
<td>ClearableFileInput</td>
<td>所有属性和方法都继承自 FileField ,此外验证上传的对象是不是有效的图像。增加了 height 和width 两个属性。需要 Pillow 库支持。</td>
</tr>
<tr>
<td>IntegerField</td>
<td>NumberInput</td>
<td>整数。取值范围是 -2147483648 到 2147483647 ,在Django 支持的所有数据库中可放心使用。</td>
</tr>
<tr>
<td>GenericIPAddressField</td>
<td>TextInput</td>
<td>IPv4 或 IPv6 地址,字符串形式(如 192.0.2.30 、</td>
</tr>
<tr>
<td>NullBooleanField</td>
<td>NullBooleanSelect</td>
<td>类似于 BooleanField ,但是 NULL 可作为其中一个选项。</td>
</tr>
<tr>
<td>PositiveIntegerField</td>
<td>NumberInput</td>
<td>整数。取值范围是 0 到 2147483647 ,在 Django 支持的所有数据库中可放心使用。</td>
</tr>
<tr>
<td>SlugField</td>
<td>TextInput</td>
<td>别名(slug)是报业术语,是某个事物的简短标注,只包含字母、数字、下划线或连字符。</td>
</tr>
<tr>
<td>SmallIntegerField</td>
<td>NumberInput</td>
<td>类似于 IntegerField ,但是对值有限制。取值范围是 -32768 到 32767 ,在 Django 支持的所有数据库中可放心使用。</td>
</tr>
<tr>
<td>TextField</td>
<td>Textarea</td>
<td>大段文本字段。如果指定了 max_length 选项,这一限制在自动生成的表单字段中会体现出来。</td>
</tr>
<tr>
<td>TimeField</td>
<td>TextInput</td>
<td>时间,在 Python 中使用 datetime.time 实例表示。</td>
</tr>
<tr>
<td>URLField</td>
<td>URLInput</td>
<td>用于输入 URL 的 CharField 。可选 max_length 选项。</td>
</tr>
<tr>
<td>UUIDField</td>
<td>TextInput</td>
<td>用于存储通用唯一标识码。使用 Python 的 UUID类</td>
</tr>
</tbody></table>
<h3 id="2-内置标签和过滤器"><a href="#2-内置标签和过滤器" class="headerlink" title="2. 内置标签和过滤器"></a>2. 内置标签和过滤器</h3><ul>
<li>看官网吧</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"><i class="fa fa-tag">python</i></a>
              <a href="/tags/django/" rel="tag"><i class="fa fa-tag">django</i></a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/python%E8%BF%9B%E9%98%B6/" rel="prev" title="python进阶">
      <i class="fa fa-chevron-left"></i> python进阶
    </a></div>
      <div class="post-nav-item">
    <a href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="next" title="机器学习与深度学习">
      机器学习与深度学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%AE%E9%A1%B6"><span class="nav-text">置顶</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8"><span class="nav-text">第一章：新手入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%89%E8%A3%85"><span class="nav-text">1. 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="nav-text">2. 新建项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Django-%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-text">3. Django 的设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">4. 开发服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%A8%A1%E5%9E%8B-%E8%A7%86%E5%9B%BE-%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">5. 模型-视图-控制器设计模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%92%8C-URL-%E9%85%8D%E7%BD%AE"><span class="nav-text">第二章：视图和 URL 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Django-%E9%A9%B1%E5%8A%A8%E7%9A%84%E9%A1%B5%E9%9D%A2"><span class="nav-text">1. Django 驱动的页面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%A7%86%E5%9B%BE%EF%BC%9A%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9"><span class="nav-text">2. 第二个视图：动态内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-URL-%E9%85%8D%E7%BD%AE%E5%92%8C%E6%9D%BE%E8%80%A6%E5%90%88"><span class="nav-text">3. URL 配置和松耦合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%AC%AC%E4%B8%89%E4%B8%AA%E8%A7%86%E5%9B%BE-%E5%8A%A8%E6%80%81-URL"><span class="nav-text">4. 第三个视图:动态 URL</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9ADjango-%E6%A8%A1%E6%9D%BF"><span class="nav-text">第三章：Django 模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A8%A1%E6%9D%BF%E5%9F%BA%E7%A1%80"><span class="nav-text">1. 模板基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%B3%BB%E7%BB%9F"><span class="nav-text">2. 使用模板系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAtemplate%E5%AF%B9%E8%B1%A1"><span class="nav-text">创建template对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E6%A8%A1%E6%9D%BF"><span class="nav-text">渲染模板</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Django-%E6%A8%A1%E6%9D%BF%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">Django 模板系统的基本用法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AD%97%E5%85%B8%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-text">3. 字典和上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E4%B8%8A%E4%B8%8B%E6%96%87-%E5%90%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF"><span class="nav-text">多个上下文,同一个模板</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8F%98%E9%87%8F%E6%9F%A5%E6%89%BE"><span class="nav-text">上下文变量查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="nav-text">方法调用的行为</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%97%A0%E6%95%88%E5%8F%98%E9%87%8F"><span class="nav-text">如何处理无效变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">4. 基本的模板标签和过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E7%AD%BE"><span class="nav-text">标签</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">过滤器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%90%86%E5%BF%B5%E5%92%8C%E5%B1%80%E9%99%90"><span class="nav-text">5. 理念和局限</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Django-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%90%86%E5%BF%B5"><span class="nav-text">Django 的核心理念</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="nav-text">6. 在视图中使用模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%A8%A1%E6%9D%BF%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-text">7. 模板加载机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-render"><span class="nav-text">8. render()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E6%A8%A1%E6%9D%BF%E5%AD%90%E7%9B%AE%E5%BD%95"><span class="nav-text">9. 模板子目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-include-%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE"><span class="nav-text">10. include 模板标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E6%A8%A1%E6%9D%BF%E7%BB%A7%E6%89%BF"><span class="nav-text">11. 模板继承</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9ADjango%E6%A8%A1%E5%9E%8B"><span class="nav-text">第四章：Django模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B8%AD%E6%89%A7%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E7%9A%84%E2%80%9C%E6%84%9A%E8%A0%A2%E2%80%9D%E6%96%B9%E5%BC%8F"><span class="nav-text">1. 在视图中执行数据库查询的“愚蠢”方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">2. 配置数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8"><span class="nav-text">3. 第一个应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BD%BF%E7%94%A8-Python-%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B"><span class="nav-text">4. 使用 Python 定义模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B"><span class="nav-text">创建模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9E%8B"><span class="nav-text">安装模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="nav-text">5. 基本的数据访问</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="nav-text">添加模型的字符串表示形式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="nav-text">插入和更新数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%AF%B9%E8%B1%A1"><span class="nav-text">选择对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE-filter"><span class="nav-text">过滤数据,filter()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1-get"><span class="nav-text">检索单个对象,get()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE"><span class="nav-text">排序数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E6%9F%A5%E6%89%BE"><span class="nav-text">链式查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%87%E7%89%87%E6%95%B0%E6%8D%AE"><span class="nav-text">切片数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%9B%B4%E6%96%B0%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="nav-text">在一个语句中更新多个对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%AF%B9%E8%B1%A1"><span class="nav-text">删除对象</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9ADjango-%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0"><span class="nav-text">第五章：Django 管理后台</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8-Django-%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0"><span class="nav-text">1. 使用 Django 管理后台</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%AE%A1%E7%90%86%E5%91%98%E7%94%A8%E6%88%B7"><span class="nav-text">创建管理员用户</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%99%BB%E5%BD%95%E5%90%8E%E5%8F%B0"><span class="nav-text">登录后台</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8A%8A%E6%A8%A1%E5%9E%8B%E6%B7%BB%E5%8A%A0%E5%88%B0-Django-%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E4%B8%AD"><span class="nav-text">2. 把模型添加到 Django 管理后台中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8A%8A%E5%AD%97%E6%AE%B5%E8%AE%BE%E4%B8%BA%E5%8F%AF%E9%80%89%E7%9A%84"><span class="nav-text">3. 把字段设为可选的</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%8A%E6%97%A5%E6%9C%9F%E5%92%8C%E6%95%B0%E5%80%BC%E5%AD%97%E6%AE%B5%E8%AE%BE%E4%B8%BA%E5%8F%AF%E9%80%89%E7%9A%84"><span class="nav-text">把日期和数值字段设为可选的</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E6%AE%B5%E7%9A%84%E6%A0%87%E6%B3%A8"><span class="nav-text">4. 自定义字段的标注</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%87%AA%E5%AE%9A%E4%B9%89-ModelAdmin-%E7%B1%BB"><span class="nav-text">5. 自定义 ModelAdmin 类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%AE%E6%94%B9%E5%88%97%E8%A1%A8"><span class="nav-text">自定义修改列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91%E8%A1%A8%E5%8D%95"><span class="nav-text">自定义编辑表单</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%94%A8%E6%88%B7%E3%80%81%E5%88%86%E7%BB%84%E5%92%8C%E6%9D%83%E9%99%90"><span class="nav-text">6. 用户、分组和权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%BD%95%E6%97%B6%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2"><span class="nav-text">7. 何时以及为何使用管理界面</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9ADjango-%E8%A1%A8%E5%8D%95"><span class="nav-text">第六章：Django 表单</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%8E%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-text">1. 从请求对象中获取数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-URL-%E7%9A%84%E4%BF%A1%E6%81%AF-HttpRequest-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="nav-text">关于 URL 的信息: HttpRequest 对象的方法和属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%B6%E4%BB%96%E4%BF%A1%E6%81%AF"><span class="nav-text">关于请求的其他信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-text">关于提交数据的信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86"><span class="nav-text">2. 一个简单的表单处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%82%E6%95%B0"><span class="nav-text">查询字符串参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%94%B9%E8%BF%9B%E8%BF%99%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86%E7%A4%BA%E4%BE%8B"><span class="nav-text">3. 改进这个简单的表单处理示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%AE%80%E5%8D%95%E7%9A%84%E9%AA%8C%E8%AF%81"><span class="nav-text">4. 简单的验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%81%94%E7%B3%BB%E8%A1%A8%E5%8D%95"><span class="nav-text">5. 创建一个联系表单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%A1%A8%E5%8D%95%E5%AF%B9%E8%B1%A1"><span class="nav-text">6. 在视图中使用表单对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E8%A1%A8%E5%8D%95%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E7%BD%AE"><span class="nav-text">7. 表单的一些设置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0%EF%BC%9A%E9%AB%98%E7%BA%A7%E8%A7%86%E5%9B%BE%E5%92%8C-URL-%E9%85%8D%E7%BD%AE"><span class="nav-text">第7章：高级视图和 URL 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-URL-%E9%85%8D%E7%BD%AE%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="nav-text">1. URL 配置小技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%8F%90%E4%BE%9B%E7%89%B9%E6%AE%8A%E7%9A%84-URL"><span class="nav-text">在调试模式下提供特殊的 URL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B7%E5%90%8D%E5%88%86%E7%BB%84"><span class="nav-text">具名分组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E7%9A%84%E5%8F%82%E6%95%B0%E5%A7%8B%E7%BB%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">捕获的参数始终是字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E8%A7%86%E5%9B%BE%E7%9A%84%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-text">为视图的参数指定默认值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-text">2. 错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96-URL-%E9%85%8D%E7%BD%AE"><span class="nav-text">3. 引入其他 URL 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%BB%E9%99%A4-URL-%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D-%E5%9C%A8%E5%A4%9A%E5%A4%84%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%89%8D%E7%BC%80%E3%80%82"><span class="nav-text">去除 URL 配置中的重复,在多处使用相同的模式前缀。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-text">捕获的参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%BB%99%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E9%A2%9D%E5%A4%96%E5%8F%82%E6%95%B0"><span class="nav-text">5. 给视图函数传递额外参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%8F%8D%E5%90%91%E8%A7%A3%E6%9E%90-URL"><span class="nav-text">6. 反向解析 URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-URL-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">7. URL 命名空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%A8%A1%E6%9D%BF%E6%8A%80%E6%9C%AF"><span class="nav-text">第八章：高级模板技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-RequestContext-%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">1. RequestContext 和上下文处理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%B8%8B%E6%96%87%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8C%87%E5%AF%BC%E6%96%B9%E9%92%88"><span class="nav-text">2. 自定义上下文处理器的指导方针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%87%AA%E5%8A%A8%E8%BD%AC%E4%B9%89-HTML"><span class="nav-text">3. 自动转义 HTML</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB-Cross-Site-Scripting-XSS"><span class="nav-text">跨站脚本攻击(Cross Site Scripting,XSS)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8"><span class="nav-text">如何禁用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%BD%AC%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8F%82%E6%95%B0%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-text">自动转义过滤器参数中的字符串字面量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%A8%A1%E6%9D%BF%E5%8A%A0%E8%BD%BD%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6"><span class="nav-text">4. 模板加载内部机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-DIRS-%E9%80%89%E9%A1%B9"><span class="nav-text">1. DIRS 选项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">2. 加载器的类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%89%A9%E5%B1%95%E6%A8%A1%E6%9D%BF%E7%B3%BB%E7%BB%9F"><span class="nav-text">5. 扩展模板系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%B8%83%E5%B1%80"><span class="nav-text">代码布局</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="nav-text">创建模板库</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">6. 自定义模板标签和过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">自定义模板过滤器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE"><span class="nav-text">自定义模板标签</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">1. 相关的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%A4%96%E9%94%AE%E5%80%BC"><span class="nav-text">访问外键值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%80%BC"><span class="nav-text">访问多对多值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-text">2. 管理器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E9%A2%9D%E5%A4%96%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8%E6%96%B9%E6%B3%95"><span class="nav-text">添加额外的管理器方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E7%AE%A1%E7%90%86%E5%99%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E6%9F%A5%E8%AF%A2%E9%9B%86%E5%90%88"><span class="nav-text">修改管理器返回的查询集合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%A8%A1%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-text">3. 模型方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%89%A7%E8%A1%8C%E5%8E%9F%E5%A7%8B-SQL"><span class="nav-text">4. 执行原始 SQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%89%A7%E8%A1%8C%E5%8E%9F%E5%A7%8B%E6%9F%A5%E8%AF%A2"><span class="nav-text">5. 执行原始查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84-SQL"><span class="nav-text">6. 直接执行自定义的 SQL</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E9%80%9A%E7%94%A8%E8%A7%86%E5%9B%BE"><span class="nav-text">第十章：通用视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">1. 视图的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8F%90%E4%BE%9B%E2%80%9C%E5%8F%8B%E5%A5%BD%E7%9A%84%E2%80%9D%E6%A8%A1%E6%9D%BF%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-text">2. 提供“友好的”模板上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8F%90%E4%BE%9B%E9%A2%9D%E5%A4%96%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8F%98%E9%87%8F"><span class="nav-text">3. 提供额外的上下文变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%98%BE%E7%A4%BA%E5%AF%B9%E8%B1%A1%E5%AD%90%E9%9B%86"><span class="nav-text">4. 显示对象子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%8A%A8%E6%80%81%E8%BF%87%E6%BB%A4"><span class="nav-text">5. 动态过滤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%9C%A8-Django-%E4%B8%AD%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E7%9A%84%E8%BA%AB%E4%BB%BD"><span class="nav-text">第十一章;在 Django 中验证用户的身份</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A6%82%E8%A7%88"><span class="nav-text">1. 概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-User-%E5%AF%B9%E8%B1%A1"><span class="nav-text">2. User 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7"><span class="nav-text">创建超级用户</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7"><span class="nav-text">创建用户</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81"><span class="nav-text">修改密码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9D%83%E9%99%90%E5%92%8C%E6%9D%83%E9%99%90%E6%A0%B8%E5%87%86"><span class="nav-text">3. 权限和权限核准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%9C%A8-Web-%E8%AF%B7%E6%B1%82%E4%B8%AD%E9%AA%8C%E8%AF%81%E8%BA%AB%E4%BB%BD"><span class="nav-text">4. 在 Web 请求中验证身份</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7"><span class="nav-text">如何登录用户</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%80%E5%87%BA%E7%94%A8%E6%88%B7"><span class="nav-text">如何退出用户</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E5%B7%B2%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-text">限制已登录用户的访问</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E8%A7%86%E5%9B%BE"><span class="nav-text">5. 身份验证视图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84URL"><span class="nav-text">默认的URL</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E6%95%B0%E6%8D%AE"><span class="nav-text">6. 模板中的身份验证数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%9C%A8%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E4%B8%AD%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7"><span class="nav-text">7. 在管理后台中管理用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86"><span class="nav-text">8. 密码管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="nav-text">9. 自定义身份验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E6%89%A9%E5%B1%95%E7%8E%B0%E6%9C%89%E7%9A%84-User-%E6%A8%A1%E5%9E%8B"><span class="nav-text">10. 扩展现有的 User 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E6%9B%BF%E6%8D%A2%E6%88%90%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84-User-%E6%A8%A1%E5%9E%8B"><span class="nav-text">11. 替换成自定义的 User 模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%B5%8B%E8%AF%95-Django-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">第十二章：测试 Django 应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%B5%8B%E8%AF%95%E7%AE%80%E4%BB%8B"><span class="nav-text">1. 测试简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5"><span class="nav-text">2. 基本的测试策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%99%E6%B5%8B%E8%AF%95%E3%80%82%E3%80%82%E3%80%82%E8%B7%B3%E8%BF%87%E5%90%A7"><span class="nav-text">这测试。。。跳过吧</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%9A%E9%83%A8%E7%BD%B2-Django-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">第十三章：部署 Django 应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%BA%E4%B8%8A%E7%BA%BF%E5%81%9A%E5%A5%BD%E5%87%86%E5%A4%87"><span class="nav-text">1. 为上线做好准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%85%B3%E9%94%AE%E8%AE%BE%E7%BD%AE"><span class="nav-text">2. 关键设置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SECRET-KEY"><span class="nav-text">SECRET_KEY</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DEBUG"><span class="nav-text">DEBUG</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%90%84%E7%8E%AF%E5%A2%83%E4%B8%93%E7%94%A8%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-text">3. 各环境专用的设置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ALLOWED-HOSTS"><span class="nav-text">ALLOWED_HOSTS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">数据库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#STATIC-ROOT-%E5%92%8C-STATIC-URL"><span class="nav-text">STATIC_ROOT 和 STATIC_URL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MEDIA-ROOT-%E5%92%8C-MEDIA-URL"><span class="nav-text">MEDIA_ROOT 和 MEDIA_URL</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-HTTPS"><span class="nav-text">4. HTTPS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-text">5. 性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CONN-MAX-AGE"><span class="nav-text">CONN_MAX_AGE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TEMPLATES"><span class="nav-text">TEMPLATES</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A"><span class="nav-text">6. 错误报告</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-text">日志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ADMINS-%E5%92%8C-MANAGERS"><span class="nav-text">ADMINS 和 MANAGERS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%BB%98%E8%AE%A4%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%86%E5%9B%BE"><span class="nav-text">自定义默认的错误视图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83"><span class="nav-text">7. 使用虚拟环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-text">8. 在生产环境中使用不同的设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E6%8A%8A-Django-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2%E5%88%B0%E7%94%9F%E4%BA%A7%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">9. 把 Django 应用程序部署到生产服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E4%BD%BF%E7%94%A8-Apache-%E5%92%8C-mod-wsgi-%E9%83%A8%E7%BD%B2-Django-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">10. 使用 Apache 和 mod_wsgi 部署 Django 应用程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%94%9F%E6%88%90%E9%9D%9E-HTML-%E5%86%85%E5%AE%B9"><span class="nav-text">第十四章：生成非 HTML 内容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9ADjango-%E4%BC%9A%E8%AF%9D"><span class="nav-text">第十五章：Django 会话</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%90%AF%E7%94%A8%E4%BC%9A%E8%AF%9D"><span class="nav-text">1. 启用会话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%85%8D%E7%BD%AE%E4%BC%9A%E8%AF%9D%E5%BC%95%E6%93%8E"><span class="nav-text">2. 配置会话引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BC%9A%E8%AF%9D"><span class="nav-text">3. 在视图中使用会话</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%EF%BC%9ADjango-%E7%9A%84%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6"><span class="nav-text">第十六章：Django 的缓存框架</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%EF%BC%9ADjango-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text">第十七章：Django 中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%BF%80%E6%B4%BB%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text">1. 激活中间件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%92%A9%E5%AD%90%E5%92%8C%E5%BA%94%E7%94%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-text">2. 钩子和应用中间件的顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E7%BC%96%E5%86%99%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text">3. 自己动手编写中间件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%8F%AF%E7%94%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-text">4. 可用的中间件,和中间件的顺序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96"><span class="nav-text">第十八章：国际化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="nav-text">1. 定义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%8B%E5%90%8E%E7%AB%A0%E8%8A%82%EF%BC%9A%E5%AE%89%E5%85%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">之后章节：安全和数据库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E5%BD%95A-%E6%A8%A1%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%8F%82%E8%80%83"><span class="nav-text">附录A:模型定义参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Django-%E6%A8%A1%E5%9E%8B%E5%AD%97%E6%AE%B5%E7%B1%BB"><span class="nav-text">1. Django 模型字段类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%86%85%E7%BD%AE%E6%A0%87%E7%AD%BE%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">2. 内置标签和过滤器</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不知自己不知"
      src="/images/head.jpeg">
  <p class="site-author-name" itemprop="name">不知自己不知</p>
  <div class="site-description" itemprop="description">以阅读为生是一件很酷的事，以写作为生是一件更酷的事。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
    <!--
    <div id="music163player">
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&id=5445280661&auto=0&height=90"></iframe>
       </div>
    -->
  </aside>
  
  
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不知自己不知</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">412k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">6:14</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='255,255,255' opacity='1' zIndex='-1' count='200' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'Dv4yd2JUuvVhLBe640B6m1jw-gzGzoHsz',
      appKey     : 'sNdrMuVcw6jJzlz0HpXBNhdB',
      placeholder: "来交流交流吧~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>



