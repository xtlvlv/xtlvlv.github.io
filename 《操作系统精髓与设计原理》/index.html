<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/head.jpeg">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xtlvlv.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":2,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="置顶 知识过于繁杂，挑重点简要记录 主要针对Linux操作系统，Windows和Android需要的时候再学 虽然书过了一遍，但深深的知道自己还有很多不动的地方，特别是多处理器那里，想起来刚学操作系统的时候，也是觉得没什么用，不知道在学什么，后来了解到Linux编程，再看操作系统真的有不少感悟，现在看多处理器那部分就是处于不知道干什么的状态，还是没有实践啊 看完后觉得我们大二的时候上操作系统课，为">
<meta property="og:type" content="article">
<meta property="og:title" content="《操作系统精髓与设计原理》">
<meta property="og:url" content="https://xtlvlv.github.io/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E3%80%8B/index.html">
<meta property="og:site_name" content="不知自己不知">
<meta property="og:description" content="置顶 知识过于繁杂，挑重点简要记录 主要针对Linux操作系统，Windows和Android需要的时候再学 虽然书过了一遍，但深深的知道自己还有很多不动的地方，特别是多处理器那里，想起来刚学操作系统的时候，也是觉得没什么用，不知道在学什么，后来了解到Linux编程，再看操作系统真的有不少感悟，现在看多处理器那部分就是处于不知道干什么的状态，还是没有实践啊 看完后觉得我们大二的时候上操作系统课，为">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-05T12:00:41.000Z">
<meta property="article:modified_time" content="2021-01-06T02:29:52.712Z">
<meta property="article:author" content="不知自己不知">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xtlvlv.github.io/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E3%80%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《操作系统精髓与设计原理》 | 不知自己不知</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">

<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->

<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 

  <!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
  
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不知自己不知</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">59</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">13</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">70</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xtlvlv.github.io/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpeg">
      <meta itemprop="name" content="不知自己不知">
      <meta itemprop="description" content="以阅读为生是一件很酷的事，以写作为生是一件更酷的事。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不知自己不知">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《操作系统精髓与设计原理》
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-05 20:00:41" itemprop="dateCreated datePublished" datetime="2021-01-05T20:00:41+08:00">2021-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-06 10:29:52" itemprop="dateModified" datetime="2021-01-06T10:29:52+08:00">2021-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><ol>
<li>知识过于繁杂，挑重点简要记录</li>
<li>主要针对Linux操作系统，Windows和Android需要的时候再学</li>
<li>虽然书过了一遍，但深深的知道自己还有很多不动的地方，特别是多处理器那里，想起来刚学操作系统的时候，也是觉得没什么用，不知道在学什么，后来了解到Linux编程，再看操作系统真的有不少感悟，现在看多处理器那部分就是处于不知道干什么的状态，还是没有实践啊</li>
<li>看完后觉得我们大二的时候上操作系统课，为什么不用这本书，觉得这里面的课后习题什么的都挺好的，附录也很好，特别是OS/161，我之前为了做大作业也尝试看过《一个64为操作系统的实现》《30天自制一个操作系统》这种书，没想到这就有一个现成的，难受。<a id="more"></a>
<h1 id="第一章：计算机系统概述"><a href="#第一章：计算机系统概述" class="headerlink" title="第一章：计算机系统概述"></a>第一章：计算机系统概述</h1></li>
</ol>
<h3 id="1-基本构成"><a href="#1-基本构成" class="headerlink" title="1. 基本构成"></a>1. 基本构成</h3><ol>
<li>处理器</li>
<li>内存</li>
<li>IO模块</li>
<li>系统总线</li>
</ol>
<h3 id="2-指令分类"><a href="#2-指令分类" class="headerlink" title="2. 指令分类"></a>2. 指令分类</h3><ol>
<li>处理器&lt;–&gt;存储器</li>
<li>处理器&lt;–&gt;IO</li>
<li>数据处理</li>
<li>控制</li>
</ol>
<h3 id="3-中断"><a href="#3-中断" class="headerlink" title="3. 中断"></a>3. 中断</h3><h5 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h5><table>
<thead>
<tr>
<th>分类</th>
<th>表现</th>
</tr>
</thead>
<tbody><tr>
<td>程序中断</td>
<td>在某些条件下由指令的执行结果产生，如算术溢出，除数为0，试图执行一条非法机器指令，访问用户不允许的位置</td>
</tr>
<tr>
<td>时钟中断</td>
<td>处理器内部的计时器产生，允许操作系统周期性的执行函数</td>
</tr>
<tr>
<td>I/O中断</td>
<td>由IO控制器产生，用于发信号通知一个操作完成或各种错误条件</td>
</tr>
<tr>
<td>硬件失效中断</td>
<td>有掉电，奇偶校验错之类的故障产生</td>
</tr>
</tbody></table>
<h5 id="多个中断"><a href="#多个中断" class="headerlink" title="多个中断"></a>多个中断</h5><ul>
<li>禁止再中断</li>
<li>优先级</li>
</ul>
<h3 id="4-内存层次"><a href="#4-内存层次" class="headerlink" title="4. 内存层次"></a>4. 内存层次</h3><h5 id="板上存储器"><a href="#板上存储器" class="headerlink" title="板上存储器"></a>板上存储器</h5><ol>
<li>寄存器</li>
<li>高速缓存</li>
<li>内存</li>
</ol>
<h5 id="板外存储器"><a href="#板外存储器" class="headerlink" title="板外存储器"></a>板外存储器</h5><ol start="4">
<li>磁盘，CD</li>
</ol>
<h5 id="离线存储器"><a href="#离线存储器" class="headerlink" title="离线存储器"></a>离线存储器</h5><ol start="5">
<li>磁带</li>
</ol>
<h3 id="5-高速缓存"><a href="#5-高速缓存" class="headerlink" title="5. 高速缓存"></a>5. 高速缓存</h3><ol>
<li>CPU&lt;—-字传送(快)—&gt;高速缓存(L1,L2,L3)&lt;—块传送(慢)—-内存</li>
</ol>
<h3 id="6-多处理器和多核"><a href="#6-多处理器和多核" class="headerlink" title="6. 多处理器和多核"></a>6. 多处理器和多核</h3><h5 id="多处理器"><a href="#多处理器" class="headerlink" title="多处理器"></a>多处理器</h5><ul>
<li>是有多个独立的CPU,每个CPU能执行相同的功能，也叫对称处理器</li>
</ul>
<h5 id="多核"><a href="#多核" class="headerlink" title="多核"></a>多核</h5><ul>
<li>是多个处理器组装在同一个硅片上，又名芯片多处理器</li>
</ul>
<h5 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h5><ul>
<li>对于多个处理器而言，它们在执行命令的时候多个处理器之间的通信手段是电脑主板上的总线；而对于多核处理器而言，多个核心处理器之间通信时通过CPU内部总线进行信息的交互的。对于执行效率而言，多核处理器要优于多个处理器</li>
<li>若跑小程序，选多核<br>  对于多处理器：如果跑一个多线程的程序（常见典型情况），不考虑超线程，那么每一个线程就要跑在一个独立的CPU上，线程间的所有协作都要走总线，而共享的数据更是有可能要在好几个Cache里同时存在。这样的话，总线开销相比较而言是很大的，怎么办？那么多Cache，即使我们不心疼存储能力的浪费，一致性怎么保证？如果真正做出来，还要在主板上占多块地盘，给布局布线带来更大的挑战？所以对于个人计算机来说，都采用单处理器多核。只需要一套芯片组，一套存储，多核之间通过芯片内部总线进行通信，共享使用内存。在这样的架构上，如果我们跑一个多线程的程序，那么线程间通信将比上一种情形更快。如果最终实现出来，对板上空间的占用较小，布局布线的压力也较小。</li>
<li>若跑大程序，选多CPU多核<br>  假设俩大程序，每一个程序都好多线程还几乎用满cache，它们分时使用CPU，那在程序间切换的时候，光指令和数据的替换就很费事。所以，需要更强的多任务并发能力，就用多颗多核CPU的机子。</li>
</ul>
<h1 id="第二章：操作系统概述"><a href="#第二章：操作系统概述" class="headerlink" title="第二章：操作系统概述"></a>第二章：操作系统概述</h1><h3 id="1-Linux主要内核组件"><a href="#1-Linux主要内核组件" class="headerlink" title="1. Linux主要内核组件"></a>1. Linux主要内核组件</h3><ol>
<li>信号(Signals)<ul>
<li>内核使用信号向进程提供信息</li>
</ul>
</li>
<li>系统调用(System calls)<ul>
<li>为进程提供系统服务，大致分为6类：文件系统，进程，调度，进程间通信，套接字，其他</li>
</ul>
</li>
<li>进程和调度器(Processes and Scheduler)<ul>
<li>创建，管理，调度进程</li>
</ul>
</li>
<li>虚存(Virtual memory)<ul>
<li>为进程分配和管理虚存</li>
</ul>
</li>
<li>文件系统(File System)<ul>
<li>为文件，目录和其他文件对象提供一个全局的分层命名空间，并提供文件系统函数</li>
</ul>
</li>
<li>网络协议(Network protocols)<ul>
<li>  为用户的TCP/IP协议套件提供套接字接口</li>
</ul>
</li>
<li>字符设备驱动(Character device drivers)<ul>
<li>如打印机，调制解调器，终端</li>
</ul>
</li>
<li>块设备驱动(Block device drivers)<ul>
<li>如各种外存</li>
</ul>
</li>
<li>网络设备驱动(Network device drivers)<ul>
<li>管理网卡和通信端口，即管理连接到网桥或路由的网络设备</li>
</ul>
</li>
<li>陷阱与错误(Traps and faults)<ul>
<li>处理CPU产生的陷阱和错误，如内存错误</li>
</ul>
</li>
<li>物理内存(Physical memory)<ul>
<li>管理实际内存中的内存页池，并为虚存分配内存页</li>
</ul>
</li>
<li>中断(Interrupts)<ul>
<li>处理来自外设的中断</li>
</ul>
</li>
</ol>
<h3 id="2-Windows和Android先不整理，以后需要再学"><a href="#2-Windows和Android先不整理，以后需要再学" class="headerlink" title="2. Windows和Android先不整理，以后需要再学"></a>2. Windows和Android先不整理，以后需要再学</h3><h1 id="第三章：进程"><a href="#第三章：进程" class="headerlink" title="第三章：进程"></a>第三章：进程</h1><h3 id="1-进程介绍"><a href="#1-进程介绍" class="headerlink" title="1. 进程介绍"></a>1. 进程介绍</h3><h5 id="进程的两个基本元素"><a href="#进程的两个基本元素" class="headerlink" title="进程的两个基本元素"></a>进程的两个基本元素</h5><ul>
<li>程序代码</li>
<li>数据集</li>
</ul>
<h5 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块(PCB)"></a>进程控制块(PCB)</h5><ul>
<li>标识符</li>
<li>状态</li>
<li>优先级</li>
<li>程序计数器</li>
<li>内存指针</li>
<li>上下文数据</li>
<li>I/O 状态信息</li>
<li>记账信息</li>
</ul>
<h3 id="2-进程状态"><a href="#2-进程状态" class="headerlink" title="2. 进程状态"></a>2. 进程状态</h3><h5 id="经典5状态"><a href="#经典5状态" class="headerlink" title="经典5状态"></a>经典5状态</h5><ul>
<li>新建态<ul>
<li>空–&gt;新建</li>
</ul>
</li>
<li>就绪<ul>
<li>新建–&gt;就绪</li>
<li>运行–&gt;就绪</li>
<li>阻塞–&gt;就绪</li>
</ul>
</li>
<li>运行<ul>
<li>就绪–&gt;运行</li>
</ul>
</li>
<li>阻塞<ul>
<li>运行–&gt;阻塞</li>
</ul>
</li>
<li>退出态<ul>
<li>运行–&gt;退出</li>
<li>阻塞–&gt;退出</li>
<li>就绪–&gt;退出</li>
</ul>
</li>
</ul>
<h5 id="挂起态"><a href="#挂起态" class="headerlink" title="挂起态"></a>挂起态</h5><ul>
<li>这个主要是内存不足，就把进程先换到外存</li>
</ul>
<h3 id="3-操作系统的控制结构"><a href="#3-操作系统的控制结构" class="headerlink" title="3. 操作系统的控制结构"></a>3. 操作系统的控制结构</h3><ul>
<li>内存–&gt;内存表</li>
<li>设备–&gt;设备表</li>
<li>文件–&gt;文件表</li>
<li>进程–&gt;主进程表–&gt;进程映像</li>
</ul>
<h3 id="4-进程映像"><a href="#4-进程映像" class="headerlink" title="4. 进程映像"></a>4. 进程映像</h3><ul>
<li>进程控制块<ul>
<li>进程id</li>
<li>处理器状态信息</li>
<li>进程控制信息</li>
</ul>
</li>
<li>用户栈</li>
<li>私有用户地址空间(程序，数据)<ul>
<li>堆</li>
<li>静态数据区</li>
<li>代码段</li>
</ul>
</li>
<li>共享地址空间</li>
</ul>
<h1 id="第四章：线程"><a href="#第四章：线程" class="headerlink" title="第四章：线程"></a>第四章：线程</h1><h3 id="1-线程介绍"><a href="#1-线程介绍" class="headerlink" title="1. 线程介绍"></a>1. 线程介绍</h3><ul>
<li>一个进程可以有多个线程</li>
<li>每个线程有自己的线程控制块，用户栈，内核栈</li>
<li>所有线程共享用户地址空间</li>
</ul>
<h3 id="2-线程状态"><a href="#2-线程状态" class="headerlink" title="2. 线程状态"></a>2. 线程状态</h3><ul>
<li>就绪，运行，阻塞</li>
<li>没有挂起</li>
</ul>
<h3 id="3-Linux中的线程"><a href="#3-Linux中的线程" class="headerlink" title="3. Linux中的线程"></a>3. Linux中的线程</h3><ul>
<li>Linux中没有给线程单独定义数据结构，所以Linux中的线程和进程没有区别</li>
<li>Linux提供一种不区分进程和线程的解决方案<ul>
<li>将用户级线程映射到内核级进程上。</li>
<li>组成一个用户级进程的多个用户级线程则映射到共享同一个组ID的多个Linux内核级进程上。</li>
<li>因此，这些进程可以共享文件和内存等资源，使得同一个组中的进程调度切换时不需要切换上下文</li>
</ul>
</li>
<li>当Linux内核执行从一个进程到另一个进程的切换时，会检查当前进程的页目录地址是否与将被调度的进程的相同。<ul>
<li>若相同，则它们共享同一个地址空间，所以此时的上下午切换仅是从代码的一处跳转到另一处</li>
<li>可以共享同一内存空间，但不能共享同一个用户栈。所以每个线程有自己单独的栈空间</li>
</ul>
</li>
</ul>
<h3 id="4-Linux的命名空间"><a href="#4-Linux的命名空间" class="headerlink" title="4. Linux的命名空间"></a>4. Linux的命名空间</h3><ul>
<li>命名空间可以使一个进程(或共享同一命名空间下的多个进程)拥有与其他相关命名空间下的其他进程不同的系统视图。</li>
<li>当前Linux有6种命名空间：mnt,pid,net,ipc,uts,user<ul>
<li>Mount命名空间<br>  为进程提供文件系统层级结构的特定视图，因次两个不同mount命名空间的进程会看到不同的文件系统层次结构</li>
<li>UTS命名空间<br>  UNIX timesharing UNIX 分时，通过UTS命名空间，初始化和配置参数能够根据同一系统上的不同进程而变化</li>
<li>IPC命名空间<br>  隔离某些进程间通信资源，如信号量</li>
<li>PID命名空间<br>  隔离进程ID空间</li>
<li>网络命名空间<br>  隔离与网络相关的系统资源</li>
<li>用户命名空间<br>  为自身的UID集建立一个容器</li>
</ul>
</li>
</ul>
<h1 id="第五章：并发性：互斥和同步"><a href="#第五章：并发性：互斥和同步" class="headerlink" title="第五章：并发性：互斥和同步"></a>第五章：并发性：互斥和同步</h1><h3 id="1-常用的并发机制"><a href="#1-常用的并发机制" class="headerlink" title="-1. 常用的并发机制"></a>-1. 常用的并发机制</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>信号量</td>
<td>用于进程间传递信号的整数值，只有三个原子操作：初始化，递增，递减</td>
</tr>
<tr>
<td>二元信号量</td>
<td>只有0和1的信号量</td>
</tr>
<tr>
<td>互斥量/互斥锁</td>
<td>类似于二元信号量，关键区别在于为其加锁(设定值为0)的进程和解锁(设定值为0)的进程必须为同一个进程</td>
</tr>
<tr>
<td>条件变量</td>
<td>一种数据类型，用于阻塞进程或线程，直到特定的条件为真</td>
</tr>
<tr>
<td>管程</td>
<td>一种编程语言结构</td>
</tr>
<tr>
<td>自旋锁</td>
<td>一种互斥机制，进程在一个无条件循环中执行，等待锁变量的值可用</td>
</tr>
</tbody></table>
<h3 id="0-进程和线程的管理"><a href="#0-进程和线程的管理" class="headerlink" title="0. 进程和线程的管理"></a>0. 进程和线程的管理</h3><ul>
<li>多道程序设计技术<br>  管理单处理器的多个进程</li>
<li>多处理器技术<br>  管理多处理器的多个进程</li>
<li>分布式处理器技术<br>  管理多态分布式计算机系统中多个进程的执行。集群就是这个的典型例子</li>
</ul>
<h5 id="互斥的要求"><a href="#互斥的要求" class="headerlink" title="互斥的要求"></a>互斥的要求</h5><ol>
<li>一次只允许一个进程进入临界区</li>
<li>一个在非临界区停止的进程不能干涉其他进程</li>
<li>不允许出现需要访问临界区的进程被无限延迟的情况，即不会死锁和饥饿</li>
<li>没有进程在临界区时，需要进入的进程要能立刻进入</li>
<li>对相关进程的执行速度和处理器的数量没有任何要求</li>
<li>一个进程驻留在临界区的时间必须是有限的</li>
</ol>
<h3 id="1-互斥：硬件的支持"><a href="#1-互斥：硬件的支持" class="headerlink" title="1. 互斥：硬件的支持"></a>1. 互斥：硬件的支持</h3><h5 id="1-中断禁用"><a href="#1-中断禁用" class="headerlink" title="1. 中断禁用"></a>1. 中断禁用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    &#x2F;&#x2F;禁用中断</span><br><span class="line">    &#x2F;&#x2F;临界区</span><br><span class="line">    &#x2F;&#x2F;启用中断</span><br><span class="line">    &#x2F;&#x2F;其余非临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这种办法执行效率低</li>
<li>不能用于多处理器体系结构中，当有多个处理器，就可能有多个进程同时执行，在这种情况下，禁用中断并不能保证互斥</li>
</ul>
<h5 id="2-专用机器指令"><a href="#2-专用机器指令" class="headerlink" title="2. 专用机器指令"></a>2. 专用机器指令</h5><ul>
<li>保证某些机器指令的原子性</li>
</ul>
<h3 id="2-信号量"><a href="#2-信号量" class="headerlink" title="2. 信号量"></a>2. 信号量</h3><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者/消费者问题"></a>生产者/消费者问题</h5><ul>
<li>有一个缓冲区，生产者往里面放东西(字节或记录)，消费者取东西，一次只能有一个进行操作</li>
</ul>
<h3 id="3-管程"><a href="#3-管程" class="headerlink" title="3. 管程"></a>3. 管程</h3><ul>
<li>为什么感觉第一次听这个概念。。。先跳过</li>
</ul>
<h3 id="4-消息传递"><a href="#4-消息传递" class="headerlink" title="4. 消息传递"></a>4. 消息传递</h3><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><ul>
<li>发送者和接收者都可阻塞或不阻塞。通常有三种组合，但任一特定操作系统通常只实现一种或两种<ul>
<li>阻塞send，阻塞receive<br>  发送者和接收者都阻塞，直到完成消息传递。进程间紧密同步</li>
<li>无阻塞send,阻塞receive<br>  发送者可以继续执行，接收阻塞，这可能是最有用的一种组合</li>
<li>无阻塞send,无阻塞receive<br>  双方都不等待</li>
</ul>
</li>
</ul>
<h5 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h5><ul>
<li>直接寻址<ul>
<li>进程对进程直接发送消息</li>
</ul>
</li>
<li>间接寻址<ul>
<li>消息发送到一个共享的数据结构，如管道</li>
</ul>
</li>
</ul>
<h5 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h5><ul>
<li>直白的说就是：具体情况具体分析</li>
</ul>
<h3 id="5-读者-写者问题"><a href="#5-读者-写者问题" class="headerlink" title="5. 读者/写者问题"></a>5. 读者/写者问题</h3><h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><ol>
<li>任意数量的读进程可以读这个文件</li>
<li>一次只有一个写进程能写这个文件</li>
<li>若一个写进程正在写文件，则禁止任何读进程读文件</li>
</ol>
<h5 id="读者优先"><a href="#读者优先" class="headerlink" title="读者优先"></a>读者优先</h5><h5 id="写者优先"><a href="#写者优先" class="headerlink" title="写者优先"></a>写者优先</h5><h1 id="第六章：并发：死锁和饥饿"><a href="#第六章：并发：死锁和饥饿" class="headerlink" title="第六章：并发：死锁和饥饿"></a>第六章：并发：死锁和饥饿</h1><h3 id="6-1-死锁原理"><a href="#6-1-死锁原理" class="headerlink" title="6.1 死锁原理"></a>6.1 死锁原理</h3><h5 id="6-1-1-可重用资源死锁"><a href="#6-1-1-可重用资源死锁" class="headerlink" title="6.1.1 可重用资源死锁"></a>6.1.1 可重用资源死锁</h5><ul>
<li>资源可重用，如设备</li>
<li>两个进程各自占用一个设备，都需要另一个设备时死锁</li>
</ul>
<h5 id="6-1-2-可消耗资源死锁"><a href="#6-1-2-可消耗资源死锁" class="headerlink" title="6.1.2 可消耗资源死锁"></a>6.1.2 可消耗资源死锁</h5><ul>
<li>资源只能使用一次，消耗性的，如缓冲区中的数据</li>
<li>两个进程都想从缓冲区读数据，没进程写，都处于阻塞等待状态，死锁</li>
</ul>
<h5 id="6-1-3-资源分配图"><a href="#6-1-3-资源分配图" class="headerlink" title="6.1.3 资源分配图"></a>6.1.3 资源分配图</h5><ul>
<li>系统资源和进程的有向状态图</li>
</ul>
<h5 id="6-1-4-死锁条件"><a href="#6-1-4-死锁条件" class="headerlink" title="6.1.4 死锁条件"></a>6.1.4 死锁条件</h5><ul>
<li>互斥<ul>
<li>一次只有一个进程可以使用某个资源</li>
</ul>
</li>
<li>占有且等待<ul>
<li>当一个进程等待其他进程时，继续占有已经占有的资源</li>
<li>解决办法：一次性占有所有资源</li>
</ul>
</li>
<li>不可抢占<ul>
<li>不能强行抢占其他进程已经占有的资源</li>
<li>解决办法：若申请其他资源不成功，则释放已占有的资源</li>
</ul>
</li>
<li>循环等待<ul>
<li>存在一个闭合的进程链，每个进程至少占有此链下一个进程所需的一个资源</li>
<li>这一条实际上是前三条的潜在结果</li>
<li>解决办法：定义资源的线性顺序，若一个进程已经占用了R资源，接下来只能占有R之后的资源</li>
</ul>
</li>
</ul>
<h5 id="6-1-5-处理死锁的办法"><a href="#6-1-5-处理死锁的办法" class="headerlink" title="6.1.5 处理死锁的办法"></a>6.1.5 处理死锁的办法</h5><ul>
<li>预防<ul>
<li>消除某一个死锁条件</li>
</ul>
</li>
<li>避免<ul>
<li>基于资源分配的当前状态做动态选择</li>
</ul>
</li>
<li>检测<ul>
<li>检测死锁的存在并从死锁中恢复</li>
</ul>
</li>
</ul>
<h3 id="6-2-小结"><a href="#6-2-小结" class="headerlink" title="6.2 小结"></a>6.2 小结</h3><table>
<thead>
<tr>
<th>原则</th>
<th>资源分配策略</th>
<th>不同的方案</th>
</tr>
</thead>
<tbody><tr>
<td>预防</td>
<td>保守:预提交资源</td>
<td>一次性请求所有方案</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
<td>抢占</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
<td>资源排序</td>
</tr>
<tr>
<td>避免</td>
<td>介于检测和预防之间</td>
<td>操作以便发现至少一条安全路径</td>
</tr>
<tr>
<td>检测</td>
<td>非常自由：只要有可能，请求的资源都被允许</td>
<td>周期性的调用以便检测死锁</td>
</tr>
</tbody></table>
<h3 id="6-3-哲学家就餐问题"><a href="#6-3-哲学家就餐问题" class="headerlink" title="6.3 哲学家就餐问题"></a>6.3 哲学家就餐问题</h3><p>假设有5跟筷子，5个座位</p>
<h5 id="6-3-1-基于信号量的解决方案"><a href="#6-3-1-基于信号量的解决方案" class="headerlink" title="6.3.1 基于信号量的解决方案"></a>6.3.1 基于信号量的解决方案</h5><ul>
<li>只能允许4个人同时吃</li>
</ul>
<h5 id="6-3-2-基于管程的解决方案"><a href="#6-3-2-基于管程的解决方案" class="headerlink" title="6.3.2 基于管程的解决方案"></a>6.3.2 基于管程的解决方案</h5><ul>
<li>实际上就是左右同时拿，只有左右同时可用才拿，只要有一个不可用，就都不拿</li>
</ul>
<h3 id="6-4-UNIX并发机制"><a href="#6-4-UNIX并发机制" class="headerlink" title="6.4 UNIX并发机制"></a>6.4 UNIX并发机制</h3><ul>
<li>管道<ul>
<li>pipe</li>
<li>mkfifo</li>
</ul>
</li>
<li>消息<ul>
<li>有msgsnd和msgrcv系统调用</li>
</ul>
</li>
<li>共享内存</li>
<li>信号量<ul>
<li>semctl</li>
<li>sem_op</li>
</ul>
</li>
<li>信号</li>
</ul>
<h3 id="6-5-Linux内核并发机制"><a href="#6-5-Linux内核并发机制" class="headerlink" title="6.5 Linux内核并发机制"></a>6.5 Linux内核并发机制</h3><ul>
<li>包含UNIX的所有</li>
<li>原子操作<ul>
<li>atomic_xxx()</li>
</ul>
</li>
<li>自旋锁<ul>
<li>一次只有一个进程能进入临界区</li>
<li>其它试图获得自旋锁的进程将一直进行尝试（即自旋），直到获得该锁</li>
<li>spin_lock系列调用</li>
</ul>
</li>
</ul>
<h1 id="第七章：内存管理"><a href="#第七章：内存管理" class="headerlink" title="第七章：内存管理"></a>第七章：内存管理</h1><h3 id="0-内存管理术语"><a href="#0-内存管理术语" class="headerlink" title="0. 内存管理术语"></a>0. 内存管理术语</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>页框</td>
<td>内存中固定长度的块</td>
</tr>
<tr>
<td>页</td>
<td>固定长度的数据块，存储在二级存储器中(如磁盘)。数据页可以临时复制到内存的页框中</td>
</tr>
<tr>
<td>段</td>
<td>变长数据块，存储在二级存储器中。整个段可以临时复制到内存中的一个可用区域(分段)，或可以将一个段分为许多页，然后将每页单独复制到内存中(分段和分页相结合)</td>
</tr>
</tbody></table>
<h3 id="1-内存管理的需求"><a href="#1-内存管理的需求" class="headerlink" title="1. 内存管理的需求"></a>1. 内存管理的需求</h3><ul>
<li>重定位</li>
<li>保护</li>
<li>共享</li>
<li>逻辑组织</li>
<li>物理组织</li>
</ul>
<h3 id="2-分页和分段"><a href="#2-分页和分段" class="headerlink" title="2. 分页和分段"></a>2. 分页和分段</h3><ul>
<li>分页是对分区的改进，减少了内存碎片</li>
<li>每个进程维护一个页表</li>
<li>使用分段技术，可以把程序和与其相关的数据划分到几个段中</li>
<li>分页对程序员透明，分段通常是可见的</li>
</ul>
<h1 id="第八章：虚拟内存"><a href="#第八章：虚拟内存" class="headerlink" title="第八章：虚拟内存"></a>第八章：虚拟内存</h1><h3 id="0-虚拟内存术语"><a href="#0-虚拟内存术语" class="headerlink" title="0. 虚拟内存术语"></a>0. 虚拟内存术语</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>虚拟内存</td>
<td>程序引用内存使用的地址与内存系统用于识别物理存储站点的地址是不同的，程序生成的地址会自动转换为机器地址。虚拟存储的大小受系统寻址机制和可用的备用内存量的限制，而不受主存储位置实际数量的限制</td>
</tr>
<tr>
<td>虚拟地址</td>
<td>在虚拟内存中分配给某一位置的地址，它使得该位置可被访问，就好像是主存内的一部分那样</td>
</tr>
<tr>
<td>虚拟地址空间</td>
<td>分配给进程的虚拟存储</td>
</tr>
<tr>
<td>地址空间</td>
<td>用于某进程的内存地址范围</td>
</tr>
<tr>
<td>实地址</td>
<td>内存中存储位置的地址</td>
</tr>
</tbody></table>
<h3 id="1-关键概念"><a href="#1-关键概念" class="headerlink" title="1. 关键概念"></a>1. 关键概念</h3><ul>
<li>内存碎片<ul>
<li>内部碎片<br>  已经使用的内存，不能用到的地方</li>
<li>外部碎片<br>  没有使用的内存，但是太小了不能再用的内存</li>
</ul>
</li>
<li>抖动<ul>
<li>频繁中断进行内存页的换进换出，常见于先进先出算法</li>
</ul>
</li>
<li>置换页的基本算法<ul>
<li>最佳<ul>
<li>置换下次访问距当前时间最长的页，需要预测</li>
<li>不可能实现，仅作为衡量其他算法性能的一种标准</li>
</ul>
</li>
<li>最近最少使用<ul>
<li>时钟策略的变体</li>
</ul>
</li>
<li>先进先出<ul>
<li>实现简单，性能较差</li>
</ul>
</li>
<li>时钟<ul>
<li>有一个只能为1或0的使用位，初始为1，若要置换，找下一个，下一个若为0，就换出，若为1就变为0，继续找下一个，就是多给了一次机会，所有的页组成一个环</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第九章：单处理器调度"><a href="#第九章：单处理器调度" class="headerlink" title="第九章：单处理器调度"></a>第九章：单处理器调度</h1><h3 id="1-处理器调度的类型"><a href="#1-处理器调度的类型" class="headerlink" title="1. 处理器调度的类型"></a>1. 处理器调度的类型</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>长程调度</td>
<td>决定加入待执行进程池</td>
</tr>
<tr>
<td>中程调度</td>
<td>决定加入部分或全部位于内存中的进程集合</td>
</tr>
<tr>
<td>短程调度</td>
<td>决定处理器执行哪个可运行进程</td>
</tr>
<tr>
<td>I/O调度</td>
<td>决定可用IO设备处理哪个进程挂起的IO请求</td>
</tr>
</tbody></table>
<ul>
<li><p>长程调度和中程调度主要由与系统并发度相关的性能驱动，如第7,8章的页面置换等。本章主要讲短程调度。</p>
</li>
<li><p>导致当前进程阻塞或抢占当前运行进程的事件发生时，调用短程调度程序。这类事件包括：</p>
<ul>
<li>时钟中断</li>
<li>IO中断</li>
<li>操作系统调用</li>
<li>信号（如信号量）</li>
</ul>
</li>
</ul>
<h3 id="2-调度算法"><a href="#2-调度算法" class="headerlink" title="2. 调度算法"></a>2. 调度算法</h3><h5 id="调度规则"><a href="#调度规则" class="headerlink" title="调度规则"></a>调度规则</h5><h5 id="优先级的使用"><a href="#优先级的使用" class="headerlink" title="优先级的使用"></a>优先级的使用</h5><h5 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h5><ul>
<li>先来先服务</li>
<li>时间片轮转</li>
<li>最短进程优先</li>
<li>最短剩余时间</li>
<li>最短相应比优先</li>
<li>反馈<br>  建立一组调度队列，基于每个进程的执行历史和其他一些规则，把它们分配到各个队列中</li>
<li>调度算法的选择取决于预期的性能和实现的复杂度</li>
</ul>
<h1 id="第十章：多处理器和实时调度"><a href="#第十章：多处理器和实时调度" class="headerlink" title="第十章：多处理器和实时调度"></a>第十章：多处理器和实时调度</h1><h3 id="1-多处理器调度"><a href="#1-多处理器调度" class="headerlink" title="1. 多处理器调度"></a>1. 多处理器调度</h3><h5 id="多处理器系统分类"><a href="#多处理器系统分类" class="headerlink" title="多处理器系统分类"></a>多处理器系统分类</h5><ul>
<li>松耦合、分布式多处理器、集群<ul>
<li>由一系列相对自治的系统组成，每个处理器都有自身的内存和IO通道</li>
</ul>
</li>
<li>专用处理器<ul>
<li>IO处理器是一个典型的例子。此时，有一个通用的主处理器，专用处理器由主处理器控制，并为主处理器提供服务。</li>
</ul>
</li>
<li>紧耦合多处理器<ul>
<li>由一系列共享同一内存并受操作系统完全控制的处理器组成</li>
</ul>
</li>
</ul>
<h5 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h5><table>
<thead>
<tr>
<th>粒度大小</th>
<th>说明</th>
<th>同步间隔(指令)</th>
</tr>
</thead>
<tbody><tr>
<td>细</td>
<td>单指令流中固有的并行</td>
<td>&lt;20</td>
</tr>
<tr>
<td>中等</td>
<td>一个单独应用中的并行处理或多任务处理</td>
<td>20~200</td>
</tr>
<tr>
<td>粗</td>
<td>多道程序环境中并发进程的多处理</td>
<td>200~2000</td>
</tr>
<tr>
<td>极粗</td>
<td>在网络节点上进行分布式处理，形成一个计算环境</td>
<td>2000~1M</td>
</tr>
<tr>
<td>无约束</td>
<td>多个无关进程</td>
<td>不适用</td>
</tr>
</tbody></table>
<ul>
<li>无约束并行性<ul>
<li>进程间没有显式的同步，每个进程都代表独立的应用或作业。这类并行性的一个典型应用是分时系统。每个yoghurt执行一个特定的应用，如字处理。</li>
</ul>
</li>
<li>粗粒度和极粗粒度并行性<ul>
<li>进程间存在同步，但这种同步的级别极粗。</li>
</ul>
</li>
</ul>
<h5 id="设计问题"><a href="#设计问题" class="headerlink" title="设计问题"></a>设计问题</h5><p>多处理器中的调度涉及三个相互关联的问题</p>
<ul>
<li>把进程分配到处理器<ul>
<li>分配到那个处理器</li>
</ul>
</li>
<li>在单处理器上使用多道程序设计</li>
<li>一个进程的实际分派<ul>
<li>选择哪个进程运行</li>
</ul>
</li>
</ul>
<h3 id="2-实时调度"><a href="#2-实时调度" class="headerlink" title="2. 实时调度"></a>2. 实时调度</h3><ul>
<li>负责Linux调度的三个类<ul>
<li>SCHED_FIFO:先进先出实时线程</li>
<li>SCHED_RR:轮转实时线程</li>
<li>SCHED_OTHER:其他非实时线程</li>
</ul>
</li>
<li>这个还有好多没记，主要是不理解什么意思，不知道哪些是重点，以后能有实践机会了深入了解了再学。</li>
</ul>
<h1 id="第十一章：IO管理和磁盘调度"><a href="#第十一章：IO管理和磁盘调度" class="headerlink" title="第十一章：IO管理和磁盘调度"></a>第十一章：IO管理和磁盘调度</h1><h3 id="1-IO设备"><a href="#1-IO设备" class="headerlink" title="1. IO设备"></a>1. IO设备</h3><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul>
<li>人可读<ul>
<li>打印机</li>
<li>终端</li>
<li>鼠标等</li>
</ul>
</li>
<li>机器可读<ul>
<li>USB秘钥</li>
<li>传感器等</li>
</ul>
</li>
<li>通信<ul>
<li>调制解调器</li>
</ul>
</li>
</ul>
<h5 id="各设备主要差异"><a href="#各设备主要差异" class="headerlink" title="各设备主要差异"></a>各设备主要差异</h5><ul>
<li>数据传输速率</li>
<li>应用</li>
<li>控制的复杂度</li>
<li>传送单位</li>
<li>数据表示</li>
<li>错误条件</li>
</ul>
<h3 id="2-IO功能的组织"><a href="#2-IO功能的组织" class="headerlink" title="2. IO功能的组织"></a>2. IO功能的组织</h3><h5 id="三种执行IO的技术"><a href="#三种执行IO的技术" class="headerlink" title="三种执行IO的技术"></a>三种执行IO的技术</h5><ul>
<li>程序控制IO</li>
<li>中断驱动IO</li>
<li>直接存储器访问(DMA)</li>
</ul>
<h3 id="3-IO缓冲"><a href="#3-IO缓冲" class="headerlink" title="3. IO缓冲"></a>3. IO缓冲</h3><h5 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h5><ul>
<li>有一个缓冲区</li>
</ul>
<h5 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h5><ul>
<li>两个系统缓冲区，在一个进程向一个缓冲区中传送数据的同时，操作系统正在清空(或填充)另一个缓冲区，这叫双缓冲或缓冲交换</li>
</ul>
<h5 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h5><ul>
<li>多于两个缓冲区</li>
</ul>
<h5 id="缓冲作用"><a href="#缓冲作用" class="headerlink" title="缓冲作用"></a>缓冲作用</h5><ul>
<li>平滑IO需求的峰值</li>
</ul>
<h3 id="4-磁盘调度"><a href="#4-磁盘调度" class="headerlink" title="4. 磁盘调度"></a>4. 磁盘调度</h3><h5 id="磁盘性能参数"><a href="#磁盘性能参数" class="headerlink" title="磁盘性能参数"></a>磁盘性能参数</h5><ul>
<li>寻道时间</li>
<li>旋转延迟</li>
<li>传输时间</li>
<li>时序比较</li>
</ul>
<h5 id="调度策略-1"><a href="#调度策略-1" class="headerlink" title="调度策略"></a>调度策略</h5><ul>
<li>先进先出</li>
<li>优先级</li>
<li>后进先出</li>
<li>最短服务时间优先</li>
<li>SCAN(电梯算法)</li>
<li>C-SCAN，只向一个方向移动</li>
</ul>
<h5 id="RDIA"><a href="#RDIA" class="headerlink" title="RDIA"></a>RDIA</h5><ul>
<li>这个需要的时候再了解吧，有点抽象，不知道是干嘛的</li>
</ul>
<h1 id="第十二章：文件管理"><a href="#第十二章：文件管理" class="headerlink" title="第十二章：文件管理"></a>第十二章：文件管理</h1><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h5 id="文件和文件系统"><a href="#文件和文件系统" class="headerlink" title="文件和文件系统"></a>文件和文件系统</h5><ul>
<li>一些理想的属性<ul>
<li>长期存在</li>
<li>可在进程间共享</li>
<li>结构</li>
</ul>
</li>
<li>典型的操作<ul>
<li>创建</li>
<li>删除</li>
<li>打开</li>
<li>关闭</li>
<li>读</li>
<li>写</li>
</ul>
</li>
<li>文件系统通常为文件维护一组属性，包括所有者、创建时间、最后修改时间和访问权限</li>
</ul>
<h5 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h5><ul>
<li>4个术语<ul>
<li>域 field<br>  基本的数据单元，如人名，出生日期</li>
<li>记录 record<br>  一组相关域的集合，如一个人作为一条记录，有名字，出生日期等域</li>
<li>文件 file<br>  一组相似记录的集合</li>
<li>数据库<br>  一组相关数据的集合</li>
</ul>
</li>
<li>并非所有文件管理系统都会是这种结构，在类UNIX系统上，文件的基本结构是字节流。例如一个C语言程序以文件的形式存储，而没有物理域、记录等</li>
</ul>
<h5 id="文件管理系统"><a href="#文件管理系统" class="headerlink" title="文件管理系统"></a>文件管理系统</h5><ul>
<li>典型情况下，文件管理系统是用户或应用程序访问文件的唯一方式</li>
<li>文件系统架构<ul>
<li>用户程序</li>
<li>堆 顺序 索引顺序 索引 散列</li>
<li>逻辑IO</li>
<li>基本IO管理程序</li>
<li>基本文件系统</li>
<li>磁盘设备驱动 磁带设备驱动等驱动程序</li>
</ul>
</li>
</ul>
<h3 id="2-文件组织和访问"><a href="#2-文件组织和访问" class="headerlink" title="2. 文件组织和访问"></a>2. 文件组织和访问</h3><ul>
<li>选择文件组织的原则<ul>
<li>快速访问</li>
<li>易于修改</li>
<li>节约存储空间</li>
<li>维护简单</li>
<li>可靠性<br>这些原则的优先级取决于使用这些文件的应用程序</li>
</ul>
</li>
<li>5种基本组织<ul>
<li>堆<ul>
<li>不是数据结构中的堆，是最简单的文件组织形式</li>
<li>堆文件没有结构，访问记录只能穷举查找</li>
<li>对大多数应用都不适用，当数据难以组织时，可以用堆文件</li>
</ul>
</li>
<li>顺序文件<ul>
<li>最常用，每条记录有固定的格式</li>
<li>通常应用于批处理应用中</li>
<li>另一种选择是把顺序文件组织成链表的形式。但增加额外的处理和空间开销</li>
</ul>
</li>
<li>索引文件<ul>
<li>只能通过索引访问</li>
</ul>
</li>
<li>索引顺序文件<ul>
<li>克服顺序文件的缺点，增加了用于支持随机访问的文件索引和溢出文件</li>
</ul>
</li>
<li>直接或散列文件<ul>
<li>记录长度固定，快速访问，一次只能访问一条记录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-B树"><a href="#3-B树" class="headerlink" title="3. B树"></a>3. B树</h3><ul>
<li>用于文件系统和数据库</li>
<li>每个节点有多个关键码的树</li>
</ul>
<h3 id="4-Linux文件系统"><a href="#4-Linux文件系统" class="headerlink" title="4. Linux文件系统"></a>4. Linux文件系统</h3><h5 id="VFS虚拟文件系统"><a href="#VFS虚拟文件系统" class="headerlink" title="VFS虚拟文件系统"></a>VFS虚拟文件系统</h5><ul>
<li>VFS的4个主要对象<ul>
<li>超级块对象 superblock<br>  表示一个已挂载的特定文件系统</li>
<li>索引节点对象 inode<br>  表示一个特定的问价</li>
<li>目录项对象 dentry<br>  表示一个特定的目录项</li>
<li>文件对象 file<br>  表示一个与进程相关的已打开文件</li>
</ul>
</li>
</ul>
<h1 id="第十三章：嵌入式操作系统"><a href="#第十三章：嵌入式操作系统" class="headerlink" title="第十三章：嵌入式操作系统"></a>第十三章：嵌入式操作系统</h1><h3 id="1-嵌入式系统"><a href="#1-嵌入式系统" class="headerlink" title="1. 嵌入式系统"></a>1. 嵌入式系统</h3><ul>
<li>为完成某个特定功能而设计的</li>
</ul>
<h3 id="2-嵌入式Linux"><a href="#2-嵌入式Linux" class="headerlink" title="2. 嵌入式Linux"></a>2. 嵌入式Linux</h3><ul>
<li>内核比普通Linux小队多</li>
<li>交叉编译，在一个平台上编译，在另一个平台上运行</li>
<li>文件系统<ul>
<li>通常使用闪存作为持久性存储设备</li>
</ul>
</li>
</ul>
<h1 id="第十四章：虚拟机"><a href="#第十四章：虚拟机" class="headerlink" title="第十四章：虚拟机"></a>第十四章：虚拟机</h1><ul>
<li>这章……讲的……真抽象</li>
<li>虚拟化技术使得单个PC或服务器能够同时运行多个操作系统或一个操作系统的多个会话</li>
</ul>
<h1 id="第十五章：计算机安全技术"><a href="#第十五章：计算机安全技术" class="headerlink" title="第十五章：计算机安全技术"></a>第十五章：计算机安全技术</h1><h3 id="1-入侵者与恶意软件"><a href="#1-入侵者与恶意软件" class="headerlink" title="1. 入侵者与恶意软件"></a>1. 入侵者与恶意软件</h3><h5 id="入侵者"><a href="#入侵者" class="headerlink" title="入侵者"></a>入侵者</h5><ul>
<li>伪装者<ul>
<li>越过系统访问控制并使用了一个合法的用户账号</li>
<li>来自外部</li>
</ul>
</li>
<li>违法者<ul>
<li>合法用户，但访问了为被授权的数据</li>
<li>来自外部</li>
</ul>
</li>
<li>秘密用户<ul>
<li>能控制系统的个体</li>
<li>来自外部或内部</li>
</ul>
</li>
</ul>
<h5 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h5><ul>
<li>寄生型<ul>
<li>需要宿主程序</li>
<li>如病毒，逻辑炸弹和程序后门</li>
</ul>
</li>
<li>独立运行<ul>
<li>可以被操作系统调度和执行的独立程序</li>
<li>如蠕虫和机器人程序</li>
</ul>
</li>
</ul>
<h5 id="应对措施"><a href="#应对措施" class="headerlink" title="应对措施"></a>应对措施</h5><ul>
<li>入侵检测系统(IDS)<ul>
<li>基于宿主的IDS</li>
<li>基于网络的IDS</li>
</ul>
</li>
<li>认证</li>
<li>访问控制</li>
<li>防火墙</li>
</ul>
<h3 id="2-缓冲区溢出"><a href="#2-缓冲区溢出" class="headerlink" title="2. 缓冲区溢出"></a>2. 缓冲区溢出</h3><h5 id="缓冲区溢出例子"><a href="#缓冲区溢出例子" class="headerlink" title="缓冲区溢出例子"></a>缓冲区溢出例子</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int valid &#x3D; FALSE;</span><br><span class="line">    char str1[8];</span><br><span class="line">    char str2[8];</span><br><span class="line"></span><br><span class="line">    next_tag(str1); &#x2F;&#x2F;另str1里面存STATE</span><br><span class="line">    gets(str2);</span><br><span class="line">    if(strncmp(str1,str2,8)&#x3D;&#x3D;0)&#123;</span><br><span class="line">        valid &#x3D; TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;str1:%s,str2:%s,valid:%d\n&quot;,str1,str2,valid);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个就会造成缓冲区溢出</li>
<li>一般情况下，valid,str1,str2在内存中连续存放</li>
<li>调用next_tag后，str1里面存储字符串”STATE”</li>
<li>C语言库函数gets不对复制的数据量做任何检查。它从程序的标准输入读取下一行文本，知道出现\n，将其复制到缓冲区，并用C语言字符串使用的NULL作为结尾。如果读入时的字符超过7个(NULL还得占一个)，照样会读入，覆盖相邻变量的值，在本例中即覆盖str1的值，从而破坏其他变量的值</li>
<li>运行如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;正确运行的例子</span><br><span class="line">$ .&#x2F;a.out</span><br><span class="line">STATE</span><br><span class="line">str1:STATE,str2:STATE,valid:1</span><br><span class="line">&#x2F;&#x2F;溢出例子,可以看出已经改变了str1的值</span><br><span class="line">$ .&#x2F;a.out</span><br><span class="line">123456789abcde</span><br><span class="line">str1:9abcde,str2:123456789abcde,valid:0</span><br><span class="line">&#x2F;&#x2F;溢出例子，不仅改了str1的值，还使valid为TRUE</span><br><span class="line">$ .&#x2F;a.out</span><br><span class="line">badinputbadinput</span><br><span class="line">str1:badinput,str2:badinputbadinput,valid:1</span><br></pre></td></tr></table></figure></li>
<li>如果这里是比较密码，成功就登入，就可以用这种办法，不需要知道密码，直接比较成功，从而登入</li>
</ul>
<h5 id="编译时防御"><a href="#编译时防御" class="headerlink" title="编译时防御"></a>编译时防御</h5><ul>
<li>编程语言的选择</li>
<li>安全编码技术</li>
<li>语言扩展及使用安全库</li>
<li>栈保护机制</li>
</ul>
<h5 id="运行时防御"><a href="#运行时防御" class="headerlink" title="运行时防御"></a>运行时防御</h5><ul>
<li>可执行的地址空间保护</li>
<li>地址空间布局随机化</li>
<li>守卫页</li>
</ul>
<h1 id="第十六章：分布式处理、客户-服务器和集群"><a href="#第十六章：分布式处理、客户-服务器和集群" class="headerlink" title="第十六章：分布式处理、客户-服务器和集群"></a>第十六章：分布式处理、客户-服务器和集群</h1><h3 id="1-客户-服务器计算"><a href="#1-客户-服务器计算" class="headerlink" title="1. 客户-服务器计算"></a>1. 客户-服务器计算</h3><table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>应用程序编程接口(API)</td>
<td>允许客户和服务器之间相互通信的一组函数和可调用程序集</td>
</tr>
<tr>
<td>客户端</td>
<td>网络上的一个信息请求方，通常是一台PC或工作站，能够从服务器处查询数据库和其他信息</td>
</tr>
<tr>
<td>中间件</td>
<td>一组驱动程序、应用程序编程接口或其他软件集，用于改善客户应用程序和服务器之间的连通性</td>
</tr>
<tr>
<td>关系数据库</td>
<td>一种把对信息的访问限制于满足搜索条件的数据行的数据库</td>
</tr>
<tr>
<td>服务器</td>
<td>一台计算机，通常是一台高性能工作站、小型计算机或大型机，存储并提供信息给网络中的众多客户使用</td>
</tr>
<tr>
<td>结构化查询语言(SQL)</td>
<td>由IBM开发并由ANSI标准化的一种语言，用于对关系数据库的寻址，创建，更新和查询</td>
</tr>
</tbody></table>
<ul>
<li>我的理解，实际上就是C/S,B/S架构，中间件是像代理服务器之类的东西</li>
</ul>
<h3 id="2-分布式消息传递"><a href="#2-分布式消息传递" class="headerlink" title="2. 分布式消息传递"></a>2. 分布式消息传递</h3><ul>
<li>就是客户端和服务器不能直接通过信号等传递消息，可以通过报文，用特定的结构传递信息，如HTTP</li>
<li>可靠和不可靠性<ul>
<li>是否保证传递消息的正确性</li>
</ul>
</li>
<li>阻塞与无阻塞<ul>
<li>发送和接受消息是否等待</li>
</ul>
</li>
</ul>
<h3 id="3-远程过程调用-RPC"><a href="#3-远程过程调用-RPC" class="headerlink" title="3. 远程过程调用(RPC)"></a>3. 远程过程调用(RPC)</h3><ul>
<li><p>是基本消息传递的一种变体</p>
</li>
<li><p>举例就是客户端给服务器发送个消息，服务器就本地调用某个程序</p>
</li>
<li><p>同步和异步</p>
<ul>
<li>同步RPC<br>  和子程序调用行为类似，要等待返回结果。</li>
<li>异步RPC<br>  调用者并不等待应答</li>
</ul>
</li>
</ul>
<h3 id="4-集群"><a href="#4-集群" class="headerlink" title="4. 集群"></a>4. 集群</h3><ul>
<li>集群技术可以替代对称多处理技术(SMP)</li>
<li>集群定义为一组互联的完整计算机，这些完整计算机作为一种统一的计算资源协同工作，就像一台计算机那样。</li>
<li>集群的四个优点<ul>
<li>绝对可伸缩性<ul>
<li>一个集群可以有用数十台至数百台机器，每台机器都可以是多处理机</li>
</ul>
</li>
<li>增加可伸缩性<ul>
<li>集群能这样配置：向集群中添加系统时只需少量的额外工作，即用户可以在一个大小适度的系统上开始工作，在需求增加时可以扩展系统，而不用升级主体来用较大的系统代替较小的系统。</li>
</ul>
</li>
<li>高可用性<ul>
<li>因为集群中的每个节点都是一台独立的计算机，因此某个节点故障并不意味着服务失败。在很多产品中，软件能够自动地进行容错处理</li>
</ul>
</li>
<li>高性价比<ul>
<li>使用普通的计算机来构建集群系统，能够以非常低的价格，获得与一台大型计算机相同或更大的计算能力</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="练习项目"><a href="#练习项目" class="headerlink" title="练习项目"></a>练习项目</h1><ul>
<li>后期可以看一下附录的一些问题，比如理发店问题，各个小作业</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"><i class="fa fa-tag">linux</i></a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag">操作系统</i></a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/" rel="prev" title="《TCPIP详解》">
      <i class="fa fa-chevron-left"></i> 《TCPIP详解》
    </a></div>
      <div class="post-nav-item">
    <a href="/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/" rel="next" title="《MySQL必知必会》">
      《MySQL必知必会》 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%AE%E9%A1%B6"><span class="nav-text">置顶</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-text">第一章：计算机系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90"><span class="nav-text">1. 基本构成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB"><span class="nav-text">2. 指令分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%B8%AD%E6%96%AD"><span class="nav-text">3. 中断</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">中断的分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E4%B8%AD%E6%96%AD"><span class="nav-text">多个中断</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%86%85%E5%AD%98%E5%B1%82%E6%AC%A1"><span class="nav-text">4. 内存层次</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%BF%E4%B8%8A%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">板上存储器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%BF%E5%A4%96%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">板外存储器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">离线存储器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-text">5. 高速缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%E5%A4%9A%E6%A0%B8"><span class="nav-text">6. 多处理器和多核</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">多处理器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E6%A0%B8"><span class="nav-text">多核</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E8%80%85%E5%8C%BA%E5%88%AB"><span class="nav-text">二者区别</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-text">第二章：操作系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Linux%E4%B8%BB%E8%A6%81%E5%86%85%E6%A0%B8%E7%BB%84%E4%BB%B6"><span class="nav-text">1. Linux主要内核组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Windows%E5%92%8CAndroid%E5%85%88%E4%B8%8D%E6%95%B4%E7%90%86%EF%BC%8C%E4%BB%A5%E5%90%8E%E9%9C%80%E8%A6%81%E5%86%8D%E5%AD%A6"><span class="nav-text">2. Windows和Android先不整理，以后需要再学</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B"><span class="nav-text">第三章：进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="nav-text">1. 进程介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0"><span class="nav-text">进程的两个基本元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97-PCB"><span class="nav-text">进程控制块(PCB)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-text">2. 进程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%8F%E5%85%B85%E7%8A%B6%E6%80%81"><span class="nav-text">经典5状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%82%E8%B5%B7%E6%80%81"><span class="nav-text">挂起态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="nav-text">3. 操作系统的控制结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%BF%9B%E7%A8%8B%E6%98%A0%E5%83%8F"><span class="nav-text">4. 进程映像</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">第四章：线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BA%BF%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="nav-text">1. 线程介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-text">2. 线程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Linux%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="nav-text">3. Linux中的线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Linux%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">4. Linux的命名空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5"><span class="nav-text">第五章：并发性：互斥和同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-text">-1. 常用的并发机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-text">0. 进程和线程的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-text">互斥的要求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BA%92%E6%96%A5%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-text">1. 互斥：硬件的支持</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%B8%AD%E6%96%AD%E7%A6%81%E7%94%A8"><span class="nav-text">1. 中断禁用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%B8%93%E7%94%A8%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">2. 专用机器指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">2. 信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">生产者&#x2F;消费者问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%AE%A1%E7%A8%8B"><span class="nav-text">3. 管程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="nav-text">4. 消息传递</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-text">同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80"><span class="nav-text">寻址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F"><span class="nav-text">消息格式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">5. 读者&#x2F;写者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6"><span class="nav-text">条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88"><span class="nav-text">读者优先</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E8%80%85%E4%BC%98%E5%85%88"><span class="nav-text">写者优先</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%B9%B6%E5%8F%91%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF"><span class="nav-text">第六章：并发：死锁和饥饿</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E6%AD%BB%E9%94%81%E5%8E%9F%E7%90%86"><span class="nav-text">6.1 死锁原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-1-%E5%8F%AF%E9%87%8D%E7%94%A8%E8%B5%84%E6%BA%90%E6%AD%BB%E9%94%81"><span class="nav-text">6.1.1 可重用资源死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-2-%E5%8F%AF%E6%B6%88%E8%80%97%E8%B5%84%E6%BA%90%E6%AD%BB%E9%94%81"><span class="nav-text">6.1.2 可消耗资源死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-3-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="nav-text">6.1.3 资源分配图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-4-%E6%AD%BB%E9%94%81%E6%9D%A1%E4%BB%B6"><span class="nav-text">6.1.4 死锁条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-5-%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E5%8A%9E%E6%B3%95"><span class="nav-text">6.1.5 处理死锁的办法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%B0%8F%E7%BB%93"><span class="nav-text">6.2 小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-text">6.3 哲学家就餐问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-1-%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">6.3.1 基于信号量的解决方案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-2-%E5%9F%BA%E4%BA%8E%E7%AE%A1%E7%A8%8B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">6.3.2 基于管程的解决方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-UNIX%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-text">6.4 UNIX并发机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-Linux%E5%86%85%E6%A0%B8%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-text">6.5 Linux内核并发机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">第七章：内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%AF%E8%AF%AD"><span class="nav-text">0. 内存管理术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E9%9C%80%E6%B1%82"><span class="nav-text">1. 内存管理的需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5"><span class="nav-text">2. 分页和分段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-text">第八章：虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%9C%AF%E8%AF%AD"><span class="nav-text">0. 虚拟内存术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 关键概念</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6"><span class="nav-text">第九章：单处理器调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">1. 处理器调度的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">2. 调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E8%A7%84%E5%88%99"><span class="nav-text">调度规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">优先级的使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="nav-text">调度策略</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="nav-text">第十章：多处理器和实时调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6"><span class="nav-text">1. 多处理器调度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB"><span class="nav-text">多处理器系统分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B2%92%E5%BA%A6"><span class="nav-text">粒度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98"><span class="nav-text">设计问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="nav-text">2. 实时调度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9AIO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="nav-text">第十一章：IO管理和磁盘调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-IO%E8%AE%BE%E5%A4%87"><span class="nav-text">1. IO设备</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-text">分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%84%E8%AE%BE%E5%A4%87%E4%B8%BB%E8%A6%81%E5%B7%AE%E5%BC%82"><span class="nav-text">各设备主要差异</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-IO%E5%8A%9F%E8%83%BD%E7%9A%84%E7%BB%84%E7%BB%87"><span class="nav-text">2. IO功能的组织</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E6%89%A7%E8%A1%8CIO%E7%9A%84%E6%8A%80%E6%9C%AF"><span class="nav-text">三种执行IO的技术</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-IO%E7%BC%93%E5%86%B2"><span class="nav-text">3. IO缓冲</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E7%BC%93%E5%86%B2"><span class="nav-text">单缓冲</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="nav-text">双缓冲</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2"><span class="nav-text">循环缓冲</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E4%BD%9C%E7%94%A8"><span class="nav-text">缓冲作用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="nav-text">4. 磁盘调度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0"><span class="nav-text">磁盘性能参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5-1"><span class="nav-text">调度策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDIA"><span class="nav-text">RDIA</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-text">第十二章：文件管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-text">1. 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">文件和文件系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-text">文件结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-text">文件管理系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="nav-text">2. 文件组织和访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-B%E6%A0%91"><span class="nav-text">3. B树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">4. Linux文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">VFS虚拟文件系统</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">第十三章：嵌入式操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="nav-text">1. 嵌入式系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B5%8C%E5%85%A5%E5%BC%8FLinux"><span class="nav-text">2. 嵌入式Linux</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-text">第十四章：虚拟机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF"><span class="nav-text">第十五章：计算机安全技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%85%A5%E4%BE%B5%E8%80%85%E4%B8%8E%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6"><span class="nav-text">1. 入侵者与恶意软件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A5%E4%BE%B5%E8%80%85"><span class="nav-text">入侵者</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6"><span class="nav-text">恶意软件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E5%AF%B9%E6%8E%AA%E6%96%BD"><span class="nav-text">应对措施</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="nav-text">2. 缓冲区溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E4%BE%8B%E5%AD%90"><span class="nav-text">缓冲区溢出例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E9%98%B2%E5%BE%A1"><span class="nav-text">编译时防御</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%98%B2%E5%BE%A1"><span class="nav-text">运行时防御</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%84%E7%90%86%E3%80%81%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E9%9B%86%E7%BE%A4"><span class="nav-text">第十六章：分布式处理、客户-服务器和集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A1%E7%AE%97"><span class="nav-text">1. 客户-服务器计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="nav-text">2. 分布式消息传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8-RPC"><span class="nav-text">3. 远程过程调用(RPC)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%9B%86%E7%BE%A4"><span class="nav-text">4. 集群</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE"><span class="nav-text">练习项目</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不知自己不知"
      src="/images/head.jpeg">
  <p class="site-author-name" itemprop="name">不知自己不知</p>
  <div class="site-description" itemprop="description">以阅读为生是一件很酷的事，以写作为生是一件更酷的事。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
    <!--
    <div id="music163player">
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&id=5445280661&auto=0&height=90"></iframe>
       </div>
    -->
  </aside>
  
  
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不知自己不知</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">412k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">6:14</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='255,255,255' opacity='1' zIndex='-1' count='200' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'Dv4yd2JUuvVhLBe640B6m1jw-gzGzoHsz',
      appKey     : 'sNdrMuVcw6jJzlz0HpXBNhdB',
      placeholder: "来交流交流吧~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>



