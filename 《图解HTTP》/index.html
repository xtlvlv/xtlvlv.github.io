<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/head.jpeg">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xtlvlv.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":2,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="第1章：了解Web及网络基础1. HTTP HTTP&#x2F;0.9: HTTP于1990年问世 HTTP&#x2F;1.0: 在1996年5月正式作为标准被公布，称为1.0版本,至今仍被广泛使用 HTTP&#x2F;1.1: 1997年1月公布，之后又有修订 HTTP&#x2F;2.0: 正在制定完善中  2. TCP&#x2F;IP&#x2F;DNS">
<meta property="og:type" content="article">
<meta property="og:title" content="《图解HTTP》">
<meta property="og:url" content="https://xtlvlv.github.io/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B/index.html">
<meta property="og:site_name" content="愚昧之巅">
<meta property="og:description" content="第1章：了解Web及网络基础1. HTTP HTTP&#x2F;0.9: HTTP于1990年问世 HTTP&#x2F;1.0: 在1996年5月正式作为标准被公布，称为1.0版本,至今仍被广泛使用 HTTP&#x2F;1.1: 1997年1月公布，之后又有修订 HTTP&#x2F;2.0: 正在制定完善中  2. TCP&#x2F;IP&#x2F;DNS">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-05T11:12:27.000Z">
<meta property="article:modified_time" content="2021-01-05T11:26:44.240Z">
<meta property="article:author" content="愚昧之巅">
<meta property="article:tag" content="http">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xtlvlv.github.io/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《图解HTTP》 | 愚昧之巅</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">

<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->

<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 

  <!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
  
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">愚昧之巅</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">22</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xtlvlv.github.io/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpeg">
      <meta itemprop="name" content="愚昧之巅">
      <meta itemprop="description" content="以阅读为生是一件很酷的事，以写作为生是一件更酷的事。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="愚昧之巅">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《图解HTTP》
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-05 19:12:27 / 修改时间：19:26:44" itemprop="dateCreated datePublished" datetime="2021-01-05T19:12:27+08:00">2021-01-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          
            <span id="/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B/" class="post-meta-item leancloud_visitors" data-flag-title="《图解HTTP》" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>26k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第1章：了解Web及网络基础"><a href="#第1章：了解Web及网络基础" class="headerlink" title="第1章：了解Web及网络基础"></a>第1章：了解Web及网络基础</h1><h3 id="1-HTTP"><a href="#1-HTTP" class="headerlink" title="1. HTTP"></a>1. HTTP</h3><ul>
<li>HTTP/0.9: HTTP于1990年问世</li>
<li>HTTP/1.0: 在1996年5月正式作为标准被公布，称为1.0版本,至今仍被广泛使用</li>
<li>HTTP/1.1: 1997年1月公布，之后又有修订</li>
<li>HTTP/2.0: 正在制定完善中</li>
</ul>
<h3 id="2-TCP-IP-DNS"><a href="#2-TCP-IP-DNS" class="headerlink" title="2. TCP/IP/DNS"></a>2. TCP/IP/DNS</h3><a id="more"></a>
<ul>
<li>TCP: 负责可靠传输</li>
<li>IP: 负责传输</li>
<li>DNS: 负责域名解析（应用层）</li>
</ul>
<h3 id="3-URI-URL"><a href="#3-URI-URL" class="headerlink" title="3. URI/URL"></a>3. URI/URL</h3><ul>
<li>URI: 统一资源标识符，标识某一互联网资源</li>
<li>URL: 统一资源定位符，标识资源的地点，URL是URI的子集<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;URI例子</span><br><span class="line">ftp:&#x2F;&#x2F;ftp.is.co.za&#x2F;rfc&#x2F;rfc1808.txt</span><br><span class="line">http:&#x2F;&#x2F;www.ietf.org&#x2F;rfc&#x2F;rfc2396.txt</span><br><span class="line">ldap:&#x2F;&#x2F;[2001:db8::7]&#x2F;c&#x3D;GB?objectClass?one</span><br><span class="line">mailto:John.Doe@example.com</span><br><span class="line">news:comp.infosystems.www.servers.unix</span><br><span class="line">tel:+1-816-555-1212</span><br><span class="line">telnet:&#x2F;&#x2F;192.0.2.16:80&#x2F;</span><br><span class="line">urn:oasis:names:specification:docbook:dtd:xml:4.1.2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-RFC"><a href="#4-RFC" class="headerlink" title="4. RFC"></a>4. RFC</h3><ul>
<li>有一些用来制定 HTTP 协议技术标准的文档,它们被称为RFC(Request for Comments,征求修正意见书)。</li>
<li>通常,应用程序会遵照由 RFC 确定的标准实现。但是也有些不遵守。</li>
</ul>
<h1 id="第2章：简单的HTTP协议"><a href="#第2章：简单的HTTP协议" class="headerlink" title="第2章：简单的HTTP协议"></a>第2章：简单的HTTP协议</h1><h3 id="1-请求头与响应头"><a href="#1-请求头与响应头" class="headerlink" title="1. 请求头与响应头"></a>1. 请求头与响应头</h3><ul>
<li>请求头<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法 URI 协议版本</span><br><span class="line">请求首部字段（可选）</span><br><span class="line">\r\n</span><br><span class="line">内容实体</span><br></pre></td></tr></table></figure></li>
<li>响应头<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">协议版本 状态码 状态码的原因短语</span><br><span class="line">响应首部字段（可选）</span><br><span class="line">\r\n</span><br><span class="line">内容主体</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-HTTP是不保存状态的协议"><a href="#2-HTTP是不保存状态的协议" class="headerlink" title="2. HTTP是不保存状态的协议"></a>2. HTTP是不保存状态的协议</h3><ul>
<li>也就是说，在HTTP这个级别，协议对于发送过的请求和相应都不做持久化处理</li>
<li>但是有些需要保持登录状态的网站，需要保存用户的状态</li>
<li>HTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。Cookie在后面详解</li>
</ul>
<h3 id="3-HTTP方法"><a href="#3-HTTP方法" class="headerlink" title="3. HTTP方法"></a>3. HTTP方法</h3><ul>
<li><p>总览</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>支持的 HTTP 协议版本</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取资源</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>POST</td>
<td>传输实体主体</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>PUT</td>
<td>传输文件</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>HEAD</td>
<td>获得报文首部</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除文件</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>询问支持的方法</td>
<td>1.1</td>
</tr>
<tr>
<td>TRACE</td>
<td>追踪路径</td>
<td>1.1</td>
</tr>
<tr>
<td>CONNECT</td>
<td>要求用隧道协议连接代理</td>
<td>1.1</td>
</tr>
<tr>
<td>LINK</td>
<td>建立和资源之间的联系</td>
<td>1.0</td>
</tr>
<tr>
<td>UNLINE</td>
<td>断开连接关系</td>
<td>1.0</td>
</tr>
</tbody></table>
</li>
<li><p>GET</p>
<ul>
<li>请求<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回 index.html 的页面资源</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>POST</p>
<ul>
<li>请求 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;submit.cgi HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br><span class="line">Content-Length: 1560(1560字节的数据)</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回 submit.cgi 接收数据的处理结果</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>PUT</p>
<ul>
<li>PUT 方法用来传输文件。就像 FTP 协议的文件上传一样,要求在请<br>求报文的主体中包含文件内容,然后保存到请求 URI 指定的位置。但是,鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制,任何人都可以上传文件 , 存在安全性问题,因此一般的 Web 网站不使用该方法。若配合 Web 应用程序的验证机制,或架构设计采用REST(REpresentational State Transfer,表征状态转移)标准的同类Web 网站,就可能会开放使用 PUT 方法。</li>
<li>请求 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;example.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Content-Length: 1560(1560 字节的数据)</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">响应返回状态码 204 No Content(比如 :该 html 已存在于服务器上)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>HEAD</p>
<ul>
<li>HEAD 方法和 GET 方法一样,只是不返回报文主体部分。用于确认URI 的有效性及资源更新的日期时间等。</li>
<li>请求 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HEAD &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回index.html有关的响应首部</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>DELETE</p>
<ul>
<li>DELETE 方法用来删除文件,是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。但是,HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制,所以一般的 Web 网站也不使用 DELETE 方法。</li>
<li>请求 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;example.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">响应返回状态码 204 No Content(比如 :该 html 已从该服务器上删除)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>OPTIONS</p>
<ul>
<li>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</li>
<li>请求 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS * HTTP&#x2F;1.1</span><br><span class="line">Host: www.hackr.jp</span><br></pre></td></tr></table></figure></li>
<li>响应 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Allow: GET, POST, HEAD, OPTIONS(返回服务器支持的方法)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>TRACE</p>
<ul>
<li>TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。</li>
<li>客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为,请求想要连接到源目标服务器可能会通过代理中转,TRACE 方法就是用来确认连接过程中发生的一系列操作。</li>
<li>请求<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TRACE &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Max-Forwards: 2</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: message&#x2F;http</span><br></pre></td></tr></table></figure></li>
<li>响应<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 1024</span><br><span class="line">TRACE &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Max-Forwards: 2(返回响应包含请求内容)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>CONNECT</p>
<ul>
<li>CONNECT 方法要求在与代理服务器通信时建立隧道,实现用隧道协议进行 TCP 通信。主要使用 SSL(Secure Sockets Layer,安全套接层)和 TLS(Transport Layer Security,传输层安全)协议把通信内容加密后经网络隧道传输。</li>
<li>请求<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONNECT proxy.hackr.jp:8080 HTTP&#x2F;1.1</span><br><span class="line">Host: proxy.hackr.jp</span><br></pre></td></tr></table></figure></li>
<li>响应<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK(之后进入网络隧道)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="4-持久连接节省通信量"><a href="#4-持久连接节省通信量" class="headerlink" title="4. 持久连接节省通信量"></a>4. 持久连接节省通信量</h3><ul>
<li>问题：<br>   HTTP 协议的初始版本中,每进行一次 HTTP 通信就要断开一次 TCP连接。因此,每次的请求都会造成无谓的 TCP 连接建立和断开,增加通信量的开销。</li>
<li><ol>
<li>持久性连接<br> 为解决上述 TCP 连接的问题,HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接(HTTP Persistent Connections,也称为 HTTP keep-alive 或HTTP connection reuse)的方法。持久连接的特点是,只要任意一端没有明确提出断开连接,则保持 TCP 连接状态。</li>
</ol>
<ul>
<li>减少TCP连接次数，减轻服务器负载</li>
<li>Web页面显示速度加快</li>
</ul>
</li>
<li><ol start="2">
<li>管线化</li>
</ol>
<ul>
<li>简单来说就是不等待响应，直接发送下一个请求</li>
<li>从前发送请求后需等待并收到响应,才能发送下一个请求。管线化技术出现后,不用等待响应亦可直接发送下一个请求。管线化技术则比持久连接还要快。请求数越多,时间差就越明显。</li>
</ul>
</li>
</ul>
<h3 id="5-使用Cookie的状态管理"><a href="#5-使用Cookie的状态管理" class="headerlink" title="5. 使用Cookie的状态管理"></a>5. 使用Cookie的状态管理</h3><ul>
<li><ol>
<li>HTTP是无状态的，即服务器不保存客户端的情况，响应之后就不管它是谁谁了。如果让服务器管理全部客户端状态则会成为负担。但这样就不能处理需要登录的情况，所以引入了Cookie技术</li>
</ol>
</li>
<li><ol start="2">
<li>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</li>
</ol>
</li>
<li><ol start="3">
<li>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息,通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入 Cookie 值后发送出去。</li>
</ol>
</li>
<li><ol start="4">
<li>服务器端发现客户端发送过来的 Cookie 后,会去检查究竟是从哪一个客户端发来的连接请求,然后对比服务器上的记录,最后得到之前的状态信息。</li>
</ol>
</li>
<li><ol start="5">
<li>Cookie交互</li>
</ol>
<ul>
<li><ol>
<li>请求报文(没有 Cookie 信息的状态)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一次连接</span><br><span class="line">GET &#x2F;reader&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">*首部字段内没有Cookie的相关信息</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>响应报文(服务器端生成 Cookie 信息)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">&lt;Set-Cookie: sid&#x3D;1342077140226724; path&#x3D;&#x2F;; expires&#x3D;Wed,10-Oct-12 07:12:20 GMT&gt;</span><br><span class="line">Content-Type: text&#x2F;plain; charset&#x3D;UTF-8</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="3">
<li>请求报文(自动发送保存着的 Cookie 信息)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;image&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Cookie: sid&#x3D;1342077140226724</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="4">
<li>服务器根据再收到的cookie知道是谁连接的</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="第3章：HTTP报文内的HTTP信息"><a href="#第3章：HTTP报文内的HTTP信息" class="headerlink" title="第3章：HTTP报文内的HTTP信息"></a>第3章：HTTP报文内的HTTP信息</h1><h3 id="1-HTTP报文"><a href="#1-HTTP报文" class="headerlink" title="1. HTTP报文"></a>1. HTTP报文</h3><ul>
<li>请求报文<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">报文首部</span><br><span class="line">    - 请求行（包含用于请求的方法,请求 URI 和 HTTP 版本。）</span><br><span class="line">    - 请求首部字段</span><br><span class="line">    - 通用首部字段</span><br><span class="line">    - 实体首部字段</span><br><span class="line">    - 其他（如Cookie等RFC未规定的内容）</span><br><span class="line">空行（CR+LF）</span><br><span class="line">报文主体</span><br></pre></td></tr></table></figure></li>
<li>响应报文<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">报文首部</span><br><span class="line">    - 状态行（包含表明响应结果的状态码,原因短语和 HTTP 版本。）</span><br><span class="line">    - 响应首部字段</span><br><span class="line">    - 通用首部字段</span><br><span class="line">    - 实体首部字段</span><br><span class="line">    - 其他（如Cookie等RFC未定义的内容）</span><br><span class="line">空行（CR+LF）</span><br><span class="line">报文主体</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-编码提高传输效率"><a href="#2-编码提高传输效率" class="headerlink" title="2. 编码提高传输效率"></a>2. 编码提高传输效率</h3><ul>
<li><ol>
<li>报文主体和实体主体的区别</li>
</ol>
<ul>
<li>通常,报文主体等于实体主体。</li>
<li>只有当传输中进行编码操作时,实体主体的内容发生变化,才导致它和报文主体产生差异。</li>
</ul>
</li>
<li><ol start="2">
<li>压缩传输的内容编码</li>
</ol>
<ul>
<li>内容编码指明应用在实体内容上的编码格式,并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。（类似于压缩文件）</li>
<li>常用的内容编码<ul>
<li>gzip(GNU zip)</li>
<li>compress(UNIX 系统的标准压缩)</li>
<li>deflate(zlib)</li>
<li>identity(不进行编码)</li>
</ul>
</li>
</ul>
</li>
<li><ol start="3">
<li>分割发送的分块传输编码</li>
</ol>
<ul>
<li>在 HTTP 通信过程中,请求的编码实体资源尚未全部传输完成之前,浏览器无法显示请求页面。在传输大容量数据时,通过把数据分割成多块,能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码(Chunked TransferCoding)</li>
</ul>
</li>
</ul>
<h3 id="3-发送多种数据的多部分对象集合"><a href="#3-发送多种数据的多部分对象集合" class="headerlink" title="3. 发送多种数据的多部分对象集合"></a>3. 发送多种数据的多部分对象集合</h3><ul>
<li>发送邮件时,我们可以在邮件里写入文字并添加多份附件。这是因为采用了 MIME(Multipurpose Internet Mail Extensions,多用途因特网邮件扩展)机制,它允许邮件处理文本、图片、视频等多个不同类型的数据。</li>
<li>相应地,HTTP 协议中也采纳了多部分对象集合,发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。<ul>
<li>multipart/form-data<br>在 Web 表单文件上传时使用。</li>
<li>multipart/byteranges<br>状态码 206(Partial Content,部分内容)响应报文包含了多</li>
<li>在 HTTP 报文中使用多部分对象集合时,需要在首部字段里加上Content-type。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart&#x2F;form-data;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="4-获取部分内容的范围请求"><a href="#4-获取部分内容的范围请求" class="headerlink" title="4. 获取部分内容的范围请求"></a>4. 获取部分内容的范围请求</h3><ul>
<li>以前,用户不能使用现在这种高速的带宽访问互联网,当时,下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况,那就必须重头开始。为了解决上述问题,需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。</li>
<li>对一份 10 000 字节大小的资源,如果使用范围请求,可以只请求5001~10 000 字节内的资源。</li>
<li>例子<ul>
<li>5001~10 000 字节<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes&#x3D;5001-10000</span><br></pre></td></tr></table></figure></li>
<li>从 5001 字节之后全部的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes&#x3D;5001-</span><br></pre></td></tr></table></figure></li>
<li>从一开始到 3000 字节和 5000~7000 字节的多重范围<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes&#x3D;-3000, 5000-7000</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>针对范围请求,响应会返回状态码为 206 Partial Content 的响应报文。另外,对于多重范围的范围请求,响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。</li>
<li>如果服务器端无法响应范围请求,则会返回状态码 200 OK 和完整的实体内容。</li>
</ul>
<h3 id="5-内容协商返回最合适的内容"><a href="#5-内容协商返回最合适的内容" class="headerlink" title="5. 内容协商返回最合适的内容"></a>5. 内容协商返回最合适的内容</h3><ul>
<li>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉,然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</li>
<li>包含在请求报文中的某些首部字段(如下)就是判断的基准。<ul>
<li>Accept</li>
<li>Accept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language</li>
</ul>
</li>
<li>内容协商技术有以下 3 种类型。<ul>
<li>服务器驱动协商(Server-driven Negotiation)<br>由服务器端进行内容协商。以请求的首部字段为参考,在服务器端自动处理。但对用户来说,以浏览器发送的信息作为判定的依据,并不一定能筛选出最优内容。</li>
<li>客户端驱动协商(Agent-driven Negotiation)<br>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型,自行切换成 PC 版页面或手机版页面。</li>
<li>透明协商(Transparent Negotiation)<br>是服务器驱动和客户端驱动的结合体,是由服务器端和客户端各自进行内容协商的一种方法。</li>
</ul>
</li>
</ul>
<h1 id="第4章：返回结果的HTTP状态码"><a href="#第4章：返回结果的HTTP状态码" class="headerlink" title="第4章：返回结果的HTTP状态码"></a>第4章：返回结果的HTTP状态码</h1><h3 id="1-状态码类别"><a href="#1-状态码类别" class="headerlink" title="1. 状态码类别"></a>1. 状态码类别</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational(信息性状态码)</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error(客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error(服务器错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<p>以下为常用的14中状态码</p>
<h3 id="2-2XX成功"><a href="#2-2XX成功" class="headerlink" title="2. 2XX成功"></a>2. 2XX成功</h3><h4 id="2-1-200-OK"><a href="#2-1-200-OK" class="headerlink" title="2.1 200 OK"></a>2.1 200 OK</h4><ul>
<li>正常处理</li>
</ul>
<h4 id="2-2-204-No-Content"><a href="#2-2-204-No-Content" class="headerlink" title="2.2 204 No Content"></a>2.2 204 No Content</h4><ul>
<li>该状态码代表服务器接收的请求已成功处理,但在返回的响应报文中不含实体的主体部分。另外,也不允许返回任何实体的主体。比如,当从浏览器发出请求处理后,返回 204 响应,那么浏览器显示的页面不发生更新。</li>
<li>一般在只需要从客户端往服务器发送信息,而对客户端不需要发送新信息内容的情况下使用</li>
</ul>
<h4 id="2-3-206-Partial-Content"><a href="#2-3-206-Partial-Content" class="headerlink" title="2.3 206 Partial Content"></a>2.3 206 Partial Content</h4><ul>
<li>该状态码表示客户端进行了范围请求,而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<h3 id="3-3XX-重定向"><a href="#3-3XX-重定向" class="headerlink" title="3. 3XX 重定向"></a>3. 3XX 重定向</h3><h4 id="3-1-301-Moved-Permanently"><a href="#3-1-301-Moved-Permanently" class="headerlink" title="3.1 301 Moved Permanently"></a>3.1 301 Moved Permanently</h4><ul>
<li>永久性重定向。该状态码表示请求的资源已被分配了新的 URI,以后应使用资源现在所指的 URI。也就是说,如果已经把资源对应的 URI保存为书签了,这时应该按 Location 首部字段提示的 URI 重新保存。</li>
<li>像下方给出的请求 URI,当指定资源路径的最后忘记添加斜杠“/”,就会产生 301 状态码。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;example.com&#x2F;sample</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-2-302-Found"><a href="#3-2-302-Found" class="headerlink" title="3.2 302 Found"></a>3.2 302 Found</h4><ul>
<li>临时性重定向。该状态码表示请求的资源已被分配了新的 URI,希望用户(本次)能使用新的 URI 访问。</li>
<li>和 301 Moved Permanently 状态码相似,但 302 状态码代表的资源不是被永久移动,只是临时性质的。换句话说,已移动的资源对应的URI 将来还有可能发生改变。比如,用户把 URI 保存成书签,但不会像 301 状态码出现时那样去更新书签,而是仍旧保留返回 302 状态码的页面对应的 URI。</li>
</ul>
<h4 id="3-3-303-See-Other"><a href="#3-3-303-See-Other" class="headerlink" title="3.3 303 See Other"></a>3.3 303 See Other</h4><ul>
<li>该状态码表示由于请求对应的资源存在着另一个 URI,应使用 GET方法定向获取请求的资源。</li>
<li>303 状态码和 302 Found 状态码有着相同的功能,但 303 状态码明确表示客户端应当采用 GET 方法获取资源,这点与 302 状态码有区别。</li>
<li>比如,当使用 POST 方法访问 CGI 程序,其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时,返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能,但这里使用 303状态码是最理想的。</li>
</ul>
<h4 id="3-4-304-Not-Modified"><a href="#3-4-304-Not-Modified" class="headerlink" title="3.4 304 Not Modified"></a>3.4 304 Not Modified</h4><ul>
<li>该状态码表示客户端发送附带条件的请求 2 时,服务器端允许请求访问资源,但未满足条件的情况。304 状态码返回时,不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中,但是和重定向没有关系。</li>
<li>附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match,If-Modified-Since,If-None-Match,If-Range，If-Unmodified-Since 中任一首部。</li>
<li>服务器说：资源已经找到，但是不符合条件请求</li>
</ul>
<h4 id="3-5-307-Temporary-Redirect"><a href="#3-5-307-Temporary-Redirect" class="headerlink" title="3.5 307 Temporary Redirect"></a>3.5 307 Temporary Redirect</h4><ul>
<li>临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET,但实际使用时大家并不遵守。</li>
<li>307 会遵照浏览器标准,不会从 POST 变成 GET。但是,对于处理响应时的行为,每种浏览器有可能出现不同的情况。</li>
</ul>
<h3 id="4-4XX-客户端错误"><a href="#4-4XX-客户端错误" class="headerlink" title="4. 4XX 客户端错误"></a>4. 4XX 客户端错误</h3><h4 id="4-1-400-Bad-Request"><a href="#4-1-400-Bad-Request" class="headerlink" title="4.1 400 Bad Request"></a>4.1 400 Bad Request</h4><ul>
<li>该状态码表示请求报文中存在语法错误。当错误发生时,需修改请求的内容后再次发送请求。另外,浏览器会像 200 OK 一样对待该状态码。</li>
<li>服务器无法理解请求</li>
</ul>
<h4 id="4-2-401-Unauthorized"><a href="#4-2-401-Unauthorized" class="headerlink" title="4.2 401 Unauthorized"></a>4.2 401 Unauthorized</h4><ul>
<li>该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、 DIGEST 认证)的认证信息。另外若之前已进行过 1 次请求,则表示用户认证失败。</li>
<li>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应,会弹出认证用的对话窗口。</li>
</ul>
<h4 id="4-3-403-Forbidden"><a href="#4-3-403-Forbidden" class="headerlink" title="4.3 403 Forbidden"></a>4.3 403 Forbidden</h4><ul>
<li>该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由,但如果想作说明的话,可以在实体的主体部分对原因进行描述,这样就能让用户看到了。</li>
<li>未获得文件系统的访问授权,访问权限出现某些问题(从未授权的发送源 IP 地址试图访问)等列举的情况都可能是发生 403 的原因。</li>
<li>即服务器不允许访问那个资源</li>
</ul>
<h4 id="4-4-404-Not-Found"><a href="#4-4-404-Not-Found" class="headerlink" title="4.4 404 Not Found"></a>4.4 404 Not Found</h4><ul>
<li>该状态码表明服务器上无法找到请求的资源。除此之外,也可以在服务器端拒绝请求且不想说明理由时使用。</li>
</ul>
<h3 id="5-5XX-服务器错误"><a href="#5-5XX-服务器错误" class="headerlink" title="5. 5XX 服务器错误"></a>5. 5XX 服务器错误</h3><h4 id="5-1-500-Internal-Server-Error"><a href="#5-1-500-Internal-Server-Error" class="headerlink" title="5.1 500 Internal Server Error"></a>5.1 500 Internal Server Error</h4><ul>
<li>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。</li>
<li>服务器内部资源出故障</li>
</ul>
<h4 id="5-2-503-Service-Unavailable"><a href="#5-2-503-Service-Unavailable" class="headerlink" title="5.2 503 Service Unavailable"></a>5.2 503 Service Unavailable</h4><ul>
<li>服务器正忙</li>
<li>该状态码表明服务器暂时处于超负载或正在进行停机维护,现在无法处理请求。如果事先得知解除以上状况需要的时间,最好写入RetryAfter 首部字段再返回给客户端。</li>
</ul>
<h3 id="6-状态码和状况的不一致"><a href="#6-状态码和状况的不一致" class="headerlink" title="6. 状态码和状况的不一致"></a>6. 状态码和状况的不一致</h3><ul>
<li>不少返回的状态码响应都是错误的,但是用户可能察觉不到这点。</li>
<li>比如 Web 应用程序内部发生错误,状态码依然返回 200 OK,这种情况也经常遇到。</li>
</ul>
<h1 id="第5章：与-HTTP-协作的-Web-服务器"><a href="#第5章：与-HTTP-协作的-Web-服务器" class="headerlink" title="第5章：与 HTTP 协作的 Web 服务器"></a>第5章：与 HTTP 协作的 Web 服务器</h1><h3 id="1-用单台虚拟主机实现多个域名"><a href="#1-用单台虚拟主机实现多个域名" class="headerlink" title="1. 用单台虚拟主机实现多个域名"></a>1. 用单台虚拟主机实现多个域名</h3><ul>
<li>HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。比如,提供 Web 托管服务(Web Hosting Service)的供应商,可以用一台服务器为多位客户服务,也可以以每位客户持有的域名运行各自不同的网站。这是因为利用了虚拟主机(Virtual Host,又称虚拟服务器)的功能。</li>
<li>若一台服务器上有多个域名，这些域名解析后的IP地址会相同</li>
<li>在相同的 IP 地址下,由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站,因此在发送 HTTP 请求时,必须在 Host 首部内完整指定主机名或域名的 URI。</li>
</ul>
<h3 id="2-通信数据转发程序-代理、网关、隧道"><a href="#2-通信数据转发程序-代理、网关、隧道" class="headerlink" title="2. 通信数据转发程序 :代理、网关、隧道"></a>2. 通信数据转发程序 :代理、网关、隧道</h3><ul>
<li><ol>
<li>代理</li>
</ol>
<ul>
<li>代理是一种有转发功能的应用程序,它扮演了位于服务器和客户端“中间人”的角色,接收由客户端发送的请求并转发给服务器,同时也接收服务器返回的响应并转发给客户端。</li>
<li>使用代理服务器的理由有:<ul>
<li>利用缓存技术(稍后讲解)减少网络带宽的流量</li>
<li>组织内部针对特定网站的访问控制</li>
<li>以获取访问日志为主要目的,等等。</li>
</ul>
</li>
<li>代理有多种使用方法,按两种基准分类。一种是是否使用缓存,另一种是是否会修改报文。<ul>
<li>缓存代理<br>代理转发响应时,缓存代理(Caching Proxy)会预先将资源的副本(缓存)保存在代理服务器上。当代理再次接收到对相同资源的请求时,就可以不从源服务器那里获取资源,而是将之前缓存的资源作为响应返回。</li>
<li>透明代理<br>转发请求或响应时,不对报文做任何加工的代理类型被称为透明代理(Transparent Proxy)。反之,对报文内容进行加工的代理被称为非透明代理。</li>
</ul>
</li>
</ul>
</li>
<li><ol start="2">
<li>网关</li>
</ol>
<ul>
<li>网关是转发其他服务器通信数据的服务器,接收从客户端发送来的请求时,它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉,自己的通信目标是一个网关。</li>
<li>利用网关可以由 HTTP 请求转化为其他协议通信  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端&lt;---------------&gt;网关&lt;---------&gt;非HTTP服务器</span><br><span class="line">    Http请求和响应        其他协议</span><br></pre></td></tr></table></figure></li>
<li>利用网关能提高通信的安全性,因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如,网关可以连接数据库,使用SQL 语句查询数据。另外,在 Web 购物网站上进行信用卡结算时,网关可以和信用卡结算系统联动。</li>
</ul>
</li>
<li><ol start="3">
<li>隧道</li>
</ol>
<ul>
<li>隧道是在相隔甚远的客户端和服务器两者之间进行中转,并保持双方通信连接的应用程序。</li>
<li>隧道可按要求建立起一条与其他服务器的通信线路,届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</li>
<li>隧道本身是透明的,客户端不用在意隧道的存在</li>
</ul>
</li>
</ul>
<h3 id="3-保存资源的缓存"><a href="#3-保存资源的缓存" class="headerlink" title="3. 保存资源的缓存"></a>3. 保存资源的缓存</h3><ul>
<li>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问,因此也就节省了通信流量和通信时间。</li>
<li>缓存有有效期限</li>
<li>客户端(浏览器)也可以缓存，也有有效期限</li>
</ul>
<h1 id="第6章：HTTP首部"><a href="#第6章：HTTP首部" class="headerlink" title="第6章：HTTP首部"></a>第6章：HTTP首部</h1><h3 id="1-HTTP-首部字段一览"><a href="#1-HTTP-首部字段一览" class="headerlink" title="1. HTTP 首部字段一览"></a>1. HTTP 首部字段一览</h3><ul>
<li>通用首部字段</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、连接的管理</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody></table>
<ul>
<li>请求首部字段</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言(自然语言)</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记(ETag)</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记(与 If-Match 相反)</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间(与If-Modified-Since相反)</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP 客户端程序的信息</td>
</tr>
</tbody></table>
<ul>
<li>响应首部字段</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody></table>
<ul>
<li>实体首部字段</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>资源可支持的HTTP方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小(单位:字节)</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody></table>
<h3 id="2-非-HTTP-1-1-首部字段"><a href="#2-非-HTTP-1-1-首部字段" class="headerlink" title="2. 非 HTTP/1.1 首部字段"></a>2. 非 HTTP/1.1 首部字段</h3><ul>
<li>在 HTTP 协议通信交互中使用到的首部字段,不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、Set-Cookie 和Content-Disposition 等在其他 RFC 中定义的首部字段,它们的使用频率也很高。</li>
<li>这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。</li>
</ul>
<h3 id="3-通用首部字段"><a href="#3-通用首部字段" class="headerlink" title="3. 通用首部字段"></a>3. 通用首部字段</h3><h3 id="4-请求首部字段"><a href="#4-请求首部字段" class="headerlink" title="4. 请求首部字段"></a>4. 请求首部字段</h3><h3 id="5-响应首部字段"><a href="#5-响应首部字段" class="headerlink" title="5. 响应首部字段"></a>5. 响应首部字段</h3><h3 id="6-实体首部字段"><a href="#6-实体首部字段" class="headerlink" title="6. 实体首部字段"></a>6. 实体首部字段</h3><ul>
<li>这四个都是讲字段的具体内容，先不做笔记了，有点多和麻烦，需要的时候再搜吧。</li>
</ul>
<h3 id="7-为Cookie服务的首部字段"><a href="#7-为Cookie服务的首部字段" class="headerlink" title="7. 为Cookie服务的首部字段"></a>7. 为Cookie服务的首部字段</h3><ul>
<li>总览</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>首部类型</th>
</tr>
</thead>
<tbody><tr>
<td>Set-Cookie</td>
<td>开始状态管理所使用的Cookie信息</td>
<td>响应首部字段</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器接收到的Cookie信息</td>
<td>请求首部字段</td>
</tr>
</tbody></table>
<ul>
<li><p>set-cookie</p>
<ul>
<li>当服务器准备开始管理客户端的状态时,会事先告知各种信息。下面的表格列举了 Set-Cookie 的字段值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: status&#x3D;enable; expires&#x3D;Tue, 05 Jul 2011 07:26:31 GMT; path</span><br></pre></td></tr></table></figure>
属性 |说明</li>
</ul>
</li>
<li><p>-|–<br>NAME=VALUE |赋予 Cookie 的名称和其值(必需项)<br>expires=DATE |Cookie 的有效期(若不明确指定则默认为浏览器关闭前为止)<br>path=PATH |将服务器上的文件目录作为Cookie的适用对象(若不指定则默认为文档所在的文件目录)<br>domain=域名 |作为 Cookie 适用对象的域名 (若不指定则默认为创建 Cookie的服务器的域名)<br>Secure |仅在 HTTPS 安全通信时才会发送 Cookie<br>HttpOnly |加以限制,使 Cookie 不能被 JavaScript 脚本访问</p>
</li>
<li><p>cookie</p>
<ul>
<li>首部字段 Cookie 会告知服务器,当客户端想获得 HTTP 状态管理支持时,就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时,同样可以以多个 Cookie 形式发送。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: status&#x3D;enable</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="8-其他首部字段"><a href="#8-其他首部字段" class="headerlink" title="8. 其他首部字段"></a>8. 其他首部字段</h3><ul>
<li>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上,会出现各种非标准的首部字段。</li>
<li>X-Frame-Options<ul>
<li>首部字段 X-Frame-Options 属于 HTTP 响应首部,用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持(clickjacking)攻击。</li>
<li>首部字段 X-Frame-Options 有以下两个可指定的字段值。<ul>
<li>DENY :拒绝</li>
<li>SAMEORIGIN :仅同源域名下的页面(Top-level-browsing-context)匹配时许可。(比如,当指定 <a target="_blank" rel="noopener" href="http://hackr.jp/sample.html%E9%A1%B5%E9%9D%A2%E4%B8%BA">http://hackr.jp/sample.html页面为</a> SAMEORIGIN 时,那么 hackr.jp 上所有页面的 frame 都被允许可加载该页面,而 example.com 等其他域名的页面就不行了)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Frame-Options: DENY</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>X-XSS-Protection<ul>
<li>首部字段 X-XSS-Protection 属于 HTTP 响应首部,它是针对跨站脚本攻击(XSS)的一种对策,用于控制浏览器 XSS 防护机制的开关。</li>
<li>首部字段 X-XSS-Protection 可指定的字段值如下。<ul>
<li>0 :将 XSS 过滤设置成无效状态</li>
<li>1 :将 XSS 过滤设置成有效状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-XSS-Protection: 1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>DNT<ul>
<li>首部字段 DNT 属于 HTTP 请求首部,其中 DNT 是 Do Not Track 的简称,意为拒绝个人信息被收集,是表示拒绝被精准广告追踪的一种方法。</li>
<li>首部字段 DNT 可指定的字段值如下。<ul>
<li>0 :同意被追踪</li>
<li>1 :拒绝被追踪</li>
</ul>
</li>
<li>由于首部字段 DNT 的功能具备有效性,所以 Web 服务器需要对 DNT做对应的支持。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DNT: 1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>P3P<ul>
<li>首部字段 P3P 属于 HTTP 相应首部,通过利用 P3P(The Platform for Privacy Preferences,在线隐私偏好平台)技术,可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式,以达到保护用户隐私的目的。</li>
<li>要进行 P3P 的设定,需按以下操作步骤进行。<ul>
<li>步骤 1:创建 P3P 隐私</li>
<li>步骤 2:创建 P3P 隐私对照文件后,保存命名在 /w3c/p3p.xml</li>
<li>步骤 3:从 P3P 隐私中新建 Compact policies 后,输出到 HTTP 响应中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第7章-确保-Web-安全的-HTTPS"><a href="#第7章-确保-Web-安全的-HTTPS" class="headerlink" title="第7章 确保 Web 安全的 HTTPS"></a>第7章 确保 Web 安全的 HTTPS</h1><h3 id="1-HTTP-主要有这些不足-例举如下。"><a href="#1-HTTP-主要有这些不足-例举如下。" class="headerlink" title="1. HTTP 主要有这些不足,例举如下。"></a>1. HTTP 主要有这些不足,例举如下。</h3><h5 id="1-通信使用明文-不加密-内容可能会被窃听"><a href="#1-通信使用明文-不加密-内容可能会被窃听" class="headerlink" title="1. 通信使用明文(不加密),内容可能会被窃听"></a>1. 通信使用明文(不加密),内容可能会被窃听</h5><ul>
<li>TCP/IP是可能被窃听的网络<ul>
<li>即使已经过加密处理的通信,也会被窥视到通信内容,这点和未加密的通信是相同的。只是说如果通信经过加密,就有可能让人无法破解报文信息的含义,但加密处理后的报文信息本身还是会被看到的。</li>
</ul>
</li>
<li>加密处理防止被窃听<ul>
<li>通信的加密<ul>
<li>HTTP 协议中没有加密机制,但可以通过和 SSL(Secure Socket Layer,安全套接层)或TLS(Transport Layer Security,安全层传输协议)的组合使用,加密 HTTP 的通信内容。</li>
<li>用 SSL 建立安全通信线路之后,就可以在这条线路上进行 HTTP通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS(HTTP Secure,超文本传输安全协议)或 HTTP over SSL。</li>
</ul>
</li>
<li>内容的加密<ul>
<li>即对报文首部不加密，对报文主体加密</li>
<li>为了做到有效的内容加密,前提是要求客户端和服务器同时具备加密和解密机制。</li>
<li>由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理,所以内容仍有被篡改的风险。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-不验证通信方的身份-因此有可能遭遇伪装"><a href="#2-不验证通信方的身份-因此有可能遭遇伪装" class="headerlink" title="2. 不验证通信方的身份,因此有可能遭遇伪装"></a>2. 不验证通信方的身份,因此有可能遭遇伪装</h5><ul>
<li>任何人都可发起请求<ul>
<li>由于不存在确认通信方的处理步骤,任何人都可以发起请求。另外,服务器只要接收到请求,不管对方是谁都会返回一个响应</li>
<li>仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下</li>
<li>存在的各种隐患<ul>
<li>无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。</li>
<li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。</li>
<li>无法确定正在通信的对方是否具备访问权限。因为某些Web 服务器上保存着重要的信息,只想发给特定用户通信的权限。</li>
<li>无法判定请求是来自何方、出自谁手。</li>
<li>即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击(Denial of Service,拒绝服务攻击)</li>
</ul>
</li>
</ul>
</li>
<li>查明对手的证书<ul>
<li>虽然使用 HTTP 协议无法确定通信方,但如果使用 SSL 则可以。SSL 不仅提供加密处理,而且还使用了一种被称为证书的手段,可用于确定方。</li>
<li>证书由值得信任的第三方机构颁发,用以证明服务器和客户端是实际存在的。另外,伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方(服务器或客户端)持有的证书,即可判断通信方的真实意图。</li>
<li>通过使用证书,以证明通信方就是意料中的服务器。这对使用者个人来讲,也减少了个人信息泄露的危险性。</li>
<li>另外,客户端持有证书即可完成个人身份的确认,也可用于对 Web 网站的认证环节。</li>
</ul>
</li>
</ul>
<h5 id="3-无法证明报文的完整性-所以有可能已遭篡改"><a href="#3-无法证明报文的完整性-所以有可能已遭篡改" class="headerlink" title="3. 无法证明报文的完整性,所以有可能已遭篡改"></a>3. 无法证明报文的完整性,所以有可能已遭篡改</h5><ul>
<li>接收到的内容可能有误<ul>
<li>请求或响应在传输途中,遭攻击者拦截并篡改内容的攻击称为中间人攻击(Man-in-the-Middle attack,MITM)。</li>
</ul>
</li>
<li>如何防止篡改<ul>
<li>虽然有使用 HTTP 协议确定报文完整性的方法,但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法,以及用来确认文件的数字签名方法。这些问题不仅在 HTTP 上出现,其他未加密的协议中也会存在这类问题。</li>
<li>提供文件下载服务的 Web 网站也会提供相应的以 PGP(PrettyGood Privacy,完美隐私)创建的数字签名及 MD5 算法生成的散列值。PGP 是用来证明创建文件的数字签名,MD5 是由单向函数生成的散列值。不论使用哪一种方法,都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件。浏览器无法自动帮用户检查。</li>
<li>可惜的是,用这些方法也依然无法百分百保证确认结果正确。因为 PGP 和 MD5 本身被改写的话,用户是没有办法意识到的。</li>
<li>为了有效防止这些弊端,有必要使用 HTTPS。SSL 提供认证和加密处理及摘要功能。仅靠 HTTP 确保完整性是非常困难的,因此通过和其他协议组合使用来实现这个目标。</li>
</ul>
</li>
</ul>
<h3 id="2-7-2-HTTP-加密-认证-完整性保护-HTTPS"><a href="#2-7-2-HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="2. 7.2 HTTP+ 加密 + 认证 + 完整性保护=HTTPS"></a>2. 7.2 HTTP+ 加密 + 认证 + 完整性保护=HTTPS</h3><h5 id="1-HTTP-加上加密处理和认证以及完整性保护后即是-HTTPS"><a href="#1-HTTP-加上加密处理和认证以及完整性保护后即是-HTTPS" class="headerlink" title="1. HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS"></a>1. HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS</h5><ul>
<li>我们把添加了加密及认证机制的 HTTP 称为 HTTPS(HTTP Secure)。</li>
</ul>
<h5 id="2-HTTPS-是身披-SSL-外壳的-HTTP"><a href="#2-HTTPS-是身披-SSL-外壳的-HTTP" class="headerlink" title="2. HTTPS 是身披 SSL 外壳的 HTTP"></a>2. HTTPS 是身披 SSL 外壳的 HTTP</h5><ul>
<li>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL(Secure Socket Layer)和 TLS(Transport Layer Security)协议代替而已。</li>
<li>通常,HTTP 直接和 TCP 通信。当使用 SSL 时,则演变成先和 SSL 通信,再由 SSL 和 TCP 通信了。简言之,所谓 HTTPS,其实就是身披SSL 协议这层外壳的 HTTP。</li>
<li>SSL 是独立于 HTTP 的协议,所以不光是 HTTP 协议,其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</li>
</ul>
<h5 id="3-相互交换密钥的公开密钥加密技术"><a href="#3-相互交换密钥的公开密钥加密技术" class="headerlink" title="3. 相互交换密钥的公开密钥加密技术"></a>3. 相互交换密钥的公开密钥加密技术</h5><ul>
<li>SSL 采用一种叫做公开密钥加密(Public-key cryptography)的加密处理方式。近代的加密方法中加密算法是公开的,而密钥却是保密的。通过这种方式得以保持加密方法的安全性。加密和解密都会用到密钥。没有密钥就无法对密码解密,反过来说,任何人只要持有密钥就能解密了。如果密钥被攻击者获得,那加密也就失去了意义。</li>
<li>共享密钥加密的困境（对称加密）<ul>
<li>加密和解密同用一个密钥的方式称为共享密钥加密(Common key crypto system),也被叫做对称密钥加密。</li>
<li>密钥发送问题，怎么保证秘钥不会被劫持监听</li>
</ul>
</li>
<li>使用两把密钥的公开密钥加密（非对称加密）<ul>
<li>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥(private key),另一把叫做公开密钥(public key)。顾名思义,私有密钥不能让其他任何人知道,而公开密钥则可以随意发布,任何人都可以获得。</li>
<li>使用公开密钥加密方式,发送密文的一方使用对方的公开密钥进行加密处理,对方收到被加密的信息后,再使用自己的私有密钥进行解密。利用这种方式,不需要发送用来解密的私有密钥,也不必担心密钥被攻击者窃听而盗走。</li>
</ul>
</li>
<li>HTTPS 采用混合加密机制<ul>
<li>若密钥能够实现安全交换,那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比,其处理速度要慢。</li>
<li>充分利用两者各自的优势,将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式,之后的建立通信交换报文阶段则使用共享密钥加密方式。</li>
</ul>
</li>
</ul>
<h5 id="4-证明公开密钥正确性的证书"><a href="#4-证明公开密钥正确性的证书" class="headerlink" title="4. 证明公开密钥正确性的证书"></a>4. 证明公开密钥正确性的证书</h5><ul>
<li>公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。</li>
<li>为了解决上述问题,可以使用由数字证书认证机构(CA,Certificate Authority)和其相关机关颁发的公开密钥证书。</li>
<li>可证明组织真实性的 EV SSL 证书<ul>
<li>证书的一个作用是用来证明作为通信一方的服务器是否规范,另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是 EV SSL 证书(Extended Validation SSL Certificate)。</li>
<li>持有 EV SSL 证书的 Web 网站的浏览器地址栏处的背景色是绿色的,从视觉上就能一眼辨别出。而且在地址栏的左侧显示了 SSL证书中记录的组织名称以及颁发证书的认证机构的名称。</li>
<li>上述机制的原意图是为了防止用户被钓鱼攻击(Phishing),但就效果上来讲,还得打一个问号。很多用户可能不了解 EV SSL证书相关的知识,因此也不太会留意它。</li>
</ul>
</li>
<li>用以确认客户端的客户端证书<ul>
<li>HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认证,证明服务器正在通信的对方始终是预料之内的客户端,其作用跟服务器证书如出一辙。</li>
<li>现状是,安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务。比如那些可支撑客户端证书支出费用的业务。例如,银行的网上银行就采用了客户端证书。在登录网银时不仅要求用户确认输入 ID 和密码,还会要求用户的客户端证书,以确认用户是否从特定的终端访问网银。</li>
</ul>
</li>
<li>认证机构信誉第一</li>
<li>由自认证机构颁发的证书称为自签名证书<ul>
<li>如果使用 OpenSSL 这套开源程序,每个人都可以构建一套属于自己的认证机构,从而自己给自己颁发服务器证书。但该服务器证书在互联网上不可作为证书使用,似乎没什么帮助。</li>
<li>浏览器访问该服务器时,会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。</li>
<li>多数浏览器内预先已植入备受信赖的认证机构的证书,但也有一小部分浏览器会植入中级认证机构的证书。对于中级认证机构颁发的服务器证书,某些浏览器会以正规的证书来对待,可有的浏览器会当作自签名证书。</li>
</ul>
</li>
</ul>
<h5 id="5-HTTPS-通信过程"><a href="#5-HTTPS-通信过程" class="headerlink" title="5. HTTPS 通信过程"></a>5. HTTPS 通信过程</h5><ul>
<li><ol>
<li>Client—&gt;Server Handshake:ClientHello<br> 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件(Cipher Suite)列表(所使用的加密算法及密钥长度等)。</li>
</ol>
</li>
<li><ol start="2">
<li>Server—&gt;Client Handshake:ServerHello<br> 服务器可进行 SSL 通信时,会以 Server Hello 报文作为应答。和客户端一样,在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li>
</ol>
</li>
<li><ol start="3">
<li>Server—&gt;Client Handshake:Certificate<br> 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</li>
</ol>
</li>
<li><ol start="4">
<li>Server—&gt;Client Handshake:ServerHelloDone<br> 最后服务器发送 Server Hello Done 报文通知客户端,最初阶段的 SSL 握手协商部分结束。</li>
</ol>
</li>
<li><ol start="5">
<li>Client—&gt;Server Handshake:ClientKeyExchange<br> SSL 第一次握手结束之后,客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</li>
</ol>
</li>
<li><ol start="6">
<li>Client—&gt;Server ChangeCipherSpec<br> 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器,在此报文之后的通信会采用 Pre-master secret 密钥加密。</li>
</ol>
</li>
<li><ol start="7">
<li>Client—&gt;Server Handshake:Finished<br> 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功,要以服务器是否能够正确解密该报文作为判定标准。</li>
</ol>
</li>
<li><ol start="8">
<li>Server—&gt;Client ChangeCipherSpec<br> 服务器同样发送 Change Cipher Spec 报文。</li>
</ol>
</li>
<li><ol start="9">
<li>Server—&gt;Client Handshake:Finished<br> 服务器同样发送 Finished 报文。</li>
</ol>
</li>
<li><ol start="10">
<li>Client—&gt;Server Application Data(HTTP)<br>服务器和客户端的 Finished 报文交换完毕之后,SSL 连接就算建立完成。当然,通信会受到 SSL 的保护。从此处开始进行应用层协议的通信,即发送 HTTP 请求。</li>
</ol>
</li>
<li><ol start="11">
<li>Server—&gt;Client Application Data(HTTP)<br>应用层协议通信,即发送 HTTP 响应。</li>
</ol>
</li>
<li><ol start="12">
<li>Client—&gt;Server Alert:warning,close_notify<br>最后由客户端断开连接。断开连接时,发送 close_notify 报文。上图做了一些省略,这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。</li>
</ol>
</li>
</ul>
<h5 id="6-HTTPS-的安全通信机制"><a href="#6-HTTPS-的安全通信机制" class="headerlink" title="6. HTTPS 的安全通信机制"></a>6. HTTPS 的安全通信机制</h5><ul>
<li>SSL 和 TLS<ul>
<li>SSL 技术最初是由浏览器开发商网景通信公司率先倡导的,开发过 SSL3.0 之前的版本。目前主导权已转移到 IETF(InternetEngineering Task Force,Internet 工程任务组)的手中。</li>
<li>IETF 以 SSL3.0 为基准,后又制定了 TLS1.0、TLS1.1 和TLS1.2。TSL 是以 SSL 为原型开发的协议,有时会统一称该协议为 SSL。当前主流的版本是 SSL3.0 和 TLS1.0。</li>
<li>由于 SSL1.0 协议在设计之初被发现出了问题,就没有实际投入使用。SSL2.0 也被发现存在问题,所以很多浏览器直接废除了该协议版本。</li>
</ul>
</li>
<li>SSL 速度慢吗<ul>
<li>HTTPS 也存在一些问题,那就是当使用 SSL 时,它的处理速度会变慢。</li>
<li>HTTPS 比 HTTP 要慢 2 到 100 倍</li>
<li>SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源,导致处理速度变慢。<ul>
<li>通信慢：除去和TCP 连接、发送 HTTP 请求 • 响应以外,还必须进行 SSL 通信,因此整体上处理通信量不可避免会增加。</li>
<li>消耗大：SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲,比起 HTTP 会更多地消耗服务器和客户端的硬件资源,导致负载增强。</li>
</ul>
</li>
</ul>
</li>
<li>为什么不全使用HTTPS<ul>
<li><ol>
<li>比HTTP慢，消耗资源多</li>
</ol>
</li>
<li><ol start="2">
<li>证书要钱，减少开销</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="第8章-确认访问用户身份的认证"><a href="#第8章-确认访问用户身份的认证" class="headerlink" title="第8章 确认访问用户身份的认证"></a>第8章 确认访问用户身份的认证</h1><h3 id="1-何为认证"><a href="#1-何为认证" class="headerlink" title="1. 何为认证"></a>1. 何为认证</h3><ul>
<li>计算机本身无法判断坐在显示器前的使用者的身份。进一步说,也无法确认网络的那头究竟有谁。可见,为了弄清究竟是谁在访问服务器,就得让对方的客户端自报家门。</li>
<li>核对的信息有如下几个<ul>
<li>密码:只有本人才会知道的字符串信息。</li>
<li>动态令牌:仅限本人持有的设备内显示的一次性密码。</li>
<li>数字证书:仅限本人(终端)持有的信息。</li>
<li>生物认证:指纹和虹膜等本人的生理信息。</li>
<li>IC 卡等:仅限本人持有的信息。</li>
</ul>
</li>
<li>HTTP/1.1 使用的认证方式<ul>
<li>BASIC 认证(基本认证)</li>
<li>DIGEST 认证(摘要认证)</li>
<li>SSL 客户端认证</li>
<li>FormBase 认证(基于表单认证)</li>
</ul>
</li>
</ul>
<h3 id="2-BASIC-认证"><a href="#2-BASIC-认证" class="headerlink" title="2. BASIC 认证"></a>2. BASIC 认证</h3><ul>
<li>BASIC 认证(基本认证)是从 HTTP/1.0 就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是 Web 服务器与通信客户端之间进行的认证方式。</li>
<li>BASIC 认证使用上不够便捷灵活,且达不到多数 Web 网站期望的安全性等级,因此它并不常用</li>
<li>步骤<ul>
<li><ol>
<li>Client—&gt;Server   GET<br> 请求的资源需要 BASIC 认证</li>
</ol>
</li>
<li><ol start="2">
<li>Server—&gt;Client   401<br> 服务器会随状态码 401 Authorization Required,返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式(BASIC) 及 Request-URI 安全域字符串(realm)。</li>
</ol>
</li>
<li><ol start="3">
<li>Client—&gt;Server<br> 接收到状态码 401 的客户端为了通过 BASIC 认证,需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成,两者中间以冒号(:)连接后,再经过 Base64 编码处理。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;例子</span><br><span class="line">&#x2F;&#x2F;假设用户 ID 为 guest,密码是 guest,连接起来就会形成guest:guest 这样的字符串。</span><br><span class="line">&#x2F;&#x2F;然后经过 Base64 编码,最后的结果即是Z3Vlc3Q6Z3Vlc3Q&#x3D;。</span><br><span class="line">&#x2F;&#x2F;把这串字符串写入首部字段 Authorization 后,发送请求。</span><br><span class="line">GET &#x2F;private&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Authorization: Basic Z3Vlc3Q6Z3Vlc3Q&#x3D;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="4">
<li>Server—&gt;Client<br> 服务器认证成功返回200，失败返回401</li>
</ol>
</li>
</ul>
</li>
<li>BASIC 认证虽然采用 Base64 编码方式,但这不是加密处理。不需要任何附加信息即可对其解码。换言之,由于明文解码后就是用户 ID和密码,在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中,如果被人窃听,被盗的可能性极高。</li>
<li>另外,除此之外想再进行一次 BASIC 认证时,一般的浏览器却无法实现认证注销操作,这也是问题之一。</li>
</ul>
<h3 id="3-DIGEST-认证"><a href="#3-DIGEST-认证" class="headerlink" title="3. DIGEST 认证"></a>3. DIGEST 认证</h3><ul>
<li><p>为弥补 BASIC 认证存在的弱点,从 HTTP/1.1 起就有了 DIGEST 认证。 DIGEST 认证同样使用质询 / 响应的方式(challenge/response),但不会像 BASIC 认证那样直接发送明文密码。</p>
</li>
<li><p>质询响应方式<br>  是指,一开始一方会先发送认证要求给另一方,接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。</p>
</li>
<li><p>步骤</p>
<ul>
<li><ol>
<li>Client—&gt;Server   GET<br> 请求的资源需要 BASIC 认证</li>
</ol>
</li>
<li><ol start="2">
<li>Server—&gt;Client   401<br> 服务器会随状态码 401 Authorization Required,返回带 WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码(随机数,nonce)</li>
</ol>
</li>
<li><ol start="3">
<li>Client—&gt;Server<br> 接收到 401 状态码的客户端,返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。</li>
</ol>
</li>
<li><ol start="4">
<li>Server—&gt;Client<br> 接收到包含首部字段 Authorization 请求的服务器,会确认认证信息的正确性。认证通过后则返回包含 Request-URI 资源的响应。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="4-SSL-客户端认证"><a href="#4-SSL-客户端认证" class="headerlink" title="4. SSL　客户端认证"></a>4. SSL　客户端认证</h3><ul>
<li><p>从使用用户 ID 和密码的认证方式方面来讲,只要二者的内容正确,即可认证是本人的行为。但如果用户 ID 和密码被盗,就很有可能被第三者冒充。利用 SSL 客户端认证则可以避免该情况的发生。</p>
</li>
<li><p>SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书(在 HTTPS 一章已讲解)认证,服务器可确认访问是否来自已登录的客户端。</p>
</li>
<li><p>步骤</p>
<ul>
<li>接收到需要认证资源的请求,服务器会发送 Certificate Request 报文,要求客户端提供客户端证书。</li>
<li>用户选择将发送的客户端证书后,客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。</li>
<li>服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥,然后开始 HTTPS 加密通信。</li>
</ul>
</li>
<li><p>SSL 客户端认证必要的费用</p>
<ul>
<li>使用 SSL 客户端认证需要用到客户端证书。而客户端证书需要支付一定费用才能使用。</li>
</ul>
</li>
</ul>
<h3 id="5-基于表单认证"><a href="#5-基于表单认证" class="headerlink" title="5. 基于表单认证"></a>5. 基于表单认证</h3><ul>
<li>基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息(Credential),按登录信息的验证结果认证。</li>
</ul>
<h5 id="1-认证多半为基于表单认证"><a href="#1-认证多半为基于表单认证" class="headerlink" title="1. 认证多半为基于表单认证"></a>1. 认证多半为基于表单认证</h5><ul>
<li>由于使用上的便利性及安全性问题,HTTP 协议标准提供的 BASIC 认证和 DIGEST 认证几乎不怎么使用。另外,SSL 客户端认证虽然具有高度的安全等级,但因为导入及维持费用等问题,还尚未普及。</li>
<li>不具备共同标准规范的表单认证,在每个 Web 网站上都会有各不相同的实现方式。</li>
</ul>
<h5 id="2-Session-管理及-Cookie-应用"><a href="#2-Session-管理及-Cookie-应用" class="headerlink" title="2. Session 管理及 Cookie 应用"></a>2. Session 管理及 Cookie 应用</h5><ul>
<li>基于表单认证本身是通过服务器端的 Web 应用,将客户端发送过来的用户 ID 和密码与之前登录过的信息做匹配来进行认证的。</li>
<li>但鉴于 HTTP 是无状态协议,之前已认证成功的用户状态无法通过协议层面保存下来。即,无法实现状态管理,因此即使当该用户下一次继续访问,也无法区分他与其他的用户。于是我们会使用 Cookie 来管理 Session,以弥补 HTTP 协议中不存在的状态管理功能。</li>
<li>步骤<ul>
<li><ol>
<li>客户端把用户 ID 和密码等登录信息放入报文的实体部分,通常是以 POST 方法把请求发送给服务器。而这时,会使用 HTTPS通信来进行 HTML 表单画面的显示和用户输入数据的发送。</li>
</ol>
</li>
<li><ol start="2">
<li>服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证,然后把用户的认证状态与Session ID 绑定后记录在服务器端。<br>向客户端返回响应时,会在首部字段 Set-Cookie 内写入 SessionID(如 PHPSESSID=028a8c…)。<br>另外,为减轻跨站脚本攻击(XSS)造成的损失,建议事先在 Cookie内加上 httponly 属性。</li>
</ol>
</li>
<li><ol start="3">
<li>客户端接收到从服务器端发来的 Session ID 后,会将其作为Cookie 保存在本地。下次向服务器发送请求时,浏览器会自动发送Cookie,所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。</li>
</ol>
</li>
</ul>
</li>
<li>通常,一种安全的保存方法是,先利用给密码加盐(salt) 1 的方式增加额外信息,再使用散列(hash)函数计算出散列值后保存。但是我们也经常看到直接保存明文密码的做法,而这样的做法具有导致密码泄露的风险。</li>
</ul>
<h1 id="第9章：基于-HTTP-的功能追加协议"><a href="#第9章：基于-HTTP-的功能追加协议" class="headerlink" title="第9章：基于 HTTP 的功能追加协议"></a>第9章：基于 HTTP 的功能追加协议</h1><h3 id="1-消除-HTTP-瓶颈的-SPDY"><a href="#1-消除-HTTP-瓶颈的-SPDY" class="headerlink" title="1. 消除 HTTP 瓶颈的 SPDY"></a>1. 消除 HTTP 瓶颈的 SPDY</h3><ul>
<li><p>互联网工程任务组（IETF）对谷歌提出的SPDY协议进行了标准化，于2015年5推出了类似于SPDY协议的 HTTP 2.0 协议标准（简称HTTP/2）。谷歌因此宣布放弃对SPDY协议的支持，转而支持HTTP/2。谷歌称，计划于 2016 年初在 Chrome 中移除 SPDY，并将为Chrome 40 添加 HTTP/2 协议支持。</p>
</li>
<li><p>总之就是弃用了</p>
</li>
<li><p>HTTP的瓶颈</p>
<ul>
<li>一条连接上只可发送一个请求。</li>
<li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。</li>
<li>请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。发送冗长的首部。每次互相发送相同的首部造成的浪费较多。</li>
<li>可任意选择数据压缩格式。非强制压缩发送。</li>
</ul>
</li>
<li><p>Ajax 的解决方法</p>
<ul>
<li>Ajax(Asynchronous JavaScript and XML, 异 步 JavaScript 与 XML 技术)是一种有效利用 JavaScript 和 DOM(Document Object Model,文档对象模型)的操作,以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比,由于它只更新一部分页面,响应中传输的数据量会因此而减少,这一优点显而易见。</li>
<li>而利用 Ajax 实时地从服务器获取内容,有可能会导致大量请求产生。另外,Ajax 仍未解决 HTTP 协议本身存在的问题。</li>
</ul>
</li>
<li><p>Comet 的解决方法</p>
<ul>
<li>一旦服务器端有内容更新了,Comet 不会让请求等待,而是直接给客户端返回响应。这是一种通过延迟应答,模拟实现服务器端向客户端推送(Server Push)的功能。</li>
<li>通常,服务器端接收到请求,在处理完毕后就会立即返回响应,但为了实现推送功能,Comet 会先将响应置于挂起状态,当服务器端有内容更新时,再返回该响应。因此,服务器端一旦有更新,就可以立即反馈给客户端。</li>
<li>内容上虽然可以做到实时更新,但为了保留响应,一次连接的持续时间也变长了。期间,为了维持连接会消耗更多的资源。另外,Comet也仍未解决 HTTP 协议本身存在的问题。</li>
</ul>
</li>
</ul>
<h3 id="2-使用浏览器进行全双工通信的-WebSocket"><a href="#2-使用浏览器进行全双工通信的-WebSocket" class="headerlink" title="2. 使用浏览器进行全双工通信的 WebSocket"></a>2. 使用浏览器进行全双工通信的 WebSocket</h3><ul>
<li><p>利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题在于通信若使用 HTTP 协议,就无法彻底解决瓶颈问题。WebSocket网络技术正是为解决这些问题而实现的一套新协议及 API。</p>
</li>
<li><p>WebSocket 协议</p>
<ul>
<li>一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接,之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML 或图片等任意格式的数据。</li>
<li>由于是建立在 HTTP 基础上的协议,因此连接的发起方仍是客户端,而一旦确立 WebSocket 通信连接,不论服务器还是客户端,任意一方都可直接向对方发送报文。</li>
</ul>
</li>
<li><p>WebSocket 协议的主要特点。</p>
<ul>
<li>推送功能<br>支持由服务器向客户端推送数据的推送功能。这样,服务器可直接发送数据,而不必等待客户端的请求。</li>
<li>减少通信量<br>只要建立起 WebSocket 连接,就希望一直保持连接状态。和 HTTP 相比,不但每次连接时的总开销减少,而且由于 WebSocket 的首部信息很小,通信量也相应减少了。</li>
<li>握手<br>为了实现 WebSocket 通信,在 HTTP 连接建立之后,需要完成一次“握手”(Handshaking)的步骤。<ul>
<li>握手·请求<br>为了实现 WebSocket 通信,需要用到 HTTP 的 Upgrade 首部字段,告知服务器通信协议发生改变,以达到握手的目的。<br>Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值。<br>Sec-WebSocket-Protocol 字段内记录使用的子协议。子协议按 WebSocket 协议标准在连接分开使用时,定义那些连接的名称。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ&#x3D;&#x3D;</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></li>
<li>握手·响应<br>对于之前的请求,返回状态码 101 Switching Protocols 的响应。<br>Sec-WebSocket-Accept 的字段值是由握手请求中的 Sec-WebSocket-Key 的字段值生成的。<br>成功握手确立 WebSocket 连接之后,通信时不再使用 HTTP 的数据帧,而采用 WebSocket 独立的数据帧。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第10章：构建-Web-内容的技术"><a href="#第10章：构建-Web-内容的技术" class="headerlink" title="第10章：构建 Web 内容的技术"></a>第10章：构建 Web 内容的技术</h1><h3 id="1-HTML-CSS-JS"><a href="#1-HTML-CSS-JS" class="headerlink" title="1. HTML/CSS/JS"></a>1. HTML/CSS/JS</h3><h3 id="2-Web-应用"><a href="#2-Web-应用" class="headerlink" title="2. Web 应用"></a>2. Web 应用</h3><ul>
<li>Web 应用是指通过 Web 功能提供的应用程序。比如购物网站、网上银行、SNS、BBS、搜索引擎和 e-learning 等。互联网(Internet)或企业内网(Intranet)上遍布各式各样的 Web 应用。原本应用 HTTP 协议的 Web 的机制就是对客户端发来的请求,返回事前准备好的内容。可随着 Web 越来越普及,仅靠这样的做法已不足以应对所有的需求,更需要引入由程序创建 HTML 内容的做法。</li>
</ul>
<h5 id="1-与-Web-服务器及程序协作的-CGI"><a href="#1-与-Web-服务器及程序协作的-CGI" class="headerlink" title="1. 与 Web 服务器及程序协作的 CGI"></a>1. 与 Web 服务器及程序协作的 CGI</h5><ul>
<li>CGI(Common Gateway Interface,通用网关接口)是指 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在 CGI 的作用下,程序会对请求内容做出相应的动作,比如创建 HTML 等动态内容。</li>
<li>使用 CGI 的程序叫做 CGI 程序,通常是用 Perl、PHP、Ruby 和 C 等编程语言编写而成。</li>
</ul>
<h5 id="2-因-Java-而普及的-Servlet"><a href="#2-因-Java-而普及的-Servlet" class="headerlink" title="2. 因 Java 而普及的 Servlet"></a>2. 因 Java 而普及的 Servlet</h5><ul>
<li>Servlet 是一种能在服务器上创建动态内容的程序。Servlet 是用 Java语言实现的一个接口,属于面向企业级 Java(JavaEE,Java Enterprise Edition)的一部分</li>
<li>CGI,由于每次接到请求,程序都要跟着启动一次。因此一旦访问量过大,Web 服务器要承担相当大的负载。而 Servlet 运行在与 Web 服务器相同的进程中,因此受到的负载较小。Servlet 的运行环境叫做 Web 容器或 Servlet 容器。</li>
<li>随着 CGI 的普及,每次请求都要启动新 CGI 程序的 CGI 运行机制逐渐变成了性能瓶颈,所以之后 Servlet 和 mod_perl 等可直接在 Web 服务器上运行的程序才得以开发、普及。</li>
</ul>
<h3 id="3-数据发布的格式及语言"><a href="#3-数据发布的格式及语言" class="headerlink" title="3. 数据发布的格式及语言"></a>3. 数据发布的格式及语言</h3><h5 id="1-XML"><a href="#1-XML" class="headerlink" title="1. XML"></a>1. XML</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;研讨会 编号&#x3D;&quot;TR001&quot; 主题&#x3D;&quot;Web应用程序脆弱性诊断讲座&quot;&gt;</span><br><span class="line">    &lt;类别&gt;安全&lt;&#x2F;类别&gt;</span><br><span class="line">    &lt;概要&gt;为深入研究Web应用程序脆弱性诊断必要的...&lt;&#x2F;概要&gt;</span><br><span class="line">&lt;&#x2F;研讨会&gt;</span><br><span class="line">&lt;研讨会 编号&#x3D;&quot;TR002&quot; 主题&#x3D;&quot;网络系统脆弱性诊断讲座&quot;&gt;</span><br><span class="line">    &lt;类别&gt;安全&lt;&#x2F;类别&gt;</span><br><span class="line">    &lt;概要&gt;为深入研究网络系统脆弱性诊断必要的...&lt;&#x2F;概要&gt;</span><br><span class="line">&lt;&#x2F;研讨会&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-JSON"><a href="#2-JSON" class="headerlink" title="2. JSON"></a>2. JSON</h5><ul>
<li>JSON(JavaScript Object Notation)是一种以JavaScript(ECMAScript)的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有 false/null/true/ 对象 / 数组 / 数字 / 字符串,这 7 种类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Web Application Security&quot;,</span><br><span class="line">    &quot;num&quot;: &quot;TR001&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="3-发布更新信息的-RSS-Atom"><a href="#3-发布更新信息的-RSS-Atom" class="headerlink" title="3. 发布更新信息的 RSS/Atom"></a>3. 发布更新信息的 RSS/Atom</h5><ul>
<li>RSS(简易信息聚合,也叫聚合内容)和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了 XML。</li>
</ul>
<h1 id="第11章：Web-的攻击技术"><a href="#第11章：Web-的攻击技术" class="headerlink" title="第11章：Web 的攻击技术"></a>第11章：Web 的攻击技术</h1><h3 id="0-说明"><a href="#0-说明" class="headerlink" title="0. 说明"></a>0. 说明</h3><ul>
<li>因对安全知识了解不多，本章只是做了个大概的笔记，对很多还不懂。</li>
</ul>
<h3 id="1-针对-Web-应用的攻击模式"><a href="#1-针对-Web-应用的攻击模式" class="headerlink" title="1. 针对 Web 应用的攻击模式"></a>1. 针对 Web 应用的攻击模式</h3><h5 id="以服务器为目标的主动攻击"><a href="#以服务器为目标的主动攻击" class="headerlink" title="以服务器为目标的主动攻击"></a>以服务器为目标的主动攻击</h5><ul>
<li>主动攻击(active attack)是指攻击者通过直接访问 Web 应用,把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击,因此攻击者需要能够访问到那些资源。</li>
<li>主动攻击模式里具有代表性的攻击是 SQL 注入攻击和 OS 命令注入攻击。</li>
</ul>
<h5 id="以服务器为目标的被动攻击"><a href="#以服务器为目标的被动攻击" class="headerlink" title="以服务器为目标的被动攻击"></a>以服务器为目标的被动攻击</h5><ul>
<li>被动攻击(passive attack)是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中,攻击者不直接对目标 Web 应用访问发起攻击。</li>
<li>攻击模式<ul>
<li>步骤 1: 攻击者诱使用户触发已设置好的陷阱,而陷阱会启动发送已嵌入攻击代码的 HTTP 请求。</li>
<li>步骤 2: 当用户不知不觉中招之后,用户的浏览器或邮件客户端就会触发这个陷阱。</li>
<li>步骤 3: 中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用,运行攻击代码。</li>
<li>步骤 4: 执行完攻击代码,存在安全漏洞的 Web 应用会成为攻击者的跳板,可能导致用户所持的 Cookie 等个人信息被窃取,登录状态中的用户权限遭恶意滥用等后果。</li>
<li>被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。</li>
</ul>
</li>
<li>利用用户的身份攻击企业内部网络<ul>
<li>利用被动攻击,可发起对原本从互联网上无法直接访问的企业内网等网络的攻击。只要用户踏入攻击者预先设好的陷阱,在用户能够访问到的网络范围内,即使是企业内网也同样会受到攻击。</li>
<li>很多企业内网依然可以连接到互联网上,访问 Web 网站,或接收互联网发来的邮件。这样就可能给攻击者以可乘之机,诱导用户触发陷阱后对企业内网发动攻击。</li>
</ul>
</li>
</ul>
<h3 id="2-因输出值转义不完全引发的安全漏洞"><a href="#2-因输出值转义不完全引发的安全漏洞" class="headerlink" title="2. 因输出值转义不完全引发的安全漏洞"></a>2. 因输出值转义不完全引发的安全漏洞</h3><ul>
<li>实施 Web 应用的安全对策可大致分为以下两部分。<ul>
<li>客户端的验证</li>
<li>Web 应用端(服务器端)的验证<ul>
<li>输入值验证</li>
<li>输出值转义</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h5><ul>
<li>跨站脚本攻击(Cross-Site Scripting,XSS)是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。</li>
<li>跨站脚本攻击有可能造成以下影响<ul>
<li>利用虚假输入表单骗取用户个人信息。</li>
<li>利用脚本窃取用户的 Cookie 值,被害者在不知情的情况下,帮助攻击者发送恶意请求。</li>
<li>显示伪造的文章或图片。</li>
<li>对用户 Cookie 的窃取攻击</li>
</ul>
</li>
</ul>
<h5 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h5><ul>
<li>会执行非法 SQL 的 SQL 注入攻击<br>  例如查询到用户密码</li>
</ul>
<h5 id="OS-命令注入攻击"><a href="#OS-命令注入攻击" class="headerlink" title="OS 命令注入攻击"></a>OS 命令注入攻击</h5><ul>
<li>OS 命令注入攻击(OS Command Injection)是指通过 Web 应用,执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。</li>
</ul>
<h5 id="HTTP-首部注入攻击"><a href="#HTTP-首部注入攻击" class="headerlink" title="HTTP 首部注入攻击"></a>HTTP 首部注入攻击</h5><ul>
<li>HTTP 首部注入攻击(HTTP Header Injection)是指攻击者通过在响应首部字段内插入换行,添加任意响应首部或主体的一种攻击。属于被动攻击模式</li>
<li>HTTP 首部注入攻击有可能会造成以下一些影响<ul>
<li>设置任何 Cookie 信息</li>
<li>重定向至任意 URL</li>
<li>显示任意的主体(HTTP 响应截断攻击)</li>
<li>HTTP 响应截断攻击</li>
</ul>
</li>
</ul>
<h5 id="邮件首部注入攻击"><a href="#邮件首部注入攻击" class="headerlink" title="邮件首部注入攻击"></a>邮件首部注入攻击</h5><ul>
<li>邮件首部注入(Mail Header Injection)是指 Web 应用中的邮件发送功能,攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。利用存在安全漏洞的 Web 网站,可对任意邮件地址发送广告邮件或病毒邮件。</li>
</ul>
<h5 id="目录遍历攻击"><a href="#目录遍历攻击" class="headerlink" title="目录遍历攻击"></a>目录遍历攻击</h5><ul>
<li>目录遍历(Directory Traversal)攻击是指对本无意公开的文件目录,通过非法截断其目录路径后,达成访问目的的一种攻击。这种攻击有时也称为路径遍历(Path Traversal)攻击。</li>
</ul>
<h5 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h5><ul>
<li>远程文件包含漏洞(Remote File Inclusion)是指当部分脚本内容需要从其他文件读入时,攻击者利用指定外部服务器的 URL 充当依赖文件,让脚本读取之后,就可运行任意脚本的一种攻击。</li>
</ul>
<h3 id="3-因设置或设计上的缺陷引发的安全漏洞"><a href="#3-因设置或设计上的缺陷引发的安全漏洞" class="headerlink" title="3. 因设置或设计上的缺陷引发的安全漏洞"></a>3. 因设置或设计上的缺陷引发的安全漏洞</h3><h5 id="强制浏览"><a href="#强制浏览" class="headerlink" title="强制浏览"></a>强制浏览</h5><ul>
<li>强制浏览有可能会造成以下一些影响。<ul>
<li>泄露顾客的个人信息等重要情报</li>
<li>泄露原本需要具有访问权限的用户才可查阅的信息内容</li>
<li>泄露未外连到外界的文件</li>
</ul>
</li>
<li>对那些原本不愿公开的文件,为了保证安全会隐蔽其 URL。可一旦知道了那些 URL,也就意味着可浏览 URL 对应的文件。直接显示容易推测的文件名或文件目录索引时,通过某些方法可能会使 URL 产生泄露。</li>
<li>例子<br>  如加锁日记不想让别人看，但是别人知道日记中的某个图片的存放地址，就能直接通过URL访问这个图片</li>
</ul>
<h5 id="不正确的错误消息处理"><a href="#不正确的错误消息处理" class="headerlink" title="不正确的错误消息处理"></a>不正确的错误消息处理</h5><ul>
<li>不正确的错误消息处理(Error Handling Vulnerability)的安全漏洞是指,Web 应用的错误信息内包含对攻击者有用的信息。</li>
<li>Web 应用不必在用户的浏览画面上展现详细的错误消息。对攻击者来说,详细的错误消息有可能给他们下一次攻击以提示。</li>
<li>与 Web 应用有关的主要错误信息如下所示。<ul>
<li>Web 应用抛出的错误消息</li>
<li>数据库等系统抛出的错误消息</li>
</ul>
</li>
</ul>
<h5 id="开放重定向"><a href="#开放重定向" class="headerlink" title="开放重定向"></a>开放重定向</h5><ul>
<li>开放重定向(Open Redirect)是一种对指定的任意 URL 作重定向跳转的功能。而于此功能相关联的安全漏洞是指,假如指定的重定向 URL到某个具有恶意的 Web 网站,那么用户就会被诱导至那个 Web 网站。</li>
</ul>
<h3 id="4-因会话管理疏忽引发的安全漏洞"><a href="#4-因会话管理疏忽引发的安全漏洞" class="headerlink" title="4. 因会话管理疏忽引发的安全漏洞"></a>4. 因会话管理疏忽引发的安全漏洞</h3><h5 id="会话劫持"><a href="#会话劫持" class="headerlink" title="会话劫持"></a>会话劫持</h5><ul>
<li>会话劫持(Session Hijack)是指攻击者通过某种手段拿到了用户的会话 ID,并非法使用此会话 ID 伪装成用户,达到攻击的目的。</li>
<li>几种攻击者可获得会话 ID 的途径。<ul>
<li>通过非正规的生成方法推测会话 ID</li>
<li>通过窃听或 XSS 攻击盗取会话 ID</li>
<li>通过会话固定攻击(Session Fixation)强行获取会话 ID</li>
</ul>
</li>
</ul>
<h5 id="会话固定攻击"><a href="#会话固定攻击" class="headerlink" title="会话固定攻击"></a>会话固定攻击</h5><ul>
<li>对以窃取目标会话 ID 为主动攻击手段的会话劫持而言,会话固定攻击(Session Fixation)攻击会强制用户使用攻击者指定的会话 ID,属于被动攻击。</li>
</ul>
<h5 id="跨站点请求伪造"><a href="#跨站点请求伪造" class="headerlink" title="跨站点请求伪造"></a>跨站点请求伪造</h5><ul>
<li>跨站点请求伪造(Cross-Site Request Forgeries,CSRF)攻击是指攻击者通过设置好的陷阱,强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新,属于被动攻击。</li>
<li>跨站点请求伪造有可能会造成以下等影响。<ul>
<li>利用已通过认证的用户权限更新设定信息等</li>
<li>利用已通过认证的用户权限购买商品</li>
<li>利用已通过认证的用户权限在留言板上发表言论</li>
</ul>
</li>
</ul>
<h3 id="5-其他安全漏洞"><a href="#5-其他安全漏洞" class="headerlink" title="5. 其他安全漏洞"></a>5. 其他安全漏洞</h3><h5 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h5><ul>
<li>通过网络的密码试错<ul>
<li>穷举法,全试一遍</li>
<li>字典攻击，构造好密码字典，一一尝试</li>
</ul>
</li>
<li>对已加密密码的破解(指攻击者入侵系统,已获得加密或散列处理的密码数据的情况)</li>
</ul>
<h5 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h5><ul>
<li>点击劫持(Clickjacking)是指利用透明的按钮或链接做成陷阱,覆盖在 Web 页面之上。然后诱使用户在不知情的情况下,点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing)。</li>
</ul>
<h5 id="DoS-攻击"><a href="#DoS-攻击" class="headerlink" title="DoS 攻击"></a>DoS 攻击</h5><ul>
<li>DoS 攻击(Denial of Service attack)是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站,还包括网络设备及服务器等。</li>
<li>主要有以下两种 DoS 攻击方式。<ul>
<li>集中利用访问请求造成资源过载,资源用尽的同时,实际上服务也就呈停止状态。</li>
<li>通过攻击安全漏洞使服务停止。</li>
</ul>
</li>
</ul>
<h5 id="后门程序"><a href="#后门程序" class="headerlink" title="后门程序"></a>后门程序</h5><ul>
<li>后门程序(Backdoor)是指开发设置的隐藏入口,可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。</li>
<li>通常的后门程序分为以下 3 种类型。<ul>
<li>开发阶段作为 Debug 调用的后门程序</li>
<li>开发者为了自身利益植入的后门程序</li>
<li>攻击者通过某种方法设置的后门程序</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/http/" rel="tag"><i class="fa fa-tag">http</i></a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/protobuf%E4%B8%8D%E8%83%BD%E5%8D%95%E7%8B%AC%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA0/" rel="prev" title="protobuf不能单独发送一个0">
      <i class="fa fa-chevron-left"></i> protobuf不能单独发送一个0
    </a></div>
      <div class="post-nav-item">
    <a href="/%E3%80%8ATCPIP%E8%AF%A6%E8%A7%A3%E3%80%8B/" rel="next" title="《TCPIP详解》">
      《TCPIP详解》 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E4%BA%86%E8%A7%A3Web%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="nav-text">第1章：了解Web及网络基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-HTTP"><span class="nav-text">1. HTTP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-TCP-IP-DNS"><span class="nav-text">2. TCP&#x2F;IP&#x2F;DNS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-URI-URL"><span class="nav-text">3. URI&#x2F;URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-RFC"><span class="nav-text">4. RFC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC2%E7%AB%A0%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE"><span class="nav-text">第2章：简单的HTTP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="nav-text">1. 请求头与响应头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-HTTP%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-text">2. HTTP是不保存状态的协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-HTTP%E6%96%B9%E6%B3%95"><span class="nav-text">3. HTTP方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5%E8%8A%82%E7%9C%81%E9%80%9A%E4%BF%A1%E9%87%8F"><span class="nav-text">4. 持久连接节省通信量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BD%BF%E7%94%A8Cookie%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-text">5. 使用Cookie的状态管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC3%E7%AB%A0%EF%BC%9AHTTP%E6%8A%A5%E6%96%87%E5%86%85%E7%9A%84HTTP%E4%BF%A1%E6%81%AF"><span class="nav-text">第3章：HTTP报文内的HTTP信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-HTTP%E6%8A%A5%E6%96%87"><span class="nav-text">1. HTTP报文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BC%96%E7%A0%81%E6%8F%90%E9%AB%98%E4%BC%A0%E8%BE%93%E6%95%88%E7%8E%87"><span class="nav-text">2. 编码提高传输效率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8F%91%E9%80%81%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E9%83%A8%E5%88%86%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88"><span class="nav-text">3. 发送多种数据的多部分对象集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%8E%B7%E5%8F%96%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E7%9A%84%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82"><span class="nav-text">4. 获取部分内容的范围请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E8%BF%94%E5%9B%9E%E6%9C%80%E5%90%88%E9%80%82%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-text">5. 内容协商返回最合适的内容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-text">第4章：返回结果的HTTP状态码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%8A%B6%E6%80%81%E7%A0%81%E7%B1%BB%E5%88%AB"><span class="nav-text">1. 状态码类别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2XX%E6%88%90%E5%8A%9F"><span class="nav-text">2. 2XX成功</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-200-OK"><span class="nav-text">2.1 200 OK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-204-No-Content"><span class="nav-text">2.2 204 No Content</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-206-Partial-Content"><span class="nav-text">2.3 206 Partial Content</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3XX-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">3. 3XX 重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-301-Moved-Permanently"><span class="nav-text">3.1 301 Moved Permanently</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-302-Found"><span class="nav-text">3.2 302 Found</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-303-See-Other"><span class="nav-text">3.3 303 See Other</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-304-Not-Modified"><span class="nav-text">3.4 304 Not Modified</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-307-Temporary-Redirect"><span class="nav-text">3.5 307 Temporary Redirect</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4XX-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF"><span class="nav-text">4. 4XX 客户端错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-400-Bad-Request"><span class="nav-text">4.1 400 Bad Request</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-401-Unauthorized"><span class="nav-text">4.2 401 Unauthorized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-403-Forbidden"><span class="nav-text">4.3 403 Forbidden</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-404-Not-Found"><span class="nav-text">4.4 404 Not Found</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5XX-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF"><span class="nav-text">5. 5XX 服务器错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-500-Internal-Server-Error"><span class="nav-text">5.1 500 Internal Server Error</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-503-Service-Unavailable"><span class="nav-text">5.2 503 Service Unavailable</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%8A%B6%E6%80%81%E7%A0%81%E5%92%8C%E7%8A%B6%E5%86%B5%E7%9A%84%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="nav-text">6. 状态码和状况的不一致</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC5%E7%AB%A0%EF%BC%9A%E4%B8%8E-HTTP-%E5%8D%8F%E4%BD%9C%E7%9A%84-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">第5章：与 HTTP 协作的 Web 服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%94%A8%E5%8D%95%E5%8F%B0%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D"><span class="nav-text">1. 用单台虚拟主机实现多个域名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91%E7%A8%8B%E5%BA%8F-%E4%BB%A3%E7%90%86%E3%80%81%E7%BD%91%E5%85%B3%E3%80%81%E9%9A%A7%E9%81%93"><span class="nav-text">2. 通信数据转发程序 :代理、网关、隧道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BF%9D%E5%AD%98%E8%B5%84%E6%BA%90%E7%9A%84%E7%BC%93%E5%AD%98"><span class="nav-text">3. 保存资源的缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC6%E7%AB%A0%EF%BC%9AHTTP%E9%A6%96%E9%83%A8"><span class="nav-text">第6章：HTTP首部</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-HTTP-%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%E4%B8%80%E8%A7%88"><span class="nav-text">1. HTTP 首部字段一览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%9D%9E-HTTP-1-1-%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="nav-text">2. 非 HTTP&#x2F;1.1 首部字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="nav-text">3. 通用首部字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="nav-text">4. 请求首部字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="nav-text">5. 响应首部字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="nav-text">6. 实体首部字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%B8%BACookie%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="nav-text">7. 为Cookie服务的首部字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%85%B6%E4%BB%96%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="nav-text">8. 其他首部字段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0-%E7%A1%AE%E4%BF%9D-Web-%E5%AE%89%E5%85%A8%E7%9A%84-HTTPS"><span class="nav-text">第7章 确保 Web 安全的 HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-HTTP-%E4%B8%BB%E8%A6%81%E6%9C%89%E8%BF%99%E4%BA%9B%E4%B8%8D%E8%B6%B3-%E4%BE%8B%E4%B8%BE%E5%A6%82%E4%B8%8B%E3%80%82"><span class="nav-text">1. HTTP 主要有这些不足,例举如下。</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%80%9A%E4%BF%A1%E4%BD%BF%E7%94%A8%E6%98%8E%E6%96%87-%E4%B8%8D%E5%8A%A0%E5%AF%86-%E5%86%85%E5%AE%B9%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%A2%AB%E7%AA%83%E5%90%AC"><span class="nav-text">1. 通信使用明文(不加密),内容可能会被窃听</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%B8%8D%E9%AA%8C%E8%AF%81%E9%80%9A%E4%BF%A1%E6%96%B9%E7%9A%84%E8%BA%AB%E4%BB%BD-%E5%9B%A0%E6%AD%A4%E6%9C%89%E5%8F%AF%E8%83%BD%E9%81%AD%E9%81%87%E4%BC%AA%E8%A3%85"><span class="nav-text">2. 不验证通信方的身份,因此有可能遭遇伪装</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%97%A0%E6%B3%95%E8%AF%81%E6%98%8E%E6%8A%A5%E6%96%87%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7-%E6%89%80%E4%BB%A5%E6%9C%89%E5%8F%AF%E8%83%BD%E5%B7%B2%E9%81%AD%E7%AF%A1%E6%94%B9"><span class="nav-text">3. 无法证明报文的完整性,所以有可能已遭篡改</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-2-HTTP-%E5%8A%A0%E5%AF%86-%E8%AE%A4%E8%AF%81-%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4-HTTPS"><span class="nav-text">2. 7.2 HTTP+ 加密 + 认证 + 完整性保护&#x3D;HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-HTTP-%E5%8A%A0%E4%B8%8A%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86%E5%92%8C%E8%AE%A4%E8%AF%81%E4%BB%A5%E5%8F%8A%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4%E5%90%8E%E5%8D%B3%E6%98%AF-HTTPS"><span class="nav-text">1. HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-HTTPS-%E6%98%AF%E8%BA%AB%E6%8A%AB-SSL-%E5%A4%96%E5%A3%B3%E7%9A%84-HTTP"><span class="nav-text">2. HTTPS 是身披 SSL 外壳的 HTTP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%9B%B8%E4%BA%92%E4%BA%A4%E6%8D%A2%E5%AF%86%E9%92%A5%E7%9A%84%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF"><span class="nav-text">3. 相互交换密钥的公开密钥加密技术</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E8%AF%81%E6%98%8E%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E8%AF%81%E4%B9%A6"><span class="nav-text">4. 证明公开密钥正确性的证书</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-HTTPS-%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="nav-text">5. HTTPS 通信过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-HTTPS-%E7%9A%84%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="nav-text">6. HTTPS 的安全通信机制</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC8%E7%AB%A0-%E7%A1%AE%E8%AE%A4%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E7%9A%84%E8%AE%A4%E8%AF%81"><span class="nav-text">第8章 确认访问用户身份的认证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%95%E4%B8%BA%E8%AE%A4%E8%AF%81"><span class="nav-text">1. 何为认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-BASIC-%E8%AE%A4%E8%AF%81"><span class="nav-text">2. BASIC 认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-DIGEST-%E8%AE%A4%E8%AF%81"><span class="nav-text">3. DIGEST 认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-SSL-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%A4%E8%AF%81"><span class="nav-text">4. SSL　客户端认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E8%AE%A4%E8%AF%81"><span class="nav-text">5. 基于表单认证</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%AE%A4%E8%AF%81%E5%A4%9A%E5%8D%8A%E4%B8%BA%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E8%AE%A4%E8%AF%81"><span class="nav-text">1. 认证多半为基于表单认证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Session-%E7%AE%A1%E7%90%86%E5%8F%8A-Cookie-%E5%BA%94%E7%94%A8"><span class="nav-text">2. Session 管理及 Cookie 应用</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC9%E7%AB%A0%EF%BC%9A%E5%9F%BA%E4%BA%8E-HTTP-%E7%9A%84%E5%8A%9F%E8%83%BD%E8%BF%BD%E5%8A%A0%E5%8D%8F%E8%AE%AE"><span class="nav-text">第9章：基于 HTTP 的功能追加协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%B6%88%E9%99%A4-HTTP-%E7%93%B6%E9%A2%88%E7%9A%84-SPDY"><span class="nav-text">1. 消除 HTTP 瓶颈的 SPDY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%85%A8%E5%8F%8C%E5%B7%A5%E9%80%9A%E4%BF%A1%E7%9A%84-WebSocket"><span class="nav-text">2. 使用浏览器进行全双工通信的 WebSocket</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC10%E7%AB%A0%EF%BC%9A%E6%9E%84%E5%BB%BA-Web-%E5%86%85%E5%AE%B9%E7%9A%84%E6%8A%80%E6%9C%AF"><span class="nav-text">第10章：构建 Web 内容的技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-HTML-CSS-JS"><span class="nav-text">1. HTML&#x2F;CSS&#x2F;JS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Web-%E5%BA%94%E7%94%A8"><span class="nav-text">2. Web 应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%B8%8E-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8A%E7%A8%8B%E5%BA%8F%E5%8D%8F%E4%BD%9C%E7%9A%84-CGI"><span class="nav-text">1. 与 Web 服务器及程序协作的 CGI</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9B%A0-Java-%E8%80%8C%E6%99%AE%E5%8F%8A%E7%9A%84-Servlet"><span class="nav-text">2. 因 Java 而普及的 Servlet</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E5%8F%91%E5%B8%83%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E8%AF%AD%E8%A8%80"><span class="nav-text">3. 数据发布的格式及语言</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-XML"><span class="nav-text">1. XML</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-JSON"><span class="nav-text">2. JSON</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%8F%91%E5%B8%83%E6%9B%B4%E6%96%B0%E4%BF%A1%E6%81%AF%E7%9A%84-RSS-Atom"><span class="nav-text">3. 发布更新信息的 RSS&#x2F;Atom</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC11%E7%AB%A0%EF%BC%9AWeb-%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF"><span class="nav-text">第11章：Web 的攻击技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E8%AF%B4%E6%98%8E"><span class="nav-text">0. 说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%92%88%E5%AF%B9-Web-%E5%BA%94%E7%94%A8%E7%9A%84%E6%94%BB%E5%87%BB%E6%A8%A1%E5%BC%8F"><span class="nav-text">1. 针对 Web 应用的攻击模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BA%E7%9B%AE%E6%A0%87%E7%9A%84%E4%B8%BB%E5%8A%A8%E6%94%BB%E5%87%BB"><span class="nav-text">以服务器为目标的主动攻击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BA%E7%9B%AE%E6%A0%87%E7%9A%84%E8%A2%AB%E5%8A%A8%E6%94%BB%E5%87%BB"><span class="nav-text">以服务器为目标的被动攻击</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9B%A0%E8%BE%93%E5%87%BA%E5%80%BC%E8%BD%AC%E4%B9%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E5%BC%95%E5%8F%91%E7%9A%84%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E"><span class="nav-text">2. 因输出值转义不完全引发的安全漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB"><span class="nav-text">跨站脚本攻击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SQL-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB"><span class="nav-text">SQL 注入攻击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#OS-%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB"><span class="nav-text">OS 命令注入攻击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP-%E9%A6%96%E9%83%A8%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB"><span class="nav-text">HTTP 首部注入攻击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%82%AE%E4%BB%B6%E9%A6%96%E9%83%A8%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB"><span class="nav-text">邮件首部注入攻击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%94%BB%E5%87%BB"><span class="nav-text">目录遍历攻击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E"><span class="nav-text">远程文件包含漏洞</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%9B%A0%E8%AE%BE%E7%BD%AE%E6%88%96%E8%AE%BE%E8%AE%A1%E4%B8%8A%E7%9A%84%E7%BC%BA%E9%99%B7%E5%BC%95%E5%8F%91%E7%9A%84%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E"><span class="nav-text">3. 因设置或设计上的缺陷引发的安全漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E6%B5%8F%E8%A7%88"><span class="nav-text">强制浏览</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="nav-text">不正确的错误消息处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">开放重定向</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%9B%A0%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E7%96%8F%E5%BF%BD%E5%BC%95%E5%8F%91%E7%9A%84%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E"><span class="nav-text">4. 因会话管理疏忽引发的安全漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D%E5%8A%AB%E6%8C%81"><span class="nav-text">会话劫持</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D%E5%9B%BA%E5%AE%9A%E6%94%BB%E5%87%BB"><span class="nav-text">会话固定攻击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0"><span class="nav-text">跨站点请求伪造</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E"><span class="nav-text">5. 其他安全漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3"><span class="nav-text">密码破解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81"><span class="nav-text">点击劫持</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DoS-%E6%94%BB%E5%87%BB"><span class="nav-text">DoS 攻击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E9%97%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">后门程序</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="愚昧之巅"
      src="/images/head.jpeg">
  <p class="site-author-name" itemprop="name">愚昧之巅</p>
  <div class="site-description" itemprop="description">以阅读为生是一件很酷的事，以写作为生是一件更酷的事。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
    <!--
    <div id="music163player">
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&id=5445280661&auto=0&height=90"></iframe>
       </div>
    -->
  </aside>
  
  
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">愚昧之巅</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">138k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:06</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='255,255,255' opacity='1' zIndex='-1' count='200' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'Dv4yd2JUuvVhLBe640B6m1jw-gzGzoHsz',
      appKey     : 'sNdrMuVcw6jJzlz0HpXBNhdB',
      placeholder: "来交流交流吧~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>



